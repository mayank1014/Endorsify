import { Animation, Browser, ChildProperty, Collection, Complex, Component, Event, EventHandler, Internationalization, L10n, NotifyPropertyChanges, Property, Touch, animationMode, compile, createElement, extend, getValue, isNullOrUndefined, merge, print, remove, resetBlazorTemplate, setValue, updateBlazorTemplate } from '@syncfusion/ej2-base';
import { CanvasRenderer, PathOption, Rect, Size, SvgRenderer, TextOption, Tooltip, getElement, measureText, removeElement, textElement } from '@syncfusion/ej2-svg-base';
import { DataManager, DataUtil, Deferred, Query } from '@syncfusion/ej2-data';
import { PdfBitmap, PdfColor, PdfDocument, PdfPageOrientation, PdfPageTemplateElement, PdfSolidBrush, PdfStandardFont, SizeF } from '@syncfusion/ej2-pdf-export';
import { Workbook } from '@syncfusion/ej2-excel-export';
import { Toolbar } from '@syncfusion/ej2-navigations';
import { DateRangePicker } from '@syncfusion/ej2-calendars';
import { DropDownButton } from '@syncfusion/ej2-splitbuttons';

var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Defines the appearance of the connectors
 */
var Connector = /** @__PURE__ @class */ (function (_super) {
    __extends$2(Connector, _super);
    function Connector() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property('Line')
    ], Connector.prototype, "type", void 0);
    __decorate$1([
        Property(null)
    ], Connector.prototype, "color", void 0);
    __decorate$1([
        Property(1)
    ], Connector.prototype, "width", void 0);
    __decorate$1([
        Property(null)
    ], Connector.prototype, "length", void 0);
    __decorate$1([
        Property('')
    ], Connector.prototype, "dashArray", void 0);
    return Connector;
}(ChildProperty));
/**
 * Configures the borders in the chart title.
 */
var titleBorder = /** @__PURE__ @class */ (function (_super) {
    __extends$2(titleBorder, _super);
    function titleBorder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property('transparent')
    ], titleBorder.prototype, "color", void 0);
    __decorate$1([
        Property(0)
    ], titleBorder.prototype, "width", void 0);
    __decorate$1([
        Property(0.8)
    ], titleBorder.prototype, "cornerRadius", void 0);
    return titleBorder;
}(ChildProperty));
/**
 * Configures the title settings in chart and 3D chart.
 */
var titleSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$2(titleSettings, _super);
    function titleSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property('Normal')
    ], titleSettings.prototype, "fontStyle", void 0);
    __decorate$1([
        Property('15px')
    ], titleSettings.prototype, "size", void 0);
    __decorate$1([
        Property('500')
    ], titleSettings.prototype, "fontWeight", void 0);
    __decorate$1([
        Property('')
    ], titleSettings.prototype, "color", void 0);
    __decorate$1([
        Property('Center')
    ], titleSettings.prototype, "textAlignment", void 0);
    __decorate$1([
        Property('Segoe UI')
    ], titleSettings.prototype, "fontFamily", void 0);
    __decorate$1([
        Property(1)
    ], titleSettings.prototype, "opacity", void 0);
    __decorate$1([
        Property('Wrap')
    ], titleSettings.prototype, "textOverflow", void 0);
    __decorate$1([
        Property('Top')
    ], titleSettings.prototype, "position", void 0);
    __decorate$1([
        Property(0)
    ], titleSettings.prototype, "x", void 0);
    __decorate$1([
        Property(0)
    ], titleSettings.prototype, "y", void 0);
    __decorate$1([
        Property('transparent')
    ], titleSettings.prototype, "background", void 0);
    __decorate$1([
        Complex({}, titleBorder)
    ], titleSettings.prototype, "border", void 0);
    return titleSettings;
}(ChildProperty));
/**
 * Configures the location for the legend.
 */
var Location = /** @__PURE__ @class */ (function (_super) {
    __extends$2(Location, _super);
    function Location() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property(0)
    ], Location.prototype, "x", void 0);
    __decorate$1([
        Property(0)
    ], Location.prototype, "y", void 0);
    return Location;
}(ChildProperty));
/**
 * Configures the fonts in charts.
 */
var Font = /** @__PURE__ @class */ (function (_super) {
    __extends$2(Font, _super);
    function Font() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property('Normal')
    ], Font.prototype, "fontStyle", void 0);
    __decorate$1([
        Property('16px')
    ], Font.prototype, "size", void 0);
    __decorate$1([
        Property('Normal')
    ], Font.prototype, "fontWeight", void 0);
    __decorate$1([
        Property('')
    ], Font.prototype, "color", void 0);
    __decorate$1([
        Property('Center')
    ], Font.prototype, "textAlignment", void 0);
    __decorate$1([
        Property('Segoe UI')
    ], Font.prototype, "fontFamily", void 0);
    __decorate$1([
        Property(1)
    ], Font.prototype, "opacity", void 0);
    __decorate$1([
        Property('Wrap')
    ], Font.prototype, "textOverflow", void 0);
    return Font;
}(ChildProperty));
/**
 * Configures the borders in the chart.
 */
var Border = /** @__PURE__ @class */ (function (_super) {
    __extends$2(Border, _super);
    function Border() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property('')
    ], Border.prototype, "color", void 0);
    __decorate$1([
        Property(1)
    ], Border.prototype, "width", void 0);
    return Border;
}(ChildProperty));
/**
 * Configures the marker position in the chart.
 */
var Offset = /** @__PURE__ @class */ (function (_super) {
    __extends$2(Offset, _super);
    function Offset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property(0)
    ], Offset.prototype, "x", void 0);
    __decorate$1([
        Property(0)
    ], Offset.prototype, "y", void 0);
    return Offset;
}(ChildProperty));
/**
 * Configures the chart area.
 */
var ChartArea = /** @__PURE__ @class */ (function (_super) {
    __extends$2(ChartArea, _super);
    function ChartArea() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Complex({}, Border)
    ], ChartArea.prototype, "border", void 0);
    __decorate$1([
        Property('transparent')
    ], ChartArea.prototype, "background", void 0);
    __decorate$1([
        Property(1)
    ], ChartArea.prototype, "opacity", void 0);
    __decorate$1([
        Property(null)
    ], ChartArea.prototype, "backgroundImage", void 0);
    __decorate$1([
        Property(null)
    ], ChartArea.prototype, "width", void 0);
    return ChartArea;
}(ChildProperty));
/**
 * Configures the chart margins.
 */
var Margin = /** @__PURE__ @class */ (function (_super) {
    __extends$2(Margin, _super);
    function Margin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property(Browser.isDevice ? 5 : 10)
    ], Margin.prototype, "left", void 0);
    __decorate$1([
        Property(Browser.isDevice ? 5 : 10)
    ], Margin.prototype, "right", void 0);
    __decorate$1([
        Property(Browser.isDevice ? 5 : 10)
    ], Margin.prototype, "top", void 0);
    __decorate$1([
        Property(Browser.isDevice ? 5 : 10)
    ], Margin.prototype, "bottom", void 0);
    return Margin;
}(ChildProperty));
/**
 * Configures the chart Legend Container Padding.
 */
var ContainerPadding = /** @__PURE__ @class */ (function (_super) {
    __extends$2(ContainerPadding, _super);
    function ContainerPadding() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property(0)
    ], ContainerPadding.prototype, "left", void 0);
    __decorate$1([
        Property(0)
    ], ContainerPadding.prototype, "right", void 0);
    __decorate$1([
        Property(0)
    ], ContainerPadding.prototype, "top", void 0);
    __decorate$1([
        Property(0)
    ], ContainerPadding.prototype, "bottom", void 0);
    return ContainerPadding;
}(ChildProperty));
/**
 * Configures the animation behavior for chart series.
 */
var Animation$1 = /** @__PURE__ @class */ (function (_super) {
    __extends$2(Animation$$1, _super);
    function Animation$$1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property(true)
    ], Animation$$1.prototype, "enable", void 0);
    __decorate$1([
        Property(1000)
    ], Animation$$1.prototype, "duration", void 0);
    __decorate$1([
        Property(0)
    ], Animation$$1.prototype, "delay", void 0);
    return Animation$$1;
}(ChildProperty));
/**
 * Series and point index
 *
 * @public
 */
var Indexes = /** @__PURE__ @class */ (function (_super) {
    __extends$2(Indexes, _super);
    function Indexes() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property(0)
    ], Indexes.prototype, "series", void 0);
    __decorate$1([
        Property(0)
    ], Indexes.prototype, "point", void 0);
    return Indexes;
}(ChildProperty));
/**
 * Column series rounded corner options
 */
var CornerRadius = /** @__PURE__ @class */ (function (_super) {
    __extends$2(CornerRadius, _super);
    function CornerRadius() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property(0)
    ], CornerRadius.prototype, "topLeft", void 0);
    __decorate$1([
        Property(0)
    ], CornerRadius.prototype, "topRight", void 0);
    __decorate$1([
        Property(0)
    ], CornerRadius.prototype, "bottomLeft", void 0);
    __decorate$1([
        Property(0)
    ], CornerRadius.prototype, "bottomRight", void 0);
    return CornerRadius;
}(ChildProperty));
/**
 * @private
 */
var Index = /** @__PURE__ @class */ (function () {
    function Index(seriesIndex, pointIndex) {
        this.series = seriesIndex;
        this.point = pointIndex;
    }
    return Index;
}());
/**
 * Configures the Empty Points of series
 */
var EmptyPointSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$2(EmptyPointSettings, _super);
    function EmptyPointSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property(null)
    ], EmptyPointSettings.prototype, "fill", void 0);
    __decorate$1([
        Complex({ color: 'transparent', width: 0 }, Border)
    ], EmptyPointSettings.prototype, "border", void 0);
    __decorate$1([
        Property('Gap')
    ], EmptyPointSettings.prototype, "mode", void 0);
    return EmptyPointSettings;
}(ChildProperty));
/**
 * Configures the drag settings of series
 */
var DragSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$2(DragSettings, _super);
    function DragSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property(false)
    ], DragSettings.prototype, "enable", void 0);
    __decorate$1([
        Property(null)
    ], DragSettings.prototype, "minY", void 0);
    __decorate$1([
        Property(null)
    ], DragSettings.prototype, "maxY", void 0);
    __decorate$1([
        Property(null)
    ], DragSettings.prototype, "fill", void 0);
    return DragSettings;
}(ChildProperty));
/**
 * Options to customize the center label of the pie and doughnut chart.
 *
 * @default {}
 */
var CenterLabel = /** @__PURE__ @class */ (function (_super) {
    __extends$2(CenterLabel, _super);
    function CenterLabel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property(null)
    ], CenterLabel.prototype, "text", void 0);
    __decorate$1([
        Complex({ fontFamily: null, size: "16px", fontStyle: 'Normal', fontWeight: '600', color: null }, Font)
    ], CenterLabel.prototype, "textStyle", void 0);
    __decorate$1([
        Property(null)
    ], CenterLabel.prototype, "hoverTextFormat", void 0);
    return CenterLabel;
}(ChildProperty));
/**
 * Configures the ToolTips in the chart.
 *
 * @public
 */
var TooltipSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$2(TooltipSettings, _super);
    function TooltipSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property(false)
    ], TooltipSettings.prototype, "enable", void 0);
    __decorate$1([
        Property(true)
    ], TooltipSettings.prototype, "enableMarker", void 0);
    __decorate$1([
        Property(false)
    ], TooltipSettings.prototype, "shared", void 0);
    __decorate$1([
        Property(null)
    ], TooltipSettings.prototype, "fill", void 0);
    __decorate$1([
        Property(null)
    ], TooltipSettings.prototype, "header", void 0);
    __decorate$1([
        Property(null)
    ], TooltipSettings.prototype, "opacity", void 0);
    __decorate$1([
        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: null, color: null }, Font)
    ], TooltipSettings.prototype, "textStyle", void 0);
    __decorate$1([
        Property(null)
    ], TooltipSettings.prototype, "format", void 0);
    __decorate$1([
        Property(null)
    ], TooltipSettings.prototype, "template", void 0);
    __decorate$1([
        Property(true)
    ], TooltipSettings.prototype, "enableAnimation", void 0);
    __decorate$1([
        Property(300)
    ], TooltipSettings.prototype, "duration", void 0);
    __decorate$1([
        Property(1000)
    ], TooltipSettings.prototype, "fadeOutDuration", void 0);
    __decorate$1([
        Property('Move')
    ], TooltipSettings.prototype, "fadeOutMode", void 0);
    __decorate$1([
        Property(false)
    ], TooltipSettings.prototype, "enableTextWrap", void 0);
    __decorate$1([
        Property(true)
    ], TooltipSettings.prototype, "showNearestPoint", void 0);
    __decorate$1([
        Complex({ color: null, width: null }, Border)
    ], TooltipSettings.prototype, "border", void 0);
    __decorate$1([
        Complex({ x: null, y: null }, Location)
    ], TooltipSettings.prototype, "location", void 0);
    return TooltipSettings;
}(ChildProperty));
var StockTooltipSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$2(StockTooltipSettings, _super);
    function StockTooltipSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property(false)
    ], StockTooltipSettings.prototype, "enable", void 0);
    __decorate$1([
        Property(true)
    ], StockTooltipSettings.prototype, "enableMarker", void 0);
    __decorate$1([
        Property(false)
    ], StockTooltipSettings.prototype, "shared", void 0);
    __decorate$1([
        Property(null)
    ], StockTooltipSettings.prototype, "fill", void 0);
    __decorate$1([
        Property(null)
    ], StockTooltipSettings.prototype, "header", void 0);
    __decorate$1([
        Property(0.75)
    ], StockTooltipSettings.prototype, "opacity", void 0);
    __decorate$1([
        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: null, color: null }, Font)
    ], StockTooltipSettings.prototype, "textStyle", void 0);
    __decorate$1([
        Property(null)
    ], StockTooltipSettings.prototype, "format", void 0);
    __decorate$1([
        Property(null)
    ], StockTooltipSettings.prototype, "template", void 0);
    __decorate$1([
        Property(true)
    ], StockTooltipSettings.prototype, "enableAnimation", void 0);
    __decorate$1([
        Property(300)
    ], StockTooltipSettings.prototype, "duration", void 0);
    __decorate$1([
        Property(1000)
    ], StockTooltipSettings.prototype, "fadeOutDuration", void 0);
    __decorate$1([
        Property('Move')
    ], StockTooltipSettings.prototype, "fadeOutMode", void 0);
    __decorate$1([
        Property(false)
    ], StockTooltipSettings.prototype, "enableTextWrap", void 0);
    __decorate$1([
        Property(true)
    ], StockTooltipSettings.prototype, "showNearestPoint", void 0);
    __decorate$1([
        Complex({ color: null, width: null }, Border)
    ], StockTooltipSettings.prototype, "border", void 0);
    __decorate$1([
        Property('Fixed')
    ], StockTooltipSettings.prototype, "position", void 0);
    return StockTooltipSettings;
}(ChildProperty));
/**
 * button settings in period selector
 */
var Periods = /** @__PURE__ @class */ (function (_super) {
    __extends$2(Periods, _super);
    function Periods() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property('Years')
    ], Periods.prototype, "intervalType", void 0);
    __decorate$1([
        Property(1)
    ], Periods.prototype, "interval", void 0);
    __decorate$1([
        Property(null)
    ], Periods.prototype, "text", void 0);
    __decorate$1([
        Property(false)
    ], Periods.prototype, "selected", void 0);
    return Periods;
}(ChildProperty));
/**
 * Period Selector Settings
 */
var PeriodSelectorSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$2(PeriodSelectorSettings, _super);
    function PeriodSelectorSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property(43)
    ], PeriodSelectorSettings.prototype, "height", void 0);
    __decorate$1([
        Property('Bottom')
    ], PeriodSelectorSettings.prototype, "position", void 0);
    __decorate$1([
        Collection([], Periods)
    ], PeriodSelectorSettings.prototype, "periods", void 0);
    return PeriodSelectorSettings;
}(ChildProperty));

/* eslint-disable jsdoc/require-returns */
/**
 * Numeric Range.
 *
 * @private
 */
var DoubleRange = /** @__PURE__ @class */ (function () {
    function DoubleRange(start, end) {
        /*
          if (!isNaN(start) && !isNaN(end)) {
           this.mIsEmpty = true;
          } else {
              this.mIsEmpty = false;
          }*/
        if (start < end) {
            this.mStart = start;
            this.mEnd = end;
        }
        else {
            this.mStart = end;
            this.mEnd = start;
        }
    }
    Object.defineProperty(DoubleRange.prototype, "start", {
        //private mIsEmpty: boolean;
        /** @private */
        get: function () {
            return this.mStart;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DoubleRange.prototype, "end", {
        /** @private */
        get: function () {
            return this.mEnd;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DoubleRange.prototype, "delta", {
        /*
          get isEmpty(): boolean {
             return this.mIsEmpty;
         }*/
        /** @private */
        get: function () {
            return (this.mEnd - this.mStart);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DoubleRange.prototype, "median", {
        /** @private */
        get: function () {
            return this.mStart + (this.mEnd - this.mStart) / 2;
        },
        enumerable: true,
        configurable: true
    });
    return DoubleRange;
}());

/**
 * Numeric module is used to render numeric axis.
 */
var Double = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for the dateTime module.
     *
     * @private
     */
    function Double(chart) {
        this.isColumn = 0;
        this.isStacking = false;
        this.chart = chart;
    }
    /**
     * Numeric Nice Interval for the axis.
     *
     * @private
     */
    Double.prototype.calculateNumericNiceInterval = function (axis, delta, size) {
        var actualDesiredIntervalsCount = getActualDesiredIntervalsCount(size, axis);
        var niceInterval = delta / actualDesiredIntervalsCount;
        if (!isNullOrUndefined(axis.desiredIntervals)) {
            if (this.isAutoIntervalOnBothAxis(axis)) {
                return niceInterval;
            }
        }
        var minInterval = Math.pow(10, Math.floor(logBase(niceInterval, 10)));
        for (var _i = 0, _a = axis.intervalDivs; _i < _a.length; _i++) {
            var interval = _a[_i];
            var currentInterval = minInterval * interval;
            if (actualDesiredIntervalsCount < (delta / currentInterval)) {
                break;
            }
            niceInterval = currentInterval;
        }
        return niceInterval;
    };
    /**
     * Actual Range for the axis.
     *
     * @private
     */
    Double.prototype.isAutoIntervalOnBothAxis = function (axis) {
        if (((axis.zoomFactor < 1 || axis.zoomPosition > 0) && axis.enableAutoIntervalOnZooming)) {
            return false;
        }
        else {
            return true;
        }
    };
    Double.prototype.getActualRange = function (axis, size) {
        this.initializeDoubleRange(axis);
        if ((!axis.startFromZero) && (this.isColumn > 0)) {
            axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);
            axis.actualRange.max = axis.doubleRange.end + axis.actualRange.interval;
            if ((axis.doubleRange.start - axis.actualRange.interval < 0 && axis.doubleRange.start > 0)) {
                axis.actualRange.min = 0;
            }
            else {
                axis.actualRange.min = axis.doubleRange.start - (this.isStacking ? 0 : axis.actualRange.interval);
            }
        }
        else {
            axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);
            axis.actualRange.min = axis.doubleRange.start;
            axis.actualRange.max = axis.doubleRange.end;
        }
    };
    /**
     * Range for the axis.
     *
     * @private
     */
    Double.prototype.initializeDoubleRange = function (axis) {
        //Axis Min
        if (axis.minimum !== null) {
            this.min = axis.minimum;
        }
        else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {
            this.min = 0;
        }
        // Axis Max
        if (axis.maximum !== null) {
            this.max = axis.maximum;
        }
        else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {
            this.max = 5;
        }
        if (this.min === this.max) {
            this.max = axis.valueType.indexOf('Category') > -1 ? this.max : this.min + 1;
        }
        axis.doubleRange = new DoubleRange(this.min, this.max);
        axis.actualRange = {};
    };
    /**
     * The function to calculate the range and labels for the axis.
     *
     * @returns {void}
     * @private
     */
    Double.prototype.calculateRangeAndInterval = function (size, axis) {
        this.calculateRange(axis);
        this.getActualRange(axis, size);
        this.applyRangePadding(axis, size);
        this.calculateVisibleLabels(axis, this.chart);
    };
    /**
     * Calculate Range for the axis.
     *
     * @private
     */
    Double.prototype.calculateRange = function (axis) {
        /*! Generate axis range */
        this.min = null;
        this.max = null;
        if (!setRange(axis)) {
            for (var _i = 0, _a = axis.series; _i < _a.length; _i++) {
                var series = _a[_i];
                if (!series.visible) {
                    continue;
                }
                this.paddingInterval = 0;
                if (!isNullOrUndefined(series.points)) {
                    axis.maxPointLength = series.points.length;
                }
                axis.maxPointLength = series.points.length;
                if (((series.type.indexOf('Column') > -1 || series.type.indexOf('Histogram') > -1) && axis.orientation === 'Horizontal')
                    || (series.type.indexOf('Bar') > -1 && axis.orientation === 'Vertical')) {
                    if ((series.xAxis.valueType === 'Double' || series.xAxis.valueType === 'DateTime')
                        && series.xAxis.rangePadding === 'Auto') {
                        this.paddingInterval = getMinPointsDelta(series.xAxis, axis.series) * 0.5;
                    }
                }
                //For xRange
                if (axis.orientation === 'Horizontal') {
                    if (this.chart.requireInvertedAxis) {
                        this.yAxisRange(axis, series);
                    }
                    else {
                        this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);
                    }
                }
                // For yRange
                if (axis.orientation === 'Vertical') {
                    this.isColumn += (series.type.indexOf('Column') !== -1 || series.type.indexOf('Bar') !== -1 || series.drawType === 'Column') ? 1 : 0;
                    this.isStacking = series.type.indexOf('Stacking') !== -1;
                    if (this.chart.requireInvertedAxis) {
                        this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);
                    }
                    else {
                        this.yAxisRange(axis, series);
                    }
                }
            }
        }
    };
    Double.prototype.yAxisRange = function (axis, series) {
        if (series.dragSettings.enable && this.chart.dragY) {
            if (this.chart.dragY >= axis.visibleRange.max) {
                series.yMax = this.chart.dragY + axis.visibleRange.interval;
            }
            if (this.chart.dragY <= axis.visibleRange.min) {
                series.yMin = this.chart.dragY - axis.visibleRange.interval;
            }
        }
        this.findMinMax(series.yMin, series.yMax);
    };
    Double.prototype.findMinMax = function (min, max) {
        if (this.min === null || this.min > min) {
            this.min = min;
        }
        if (this.max === null || this.max < max) {
            this.max = max;
        }
        if ((this.max === this.min) && this.max < 0 && this.min < 0) { // max == min
            this.max = 0;
        }
    };
    /**
     * Apply padding for the range.
     *
     * @private
     */
    Double.prototype.applyRangePadding = function (axis, size) {
        var start = axis.actualRange.min;
        var end = axis.actualRange.max;
        if (!setRange(axis)) {
            var interval = axis.actualRange.interval;
            var padding = axis.getRangePadding(this.chart);
            if (padding === 'Additional' || padding === 'Round') {
                this.findAdditional(axis, start, end, interval, size);
            }
            else if (padding === 'Normal') {
                this.findNormal(axis, start, end, interval, size);
            }
            else {
                this.updateActualRange(axis, start, end, interval);
            }
        }
        axis.actualRange.delta = axis.actualRange.max - axis.actualRange.min;
        this.calculateVisibleRange(size, axis);
    };
    Double.prototype.updateActualRange = function (axis, minimum, maximum, interval) {
        axis.actualRange = {
            min: axis.minimum != null ? axis.minimum : minimum,
            max: axis.maximum != null ? axis.maximum : maximum,
            interval: axis.interval != null ? axis.interval : interval,
            delta: axis.actualRange.delta
        };
    };
    Double.prototype.findAdditional = function (axis, start, end, interval, size) {
        var minimum;
        var maximum;
        minimum = Math.floor(start / interval) * interval;
        maximum = Math.ceil(end / interval) * interval;
        if (axis.rangePadding === 'Additional') {
            minimum -= interval;
            maximum += interval;
        }
        if (!isNullOrUndefined(axis.desiredIntervals)) {
            var delta = maximum - minimum;
            interval = this.calculateNumericNiceInterval(axis, delta, size);
        }
        this.updateActualRange(axis, minimum, maximum, interval);
    };
    Double.prototype.findNormal = function (axis, start, end, interval, size) {
        var remaining;
        var minimum;
        var maximum;
        var startValue = start;
        if (start < 0) {
            startValue = 0;
            minimum = start + (start * 0.05);
            remaining = interval + (minimum % interval);
            if ((0.365 * interval) >= remaining) {
                minimum -= interval;
            }
            if (minimum % interval < 0) {
                minimum = (minimum - interval) - (minimum % interval);
            }
        }
        else {
            minimum = start < ((5.0 / 6.0) * end) ? 0 : (start - (end - start) * 0.5);
            if (minimum % interval > 0) {
                minimum -= (minimum % interval);
            }
        }
        maximum = (end > 0) ? (end + (end - startValue) * 0.05) : (end - (end - startValue) * 0.05);
        remaining = interval - (maximum % interval);
        if ((0.365 * interval) >= remaining) {
            maximum += interval;
        }
        if (maximum % interval > 0) {
            maximum = (maximum + interval) - (maximum % interval);
        }
        axis.doubleRange = new DoubleRange(minimum, maximum);
        if (minimum === 0 || (minimum < 0 && maximum < 0)) {
            interval = this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);
            maximum = Math.ceil(maximum / interval) * interval;
        }
        this.updateActualRange(axis, minimum, maximum, interval);
    };
    /**
     * Calculate visible range for axis.
     *
     * @private
     */
    Double.prototype.calculateVisibleRange = function (size, axis) {
        axis.visibleRange = {
            max: axis.actualRange.max, min: axis.actualRange.min,
            delta: axis.actualRange.delta, interval: axis.actualRange.interval
        };
        if (this.chart.chartAreaType === 'Cartesian') {
            var isLazyLoad = isNullOrUndefined(axis.zoomingScrollBar) ? false : axis.zoomingScrollBar.isLazyLoad;
            if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && !isLazyLoad) {
                axis.calculateVisibleRangeOnZooming(size);
                axis.visibleRange.interval = (axis.enableAutoIntervalOnZooming) ?
                    this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size)
                    : axis.visibleRange.interval;
            }
        }
        if (axis.maximum && axis.orientation === 'Vertical' && axis.rangePadding === 'Auto') {
            var duplicateTempInterval = void 0;
            var tempInterval = axis.visibleRange.min;
            for (; (tempInterval <= axis.visibleRange.max) && (duplicateTempInterval !== tempInterval); tempInterval += axis.visibleRange.interval) {
                duplicateTempInterval = tempInterval;
            }
            if (duplicateTempInterval < axis.visibleRange.max) {
                axis.visibleRange.max = duplicateTempInterval + axis.visibleRange.interval;
            }
        }
        axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);
    };
    /**
     * Calculate label for the axis.
     *
     * @private
     */
    Double.prototype.calculateVisibleLabels = function (axis, chart) {
        /*! Generate axis labels */
        axis.visibleLabels = [];
        var tempInterval = axis.visibleRange.min;
        var labelStyle;
        var controlName = chart.getModuleName();
        var isPolarRadar = controlName === 'chart' && chart.chartAreaType === 'PolarRadar';
        if (!isPolarRadar && (axis.zoomFactor < 1 || axis.zoomPosition > 0 || this.paddingInterval)) {
            tempInterval = axis.visibleRange.min - (axis.visibleRange.min % axis.visibleRange.interval);
        }
        var format = this.getFormat(axis);
        var isCustom = format.match('{value}') !== null;
        var intervalDigits = 0;
        var formatDigits = 0;
        if (axis.labelFormat && axis.labelFormat.indexOf('n') > -1) {
            formatDigits = parseInt(axis.labelFormat.substring(1, axis.labelFormat.length), 10);
        }
        axis.format = chart.intl.getNumberFormat({
            format: isCustom ? '' : format,
            useGrouping: chart.useGroupingSeparator
        });
        axis.startLabel = axis.format(axis.visibleRange.min);
        axis.endLabel = axis.format(axis.visibleRange.max);
        if (axis.visibleRange.interval && (axis.visibleRange.interval + '').indexOf('.') >= 0) {
            intervalDigits = (axis.visibleRange.interval + '').split('.')[1].length;
        }
        var duplicateTempInterval;
        for (; (tempInterval <= axis.visibleRange.max) && (duplicateTempInterval !== tempInterval); tempInterval += axis.visibleRange.interval) {
            duplicateTempInterval = tempInterval;
            labelStyle = (extend({}, getValue('properties', axis.labelStyle), null, true));
            if (withIn(tempInterval, axis.visibleRange)) {
                triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);
            }
        }
        if (tempInterval && (tempInterval + '').indexOf('.') >= 0 && (tempInterval + '').split('.')[1].length > 10) {
            tempInterval = (tempInterval + '').split('.')[1].length > (formatDigits || intervalDigits) ?
                +tempInterval.toFixed(formatDigits || intervalDigits) : tempInterval;
            if (tempInterval <= axis.visibleRange.max) {
                triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);
            }
        }
        if (axis.getMaxLabelWidth) {
            axis.getMaxLabelWidth(this.chart);
        }
    };
    /**
     * Format of the axis label.
     *
     * @private
     */
    Double.prototype.getFormat = function (axis) {
        if (axis.labelFormat) {
            if (axis.labelFormat.indexOf('p') === 0 && axis.labelFormat.indexOf('{value}') === -1 && axis.isStack100) {
                return '{value}%';
            }
            return axis.labelFormat;
        }
        return axis.isStack100 ? '{value}%' : '';
    };
    /**
     * Formatted the axis label.
     *
     * @private
     */
    Double.prototype.formatValue = function (axis, isCustom, format, tempInterval) {
        /*The toLocaleString method is used to adjust the decimal points for this ticket, specifically for ticket numbers I481747 and I541484.*/
        var labelValue = !(tempInterval % 1) ? tempInterval : Number(tempInterval.toLocaleString('en-US').split(',').join(''));
        return isCustom ? format.replace('{value}', axis.format(labelValue))
            : format ? axis.format(tempInterval) : axis.format(labelValue);
    };
    return Double;
}());

/**
 * Specifies the chart constant value
 */
/** @private */
var loaded = 'loaded';
/** @private */
var legendClick = 'legendClick';
/** @private */
var load = 'load';
/** @private */
var animationComplete = 'animationComplete';
/** @private */
var legendRender = 'legendRender';
/** @private */
var textRender = 'textRender';
/** @private */
var pointRender = 'pointRender';
/** @private */
var sharedTooltipRender = 'sharedTooltipRender';
/** @private */
var seriesRender = 'seriesRender';
/** @private */
var axisLabelRender = 'axisLabelRender';
/** @private */
var axisLabelClick = 'axisLabelClick';
/** @private */
var axisRangeCalculated = 'axisRangeCalculated';
/** @private */
var axisMultiLabelRender = 'axisMultiLabelRender';
/** @private */
var tooltipRender = 'tooltipRender';
/** @private */
var chartMouseMove = 'chartMouseMove';
/** @private */
var chartMouseClick = 'chartMouseClick';
/** @private */
var chartDoubleClick = 'chartDoubleClick';
/** @private */
var pointClick = 'pointClick';
/** @private */
var pointDoubleClick = 'pointDoubleClick';
/** @private */
var pointMove = 'pointMove';
/** @private */
var chartMouseLeave = 'chartMouseLeave';
/** @private */
var chartMouseDown = 'chartMouseDown';
/** @private */
var chartMouseUp = 'chartMouseUp';
/** @private */
var zoomComplete = 'zoomComplete';
/** @private */
var dragComplete = 'dragComplete';
/** @private */
var selectionComplete = 'selectionComplete';
/** @private */
var resized = 'resized';
/** @private */
var beforeResize = 'beforeResize';
/** @private */
var beforePrint = 'beforePrint';
/** @private */
var annotationRender = 'annotationRender';
/** @private */
var scrollStart = 'scrollStart';
/** @private */
var scrollEnd = 'scrollEnd';
/** @private */
var scrollChanged = 'scrollChanged';
/** @private */
var stockEventRender = 'stockEventRender';
/** @private */
var multiLevelLabelClick = 'multiLevelLabelClick';
/** @private */
var dragStart = 'dragStart';
/** @private */
var drag = 'drag';
/** @private */
var dragEnd = 'dragEnd';
/*** @private*/
var regSub = /~\d+~/g;
/*** @private*/
var regSup = /\^\d+\^/g;
/** @private */
var beforeExport = 'beforeExport';
/** @private */
var afterExport = 'afterExport';
/** @private */
var bulletChartMouseClick = 'bulletChartMouseClick';
/** @private */
var onZooming = 'onZooming';

var __extends$4 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Configures the Annotation for chart.
 */
var ChartAnnotationSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$4(ChartAnnotationSettings, _super);
    function ChartAnnotationSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$3([
        Property('0')
    ], ChartAnnotationSettings.prototype, "x", void 0);
    __decorate$3([
        Property('0')
    ], ChartAnnotationSettings.prototype, "y", void 0);
    __decorate$3([
        Property(null)
    ], ChartAnnotationSettings.prototype, "content", void 0);
    __decorate$3([
        Property('Center')
    ], ChartAnnotationSettings.prototype, "horizontalAlignment", void 0);
    __decorate$3([
        Property('Pixel')
    ], ChartAnnotationSettings.prototype, "coordinateUnits", void 0);
    __decorate$3([
        Property('Chart')
    ], ChartAnnotationSettings.prototype, "region", void 0);
    __decorate$3([
        Property('Middle')
    ], ChartAnnotationSettings.prototype, "verticalAlignment", void 0);
    __decorate$3([
        Property(null)
    ], ChartAnnotationSettings.prototype, "xAxisName", void 0);
    __decorate$3([
        Property(null)
    ], ChartAnnotationSettings.prototype, "yAxisName", void 0);
    __decorate$3([
        Property(null)
    ], ChartAnnotationSettings.prototype, "description", void 0);
    return ChartAnnotationSettings;
}(ChildProperty));
/**
 * label border properties.
 */
var LabelBorder = /** @__PURE__ @class */ (function (_super) {
    __extends$4(LabelBorder, _super);
    function LabelBorder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$3([
        Property('')
    ], LabelBorder.prototype, "color", void 0);
    __decorate$3([
        Property(1)
    ], LabelBorder.prototype, "width", void 0);
    __decorate$3([
        Property('Rectangle')
    ], LabelBorder.prototype, "type", void 0);
    return LabelBorder;
}(ChildProperty));
/**
 * categories for multi level labels
 */
var MultiLevelCategories = /** @__PURE__ @class */ (function (_super) {
    __extends$4(MultiLevelCategories, _super);
    function MultiLevelCategories() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$3([
        Property(null)
    ], MultiLevelCategories.prototype, "start", void 0);
    __decorate$3([
        Property(null)
    ], MultiLevelCategories.prototype, "end", void 0);
    __decorate$3([
        Property('')
    ], MultiLevelCategories.prototype, "text", void 0);
    __decorate$3([
        Property(null)
    ], MultiLevelCategories.prototype, "maximumTextWidth", void 0);
    __decorate$3([
        Property(null)
    ], MultiLevelCategories.prototype, "customAttributes", void 0);
    __decorate$3([
        Property('')
    ], MultiLevelCategories.prototype, "type", void 0);
    return MultiLevelCategories;
}(ChildProperty));
/**
 * Strip line properties
 */
var StripLineSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$4(StripLineSettings, _super);
    function StripLineSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$3([
        Property(true)
    ], StripLineSettings.prototype, "visible", void 0);
    __decorate$3([
        Property(false)
    ], StripLineSettings.prototype, "startFromAxis", void 0);
    __decorate$3([
        Property(null)
    ], StripLineSettings.prototype, "start", void 0);
    __decorate$3([
        Property(null)
    ], StripLineSettings.prototype, "end", void 0);
    __decorate$3([
        Property(null)
    ], StripLineSettings.prototype, "size", void 0);
    __decorate$3([
        Property('#808080')
    ], StripLineSettings.prototype, "color", void 0);
    __decorate$3([
        Property(null)
    ], StripLineSettings.prototype, "dashArray", void 0);
    __decorate$3([
        Property('Auto')
    ], StripLineSettings.prototype, "sizeType", void 0);
    __decorate$3([
        Property(false)
    ], StripLineSettings.prototype, "isRepeat", void 0);
    __decorate$3([
        Property(null)
    ], StripLineSettings.prototype, "repeatEvery", void 0);
    __decorate$3([
        Property(null)
    ], StripLineSettings.prototype, "repeatUntil", void 0);
    __decorate$3([
        Property(false)
    ], StripLineSettings.prototype, "isSegmented", void 0);
    __decorate$3([
        Property(null)
    ], StripLineSettings.prototype, "segmentStart", void 0);
    __decorate$3([
        Property(null)
    ], StripLineSettings.prototype, "segmentEnd", void 0);
    __decorate$3([
        Property(null)
    ], StripLineSettings.prototype, "segmentAxisName", void 0);
    __decorate$3([
        Complex({ color: 'transparent', width: 1 }, Border)
    ], StripLineSettings.prototype, "border", void 0);
    __decorate$3([
        Property('')
    ], StripLineSettings.prototype, "text", void 0);
    __decorate$3([
        Property(null)
    ], StripLineSettings.prototype, "rotation", void 0);
    __decorate$3([
        Property('Middle')
    ], StripLineSettings.prototype, "horizontalAlignment", void 0);
    __decorate$3([
        Property('Middle')
    ], StripLineSettings.prototype, "verticalAlignment", void 0);
    __decorate$3([
        Complex({ size: '12px', color: null, fontStyle: 'Normal', fontWeight: '400', fontFamily: null }, Font)
    ], StripLineSettings.prototype, "textStyle", void 0);
    __decorate$3([
        Property('Behind')
    ], StripLineSettings.prototype, "zIndex", void 0);
    __decorate$3([
        Property(1)
    ], StripLineSettings.prototype, "opacity", void 0);
    __decorate$3([
        Property('')
    ], StripLineSettings.prototype, "imageUrl", void 0);
    return StripLineSettings;
}(ChildProperty));
/**
 * MultiLevelLabels properties
 */
var MultiLevelLabels = /** @__PURE__ @class */ (function (_super) {
    __extends$4(MultiLevelLabels, _super);
    function MultiLevelLabels() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$3([
        Property('Center')
    ], MultiLevelLabels.prototype, "alignment", void 0);
    __decorate$3([
        Property('Wrap')
    ], MultiLevelLabels.prototype, "overflow", void 0);
    __decorate$3([
        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, Font)
    ], MultiLevelLabels.prototype, "textStyle", void 0);
    __decorate$3([
        Complex({ color: null, width: 1, type: 'Rectangle' }, LabelBorder)
    ], MultiLevelLabels.prototype, "border", void 0);
    __decorate$3([
        Collection([], MultiLevelCategories)
    ], MultiLevelLabels.prototype, "categories", void 0);
    return MultiLevelLabels;
}(ChildProperty));
/**
 * Specifies range for scrollbarSettings property
 *
 * @public
 */
var ScrollbarSettingsRange = /** @__PURE__ @class */ (function (_super) {
    __extends$4(ScrollbarSettingsRange, _super);
    function ScrollbarSettingsRange() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$3([
        Property(null)
    ], ScrollbarSettingsRange.prototype, "minimum", void 0);
    __decorate$3([
        Property(null)
    ], ScrollbarSettingsRange.prototype, "maximum", void 0);
    return ScrollbarSettingsRange;
}(ChildProperty));
/**
 * Scrollbar Settings Properties for Lazy Loading
 */
var ScrollbarSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$4(ScrollbarSettings, _super);
    function ScrollbarSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$3([
        Property(false)
    ], ScrollbarSettings.prototype, "enable", void 0);
    __decorate$3([
        Property(null)
    ], ScrollbarSettings.prototype, "pointsLength", void 0);
    __decorate$3([
        Complex({}, ScrollbarSettingsRange)
    ], ScrollbarSettings.prototype, "range", void 0);
    __decorate$3([
        Property(null)
    ], ScrollbarSettings.prototype, "trackColor", void 0);
    __decorate$3([
        Property(0)
    ], ScrollbarSettings.prototype, "scrollbarRadius", void 0);
    __decorate$3([
        Property(null)
    ], ScrollbarSettings.prototype, "scrollbarColor", void 0);
    __decorate$3([
        Property(0)
    ], ScrollbarSettings.prototype, "trackRadius", void 0);
    __decorate$3([
        Property(null)
    ], ScrollbarSettings.prototype, "gripColor", void 0);
    __decorate$3([
        Property(16)
    ], ScrollbarSettings.prototype, "height", void 0);
    __decorate$3([
        Property(true)
    ], ScrollbarSettings.prototype, "enableZoom", void 0);
    return ScrollbarSettings;
}(ChildProperty));

var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * Configures the `rows` of the chart.
 */
var Row = /** @__PURE__ @class */ (function (_super) {
    __extends$3(Row, _super);
    function Row() {
        /**
         * The height of the row as a string accept input both as '100px' and '100%'.
         * If specified as '100%, row renders to the full height of its chart.
         *
         * @default '100%'
         */
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** @private */
        _this.axes = [];
        /** @private */
        _this.nearSizes = [];
        /** @private */
        _this.farSizes = [];
        /** @private */
        _this.insideFarSizes = [];
        /** @private */
        _this.insideNearSizes = [];
        return _this;
    }
    /**
     * Measure the row size
     *
     * @returns {void}
     * @private
     */
    Row.prototype.computeSize = function (axis, scrollBarHeight, definition, chart) {
        var width = 0;
        var innerPadding = (axis.labelPosition === 'Inside' && (chart.axes.indexOf(axis) > -1)) ? -5 : 5;
        if (axis.visible && axis.internalVisibility) {
            width += (axis.findTickSize(axis.crossInAxis) + scrollBarHeight +
                axis.findLabelSize(axis.crossInAxis, innerPadding, definition, chart) + axis.lineStyle.width * 0.5);
        }
        if (axis.isAxisOpposedPosition) {
            this.farSizes.push(width);
        }
        else {
            this.nearSizes.push(width);
        }
    };
    __decorate$2([
        Property('100%')
    ], Row.prototype, "height", void 0);
    __decorate$2([
        Complex({}, Border)
    ], Row.prototype, "border", void 0);
    return Row;
}(ChildProperty));
/**
 * Configures the `columns` of the chart.
 */
var Column = /** @__PURE__ @class */ (function (_super) {
    __extends$3(Column, _super);
    function Column() {
        /**
         * The width of the column as a string accepts input both as like '100px' or '100%'.
         * If specified as '100%, column renders to the full width of its chart.
         *
         * @default '100%'
         */
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** @private */
        _this.axes = [];
        /** @private */
        _this.nearSizes = [];
        /** @private */
        _this.farSizes = [];
        /** @private */
        _this.insideFarSizes = [];
        /** @private */
        _this.insideNearSizes = [];
        /** @private */
        _this.padding = 0;
        return _this;
    }
    /**
     * Measure the column size
     *
     * @returns {void}
     * @private
     */
    Column.prototype.computeSize = function (axis, scrollBarHeight, definition, chart) {
        var height = 0;
        var innerPadding = 5;
        if (axis.visible && axis.internalVisibility) {
            height += (axis.findTickSize(axis.crossInAxis) + scrollBarHeight +
                axis.findLabelSize(axis.crossInAxis, innerPadding, definition, chart) + axis.lineStyle.width * 0.5);
        }
        if (axis.isAxisOpposedPosition) {
            this.farSizes.push(height);
        }
        else {
            this.nearSizes.push(height);
        }
    };
    __decorate$2([
        Property('100%')
    ], Column.prototype, "width", void 0);
    __decorate$2([
        Complex({}, Border)
    ], Column.prototype, "border", void 0);
    return Column;
}(ChildProperty));
/**
 * Configures the major grid lines in the `axis`.
 */
var MajorGridLines = /** @__PURE__ @class */ (function (_super) {
    __extends$3(MajorGridLines, _super);
    function MajorGridLines() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$2([
        Property(1)
    ], MajorGridLines.prototype, "width", void 0);
    __decorate$2([
        Property('')
    ], MajorGridLines.prototype, "dashArray", void 0);
    __decorate$2([
        Property(null)
    ], MajorGridLines.prototype, "color", void 0);
    return MajorGridLines;
}(ChildProperty));
/**
 * Configures the minor grid lines in the `axis`.
 */
var MinorGridLines = /** @__PURE__ @class */ (function (_super) {
    __extends$3(MinorGridLines, _super);
    function MinorGridLines() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$2([
        Property(0.7)
    ], MinorGridLines.prototype, "width", void 0);
    __decorate$2([
        Property('')
    ], MinorGridLines.prototype, "dashArray", void 0);
    __decorate$2([
        Property(null)
    ], MinorGridLines.prototype, "color", void 0);
    return MinorGridLines;
}(ChildProperty));
/**
 * Configures the axis line of a chart.
 */
var AxisLine = /** @__PURE__ @class */ (function (_super) {
    __extends$3(AxisLine, _super);
    function AxisLine() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$2([
        Property(1)
    ], AxisLine.prototype, "width", void 0);
    __decorate$2([
        Property('')
    ], AxisLine.prototype, "dashArray", void 0);
    __decorate$2([
        Property(null)
    ], AxisLine.prototype, "color", void 0);
    return AxisLine;
}(ChildProperty));
/**
 * Configures the major tick lines.
 */
var MajorTickLines = /** @__PURE__ @class */ (function (_super) {
    __extends$3(MajorTickLines, _super);
    function MajorTickLines() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$2([
        Property(1)
    ], MajorTickLines.prototype, "width", void 0);
    __decorate$2([
        Property(5)
    ], MajorTickLines.prototype, "height", void 0);
    __decorate$2([
        Property(null)
    ], MajorTickLines.prototype, "color", void 0);
    return MajorTickLines;
}(ChildProperty));
/**
 * Configures the minor tick lines.
 */
var MinorTickLines = /** @__PURE__ @class */ (function (_super) {
    __extends$3(MinorTickLines, _super);
    function MinorTickLines() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$2([
        Property(0.7)
    ], MinorTickLines.prototype, "width", void 0);
    __decorate$2([
        Property(5)
    ], MinorTickLines.prototype, "height", void 0);
    __decorate$2([
        Property(null)
    ], MinorTickLines.prototype, "color", void 0);
    return MinorTickLines;
}(ChildProperty));
/**
 * Configures the crosshair ToolTip.
 */
var CrosshairTooltip = /** @__PURE__ @class */ (function (_super) {
    __extends$3(CrosshairTooltip, _super);
    function CrosshairTooltip() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$2([
        Property(false)
    ], CrosshairTooltip.prototype, "enable", void 0);
    __decorate$2([
        Property(null)
    ], CrosshairTooltip.prototype, "fill", void 0);
    __decorate$2([
        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, Font)
    ], CrosshairTooltip.prototype, "textStyle", void 0);
    return CrosshairTooltip;
}(ChildProperty));
/**
 * Configures the axes in the chart.
 *
 * @public
 */
var Axis = /** @__PURE__ @class */ (function (_super) {
    __extends$3(Axis, _super);
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    function Axis(parent, propName, defaultValue, isArray) {
        var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;
        /** @private */
        _this.visibleLabels = [];
        /** @private */
        _this.series = [];
        /** @private */
        _this.rect = new Rect(undefined, undefined, 0, 0);
        /** @private */
        _this.axisBottomLine = null;
        /** @private */
        _this.intervalDivs = [10, 5, 2, 1];
        /** @private */
        _this.isStack100 = false;
        /** @private */
        _this.crossAt = null;
        /** @private */
        _this.updatedRect = null;
        /** @private */
        _this.multiLevelLabelHeight = 0;
        /** @private */
        _this.isChart = true;
        /** @private */
        _this.isIntervalInDecimal = true;
        /** @private */
        _this.titleCollection = [];
        /** @private */
        _this.titleSize = new Size(0, 0);
        /**
         * Task: BLAZ-2044
         * This property used to hide the axis when series hide from legend click
         *
         * @private
         */
        _this.internalVisibility = true;
        /**
         * This property is used to place the vertical axis in opposed position and horizontal axis in inversed
         * when RTL is enabled in chart
         *
         * @private */
        _this.isRTLEnabled = false;
        _this.angle = _this.labelRotation;
        return _this;
    }
    /**
     * The function used to find tick size.
     *
     * @returns {number} tick line size
     * @private
     */
    Axis.prototype.findTickSize = function (crossAxis) {
        if (this.tickPosition === 'Inside') {
            return 0;
        }
        if (crossAxis && (!crossAxis.visibleRange || this.isInside(crossAxis.visibleRange))) {
            return 0;
        }
        return this.majorTickLines.height;
    };
    /**
     * The function used to find axis position.
     *
     * @returns {number}
     * @private
     */
    Axis.prototype.isInside = function (range) {
        return (inside(this.crossAt, range) ||
            (!this.isAxisOpposedPosition && this.crossAt >= range.max) || (this.isAxisOpposedPosition && this.crossAt <= range.min));
    };
    /**
     * The function used to find label Size.
     *
     * @returns {number} labelSize
     * @private
     */
    Axis.prototype.findLabelSize = function (crossAxis, innerPadding, definition, chart) {
        var titleSize = 0;
        var isHorizontal = this.orientation === 'Horizontal';
        if (this.title) {
            var angle = this.titleRotation;
            if ((isNullOrUndefined(angle))) {
                this.titleSize = measureText(this.title, this.titleStyle, chart.themeStyle.axisTitleFont);
                titleSize = this.titleSize.height + innerPadding;
            }
            else {
                this.titleSize = rotateTextSize(this.titleStyle, this.title, angle, chart);
                titleSize = (this.orientation === 'Vertical' ? this.titleSize.width : this.titleSize.height) + innerPadding;
            }
            if (this.rect.width || this.rect.height) {
                var length_1 = isHorizontal ? this.rect.width : this.rect.height;
                this.titleCollection = getTitle(this.title, this.titleStyle, length_1, chart.enableRtl, chart.themeStyle.legendLabelFont);
                titleSize = (titleSize * this.titleCollection.length);
            }
        }
        var diff;
        var value;
        var labelSize = titleSize + innerPadding + this.titlePadding + this.labelPadding +
            ((this.orientation === 'Vertical') ? this.maxLabelSize.width : this.maxLabelSize.height) + this.multiLevelLabelHeight;
        if (crossAxis && this.placeNextToAxisLine) {
            var range = crossAxis.visibleRange;
            var size = (crossAxis.orientation === 'Horizontal') ? crossAxis.rect.width : crossAxis.rect.height;
            if (!range || !size) {
                return 0;
            }
            else if (this.isInside(range)) {
                value = this.findDifference(crossAxis);
                diff = (value) * (size / range.delta);
                diff = (value) * ((size - (diff < labelSize ? (labelSize - diff) : 0)) / range.delta);
                labelSize = (diff < labelSize) ? (labelSize - diff) : 0;
            }
        }
        if (this.isAxisOpposedPosition) {
            definition.insideFarSizes.push(labelSize);
        }
        else {
            definition.insideNearSizes.push(labelSize);
        }
        if (this.labelPosition === 'Inside') {
            return titleSize + innerPadding;
        }
        return labelSize;
    };
    /**
     * The function used to find axis position.
     *
     * @returns {void}
     * @private
     */
    Axis.prototype.updateCrossValue = function () {
        var value = this.crossAt;
        if (value === null || !this.isInside(this.crossInAxis.visibleRange)) {
            this.updatedRect = this.rect;
            return null;
        }
        var range = this.crossInAxis.visibleRange;
        if (!this.isAxisOpposedPosition) {
            if (this.crossAt > range.max) {
                value = range.max;
            }
        }
        else {
            if (this.crossAt < range.min) {
                value = range.min;
            }
        }
        this.updatedRect = extend({}, this.rect, null, true);
        if (this.orientation === 'Horizontal') {
            value = this.crossInAxis.rect.height - (valueToCoefficient(value, this.crossInAxis) * this.crossInAxis.rect.height);
            this.updatedRect.y = this.crossInAxis.rect.y + value;
        }
        else {
            value = valueToCoefficient(value, this.crossInAxis) * this.crossInAxis.rect.width;
            this.updatedRect.x = this.crossInAxis.rect.x + value;
        }
    };
    Axis.prototype.findDifference = function (crossAxis) {
        var value = 0;
        if (this.isAxisOpposedPosition) {
            value = crossAxis.isAxisInverse ? crossAxis.visibleRange.min : crossAxis.visibleRange.max;
        }
        else {
            value = crossAxis.isAxisInverse ? crossAxis.visibleRange.max : crossAxis.visibleRange.min;
        }
        return Math.abs(this.crossAt - value);
    };
    /**
     * Calculate visible range for axis.
     *
     * @returns {void}
     * @private
     */
    Axis.prototype.calculateVisibleRangeOnZooming = function (size) {
        if (isZoomSet(this)) {
            var baseRange = this.actualRange;
            var start = void 0;
            var end = void 0;
            if (!this.isAxisInverse) {
                start = this.actualRange.min + this.zoomPosition * this.actualRange.delta;
                end = start + this.zoomFactor * this.actualRange.delta;
            }
            else {
                start = this.actualRange.max - (this.zoomPosition * this.actualRange.delta);
                end = start - (this.zoomFactor * this.actualRange.delta);
            }
            if (start < baseRange.min) {
                end = end + (baseRange.min - start);
                start = baseRange.min;
            }
            if (end > baseRange.max) {
                start = start - (end - baseRange.max);
                end = baseRange.max;
            }
            this.doubleRange = new DoubleRange(start, end);
            this.visibleRange = { min: this.doubleRange.start, max: this.doubleRange.end,
                delta: this.doubleRange.delta, interval: this.visibleRange.interval };
        }
    };
    /**
     * Triggers the event.
     *
     * @returns {void}
     * @private
     */
    Axis.prototype.triggerRangeRender = function (chart, minimum, maximum, interval) {
        var argsData = {
            cancel: false, name: axisRangeCalculated, axis: this,
            minimum: minimum, maximum: maximum, interval: interval
        };
        chart.trigger(axisRangeCalculated, argsData);
        if (!argsData.cancel) {
            this.visibleRange = { min: argsData.minimum, max: argsData.maximum, interval: argsData.interval,
                delta: argsData.maximum - argsData.minimum };
        }
    };
    /**
     * Calculate padding for the axis.
     *
     * @returns {string}
     * @private
     */
    Axis.prototype.getRangePadding = function (chart) {
        var padding = this.rangePadding;
        if (padding !== 'Auto') {
            return padding;
        }
        switch (this.orientation) {
            case 'Horizontal':
                if (chart.requireInvertedAxis) {
                    padding = (this.isStack100 || this.baseModule.chart.stockChart ? 'Round' : 'Normal');
                }
                else {
                    padding = 'None';
                }
                break;
            case 'Vertical':
                if (!chart.requireInvertedAxis) {
                    padding = (this.isStack100 || this.baseModule.chart.stockChart ? 'Round' : 'Normal');
                }
                else {
                    padding = 'None';
                }
                break;
        }
        return padding;
    };
    /**
     * Calculate maximum label width for the axis.
     *
     * @returns {void}
     * @private
     */
    Axis.prototype.getMaxLabelWidth = function (chart) {
        var pointX;
        var previousEnd = 0;
        var isIntersect = false;
        var isAxisLabelBreak;
        this.angle = this.labelRotation;
        this.maxLabelSize = new Size(0, 0);
        var action = this.labelIntersectAction;
        var label;
        for (var i = 0, len = this.visibleLabels.length; i < len; i++) {
            label = this.visibleLabels[i];
            isAxisLabelBreak = isBreakLabel(label.originalText);
            if (isAxisLabelBreak) {
                label.size = measureText(label.originalText.replace(/<br>/g, ' '), this.labelStyle, chart.themeStyle.axisLabelFont);
                label.breakLabelSize = measureText(this.enableTrim ? label.text.join('<br>') : label.originalText, this.labelStyle, chart.themeStyle.axisLabelFont);
            }
            else {
                label.size = measureText(label.text, this.labelStyle, chart.themeStyle.axisLabelFont);
            }
            var width = isAxisLabelBreak ? label.breakLabelSize.width : label.size.width;
            if (width > this.maxLabelSize.width) {
                this.maxLabelSize.width = width;
                this.rotatedLabel = label.text;
            }
            var height = isAxisLabelBreak ? label.breakLabelSize.height : label.size.height;
            if (height > this.maxLabelSize.height) {
                this.maxLabelSize.height = height;
            }
            if (isAxisLabelBreak) {
                label.text = this.enableTrim ? label.text : label.originalText.split('<br>');
            }
            if (action === 'None' || action === 'Hide' || action === 'Trim') {
                continue;
            }
            if ((action !== 'None' || this.angle % 360 === 0) && this.orientation === 'Horizontal' &&
                this.rect.width > 0 && !isIntersect) {
                var width1 = isAxisLabelBreak ? label.breakLabelSize.width : label.size.width;
                pointX = (valueToCoefficient(label.value, this) * this.rect.width) + this.rect.x;
                pointX -= width1 / 2;
                if (this.edgeLabelPlacement === 'Shift') {
                    if (i === 0 && pointX < this.rect.x) {
                        pointX = this.rect.x;
                    }
                    if (i === this.visibleLabels.length - 1 && ((pointX + width1) > (this.rect.x + this.rect.width))) {
                        pointX = this.rect.x + this.rect.width - width1;
                    }
                }
                switch (action) {
                    case 'MultipleRows':
                        if (i > 0) {
                            this.findMultiRows(i, pointX, label, isAxisLabelBreak);
                        }
                        break;
                    case 'Rotate45':
                    case 'Rotate90':
                        if (i > 0 && (!this.isAxisInverse ? pointX <= previousEnd : pointX + width1 >= previousEnd)) {
                            this.angle = (action === 'Rotate45') ? 45 : 90;
                            isIntersect = true;
                        }
                        break;
                    default:
                        if (isAxisLabelBreak) {
                            var result = void 0;
                            var result1 = [];
                            var str = void 0;
                            for (var index = 0; index < label.text.length; index++) {
                                result = textWrap(label.text[index], this.rect.width / this.visibleLabels.length, this.labelStyle, chart.enableRtl, null, null, chart.themeStyle.axisLabelFont);
                                if (result.length > 1) {
                                    for (var j = 0; j < result.length; j++) {
                                        str = result[j];
                                        result1.push(str);
                                    }
                                }
                                else {
                                    result1.push(result[0]);
                                }
                            }
                            label.text = result1;
                        }
                        else {
                            label.text = textWrap(label.text, this.rect.width / this.visibleLabels.length, this.labelStyle, chart.enableRtl, null, null, chart.themeStyle.axisLabelFont);
                        }
                        // eslint-disable-next-line no-case-declarations
                        var height_1 = (label.size.height * label.text.length);
                        if (height_1 > this.maxLabelSize.height) {
                            this.maxLabelSize.height = height_1;
                        }
                        break;
                }
                previousEnd = this.isAxisInverse ? pointX : pointX + width1;
            }
        }
        if (this.angle !== 0 && this.orientation === 'Horizontal') {
            //I264474: Fix for datasource bind im mounted console error ocurred
            this.rotatedLabel = isNullOrUndefined(this.rotatedLabel) ? '' : this.rotatedLabel;
            var isHorizontalAngle = this.angle === -360 || this.angle === 0 || this.angle === -180 ||
                this.angle === 180 || this.angle === 360;
            // To avoid overlap axis label with chart title or chart legend when it is outside.
            if (this.labelPosition === 'Outside' && !isHorizontalAngle && isBreakLabel(this.rotatedLabel)) {
                this.maxLabelSize = new Size(this.maxLabelSize.height, this.maxLabelSize.width);
            }
            else {
                this.maxLabelSize = rotateTextSize(this.labelStyle, this.rotatedLabel, this.angle, chart);
            }
        }
        else if (this.angle !== 0 && this.orientation === 'Vertical') {
            //I264474: Fix for datasource bind im mounted console error ocurred
            this.rotatedLabel = isNullOrUndefined(this.rotatedLabel) ? '' : this.rotatedLabel;
            var isHorizontalAngle = this.angle === -360 || this.angle === 0 || this.angle === -180 ||
                this.angle === 180 || this.angle === 360;
            // To avoid overlap axis label with chart title or chart legend when it is outside.
            if (this.labelPosition === 'Outside' && !isHorizontalAngle && isBreakLabel(this.rotatedLabel)) {
                this.maxLabelSize = new Size(this.maxLabelSize.height, this.maxLabelSize.width);
            }
            else {
                this.maxLabelSize = rotateTextSize(this.labelStyle, this.rotatedLabel, this.angle, chart);
            }
        }
        if (chart.multiLevelLabelModule && this.multiLevelLabels.length > 0) {
            chart.multiLevelLabelModule.getMultilevelLabelsHeight(this);
        }
    };
    /**
     * Finds the multiple rows for axis.
     *
     * @returns {void}
     */
    Axis.prototype.findMultiRows = function (length, currentX, currentLabel, isBreakLabels) {
        var label;
        var pointX;
        var width2;
        var store = [];
        var isMultiRows;
        for (var i = length - 1; i >= 0; i--) {
            label = this.visibleLabels[i];
            width2 = isBreakLabels ? label.breakLabelSize.width : label.size.width;
            pointX = (valueToCoefficient(label.value, this) * this.rect.width) + this.rect.x;
            isMultiRows = !this.isAxisInverse ? currentX < (pointX + width2 * 0.5) :
                currentX + currentLabel.size.width > (pointX - width2 * 0.5);
            if (isMultiRows) {
                store.push(label.index);
                currentLabel.index = (currentLabel.index > label.index) ? currentLabel.index : label.index + 1;
            }
            else {
                currentLabel.index = store.indexOf(label.index) > -1 ? currentLabel.index : label.index;
            }
        }
        var height = ((isBreakLabels ? currentLabel.breakLabelSize.height : currentLabel.size.height) * currentLabel.index) +
            (5 * (currentLabel.index - 1));
        if (height > this.maxLabelSize.height) {
            this.maxLabelSize.height = height;
        }
    };
    /**
     * Finds the default module for axis.
     *
     * @returns {void}
     * @private
     */
    Axis.prototype.getModule = function (chart) {
        if (this.valueType === 'Double') {
            this.baseModule = new Double(chart);
        }
        else {
            this.baseModule = chart[firstToLowerCase(this.valueType) + 'Module'];
        }
    };
    /**
     * Set the axis `opposedPosition` and `isInversed` properties.
     *
     * @returns {void}
     * @private
     */
    Axis.prototype.setIsInversedAndOpposedPosition = function (isPolar) {
        if (isPolar === void 0) { isPolar = false; }
        this.isAxisOpposedPosition = this.opposedPosition || (!isPolar && this.isRTLEnabled && this.orientation === 'Vertical');
        if (this.opposedPosition && (!isPolar && this.isRTLEnabled && this.orientation === 'Vertical')) {
            this.isAxisOpposedPosition = false;
        }
        this.isAxisInverse = this.isInversed || (this.isRTLEnabled && this.orientation === 'Horizontal');
        if (this.isInversed && (!isPolar && this.isRTLEnabled && this.orientation === 'Horizontal')) {
            this.isAxisInverse = false;
        }
    };
    __decorate$2([
        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, Font)
    ], Axis.prototype, "labelStyle", void 0);
    __decorate$2([
        Complex({}, CrosshairTooltip)
    ], Axis.prototype, "crosshairTooltip", void 0);
    __decorate$2([
        Property('')
    ], Axis.prototype, "title", void 0);
    __decorate$2([
        Complex({ fontFamily: null, size: "14px", fontStyle: 'Normal', fontWeight: '600', color: null }, Font)
    ], Axis.prototype, "titleStyle", void 0);
    __decorate$2([
        Property('')
    ], Axis.prototype, "labelFormat", void 0);
    __decorate$2([
        Property('')
    ], Axis.prototype, "skeleton", void 0);
    __decorate$2([
        Property('DateTime')
    ], Axis.prototype, "skeletonType", void 0);
    __decorate$2([
        Property('Center')
    ], Axis.prototype, "lineBreakAlignment", void 0);
    __decorate$2([
        Property(0)
    ], Axis.prototype, "plotOffset", void 0);
    __decorate$2([
        Property(null)
    ], Axis.prototype, "plotOffsetLeft", void 0);
    __decorate$2([
        Property(null)
    ], Axis.prototype, "plotOffsetTop", void 0);
    __decorate$2([
        Property(null)
    ], Axis.prototype, "plotOffsetRight", void 0);
    __decorate$2([
        Property(null)
    ], Axis.prototype, "plotOffsetBottom", void 0);
    __decorate$2([
        Property(false)
    ], Axis.prototype, "isIndexed", void 0);
    __decorate$2([
        Property(10)
    ], Axis.prototype, "logBase", void 0);
    __decorate$2([
        Property(0)
    ], Axis.prototype, "columnIndex", void 0);
    __decorate$2([
        Property(0)
    ], Axis.prototype, "rowIndex", void 0);
    __decorate$2([
        Property(1)
    ], Axis.prototype, "span", void 0);
    __decorate$2([
        Property(null)
    ], Axis.prototype, "desiredIntervals", void 0);
    __decorate$2([
        Property(3)
    ], Axis.prototype, "maximumLabels", void 0);
    __decorate$2([
        Property(1)
    ], Axis.prototype, "zoomFactor", void 0);
    __decorate$2([
        Property(0)
    ], Axis.prototype, "zoomPosition", void 0);
    __decorate$2([
        Property(true)
    ], Axis.prototype, "enableScrollbarOnZooming", void 0);
    __decorate$2([
        Property(false)
    ], Axis.prototype, "opposedPosition", void 0);
    __decorate$2([
        Property(true)
    ], Axis.prototype, "enableAutoIntervalOnZooming", void 0);
    __decorate$2([
        Property('Auto')
    ], Axis.prototype, "rangePadding", void 0);
    __decorate$2([
        Property('Double')
    ], Axis.prototype, "valueType", void 0);
    __decorate$2([
        Property('None')
    ], Axis.prototype, "edgeLabelPlacement", void 0);
    __decorate$2([
        Property('Auto')
    ], Axis.prototype, "intervalType", void 0);
    __decorate$2([
        Property('BetweenTicks')
    ], Axis.prototype, "labelPlacement", void 0);
    __decorate$2([
        Property('Outside')
    ], Axis.prototype, "tickPosition", void 0);
    __decorate$2([
        Property('Outside')
    ], Axis.prototype, "labelPosition", void 0);
    __decorate$2([
        Property('')
    ], Axis.prototype, "name", void 0);
    __decorate$2([
        Property(true)
    ], Axis.prototype, "visible", void 0);
    __decorate$2([
        Property(0)
    ], Axis.prototype, "minorTicksPerInterval", void 0);
    __decorate$2([
        Property(0)
    ], Axis.prototype, "labelRotation", void 0);
    __decorate$2([
        Property(null)
    ], Axis.prototype, "titleRotation", void 0);
    __decorate$2([
        Property(null)
    ], Axis.prototype, "crossesAt", void 0);
    __decorate$2([
        Property(true)
    ], Axis.prototype, "placeNextToAxisLine", void 0);
    __decorate$2([
        Property(null)
    ], Axis.prototype, "crossesInAxis", void 0);
    __decorate$2([
        Property(null)
    ], Axis.prototype, "minimum", void 0);
    __decorate$2([
        Property(null)
    ], Axis.prototype, "maximum", void 0);
    __decorate$2([
        Property(null)
    ], Axis.prototype, "interval", void 0);
    __decorate$2([
        Property(34)
    ], Axis.prototype, "maximumLabelWidth", void 0);
    __decorate$2([
        Property(false)
    ], Axis.prototype, "enableTrim", void 0);
    __decorate$2([
        Property(5)
    ], Axis.prototype, "labelPadding", void 0);
    __decorate$2([
        Property(5)
    ], Axis.prototype, "titlePadding", void 0);
    __decorate$2([
        Complex({}, MajorTickLines)
    ], Axis.prototype, "majorTickLines", void 0);
    __decorate$2([
        Complex({}, MinorTickLines)
    ], Axis.prototype, "minorTickLines", void 0);
    __decorate$2([
        Complex({}, MajorGridLines)
    ], Axis.prototype, "majorGridLines", void 0);
    __decorate$2([
        Complex({}, MinorGridLines)
    ], Axis.prototype, "minorGridLines", void 0);
    __decorate$2([
        Complex({}, AxisLine)
    ], Axis.prototype, "lineStyle", void 0);
    __decorate$2([
        Property(Browser.isDevice ? 'Rotate45' : 'Trim')
    ], Axis.prototype, "labelIntersectAction", void 0);
    __decorate$2([
        Property(false)
    ], Axis.prototype, "isInversed", void 0);
    __decorate$2([
        Property(100)
    ], Axis.prototype, "coefficient", void 0);
    __decorate$2([
        Property(0)
    ], Axis.prototype, "startAngle", void 0);
    __decorate$2([
        Property(true)
    ], Axis.prototype, "startFromZero", void 0);
    __decorate$2([
        Property(null)
    ], Axis.prototype, "description", void 0);
    __decorate$2([
        Property(2)
    ], Axis.prototype, "tabIndex", void 0);
    __decorate$2([
        Collection([], StripLineSettings)
    ], Axis.prototype, "stripLines", void 0);
    __decorate$2([
        Collection([], MultiLevelLabels)
    ], Axis.prototype, "multiLevelLabels", void 0);
    __decorate$2([
        Complex({ color: null, width: 0, type: 'Rectangle' }, LabelBorder)
    ], Axis.prototype, "border", void 0);
    __decorate$2([
        Complex({}, ScrollbarSettings)
    ], Axis.prototype, "scrollbarSettings", void 0);
    return Axis;
}(ChildProperty));
/** @private */
var VisibleLabels = /** @__PURE__ @class */ (function () {
    function VisibleLabels(text, value, labelStyle, originalText, size, breakLabelSize, index) {
        if (size === void 0) { size = new Size(0, 0); }
        if (breakLabelSize === void 0) { breakLabelSize = new Size(0, 0); }
        if (index === void 0) { index = 1; }
        this.text = text;
        this.originalText = originalText;
        this.value = value;
        this.labelStyle = labelStyle;
        this.size = size;
        this.breakLabelSize = breakLabelSize;
        this.index = index;
    }
    return VisibleLabels;
}());

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * Function to sort the dataSource, by default it sort the data in ascending order.
 *
 * @param  {Object} data chart data
 * @param  {string} fields date fields
 * @param  {boolean} isDescending boolean values of descending
 * @returns {Object[]} It returns chart data which be sorted.
 */
function sort(data, fields, isDescending) {
    var sortData = extend([], data, null);
    for (var i = 0; i < sortData.length; i++) {
        for (var j = 0; j < fields.length; j++) {
            if (sortData[i][fields[j]] instanceof Date) {
                sortData[i][fields[j]] = sortData[i][fields[j]].getTime();
            }
        }
    }
    sortData.sort(function (a, b) {
        var first = 0;
        var second = 0;
        for (var i = 0; i < fields.length; i++) {
            first += a[fields[i]];
            second += b[fields[i]];
        }
        if ((!isDescending && first < second) || (isDescending && first > second)) {
            return -1;
        }
        else if (first === second) {
            return 0;
        }
        return 1;
    });
    return sortData;
}
/** @private */
function isBreakLabel(label) {
    return label.indexOf('<br>') !== -1;
}
/** @private */
function getVisiblePoints(series) {
    var points = extend([], series.points, null, true);
    var tempPoints = [];
    var tempPoint;
    var pointIndex = 0;
    for (var i = 0; i < points.length; i++) {
        tempPoint = points[i];
        if (isNullOrUndefined(tempPoint.x)) {
            continue;
        }
        else {
            tempPoint.index = pointIndex++;
            tempPoints.push(tempPoint);
        }
    }
    return tempPoints;
}
/** @private */
function rotateTextSize(font, text, angle, chart) {
    var transformValue = chart.element.style.transform;
    if (transformValue) {
        chart.element.style.transform = '';
    }
    var renderer = new SvgRenderer(chart.element.id);
    var labelText;
    var textCollection = [];
    var height;
    var dy;
    var label;
    var tspanElement;
    var options = {
        id: 'rotate_text',
        x: chart.initialClipRect.x,
        y: chart.initialClipRect.y,
        'font-size': font.size,
        'font-style': font.fontStyle,
        'font-family': font.fontFamily,
        'font-weight': font.fontWeight,
        'transform': 'rotate(' + angle + ', 0, 0)',
        'text-anchor': 'middle'
    };
    if (isBreakLabel(text)) {
        textCollection = text.split('<br>');
        labelText = textCollection[0];
    }
    else {
        labelText = text;
    }
    var htmlObject = renderer.createText(options, labelText);
    if (!chart.delayRedraw && !chart.redraw && !chart.stockChart) {
        chart.element.appendChild(chart.svgObject);
    }
    // for line break label
    if (typeof textCollection !== 'string' && textCollection.length > 1) {
        for (var i = 1, len = textCollection.length; i < len; i++) {
            height = (measureText(textCollection[i], font, chart.themeStyle.axisLabelFont).height);
            dy = (options.y) + ((i * height));
            label = textCollection[i];
            tspanElement = renderer.createTSpan({
                'x': options.x, 'id': options.id,
                'y': dy
            }, label);
            htmlObject.appendChild(tspanElement);
        }
    }
    chart.svgObject.appendChild(htmlObject);
    var box = htmlObject.getBoundingClientRect();
    if (transformValue) {
        chart.element.style.transform = transformValue;
    }
    remove(htmlObject);
    if (!chart.delayRedraw && !chart.redraw && !chart.stockChart) {
        remove(chart.svgObject);
    }
    if (chart.enableCanvas) {
        var textWidth = measureText(text, font, chart.themeStyle.axisLabelFont).width;
        var textHeight = measureText(text, font, chart.themeStyle.axisLabelFont).height;
        var angleInRadians = (angle * Math.PI) / 180; // Convert the rotation angle to radians
        var rotatedTextWidth = Math.abs(Math.cos(angleInRadians) * textWidth) + Math.abs(Math.sin(angleInRadians) * textHeight);
        var rotatedTextHeight = Math.abs(Math.sin(angleInRadians) * textWidth) + Math.abs(Math.cos(angleInRadians) * textHeight);
        return new Size(rotatedTextWidth, rotatedTextHeight);
    }
    return new Size((box.right - box.left), (box.bottom - box.top));
}
/** @private */
function removeElement$1(id) {
    if (!id) {
        return null;
    }
    var element = typeof id === 'string' ? getElement$1(id) : id;
    if (element) {
        remove(element);
    }
}
/** @private */
function logBase(value, base) {
    return Math.log(value) / Math.log(base);
}
/** @private */
function showTooltip(text, x, y, areaWidth, id, element, isTouch, isTitleOrLegendEnabled) {
    //let id1: string = 'EJ2_legend_tooltip';
    var tooltip = document.getElementById(id);
    var size = measureText(text, {
        fontFamily: 'Segoe UI', size: '12px',
        fontStyle: 'Normal', fontWeight: 'Regular'
    });
    var width = size.width + 5;
    x = (x + width > areaWidth) ? x - (width + 15) : x;
    y = isTitleOrLegendEnabled ? (y - size.height / 2) : y + 15;
    if (!tooltip) {
        tooltip = createElement('div', {
            id: id,
            styles: 'top:' + (y).toString() + 'px;left:' + (x + 15).toString() +
                'px;background-color: rgb(255, 255, 255) !important; color:black !important; ' +
                'position:absolute;border:1px solid rgb(112, 112, 112); padding-left : 3px; padding-right : 2px;' +
                'padding-bottom : 2px; padding-top : 2px; font-size:12px; font-family: "Segoe UI"'
        });
        tooltip.innerText = text;
        element.appendChild(tooltip);
        var left = parseInt(tooltip.style.left.replace('px', ''), 10);
        if (left < 0) {
            tooltip.style.left = '0px';
        }
    }
    else {
        tooltip.innerText = text;
        tooltip.style.top = (y).toString() + 'px';
        tooltip.style.left = (x + 15).toString() + 'px';
    }
    if (isTouch) {
        setTimeout(function () { removeElement$1(id); }, 1500);
    }
}
/** @private */
function inside(value, range) {
    return (value < range.max) && (value > range.min);
}
/** @private */
function withIn(value, range) {
    return (value <= range.max) && (value >= range.min);
}
/** @private */
function logWithIn(value, axis) {
    return axis.valueType === 'Logarithmic' ? logBase(value, axis.logBase) : value;
}
/** @private */
function withInRange(previousPoint, currentPoint, nextPoint, series) {
    var mX2 = logWithIn(currentPoint.xValue, series.xAxis);
    var mX1 = previousPoint ? logWithIn(previousPoint.xValue, series.xAxis) : mX2;
    var mX3 = nextPoint ? logWithIn(nextPoint.xValue, series.xAxis) : mX2;
    var xStart = Math.floor(series.xAxis.visibleRange.min);
    var xEnd = Math.ceil(series.xAxis.visibleRange.max);
    return ((mX1 >= xStart && mX1 <= xEnd) || (mX2 >= xStart && mX2 <= xEnd) ||
        (mX3 >= xStart && mX3 <= xEnd) || (xStart >= mX1 && xStart <= mX3));
}
/** @private */
function sum(values) {
    var sum = 0;
    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
        var value = values_1[_i];
        sum += value;
    }
    return sum;
}
/** @private */
function subArraySum(values, first, last, index, series) {
    var sum = 0;
    if (index !== null) {
        for (var i = (first + 1); i < last; i++) {
            if (index.indexOf(i) === -1) {
                sum += values[i][series.yName];
            }
        }
    }
    else {
        for (var i = (first + 1); i < last; i++) {
            if (!isNullOrUndefined(values[i][series.yName])) {
                sum += values[i][series.yName];
            }
        }
    }
    return sum;
}
/** @private */
function subtractThickness(rect, thickness) {
    rect.x += thickness.left;
    rect.y += thickness.top;
    rect.width -= thickness.left + thickness.right;
    rect.height -= thickness.top + thickness.bottom;
    return rect;
}
/** @private */
function subtractRect(rect, thickness) {
    rect.x += thickness.x;
    rect.y += thickness.y;
    rect.width -= thickness.x + thickness.width;
    rect.height -= thickness.y + thickness.height;
    return rect;
}
/** @private */
function degreeToLocation(degree, radius, center) {
    var radian = (degree * Math.PI) / 180;
    return new ChartLocation(Math.cos(radian) * radius + center.x, Math.sin(radian) * radius + center.y);
}
/** @private */
function degreeToRadian(degree) {
    return degree * (Math.PI / 180);
}
/** @private */
function getRotatedRectangleCoordinates(actualPoints, centerX, centerY, angle) {
    var coordinatesAfterRotation = [];
    for (var i = 0; i < 4; i++) {
        var point = actualPoints[i];
        // translate point to origin
        var tempX = point.x - centerX;
        var tempY = point.y - centerY;
        // now apply rotation
        var rotatedX = tempX * Math.cos(degreeToRadian(angle)) - tempY * Math.sin(degreeToRadian(angle));
        var rotatedY = tempX * Math.sin(degreeToRadian(angle)) + tempY * Math.cos(degreeToRadian(angle));
        // translate back
        point.x = rotatedX + centerX;
        point.y = rotatedY + centerY;
        coordinatesAfterRotation.push(new ChartLocation(point.x, point.y));
    }
    return coordinatesAfterRotation;
}
/**
 * Helper function to determine whether there is an intersection between the two polygons described
 * by the lists of vertices. Uses the Separating Axis Theorem
 *
 * @param {ChartLocation[]} a an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon
 * @param {ChartLocation[]} b an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon
 * @returns {boolean} if there is any intersection between the 2 polygons, false otherwise
 */
function isRotatedRectIntersect(a, b) {
    var polygons = [a, b];
    var minA;
    var maxA;
    var projected;
    var i;
    var i1;
    var j;
    var minB;
    var maxB;
    for (i = 0; i < polygons.length; i++) {
        // for each polygon, look at each edge of the polygon, and determine if it separates
        // the two shapes
        var polygon = polygons[i];
        for (i1 = 0; i1 < polygon.length; i1++) {
            // grab 2 vertices to create an edge
            var i2 = (i1 + 1) % polygon.length;
            var p1 = polygon[i1];
            var p2 = polygon[i2];
            // find the line perpendicular to this edge
            var normal = new ChartLocation(p2.y - p1.y, p1.x - p2.x);
            minA = maxA = undefined;
            // for each vertex in the first shape, project it onto the line perpendicular to the edge
            // and keep track of the min and max of these values
            for (j = 0; j < a.length; j++) {
                projected = normal.x * a[j].x + normal.y * a[j].y;
                if (isNullOrUndefined(minA) || projected < minA) {
                    minA = projected;
                }
                if (isNullOrUndefined(maxA) || projected > maxA) {
                    maxA = projected;
                }
            }
            // for each vertex in the second shape, project it onto the line perpendicular to the edge
            // and keep track of the min and max of these values
            minB = maxB = undefined;
            for (j = 0; j < b.length; j++) {
                projected = normal.x * b[j].x + normal.y * b[j].y;
                if (isNullOrUndefined(minB) || projected < minB) {
                    minB = projected;
                }
                if (isNullOrUndefined(maxB) || projected > maxB) {
                    maxB = projected;
                }
            }
            // if there is no overlap between the projects, the edge we are looking at separates the two
            // polygons, and we know there is no overlap
            if (maxA < minB || maxB < minA) {
                return false;
            }
        }
    }
    return true;
}
/** @private */
function getAccumulationLegend(locX, locY, r, height, width, mode) {
    var cartesianlarge = degreeToLocation(270, r, new ChartLocation(locX, locY));
    var cartesiansmall = degreeToLocation(270, r, new ChartLocation(locX + (width / 10), locY));
    return 'M' + ' ' + locX + ' ' + locY + ' ' + 'L' + ' ' + (locX + r) + ' ' + (locY) + ' ' + 'A' + ' ' + (r) + ' ' + (r) +
        ' ' + 0 + ' ' + 1 + ' ' + 1 + ' ' + cartesianlarge.x + ' ' + cartesianlarge.y + ' ' + 'Z' + ' ' + 'M' + ' ' + (locX +
        (width / 10)) + ' ' + (locY - (height / 10)) + ' ' + 'L' + (locX + (r)) + ' ' + (locY - height / 10) + ' ' + 'A' + ' '
        + (r) + ' ' + (r) + ' ' + 0 + ' ' + 0 + ' ' + 0 + ' ' + cartesiansmall.x + ' ' + cartesiansmall.y + ' ' + 'Z';
}
/** @private */
function getAngle(center, point) {
    var angle = Math.atan2((point.y - center.y), (point.x - center.x));
    angle = angle < 0 ? (6.283 + angle) : angle;
    return angle * (180 / Math.PI);
}
/** @private */
function subArray(values, index) {
    var subArray = [];
    for (var i = 0; i <= index - 1; i++) {
        subArray.push(values[i]);
    }
    return subArray;
}
/** @private */
function valueToCoefficient(value, axis) {
    var range = axis.visibleRange;
    var result = (value - range.min) / (range.delta);
    var isInverse = axis.isChart ? axis.isAxisInverse : axis.isInversed;
    return isInverse ? (1 - result) : result;
}
/** @private */
function TransformToVisible(x, y, xAxis, yAxis, isInverted, series) {
    x = (xAxis.valueType === 'Logarithmic' ? logBase(x > 1 ? x : 1, xAxis.logBase) : x);
    y = (yAxis.valueType === 'Logarithmic' ?
        logBase(y > 1 ? y : 1, yAxis.logBase) : y);
    x += xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks' && series.type !== 'Radar' ? 0.5 : 0;
    var radius = series.chart.radius * valueToCoefficient(y, yAxis);
    var point = CoefficientToVector(valueToPolarCoefficient(x, xAxis), series.chart.primaryXAxis.startAngle);
    return {
        x: (series.clipRect.width / 2 + series.clipRect.x) + radius * point.x,
        y: (series.clipRect.height / 2 + series.clipRect.y) + radius * point.y
    };
}
/**
 * method to find series, point index by element id
 *
 * @private
 */
function indexFinder(id, isPoint) {
    if (isPoint === void 0) { isPoint = false; }
    var ids = ['NaN', 'NaN'];
    if (id.indexOf('_Point_') > -1) {
        ids = id.split('_Series_')[1].split('_Point_');
    }
    else if (id.indexOf('_shape_') > -1 && (!isPoint || (isPoint && id.indexOf('_legend_') === -1))) {
        ids = id.split('_shape_');
        ids[0] = '0';
    }
    else if (id.indexOf('_text_') > -1 && (!isPoint || (isPoint && id.indexOf('_legend_') === -1))) {
        ids = id.split('_text_');
        ids[0] = '0';
    }
    return new Index(parseInt(ids[0], 10), parseInt(ids[1], 10));
}
/** @private */
function CoefficientToVector(coefficient, startAngle) {
    startAngle = startAngle < 0 ? startAngle + 360 : startAngle;
    var angle = Math.PI * (1.5 - 2 * coefficient);
    angle = angle + (startAngle * Math.PI) / 180;
    return { x: Math.cos(angle), y: Math.sin(angle) };
}
/** @private */
function valueToPolarCoefficient(value, axis) {
    var range = axis.visibleRange;
    var delta;
    var length;
    if (axis.valueType !== 'Category') {
        delta = (range.max - (axis.valueType === 'DateTime' ? axis.dateTimeInterval : range.interval)) - range.min;
        length = axis.visibleLabels.length - 1;
        delta = delta === 0 ? 1 : delta;
    }
    else {
        // To split an interval equally based on visible labels count
        delta = axis.visibleLabels.length === 1 ? 1 :
            (axis.visibleLabels[axis.visibleLabels.length - 1].value - axis.visibleLabels[0].value);
        length = axis.visibleLabels.length;
    }
    return axis.isAxisInverse ? ((value - range.min) / delta) * (1 - 1 / (length)) :
        1 - ((value - range.min) / delta) * (1 - 1 / (length));
}
/** @private */
var Mean = /** @__PURE__ @class */ (function () {
    function Mean(verticalStandardMean, verticalSquareRoot, horizontalStandardMean, horizontalSquareRoot, verticalMean, horizontalMean) {
        this.verticalStandardMean = verticalStandardMean;
        this.horizontalStandardMean = horizontalStandardMean;
        this.verticalSquareRoot = verticalSquareRoot;
        this.horizontalSquareRoot = horizontalSquareRoot;
        this.verticalMean = verticalMean;
        this.horizontalMean = horizontalMean;
    }
    return Mean;
}());
/** @private */
var PolarArc = /** @__PURE__ @class */ (function () {
    function PolarArc(startAngle, endAngle, innerRadius, radius, currentXPosition) {
        this.startAngle = startAngle;
        this.endAngle = endAngle;
        this.innerRadius = innerRadius;
        this.radius = radius;
        this.currentXPosition = currentXPosition;
    }
    return PolarArc;
}());
/** @private */
function createTooltip(id, text, top, left, fontSize) {
    var tooltip = getElement$1(id);
    var style = 'top:' + top.toString() + 'px;' +
        'left:' + left.toString() + 'px;' +
        'color:black !important; ' +
        'background:#FFFFFF !important; ' +
        'position:absolute;border:1px solid #707070;font-size:' + fontSize + ';border-radius:2px; z-index:1';
    if (!tooltip) {
        tooltip = createElement('div', {
            id: id, innerHTML: '&nbsp;' + text + '&nbsp;', styles: style
        });
        document.body.appendChild(tooltip);
    }
    else {
        tooltip.setAttribute('innerHTML', '&nbsp;' + text + '&nbsp;');
        tooltip.setAttribute('styles', style);
    }
}
/** @private */
function createZoomingLabels(chart, axis, parent, index, isVertical, rect) {
    var margin = 5;
    var opposedPosition = axis.isAxisOpposedPosition;
    var anchor = chart.enableRtl ? 'end' : isVertical ? 'start' : 'auto';
    var size;
    var chartRect = chart.availableSize.width;
    var pathElement;
    var x;
    var y;
    var rx = 3;
    var arrowLocation;
    var direction;
    var scrollBarHeight = axis.scrollbarSettings.enable || (axis.zoomingScrollBar && axis.zoomingScrollBar.svgObject)
        ? axis.scrollBarHeight : 0;
    var isRtlEnabled = (chart.enableRtl && !isVertical && !axis.isInversed) || (axis.isInversed && !(chart.enableRtl && !isVertical));
    for (var i = 0; i < 2; i++) {
        size = measureText(i ? (isRtlEnabled ? axis.startLabel : axis.endLabel) : (isRtlEnabled ? axis.endLabel : axis.startLabel), axis.labelStyle, chart.themeStyle.axisLabelFont);
        if (isVertical) {
            arrowLocation = i ? new ChartLocation(rect.x - scrollBarHeight, rect.y + rx) :
                new ChartLocation(axis.rect.x - scrollBarHeight, (rect.y + rect.height - rx));
            x = (rect.x + (opposedPosition ? (rect.width + margin + scrollBarHeight) : -(size.width + margin + margin + scrollBarHeight)));
            y = (rect.y + (i ? 0 : rect.height - size.height - margin));
            x += (x < 0 || ((chartRect) < (x + size.width + margin))) ? (opposedPosition ? -(size.width / 2) : size.width / 2) : 0;
            direction = findCrosshairDirection(rx, rx, new Rect(x, y, size.width + margin, size.height + margin), arrowLocation, margin, false, false, !opposedPosition, arrowLocation.x, arrowLocation.y + (i ? -rx : rx));
        }
        else {
            arrowLocation = i ? new ChartLocation((rect.x + rect.width - rx), (rect.y + rect.height + scrollBarHeight)) :
                new ChartLocation(rect.x + rx, (rect.y + rect.height + scrollBarHeight));
            x = (rect.x + (i ? (rect.width - size.width - margin) : 0));
            y = (opposedPosition ? (rect.y - size.height - 10 - scrollBarHeight) : (rect.y + rect.height + margin + scrollBarHeight));
            direction = findCrosshairDirection(rx, rx, new Rect(x, y, size.width + margin, size.height + margin), arrowLocation, margin, opposedPosition, !opposedPosition, false, arrowLocation.x + (i ? rx : -rx), arrowLocation.y);
        }
        x = x + (margin / 2);
        y = y + (3 * (size.height / 4)) + (margin / 2);
        pathElement = chart.renderer.drawPath({
            'id': chart.element.id + '_Zoom_' + index + '_AxisLabel_Shape_' + i,
            'fill': chart.themeStyle.crosshairFill, 'width': 2, 'color': chart.themeStyle.crosshairFill,
            'opacity': 1, 'stroke-dasharray': null, 'd': direction
        }, null);
        parent.appendChild(pathElement);
        if (chart.theme === 'Fluent' || chart.theme === 'FluentDark') {
            var shadowId = chart.element.id + '_shadow';
            pathElement.setAttribute('filter', Browser.isIE ? '' : 'url(#' + shadowId + ')');
            var shadow = '<filter id="' + shadowId + '" height="130%"><feGaussianBlur in="SourceAlpha" stdDeviation="3"/>';
            shadow += '<feOffset dx="3" dy="3" result="offsetblur"/><feComponentTransfer><feFuncA type="linear" slope="0.5"/>';
            shadow += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
            var defElement = chart.renderer.createDefs();
            defElement.setAttribute('id', chart.element.id + 'SVG_tooltip_definition');
            parent.appendChild(defElement);
            defElement.innerHTML = shadow;
            pathElement.setAttribute('stroke', '#cccccc');
            pathElement.setAttribute('stroke-width', '0.5');
        }
        textElement$1(chart.renderer, new TextOption(chart.element.id + '_Zoom_' + index + '_AxisLabel_' + i, x, y, anchor, i ? (isRtlEnabled ? axis.startLabel : axis.endLabel) : (isRtlEnabled ? axis.endLabel : axis.startLabel)), { color: chart.themeStyle.crosshairLabelFont.color, fontFamily: 'Segoe UI', fontWeight: 'Regular', size: '11px' }, chart.themeStyle.crosshairLabelFont.color, parent, null, null, null, null, null, null, null, null, null, null, chart.themeStyle.crosshairLabelFont);
    }
    return parent;
}
/** @private */
function findCrosshairDirection(rX, rY, rect, arrowLocation, arrowPadding, top, bottom, left, tipX, tipY) {
    var direction = '';
    var startX = rect.x;
    var startY = rect.y;
    var width = rect.x + rect.width;
    var height = rect.y + rect.height;
    if (top) {
        direction = direction.concat('M' + ' ' + (startX) + ' ' + (startY + rY) + ' Q ' + startX + ' '
            + startY + ' ' + (startX + rX) + ' ' + startY);
        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (startY) + ' Q ' + width + ' '
            + startY + ' ' + (width) + ' ' + (startY + rY));
        direction = direction.concat(' L' + ' ' + (width) + ' ' + (height - rY) + ' Q ' + width + ' '
            + (height) + ' ' + (width - rX) + ' ' + (height));
        if (arrowPadding !== 0) {
            direction = direction.concat(' L' + ' ' + (arrowLocation.x + arrowPadding / 2) + ' ' + (height));
            direction = direction.concat(' L' + ' ' + (tipX) + ' ' + (height + arrowPadding)
                + ' L' + ' ' + (arrowLocation.x - arrowPadding / 2) + ' ' + height);
        }
        if ((arrowLocation.x - arrowPadding / 2) > startX) {
            direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' '
                + height + ' ' + (startX) + ' ' + (height - rY) + ' z');
        }
        else {
            if (arrowPadding === 0) {
                direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' '
                    + height + ' ' + (startX) + ' ' + (height - rY) + ' z');
            }
            else {
                direction = direction.concat(' L' + ' ' + (startX) + ' ' + (height + rY) + ' z');
            }
        }
    }
    else if (bottom) {
        direction = direction.concat('M' + ' ' + (startX) + ' ' + (startY + rY) + ' Q ' + startX + ' '
            + (startY) + ' ' + (startX + rX) + ' ' + (startY) + ' L' + ' ' + (arrowLocation.x - arrowPadding / 2) + ' ' + (startY));
        direction = direction.concat(' L' + ' ' + (tipX) + ' ' + (arrowLocation.y));
        direction = direction.concat(' L' + ' ' + (arrowLocation.x + arrowPadding / 2) + ' ' + (startY));
        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (startY)
            + ' Q ' + (width) + ' ' + (startY) + ' ' + (width) + ' ' + (startY + rY));
        direction = direction.concat(' L' + ' ' + (width) + ' ' + (height - rY) + ' Q ' + (width) + ' '
            + (height) + ' ' + (width - rX) + ' ' + (height));
        direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + (height) + ' Q ' + (startX) + ' '
            + (height) + ' ' + (startX) + ' ' + (height - rY) + ' z');
    }
    else if (left) {
        direction = direction.concat('M' + ' ' + (startX) + ' ' + (startY + rY) + ' Q ' + startX + ' '
            + (startY) + ' ' + (startX + rX) + ' ' + (startY));
        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (startY) + ' Q ' + (width) + ' '
            + (startY) + ' ' + (width) + ' ' + (startY + rY) + ' L' + ' ' + (width) + ' ' + (arrowLocation.y - arrowPadding / 2));
        direction = direction.concat(' L' + ' ' + (width + arrowPadding) + ' ' + (tipY));
        direction = direction.concat(' L' + ' ' + (width) + ' ' + (arrowLocation.y + arrowPadding / 2));
        direction = direction.concat(' L' + ' ' + (width) + ' ' + (height - rY) + ' Q ' + width + ' ' + (height) + ' ' + (width - rX) + ' ' + (height));
        direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + (height) + ' Q ' + startX + ' '
            + (height) + ' ' + (startX) + ' ' + (height - rY) + ' z');
    }
    else {
        direction = direction.concat('M' + ' ' + (startX + rX) + ' ' + (startY) + ' Q ' + (startX) + ' '
            + (startY) + ' ' + (startX) + ' ' + (startY + rY) + ' L' + ' ' + (startX) + ' ' + (arrowLocation.y - arrowPadding / 2));
        direction = direction.concat(' L' + ' ' + (startX - arrowPadding) + ' ' + (tipY));
        direction = direction.concat(' L' + ' ' + (startX) + ' ' + (arrowLocation.y + arrowPadding / 2));
        direction = direction.concat(' L' + ' ' + (startX) + ' ' + (height - rY) + ' Q ' + startX + ' '
            + (height) + ' ' + (startX + rX) + ' ' + (height));
        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (height) + ' Q ' + width + ' '
            + (height) + ' ' + (width) + ' ' + (height - rY));
        direction = direction.concat(' L' + ' ' + (width) + ' ' + (startY + rY) + ' Q ' + width + ' '
            + (startY) + ' ' + (width - rX) + ' ' + (startY) + ' z');
    }
    return direction;
}
//Within bounds
/** @private */
function withInBounds(x, y, bounds, width, height) {
    if (width === void 0) { width = 0; }
    if (height === void 0) { height = 0; }
    return (x >= bounds.x - width && x <= bounds.x + bounds.width + width && y >= bounds.y - height
        && y <= bounds.y + bounds.height + height);
}
/** @private */
function getValueXByPoint(value, size, axis) {
    var actualValue = !axis.isAxisInverse ? value / size : (1 - (value / size));
    return actualValue * (axis.visibleRange.delta) + axis.visibleRange.min;
}
/** @private */
function getValueYByPoint(value, size, axis) {
    var actualValue = axis.isAxisInverse ? value / size : (1 - (value / size));
    return actualValue * (axis.visibleRange.delta) + axis.visibleRange.min;
}
/** @private */
function findClipRect(series, isCanvas) {
    if (isCanvas === void 0) { isCanvas = false; }
    var rect = series.clipRect;
    if (isCanvas && (series.type === 'Polar' || series.type === 'Radar')) {
        if (series.drawType === 'Scatter') {
            rect.x = series.xAxis.rect.x;
            rect.y = series.yAxis.rect.y;
            rect.width = series.xAxis.rect.width;
            rect.height = series.yAxis.rect.height;
        }
        else {
            rect.x = series.xAxis.rect.x / 2;
            rect.y = series.yAxis.rect.y / 2;
            rect.width = series.xAxis.rect.width;
            rect.height = series.yAxis.rect.height;
        }
    }
    else {
        if (series.chart.requireInvertedAxis) {
            rect.x = series.yAxis.rect.x;
            rect.y = series.xAxis.rect.y;
            rect.width = series.yAxis.rect.width;
            rect.height = series.xAxis.rect.height;
        }
        else {
            rect.x = series.xAxis.rect.x;
            rect.y = series.yAxis.rect.y;
            rect.width = series.xAxis.rect.width;
            rect.height = series.yAxis.rect.height;
        }
    }
}
/** @private */
function firstToLowerCase(str) {
    return str.substr(0, 1).toLowerCase() + str.substr(1);
}
/** @private */
function getTransform(xAxis, yAxis, invertedAxis) {
    var x;
    var y;
    var width;
    var height;
    if (invertedAxis) {
        x = yAxis.rect.x;
        y = xAxis.rect.y;
        width = yAxis.rect.width;
        height = xAxis.rect.height;
    }
    else {
        x = xAxis.rect.x;
        y = yAxis.rect.y;
        width = xAxis.rect.width;
        height = yAxis.rect.height;
    }
    return new Rect(x, y, width, height);
}
/** @private */
function getMinPointsDelta(axis, seriesCollection) {
    var minDelta = Number.MAX_VALUE;
    var xValues;
    var minVal;
    var seriesMin;
    var stackingGroups = [];
    for (var index = 0; index < seriesCollection.length; index++) {
        var series = seriesCollection[index];
        xValues = [];
        if (series.visible &&
            (axis.name === series.xAxisName || (axis.name === 'primaryXAxis' && series.xAxisName === null)
                || (axis.name === series.chart.primaryXAxis.name && !series.xAxisName))) {
            if (series.type.indexOf('Stacking') > -1 && stackingGroups.indexOf(series.stackingGroup) === -1) {
                stackingGroups.push(series.stackingGroup);
            }
            xValues = series.points.map(function (point) {
                return point.xValue;
            });
            xValues.sort(function (first, second) { return first - second; });
            if (xValues.length === 1) {
                seriesMin = (axis.valueType === 'DateTime' && series.xMin === series.xMax) ? (series.xMin - 25920000) : series.xMin;
                minVal = xValues[0] - (!isNullOrUndefined(seriesMin) ?
                    seriesMin : axis.visibleRange.min);
                if (minVal !== 0) {
                    minDelta = Math.min(minDelta, minVal);
                }
            }
            else {
                for (var index_1 = 0; index_1 < xValues.length; index_1++) {
                    var value = xValues[index_1];
                    if (index_1 > 0 && value) {
                        minVal = series.type.indexOf('Stacking') > -1 && axis.valueType == "Category" ? stackingGroups.length : value - xValues[index_1 - 1];
                        if (minVal !== 0) {
                            minDelta = Math.min(minDelta, minVal);
                        }
                    }
                }
            }
        }
    }
    if (minDelta === Number.MAX_VALUE) {
        minDelta = 1;
    }
    return minDelta;
}
/** @private */
function getAnimationFunction(effect) {
    var functionName;
    switch (effect) {
        case 'Linear':
            functionName = linear;
            break;
    }
    return functionName;
}
/**
 * Animation Effect Calculation Started Here
 *
 * @param {number} currentTime currentTime
 * @param {number} startValue startValue of the animation
 * @param {number} endValue endValue of the animation
 * @param {number} duration duration of the animation
 * @private
 */
function linear(currentTime, startValue, endValue, duration) {
    return -endValue * Math.cos(currentTime / duration * (Math.PI / 2)) + endValue + startValue;
}
/**
 * Animation Effect Calculation End
 *
 * @private
 */
function markerAnimate(element, delay, duration, series, pointIndex, point, isLabel) {
    var centerX = point.x;
    var centerY = point.y;
    var height = 0;
    element.style.visibility = 'hidden';
    var transform = element.getAttribute('transform');
    new Animation({}).animate(element, {
        duration: duration,
        delay: delay,
        progress: function (args) {
            if (args.timeStamp > args.delay) {
                args.element.style.visibility = 'visible';
                height = ((args.timeStamp - args.delay) / args.duration);
                element.setAttribute('transform', 'translate(' + centerX
                    + ' ' + centerY + ') scale(' + height + ') translate(' + (-centerX) + ' ' + (-centerY) + ')');
            }
        },
        end: function () {
            element.style.visibility = '';
            element.setAttribute('transform', transform ? transform : '');
            if ((series.type === 'Scatter' || series.type === 'Bubble') && !isLabel && (pointIndex === series.points.length - 1)) {
                series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });
            }
        }
    });
}
/**
 * Animate the rect element.
 */
function animateRectElement(element, delay, duration, currentRect, previousRect) {
    var setStyle = function (rect) {
        element.setAttribute('x', rect.x + '');
        element.setAttribute('y', rect.y + '');
        element.setAttribute('width', rect.width + '');
        element.setAttribute('height', rect.height + '');
    };
    new Animation({}).animate(createElement('div'), {
        duration: duration,
        delay: delay,
        //name: name,
        progress: function (args) {
            setStyle(new Rect(linear(args.timeStamp, previousRect.x, currentRect.x - previousRect.x, args.duration), linear(args.timeStamp, previousRect.y, currentRect.y - previousRect.y, args.duration), linear(args.timeStamp, previousRect.width, currentRect.width - previousRect.width, args.duration), linear(args.timeStamp, previousRect.height, currentRect.height - previousRect.height, args.duration)));
        },
        end: function () {
            setStyle(currentRect);
        }
    });
}
/**
 * Animation after legend click a path.
 *
 * @param {Element} element element to be animated
 * @param {string} direction current direction of the path
 * @param {boolean} redraw chart redraw
 * @param {string} previousDirection previous direction of the path
 * @param {number} animateDuration animateDuration of the path
 */
function pathAnimation(element, direction, redraw, previousDirection, animateDuration) {
    if (!redraw || (!previousDirection && !element)) {
        return null;
    }
    var duration = 300;
    if (animateDuration) {
        duration = animateDuration;
    }
    var startDirections = previousDirection || element.getAttribute('d');
    var splitDirections = startDirections.split(/(?=[LMCZAQ])/);
    var endDirections = direction.split(/(?=[LMCZAQ])/);
    var currentDireciton;
    var startPath = [];
    var endPath = [];
    var c;
    var end;
    element.setAttribute('d', startDirections);
    new Animation({}).animate(createElement('div'), {
        duration: duration,
        progress: function (args) {
            currentDireciton = '';
            splitDirections.map(function (directions, index) {
                startPath = directions.split(' ');
                endPath = endDirections[index] ? endDirections[index].split(' ') : startPath;
                if (startPath[0] === 'Z') {
                    currentDireciton += 'Z' + ' ';
                }
                else if (startPath[0] === '') {
                    currentDireciton = '';
                }
                else {
                    currentDireciton += startPath[0] + ' ' +
                        linear(args.timeStamp, +startPath[1], (+endPath[1] - +startPath[1]), args.duration) + ' ' +
                        linear(args.timeStamp, +startPath[2], (+endPath[2] - +startPath[2]), args.duration) + ' ';
                }
                if (startPath[0] === 'C' || startPath[0] === 'Q') {
                    c = 3;
                    end = startPath[0] === 'Q' ? 4 : 6;
                    while (c < end) {
                        currentDireciton += linear(args.timeStamp, +startPath[c], (+endPath[c] - +startPath[c]), args.duration) + ' ' +
                            linear(args.timeStamp, +startPath[++c], (+endPath[c] - +startPath[c]), args.duration) + ' ';
                        ++c;
                    }
                }
                if (startPath[0] === 'A') {
                    currentDireciton += 0 + ' ' + 0 + ' ' + 1 + ' ' +
                        linear(args.timeStamp, +startPath[6], (+endPath[6] - +startPath[6]), args.duration) + ' ' +
                        linear(args.timeStamp, +startPath[7], (+endPath[7] - +startPath[7]), args.duration) + ' ';
                }
            });
            element.setAttribute('d', currentDireciton);
        },
        end: function () {
            element.setAttribute('d', direction);
        }
    });
}
/**
 * To append the clip rect element.
 *
 * @param {boolean} redraw chart redraw value
 * @param {BaseAttibutes} options element options
 * @param {SvgRenderer} renderer svg renderer values
 * @param {string} clipPath clipPath of the element
 */
function appendClipElement(redraw, options, renderer, clipPath) {
    if (clipPath === void 0) { clipPath = 'drawClipPath'; }
    var clipElement = redrawElement(redraw, options.id, options, renderer);
    if (clipElement) {
        var def = renderer.createDefs();
        def.appendChild(clipElement);
        return def;
    }
    else {
        return renderer[clipPath](options);
    }
}
/**
 * Triggers the event.
 *
 * @returns {void}
 * @private
 */
function triggerLabelRender(chart, tempInterval, text, labelStyle, axis) {
    var argsData = {
        cancel: false, name: axisLabelRender, axis: axis,
        text: text, value: tempInterval, labelStyle: labelStyle
    };
    chart.trigger(axisLabelRender, argsData);
    if (!argsData.cancel) {
        var isLineBreakLabels = argsData.text.indexOf('<br>') !== -1;
        var text_1 = (axis.enableTrim) ? (isLineBreakLabels ?
            lineBreakLabelTrim(axis.maximumLabelWidth, argsData.text, axis.labelStyle, chart.themeStyle.axisLabelFont) :
            textTrim(axis.maximumLabelWidth, argsData.text, axis.labelStyle, chart.enableRtl, chart.themeStyle.axisLabelFont)) : argsData.text;
        axis.visibleLabels.push(new VisibleLabels(text_1, argsData.value, argsData.labelStyle, argsData.text));
    }
}
/**
 * The function used to find whether the range is set.
 *
 * @returns {boolean} It returns true if the axis range is set otherwise false.
 * @private
 */
function setRange(axis) {
    return (axis.minimum != null && axis.maximum != null);
}
/**
 * To check whether the axis is zoomed or not.
 *
 * @param {Axis} axis axis model
 */
function isZoomSet(axis) {
    return (axis.zoomFactor < 1 && axis.zoomPosition >= 0);
}
/**
 * Calculate desired interval for the axis.
 *
 * @returns {void} It returns desired interval count.
 * @private
 */
function getActualDesiredIntervalsCount(availableSize, axis) {
    var size = axis.orientation === 'Horizontal' ? availableSize.width : availableSize.height;
    if (isNullOrUndefined(axis.desiredIntervals)) {
        var desiredIntervalsCount = (axis.orientation === 'Horizontal' ? 0.533 : 1) * axis.maximumLabels;
        desiredIntervalsCount = Math.max((size * (desiredIntervalsCount / 100)), 1);
        return desiredIntervalsCount;
    }
    else {
        return axis.desiredIntervals;
    }
}
/**
 * Animation for template
 *
 * @private
 */
function templateAnimate(element, delay, duration, name, isRemove) {
    new Animation({}).animate(element, {
        duration: duration,
        delay: delay,
        name: name,
        progress: function (args) {
            args.element.style.visibility = 'visible';
        },
        end: function (args) {
            if (isRemove) {
                remove(args.element);
            }
            else {
                args.element.style.visibility = 'visible';
            }
        }
    });
}
/** @private */
function drawSymbol(location, shape, size, url, options, label, renderer, clipRect, isChartControl, control) {
    var chartRenderer = renderer ? renderer : new SvgRenderer('');
    var shapeOption = calculateShapes(location, size, shape, options, url, isChartControl, control);
    var drawElement = chartRenderer['draw' + shapeOption.functionName](shapeOption.renderOption, clipRect ? new Int32Array([clipRect.x, clipRect.y]) : null);
    //drawElement.setAttribute('aria-label', label);
    return drawElement;
}
/** @private */
function calculateShapes(location, size, shape, options, url, isChart, control) {
    var dir;
    var functionName = 'Path';
    var isBulletChart = isChart;
    var width = (isBulletChart && shape === 'Circle') ? (size.width - 2) : size.width;
    var height = (isBulletChart && shape === 'Circle') ? (size.height - 2) : size.height;
    var sizeBullet = (isBulletChart) ? control.targetWidth : 0;
    var lx = location.x;
    var ly = location.y;
    var y = location.y + (-height / 2);
    var x = location.x + (-width / 2);
    var eq = 72;
    var xVal;
    var yVal;
    switch (shape) {
        case 'Bubble':
        case 'Circle':
            functionName = 'Ellipse';
            merge(options, { 'rx': width / 2, 'ry': height / 2, 'cx': lx, 'cy': ly });
            break;
        case 'Plus':
            dir = 'M' + ' ' + x + ' ' + ly + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + ly + ' ' +
                'M' + ' ' + lx + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + lx + ' ' +
                (ly + (-height / 2));
            merge(options, { 'd': dir });
            break;
        case 'Cross':
            dir = 'M' + ' ' + x + ' ' + (ly + (-height / 2)) + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' +
                'M' + ' ' + x + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (-height / 2));
            merge(options, { 'd': dir });
            break;
        case 'Multiply':
            dir = 'M ' + (lx - sizeBullet) + ' ' + (ly - sizeBullet) + ' L ' +
                (lx + sizeBullet) + ' ' + (ly + sizeBullet) + ' M ' +
                (lx - sizeBullet) + ' ' + (ly + sizeBullet) + ' L ' + (lx + sizeBullet) + ' ' + (ly - sizeBullet);
            merge(options, { 'd': dir, stroke: options.fill });
            break;
        case 'HorizontalLine':
            dir = 'M' + ' ' + x + ' ' + ly + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + ly;
            merge(options, { 'd': dir });
            break;
        case 'VerticalLine':
            dir = 'M' + ' ' + lx + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + lx + ' ' + (ly + (-height / 2));
            merge(options, { 'd': dir });
            break;
        case 'Diamond':
            dir = 'M' + ' ' + x + ' ' + ly + ' ' +
                'L' + ' ' + lx + ' ' + (ly + (-height / 2)) + ' ' +
                'L' + ' ' + (lx + (width / 2)) + ' ' + ly + ' ' +
                'L' + ' ' + lx + ' ' + (ly + (height / 2)) + ' ' +
                'L' + ' ' + x + ' ' + ly + ' z';
            merge(options, { 'd': dir });
            break;
        case 'ActualRect':
            dir = 'M' + ' ' + x + ' ' + (ly + (-height / 8)) + ' ' +
                'L' + ' ' + (lx + (sizeBullet)) + ' ' + (ly + (-height / 8)) + ' ' +
                'L' + ' ' + (lx + (sizeBullet)) + ' ' + (ly + (height / 8)) + ' ' +
                'L' + ' ' + x + ' ' + (ly + (height / 8)) + ' ' +
                'L' + ' ' + x + ' ' + (ly + (-height / 8)) + ' z';
            merge(options, { 'd': dir });
            break;
        case 'TargetRect':
            dir = 'M' + ' ' + (x + (sizeBullet)) + ' ' + (ly + (-height / 2)) + ' ' +
                'L' + ' ' + (lx + (sizeBullet / 2)) + ' ' + (ly + (-height / 2)) + ' ' +
                'L' + ' ' + (lx + (sizeBullet / 2)) + ' ' + (ly + (height / 2)) + ' ' +
                'L' + ' ' + (x + (sizeBullet)) + ' ' + (ly + (height / 2)) + ' ' +
                'L' + ' ' + (x + (sizeBullet)) + ' ' + (ly + (-height / 2)) + ' z';
            merge(options, { 'd': dir });
            break;
        case 'Rectangle':
        case 'Hilo':
        case 'HiloOpenClose':
        case 'Candle':
        case 'Waterfall':
        case 'BoxAndWhisker':
        case 'StepArea':
        case 'RangeStepArea':
        case 'StackingStepArea':
        case 'Square':
        case 'Flag':
            dir = 'M' + ' ' + x + ' ' + (ly + (-height / 2)) + ' ' +
                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (-height / 2)) + ' ' +
                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' +
                'L' + ' ' + x + ' ' + (ly + (height / 2)) + ' ' +
                'L' + ' ' + x + ' ' + (ly + (-height / 2)) + ' z';
            merge(options, { 'd': dir });
            break;
        case 'Pyramid':
        case 'Triangle':
            dir = 'M' + ' ' + x + ' ' + (ly + (height / 2)) + ' ' +
                'L' + ' ' + lx + ' ' + (ly + (-height / 2)) + ' ' +
                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' +
                'L' + ' ' + x + ' ' + (ly + (height / 2)) + ' z';
            merge(options, { 'd': dir });
            break;
        case 'Funnel':
        case 'InvertedTriangle':
            dir = 'M' + ' ' + (lx + (width / 2)) + ' ' + (ly - (height / 2)) + ' ' +
                'L' + ' ' + lx + ' ' + (ly + (height / 2)) + ' ' +
                'L' + ' ' + (lx - (width / 2)) + ' ' + (ly - (height / 2)) + ' ' +
                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly - (height / 2)) + ' z';
            merge(options, { 'd': dir });
            break;
        case 'Pentagon':
            for (var i = 0; i <= 5; i++) {
                xVal = (width / 2) * Math.cos((Math.PI / 180) * (i * eq));
                yVal = (height / 2) * Math.sin((Math.PI / 180) * (i * eq));
                if (i === 0) {
                    dir = 'M' + ' ' + (lx + xVal) + ' ' + (ly + yVal) + ' ';
                }
                else {
                    dir = dir.concat('L' + ' ' + (lx + xVal) + ' ' + (ly + yVal) + ' ');
                }
            }
            dir = dir.concat('Z');
            merge(options, { 'd': dir });
            break;
        case 'Image':
            functionName = 'Image';
            merge(options, { 'href': url, 'height': height, 'width': width, x: x, y: y });
            break;
    }
    options = calculateLegendShapes(location, new Size(width, height), shape, options).renderOption;
    return { renderOption: options, functionName: functionName };
}
/** @private */
function getRectLocation(startLocation, endLocation, outerRect) {
    var x = (endLocation.x < outerRect.x) ? outerRect.x :
        (endLocation.x > (outerRect.x + outerRect.width)) ? outerRect.x + outerRect.width : endLocation.x;
    var y = (endLocation.y < outerRect.y) ? outerRect.y :
        (endLocation.y > (outerRect.y + outerRect.height)) ? outerRect.y + outerRect.height : endLocation.y;
    return new Rect((x > startLocation.x ? startLocation.x : x), (y > startLocation.y ? startLocation.y : y), Math.abs(x - startLocation.x), Math.abs(y - startLocation.y));
}
/** @private */
function minMax(value, min, max) {
    return value > max ? max : (value < min ? min : value);
}
/** @private */
function getElement$1(id) {
    return document.getElementById(id);
}
/** @private */
function getTemplateFunction(template) {
    var templateFn = null;
    try {
        if (typeof template !== 'function' && document.querySelectorAll(template).length) {
            templateFn = compile(document.querySelector(template).innerHTML.trim());
        }
        else {
            templateFn = compile(template);
        }
    }
    catch (e) {
        templateFn = compile(template);
    }
    return templateFn;
}
/** @private */
function accReactTemplate(childElement, chart, isTemplate, points, argsData, point, datalabelGroup, id, dataLabel, redraw) {
    var clientRect = childElement.getBoundingClientRect();
    chart.accumulationDataLabelModule.calculateLabelSize(isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw, clientRect, true);
}
/** @private */
function chartReactTemplate(childElement, chart, point, series, labelIndex, redraw) {
    var parentElement = document.getElementById(chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabelCollections');
    if (parentElement) {
        if (point.index === 0) {
            chart.dataLabelCollections = []; // clear old datalabel bounds for react callback
        }
        chart.dataLabelModule.calculateTemplateLabelSize(parentElement, childElement, point, series, series.marker.dataLabel, labelIndex, series.clipRect, redraw, true);
    }
}
/** @private */
function createTemplate(childElement, pointIndex, content, chart, point, series, dataLabelId, labelIndex, argsData, isTemplate, points, datalabelGroup, id, dataLabel, redraw) {
    var templateFn = getTemplateFunction(content);
    var templateElement;
    try {
        var blazor = 'Blazor';
        var tempObject = window[blazor] ? (dataLabelId ? point : { point: point }) :
            { chart: chart, series: series, point: point };
        var templateId = dataLabelId ? dataLabelId + '_template' : 'template';
        var elementData = templateFn ? templateFn(tempObject, chart, templateId, dataLabelId ||
            childElement.id.replace(/[^a-zA-Z0-9]/g, '')) : [];
        if (elementData.length) {
            templateElement = Array.prototype.slice.call(elementData);
            var len = templateElement.length;
            for (var i = 0; i < len; i++) {
                childElement.appendChild(templateElement[i]);
            }
        }
        var reactCallback = void 0;
        if (chart.getModuleName() === 'accumulationchart') {
            reactCallback = accReactTemplate.bind(this, childElement, chart, isTemplate, points, argsData, points[pointIndex], datalabelGroup, id, dataLabel, redraw);
            // tslint:disable-next-line:no-any
            if (chart.isReact) {
                chart.renderReactTemplates(reactCallback);
            }
        }
        else if (chart.getModuleName() === 'chart') {
            reactCallback = (point && series) ? chartReactTemplate.bind(this, childElement, chart, point, series, labelIndex, redraw) : reactCallback;
            // tslint:disable-next-line:no-any
            if (chart.isReact) {
                chart.renderReactTemplates(reactCallback);
            }
        }
    }
    catch (e) {
        return childElement;
    }
    return childElement;
}
/** @private */
function getFontStyle(font) {
    var style = '';
    style = 'font-size:' + font.size +
        '; font-style:' + font.fontStyle + '; font-weight:' + font.fontWeight +
        '; font-family:' + font.fontFamily + ';opacity:' + font.opacity +
        '; color:' + font.color + ';';
    return style;
}
/** @private */
function measureElementRect(element, redraw, isReactCallback) {
    if (redraw === void 0) { redraw = false; }
    if (!isReactCallback) { // If the element is already in DOM, no need to append in the body.
        document.body.appendChild(element);
    }
    var bounds = element.getBoundingClientRect();
    if (redraw) {
        remove(element);
    }
    else if (!isReactCallback) { // for react chart data label template - (callback function)
        removeElement$1(element.id);
    }
    return bounds;
}
/** @private */
function findlElement(elements, id) {
    var element;
    for (var i = 0, length_1 = elements.length; i < length_1; i++) {
        if (elements[i].id.indexOf(id) > -1) {
            element = elements[i];
            continue;
        }
    }
    return element;
}
/** @private */
function getPoint(x, y, xAxis, yAxis, isInverted) {
    x = ((xAxis.valueType === 'Logarithmic') ?
        logBase(((x > 0) ? x : Math.pow(xAxis.logBase, xAxis.visibleRange.min)), xAxis.logBase) : x);
    y = ((yAxis.valueType === 'Logarithmic') ?
        logBase(((y > 0) ? y : Math.pow(yAxis.logBase, yAxis.visibleRange.min)), yAxis.logBase) : y);
    x = valueToCoefficient(x, xAxis);
    y = valueToCoefficient(y, yAxis);
    var xLength = (isInverted ? xAxis.rect.height : xAxis.rect.width);
    var yLength = (isInverted ? yAxis.rect.width : yAxis.rect.height);
    var locationX = isInverted ? y * (yLength) : x * (xLength);
    var locationY = isInverted ? (1 - x) * (xLength) : (1 - y) * (yLength);
    return new ChartLocation(locationX, locationY);
}
/** @private */
function appendElement(child, parent, redraw, animate, x, y) {
    if (redraw === void 0) { redraw = false; }
    if (animate === void 0) { animate = false; }
    if (x === void 0) { x = 'x'; }
    if (y === void 0) { y = 'y'; }
    if (child && child.hasChildNodes() && parent) {
        appendChildElement(false, parent, child, redraw, animate, x, y);
    }
    else {
        return null;
    }
}
/**
 * Method to append child element.
 *
 * @param {boolean} isCanvas canvas mode value
 * @param {Element} parent parent element
 * @param {Element} childElement childElement element
 * @param {boolean} redraw chart redraw value
 * @param {boolean} isAnimate animation value
 * @param {string} x x position
 * @param {string} y y position
 * @param {ChartLocation} start start location value
 * @param {string} direction direction of the element
 * @param {boolean} forceAnimate forceAnimate
 * @param {boolean} isRect isRect
 * @param {Rect} previousRect previousRect
 * @param {number} animateDuration duration of the animation
 */
function appendChildElement(isCanvas, parent, childElement, redraw, isAnimate, x, y, start, direction, forceAnimate, isRect, previousRect, animateDuration, scatterElement) {
    if (isAnimate === void 0) { isAnimate = false; }
    if (x === void 0) { x = 'x'; }
    if (y === void 0) { y = 'y'; }
    if (forceAnimate === void 0) { forceAnimate = false; }
    if (isRect === void 0) { isRect = false; }
    if (previousRect === void 0) { previousRect = null; }
    if (scatterElement === void 0) { scatterElement = false; }
    if (isCanvas) {
        return null;
    }
    var existChild = scatterElement ? null : parent.querySelector('#' + childElement.id);
    var element = (existChild || getElement$1(childElement.id));
    var child = childElement;
    var duration = animateDuration ? animateDuration : 300;
    if (redraw && isAnimate && element) {
        start = start || (element.tagName === 'DIV' ?
            new ChartLocation(+(element.style[x].split('px')[0]), +(element.style[y].split('px')[0])) :
            new ChartLocation(+element.getAttribute(x), +element.getAttribute(y)));
        if (direction && direction !== 'undefined') {
            pathAnimation(childElement, childElement.getAttribute('d'), redraw, direction, duration);
        }
        else if (isRect && previousRect) {
            animateRectElement(child, 0, duration, new Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')), previousRect);
        }
        else {
            var end = child.tagName === 'DIV' ?
                new ChartLocation(+(child.style[x].split('px')[0]), +(child.style[y].split('px')[0])) :
                new ChartLocation(+child.getAttribute(x), +child.getAttribute(y));
            animateRedrawElement(child, duration, start, end, x, y);
        }
    }
    else if (redraw && isAnimate && !element && forceAnimate) {
        templateAnimate(child, 0, 600, 'FadeIn');
    }
    if (existChild) {
        parent.replaceChild(child, element);
    }
    else {
        parent.appendChild(child);
    }
}
/** @private */
function getDraggedRectLocation(x1, y1, x2, y2, outerRect) {
    var width = Math.abs(x1 - x2);
    var height = Math.abs(y1 - y2);
    var x = Math.max(checkBounds(Math.min(x1, x2), width, outerRect.x, outerRect.width), outerRect.x);
    var y = Math.max(checkBounds(Math.min(y1, y2), height, outerRect.y, outerRect.height), outerRect.y);
    return new Rect(x, y, Math.min(width, outerRect.width), Math.min(height, outerRect.height));
}
/** @private */
function checkBounds(start, size, min, max) {
    if (start < min) {
        start = min;
    }
    else if ((start + size) > (max + min)) {
        start = (max + min) - size;
    }
    return start;
}
/** @private */
function getLabelText(currentPoint, series, chart) {
    var labelFormat = series.marker.dataLabel.format ? series.marker.dataLabel.format : series.yAxis.labelFormat;
    var text = [];
    var customLabelFormat = labelFormat.match('{value}') !== null;
    switch (series.seriesType) {
        case 'XY':
            /**
             * I255790
             * For Polar radar series, the dataLabel appears out of range when axis range is given for yaxis
             * Cause: Since symbol location for the points which did not lies in within range, lies outside of seriesRect.
             * Fix: DataLabel rendered after checking WithIn for the points
             */
            if (series.chart.chartAreaType === 'PolarRadar') {
                if (series.drawType.indexOf('Stacking') !== -1) {
                    if ((series.yAxis.valueType === 'Logarithmic' &&
                        logWithIn(series.stackedValues.endValues[currentPoint.index], series.yAxis)) ||
                        withIn(series.stackedValues.endValues[currentPoint.index], series.yAxis.visibleRange)) {
                        text.push(currentPoint.text || currentPoint.yValue.toString());
                    }
                }
                else {
                    if ((series.yAxis.valueType === 'Logarithmic' && logWithIn(currentPoint.yValue, series.yAxis)) ||
                        withIn(currentPoint.yValue, series.yAxis.visibleRange)) {
                        text.push(currentPoint.text || currentPoint.yValue.toString());
                    }
                }
            }
            else {
                text.push(currentPoint.text || currentPoint.yValue.toString());
            }
            break;
        case 'HighLow':
            text.push(currentPoint.text || Math.max(currentPoint.high, currentPoint.low).toString());
            text.push(currentPoint.text || Math.min(currentPoint.high, currentPoint.low).toString());
            break;
        case 'HighLowOpenClose':
            text.push(currentPoint.text || Math.max(currentPoint.high, currentPoint.low).toString());
            text.push(currentPoint.text || Math.min(currentPoint.high, currentPoint.low).toString());
            text.push(currentPoint.text || Math.max(currentPoint.open, currentPoint.close).toString());
            text.push(currentPoint.text || Math.min(currentPoint.open, currentPoint.close).toString());
            break;
        case 'BoxPlot':
            text.push(currentPoint.text || currentPoint.median.toString());
            text.push(currentPoint.text || currentPoint.maximum.toString());
            text.push(currentPoint.text || currentPoint.minimum.toString());
            text.push(currentPoint.text || currentPoint.upperQuartile.toString());
            text.push(currentPoint.text || currentPoint.lowerQuartile.toString());
            for (var _i = 0, _a = currentPoint.outliers; _i < _a.length; _i++) {
                var liers = _a[_i];
                text.push(currentPoint.text || liers.toString());
            }
            break;
    }
    if ((labelFormat || chart.useGroupingSeparator) && !currentPoint.text) {
        series.yAxis.format = chart.intl.getNumberFormat({
            format: customLabelFormat ? '' : labelFormat,
            useGrouping: chart.useGroupingSeparator
        });
        for (var i = 0; i < text.length; i++) {
            text[i] = customLabelFormat ? labelFormat.replace('{value}', series.yAxis.format(parseFloat(text[i]))) :
                series.yAxis.format(parseFloat(text[i]));
        }
    }
    return text;
}
/** @private */
function stopTimer(timer) {
    window.clearInterval(timer);
}
/** @private */
function isCollide(rect, collections, clipRect) {
    var currentRect = new Rect(rect.x + clipRect.x, rect.y + clipRect.y, rect.width, rect.height);
    var isCollide = collections.some(function (rect) {
        return (currentRect.x < rect.x + rect.width && currentRect.x + currentRect.width > rect.x &&
            currentRect.y < rect.y + rect.height && currentRect.height + currentRect.y > rect.y);
    });
    return isCollide;
}
/** @private */
function isOverlap(currentRect, rect) {
    return (currentRect.x < rect.x + rect.width && currentRect.x + currentRect.width > rect.x &&
        currentRect.y < rect.y + rect.height && currentRect.height + currentRect.y > rect.y);
}
/** @private */
function containsRect(currentRect, rect) {
    return (currentRect.x <= rect.x && currentRect.x + currentRect.width >= rect.x + rect.width &&
        currentRect.y <= rect.y && currentRect.height + currentRect.y >= rect.y + rect.height);
}
/** @private */
function calculateRect(location, textSize, margin) {
    return new Rect((location.x - (textSize.width / 2) - margin.left), (location.y - (textSize.height / 2) - margin.top), textSize.width + margin.left + margin.right, textSize.height + margin.top + margin.bottom);
}
/** @private */
function convertToHexCode(value) {
    return '#' + componentToHex(value.r) + componentToHex(value.g) + componentToHex(value.b);
}
/** @private */
function componentToHex(value) {
    var hex = value.toString(16);
    return hex.length === 1 ? '0' + hex : hex;
}
/** @private */
function convertHexToColor(hex) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? new ColorValue(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)) :
        new ColorValue(255, 255, 255);
}
/** @private */
function colorNameToHex(color) {
    color = color === 'transparent' ? 'white' : color;
    document.body.appendChild(createElement('text', { id: 'chartmeasuretext' }));
    var element = document.getElementById('chartmeasuretext');
    element.style.color = color;
    color = window.getComputedStyle(element).color;
    remove(element);
    // eslint-disable-next-line security/detect-unsafe-regex
    var exp = /^(rgb|hsl)(a?)[(]\s*([\d.]+\s*%?)\s*,\s*([\d.]+\s*%?)\s*,\s*([\d.]+\s*%?)\s*(?:,\s*([\d.]+)\s*)?[)]$/;
    var isRGBValue = exp.exec(color);
    return convertToHexCode(new ColorValue(parseInt(isRGBValue[3], 10), parseInt(isRGBValue[4], 10), parseInt(isRGBValue[5], 10)));
}
/** @private */
function checkColorFormat(color) {
    // eslint-disable-next-line security/detect-unsafe-regex
    return /(rgba?\((?:\d{1,3}[,)]){3}(?:\d+\.\d+\))?)|(^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$)/gmi.test(color);
}
/** @private */
function getSaturationColor(color, factor) {
    color = colorNameToHex(color);
    color = color.replace(/[^0-9a-f]/gi, '');
    if (color.length < 6) {
        color = color[0] + color[0] + color[1] + color[1] + color[2] + color[2];
    }
    factor = factor || 0;
    // convert to decimal and change luminosity
    var rgb = '#';
    var colorCode;
    for (var i = 0; i < 3; i++) {
        colorCode = parseInt(color.substr(i * 2, 2), 16);
        colorCode = Math.round(Math.min(Math.max(0, colorCode + (colorCode * factor)), 255));
        rgb += ('00' + colorCode.toString(16)).substr(colorCode.toString(16).length);
    }
    return rgb;
}
/** @private */
function applyZLight(color, value) {
    var RGB = convertHexToColor(color);
    RGB.r = parseInt(Math.floor(RGB.r * value).toString(), 10);
    RGB.g = parseInt(Math.floor(RGB.g * value).toString(), 10);
    RGB.b = parseInt(Math.floor(RGB.b * value).toString(), 10);
    return '#' + componentToHex(RGB.r).toUpperCase() + componentToHex(RGB.g).toUpperCase() + componentToHex(RGB.b).toUpperCase();
}
/** @private */
function getMedian(values) {
    var half = Math.floor(values.length / 2);
    return values.length % 2 ? values[half] : ((values[half - 1] + values[half]) / 2.0);
}
/** @private */
function calculateLegendShapes(location, size, shape, options) {
    var padding = 10;
    var dir = '';
    var space = 2;
    var height = size.height;
    var width = size.width;
    var lx = location.x;
    var ly = location.y;
    switch (shape) {
        case 'MultiColoredLine':
        case 'Line':
        case 'StackingLine':
        case 'StackingLine100':
            dir = 'M' + ' ' + (lx + (-width * (3 / 4))) + ' ' + (ly) + ' ' +
                'L' + ' ' + (lx + (width * (3 / 4))) + ' ' + (ly);
            merge(options, { 'd': dir });
            break;
        case 'StepLine':
            options.fill = 'transparent';
            dir = 'M' + ' ' + (lx + (-width / 2) - (padding / 4)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx +
                (-width / 2) + (width / 10)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx + (-width / 2) + (width / 10))
                + ' ' + (ly) + ' ' + 'L' + ' ' + (lx + (-width / 10)) + ' ' + (ly) + ' ' + 'L' + ' ' + (lx + (-width / 10))
                + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx + (width / 5)) + ' ' + (ly + (height / 2)) + ' ' + 'L' +
                ' ' + (lx + (width / 5)) + ' ' + (ly + (-height / 2)) + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + (ly +
                (-height / 2)) + 'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + '' + (lx + (width / 2)
                + (padding / 4)) + ' ' + (ly + (height / 2));
            merge(options, { 'd': dir });
            break;
        case 'UpArrow':
            options.fill = options.stroke;
            options.stroke = 'transparent';
            dir = 'M' + ' ' + (lx + (-width / 2)) + ' ' + (ly + (height / 2)) + ' ' +
                'L' + ' ' + (lx) + ' ' + (ly - (height / 2)) + ' ' +
                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) +
                'L' + ' ' + (lx + (width / 2) - space) + ' ' + (ly + (height / 2)) + ' ' +
                'L' + ' ' + (lx) + ' ' + (ly - (height / 2) + (2 * space)) +
                'L' + (lx - (width / 2) + space) + ' ' + (ly + (height / 2)) + ' Z';
            merge(options, { 'd': dir });
            break;
        case 'DownArrow':
            dir = 'M' + ' ' + (lx - (width / 2)) + ' ' + (ly - (height / 2)) + ' ' +
                'L' + ' ' + (lx) + ' ' + (ly + (height / 2)) + ' ' +
                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly - (height / 2)) +
                'L' + ' ' + (lx + (width / 2) - space) + ' ' + (ly - (height / 2)) + ' ' +
                'L' + ' ' + (lx) + ' ' + (ly + (height / 2) - (2 * space)) +
                'L' + (lx - (width / 2) + space) + ' ' + (ly - (height / 2)) + ' Z';
            merge(options, { 'd': dir });
            break;
        case 'RightArrow':
            dir = 'M' + ' ' + (lx + (-width / 2)) + ' ' + (ly - (height / 2)) + ' ' +
                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly) + ' ' + 'L' + ' ' +
                (lx + (-width / 2)) + ' ' + (ly + (height / 2)) + ' L' + ' ' + (lx + (-width / 2)) + ' ' +
                (ly + (height / 2) - space) + ' ' + 'L' + ' ' + (lx + (width / 2) - (2 * space)) + ' ' + (ly) +
                ' L' + (lx + (-width / 2)) + ' ' + (ly - (height / 2) + space) + ' Z';
            merge(options, { 'd': dir });
            break;
        case 'LeftArrow':
            options.fill = options.stroke;
            options.stroke = 'transparent';
            dir = 'M' + ' ' + (lx + (width / 2)) + ' ' + (ly - (height / 2)) + ' ' +
                'L' + ' ' + (lx + (-width / 2)) + ' ' + (ly) + ' ' + 'L' + ' ' +
                (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' +
                (lx + (width / 2)) + ' ' + (ly + (height / 2) - space) + ' L' + ' ' + (lx + (-width / 2) + (2 * space))
                + ' ' + (ly) + ' L' + (lx + (width / 2)) + ' ' + (ly - (height / 2) + space) + ' Z';
            merge(options, { 'd': dir });
            break;
        case 'Column':
        case 'Pareto':
        case 'StackingColumn':
        case 'StackingColumn100':
        case 'RangeColumn':
        case 'Histogram':
            dir = 'M' + ' ' + (lx - 3 * (width / 5)) + ' ' + (ly - (height / 5)) + ' ' + 'L' + ' ' +
                (lx + 3 * (-width / 10)) + ' ' + (ly - (height / 5)) + ' ' + 'L' + ' ' +
                (lx + 3 * (-width / 10)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx - 3 *
                (width / 5)) + ' ' + (ly + (height / 2)) + ' ' + 'Z' + ' ' + 'M' + ' ' +
                (lx + (-width / 10) - (width / 20)) + ' ' + (ly - (height / 4) - (padding / 2))
                + ' ' + 'L' + ' ' + (lx + (width / 10) + (width / 20)) + ' ' + (ly - (height / 4) -
                (padding / 2)) + ' ' + 'L' + ' ' + (lx + (width / 10) + (width / 20)) + ' ' + (ly
                + (height / 2)) + ' ' + 'L' + ' ' + (lx + (-width / 10) - (width / 20)) + ' ' + (ly +
                (height / 2)) + ' ' + 'Z' + ' ' + 'M' + ' ' + (lx + 3 * (width / 10)) + ' ' + (ly) + ' ' +
                'L' + ' ' + (lx + 3 * (width / 5)) + ' ' + (ly) + ' ' + 'L' + ' '
                + (lx + 3 * (width / 5)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' '
                + (lx + 3 * (width / 10)) + ' ' + (ly + (height / 2)) + ' ' + 'Z';
            merge(options, { 'd': dir });
            break;
        case 'Bar':
        case 'StackingBar':
        case 'StackingBar100':
            dir = 'M' + ' ' + (lx + (-width / 2) + (-padding / 4)) + ' ' + (ly - 3 * (height / 5)) + ' '
                + 'L' + ' ' + (lx + 3 * (width / 10)) + ' ' + (ly - 3 * (height / 5)) + ' ' + 'L' + ' ' +
                (lx + 3 * (width / 10)) + ' ' + (ly - 3 * (height / 10)) + ' ' + 'L' + ' ' +
                (lx - (width / 2) + (-padding / 4)) + ' ' + (ly - 3 * (height / 10)) + ' ' + 'Z' + ' '
                + 'M' + ' ' + (lx + (-width / 2) + (-padding / 4)) + ' ' + (ly - (height / 5)
                + (padding / 20)) + ' ' + 'L' + ' ' + (lx + (width / 2) + (padding / 4)) + ' ' + (ly
                - (height / 5) + (padding / 20)) + ' ' + 'L' + ' ' + (lx + (width / 2) + (padding / 4))
                + ' ' + (ly + (height / 10) + (padding / 20)) + ' ' + 'L' + ' ' + (lx - (width / 2)
                + (-padding / 4)) + ' ' + (ly + (height / 10) + (padding / 20)) + ' ' + 'Z' + ' ' + 'M'
                + ' ' + (lx - (width / 2) + (-padding / 4)) + ' ' + (ly + (height / 5)
                + (padding / 10)) + ' ' + 'L' + ' ' + (lx + (-width / 4)) + ' ' + (ly + (height / 5)
                + (padding / 10)) + ' ' + 'L' + ' ' + (lx + (-width / 4)) + ' ' + (ly + (height / 2)
                + (padding / 10)) + ' ' + 'L' + ' ' + (lx - (width / 2) + (-padding / 4))
                + ' ' + (ly + (height / 2) + (padding / 10)) + ' ' + 'Z';
            merge(options, { 'd': dir });
            break;
        case 'Spline':
            options.fill = 'transparent';
            dir = 'M' + ' ' + (lx - (width / 2)) + ' ' + (ly + (height / 5)) + ' ' + 'Q' + ' '
                + lx + ' ' + (ly - height) + ' ' + lx + ' ' + (ly + (height / 5))
                + ' ' + 'M' + ' ' + lx + ' ' + (ly + (height / 5)) + ' ' + 'Q' + ' ' + (lx
                + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' + (lx + (width / 2)) + ' '
                + (ly - (height / 2));
            merge(options, { 'd': dir });
            break;
        case 'Area':
        case 'MultiColoredArea':
        case 'RangeArea':
        case 'StackingArea':
        case 'StackingArea100':
            dir = 'M' + ' ' + (lx - (width / 2) - (padding / 4)) + ' ' + (ly + (height / 2))
                + ' ' + 'L' + ' ' + (lx + (-width / 4) + (-padding / 8)) + ' ' + (ly - (height / 2))
                + ' ' + 'L' + ' ' + (lx) + ' ' + (ly + (height / 4)) + ' ' + 'L' + ' ' + (lx
                + (width / 4) + (padding / 8)) + ' ' + (ly + (-height / 2) + (height / 4)) + ' '
                + 'L' + ' ' + (lx + (height / 2) + (padding / 4)) + ' ' + (ly + (height / 2)) + ' ' + 'Z';
            merge(options, { 'd': dir });
            break;
        case 'SplineArea':
        case 'SplineRangeArea':
            dir = 'M' + ' ' + (lx - (width / 2)) + ' ' + (ly + (height / 5)) + ' ' + 'Q' + ' ' + lx
                + ' ' + (ly - height) + ' ' + lx + ' ' + (ly + (height / 5)) + ' ' + 'Z' + ' ' + 'M'
                + ' ' + lx + ' ' + (ly + (height / 5)) + ' ' + 'Q' + ' ' + (lx + (width / 2)) + ' '
                + (ly + (height / 2)) + ' ' + (lx + (width / 2)) + ' '
                + (ly - (height / 2)) + ' ' + ' Z';
            merge(options, { 'd': dir });
            break;
        case 'Pie':
        case 'Doughnut':
            options.stroke = 'transparent';
            // eslint-disable-next-line no-case-declarations
            var r = Math.min(height, width) / 2;
            dir = getAccumulationLegend(lx, ly, r, height, width, shape);
            merge(options, { 'd': dir });
            break;
    }
    return { renderOption: options };
}
/** @private */
function textTrim(maxWidth, text, font, isRtlEnabled, themeFontStyle) {
    var label = text;
    var size = measureText(text, font, themeFontStyle).width;
    if (size > maxWidth) {
        var textLength = text.length;
        for (var i = textLength - 1; i >= 0; --i) {
            label = isRtlEnabled ? '...' + text.substring(0, i) : text.substring(0, i) + '...';
            size = measureText(label, font, themeFontStyle).width;
            if (size <= maxWidth) {
                return label;
            }
        }
    }
    return label;
}
/** @private */
function lineBreakLabelTrim(maxWidth, text, font, themeFontStyle) {
    var labelCollection = [];
    var breakLabels = text.split('<br>');
    for (var i = 0; i < breakLabels.length; i++) {
        text = breakLabels[i];
        var size = measureText(text, font, themeFontStyle).width;
        if (size > maxWidth) {
            var textLength = text.length;
            for (var i_1 = textLength - 1; i_1 >= 0; --i_1) {
                text = text.substring(0, i_1) + '...';
                size = measureText(text, font, themeFontStyle).width;
                if (size <= maxWidth) {
                    labelCollection.push(text);
                    break;
                }
            }
        }
        else {
            labelCollection.push(text);
        }
    }
    return labelCollection;
}
/** @private */
function stringToNumber(value, containerSize) {
    if (value !== null && value !== undefined) {
        return value.indexOf('%') !== -1 ? (containerSize / 100) * parseInt(value, 10) : parseInt(value, 10);
    }
    return null;
}
/** @private */
function redrawElement(redraw, id, options, renderer) {
    if (!redraw) {
        return null;
    }
    var element = getElement$1(id);
    if (element && options) {
        renderer.setElementAttributes(options, element.tagName === 'clipPath' ? element.childNodes[0] : element);
    }
    return element;
}
/** @private */
function animateRedrawElement(element, duration, start, end, x, y) {
    if (x === void 0) { x = 'x'; }
    if (y === void 0) { y = 'y'; }
    var isDiv = element.tagName === 'DIV';
    var setStyle = function (xValue, yValue) {
        if (isDiv) {
            element.style[x] = xValue + 'px';
            element.style[y] = yValue + 'px';
        }
        else {
            element.setAttribute(x, xValue + '');
            element.setAttribute(y, yValue + '');
        }
    };
    setStyle(start.x, start.y);
    new Animation({}).animate(createElement('div'), {
        duration: duration,
        progress: function (args) {
            setStyle(linear(args.timeStamp, start.x, end.x - start.x, args.duration), linear(args.timeStamp, start.y, end.y - start.y, args.duration));
        },
        end: function () {
            setStyle(end.x, end.y);
        }
    });
}
/** @private */
function textElement$1(renderer, option, font, color, parent, isMinus, redraw, isAnimate, forceAnimate, animateDuration, seriesClipRect, labelSize, isRotatedLabelIntersect, isCanvas, isDataLabelWrap, themeFontStyle) {
    if (isMinus === void 0) { isMinus = false; }
    if (forceAnimate === void 0) { forceAnimate = false; }
    var renderOptions = {};
    var tspanElement;
    //let renderer: SvgRenderer = new SvgRenderer('');
    var height;
    var dy;
    var label;
    var width = 0;
    var dx;
    var maxWidth = 0;
    if (option.text.length > 1 && isDataLabelWrap) {
        for (var i = 0, len = option.text.length; i < len; i++) {
            maxWidth = Math.max(maxWidth, measureText(option.text[i], font, themeFontStyle).width);
        }
        width = measureText(option.text[0], font, themeFontStyle).width;
    }
    dx = (option.text.length > 1 && isDataLabelWrap) ? (option.x + maxWidth / 2 - width / 2) : option.x;
    renderOptions = {
        'id': option.id,
        'x': dx,
        'y': option.y,
        'fill': color ? color : 'black',
        'font-size': font.size,
        'font-style': font.fontStyle,
        'font-family': font.fontFamily || themeFontStyle.fontFamily,
        'font-weight': font.fontWeight,
        'text-anchor': option.anchor,
        'labelRotation': option.labelRotation,
        'transform': option.transform,
        'opacity': font.opacity,
        'dominant-baseline': option.baseLine
    };
    var text = typeof option.text === 'string' ? option.text : isMinus ? option.text[option.text.length - 1] : option.text[0];
    var transX = seriesClipRect ? seriesClipRect.x : 0;
    var transY = seriesClipRect ? seriesClipRect.y : 0;
    var htmlObject = renderer.createText(renderOptions, text, transX, transY);
    if (typeof option.text !== 'string' && option.text.length > 1) {
        for (var i = 1, len = option.text.length; i < len; i++) {
            height = (measureText(option.text[i], font, themeFontStyle).height);
            width = measureText(option.text[i], font, themeFontStyle).width;
            dy = (option.y) + ((isMinus) ? -(i * height) : (i * height));
            dx = isDataLabelWrap ? (option.x + maxWidth / 2 - width / 2) : option.x;
            label = isMinus ? option.text[option.text.length - (i + 1)] : option.text[i];
            if (isCanvas) {
                tspanElement = renderer.createText(renderOptions, label, null, null, dy, true);
            }
            else {
                tspanElement = renderer.createTSpan({
                    'x': dx, 'id': option.id,
                    'y': dy
                }, label);
                htmlObject.appendChild(tspanElement);
            }
        }
    }
    if (!isRotatedLabelIntersect) {
        appendChildElement(renderer instanceof CanvasRenderer, parent, htmlObject, redraw, isAnimate, 'x', 'y', null, null, forceAnimate, false, null, animateDuration);
    }
    return htmlObject;
}
/**
 * Method to calculate the width and height of the chart.
 */
function calculateSize(chart) {
    // fix for Chart rendered with default width in IE issue
    var containerWidth = chart.element.clientWidth || chart.element.offsetWidth;
    var containerHeight = chart.element.clientHeight;
    if (chart.stockChart) {
        containerWidth = chart.stockChart.availableSize.width;
        containerHeight = chart.stockChart.availableSize.height;
    }
    var height = 450;
    var marginHeight;
    if (chart.getModuleName() === 'rangeNavigator') {
        var range = chart;
        var tooltipSpace = range.tooltip.enable ? 35 : 0;
        var periodHeight = range.periodSelectorSettings.periods.length ?
            range.periodSelectorSettings.height : 0;
        marginHeight = range.margin.top + range.margin.bottom + tooltipSpace;
        var labelSize = measureText('tempString', range.labelStyle, range.themeStyle.axisLabelFont).height;
        var labelPadding = 15;
        height = (chart.series.length ? (Browser.isDevice ? 80 : 120) : ((range.enableGrouping ? (40 + labelPadding + labelSize) : 40)
            + marginHeight)) + periodHeight;
        if (range.disableRangeSelector) {
            height = periodHeight;
        }
    }
    chart.availableSize = new Size(stringToNumber(chart.width, containerWidth) || containerWidth || 600, stringToNumber(chart.height, containerHeight || height) || containerHeight || height);
    if (chart.getModuleName() === 'chart') {
        var scaleX = 1;
        var scaleY = 1;
        if (chart.width === '' || chart.width === null || chart.width === '100%') {
            scaleX = chart.element.getBoundingClientRect().width > 0 ?
                chart.element.getBoundingClientRect().width / chart.availableSize.width : 1;
            scaleY = chart.element.getBoundingClientRect().height > 0 ?
                chart.element.getBoundingClientRect().height / chart.availableSize.height : 1;
            var transformValue = chart.element.style.transform;
            if (transformValue) {
                var scaleValue = parseFloat(transformValue.match(/scale\((.*?)\)/)[1]);
                scaleX = scaleValue ? scaleX / scaleValue : scaleX;
                scaleY = scaleValue ? scaleY / scaleValue : scaleY;
            }
            chart.availableSize.width = chart.availableSize.width * scaleX;
            chart.availableSize.height = chart.availableSize.height * scaleY;
            chart.scaleX = scaleX;
            chart.scaleY = scaleY;
        }
    }
}
/**
 * To create svg element.
 *
 * @param {Chart} chart chart instance
 */
function createSvg(chart) {
    chart.canvasRender = new CanvasRenderer(chart.element.id);
    chart.renderer = chart.enableCanvas ? chart.canvasRender : new SvgRenderer(chart.element.id);
    calculateSize(chart);
    if (chart.stockChart && chart.getModuleName() === 'chart') {
        chart.svgObject = chart.stockChart.chartObject;
    }
    else if (chart.stockChart && chart.getModuleName() === 'rangeNavigator') {
        chart.svgObject = chart.stockChart.selectorObject;
    }
    else {
        if (chart.enableCanvas) {
            chart.svgObject = chart.renderer.createCanvas({
                id: chart.element.id + '_canvas',
                width: chart.availableSize.width,
                height: chart.availableSize.height
            });
        }
        else {
            chart.svgObject = chart.renderer.createSvg({
                id: chart.element.id + '_svg',
                width: chart.availableSize.width,
                height: chart.availableSize.height
            });
        }
    }
    if (chart.enableCanvas) {
        chart.renderer.ctx.direction = chart.enableRtl ? 'rtl' : 'ltr';
    }
}
/**
 * To calculate chart title and height.
 *
 * @param {string} title text of the title
 * @param {FontModel} style style of the title
 * @param {number} width width of the title
 */
function getTitle(title, style, width, isRtlEnabled, themeFontStyle) {
    var titleCollection = [];
    switch (style.textOverflow) {
        case 'Wrap':
            titleCollection = textWrap(title, width, style, isRtlEnabled, null, null, themeFontStyle);
            break;
        case 'Trim':
            titleCollection.push(textTrim(width, title, style, isRtlEnabled, themeFontStyle));
            break;
        default:
            titleCollection.push(title);
            break;
    }
    return titleCollection;
}
/**
 * Method to calculate x position of title.
 */
function titlePositionX(rect, titleStyle) {
    var positionX;
    if (titleStyle.textAlignment === 'Near') {
        positionX = rect.x;
    }
    else if (titleStyle.textAlignment === 'Center') {
        positionX = rect.x + rect.width / 2;
    }
    else {
        positionX = rect.x + rect.width;
    }
    return positionX;
}
/**
 * Method to find new text and element size based on textOverflow.
 */
function textWrap(currentLabel, maximumWidth, font, isRtlEnabled, wrapAnyWhere, clip, themeFontStyle) {
    if (wrapAnyWhere) {
        return (textWrapAnyWhere(currentLabel, maximumWidth, font, themeFontStyle));
    }
    else {
        var textCollection = currentLabel.split(' ');
        var label = '';
        var labelCollection = [];
        var text = void 0;
        for (var i = 0, len = textCollection.length; i < len; i++) {
            text = textCollection[i];
            if (measureText(label.concat(label === '' ? '' : ' ' + text), font, themeFontStyle).width < maximumWidth) {
                label = label.concat((label === '' ? '' : ' ') + text);
            }
            else {
                if (label !== '') {
                    labelCollection.push(clip ? label : textTrim(maximumWidth, label, font, isRtlEnabled, themeFontStyle));
                    label = text;
                }
                else {
                    labelCollection.push(clip ? text : textTrim(maximumWidth, text, font, isRtlEnabled, themeFontStyle));
                    text = '';
                }
            }
            if (label && i === len - 1) {
                labelCollection.push(clip ? label : textTrim(maximumWidth, label, font, isRtlEnabled, themeFontStyle));
            }
        }
        return labelCollection;
    }
}
/**
 * Method to find new text and element size based on textWrap.
 */
function textWrapAnyWhere(currentLabel, maximumWidth, font, themeFontStyle) {
    var size = measureText(currentLabel, font, themeFontStyle).width;
    var labelCollection = [];
    if (size > maximumWidth) {
        var label = '';
        var startIndex = 0;
        var labelIndex = 1;
        while (labelIndex < currentLabel.length) {
            label = currentLabel.substring(startIndex, labelIndex);
            size = measureText(label, font, themeFontStyle).width;
            if (size < maximumWidth) {
                labelIndex++;
            }
            else if (size === maximumWidth) {
                startIndex = labelIndex;
                labelCollection.push(label);
                labelIndex++;
                label = '';
            }
            else if (size > maximumWidth) {
                label = label.slice(0, -1);
                startIndex = labelIndex - 1;
                labelCollection.push(label);
                label = '';
            }
        }
        if (label.length > 0) {
            labelCollection.push(label);
        }
    }
    else {
        labelCollection.push(currentLabel);
    }
    return labelCollection;
}
/**
 * Method to support the subscript and superscript value to text.
 */
function getUnicodeText(text, regexp) {
    var title = text.replace(regexp, ' ');
    var digit = text.match(regexp);
    var digitSpecific = ' ';
    var convertedText = ' ';
    var k = 0;
    var unicodeSub = {
        '0': '\u2080', '1': '\u2081', '2': '\u2082', '3': '\u2083', '4': '\u2084',
        '5': '\u2085', '6': '\u2086', '7': '\u2087', '8': '\u2088', '9': '\u2089'
    };
    var unicodeSup = {
        '0': '\u2070', '1': '\u00B9', '2': '\u00B2', '3': '\u00B3', '4': '\u2074',
        '5': '\u2075', '6': '\u2076', '7': '\u2077', '8': '\u2078', '9': '\u2079'
    };
    for (var i = 0; i <= title.length - 1; i++) {
        if (title[i] === ' ') {
            digitSpecific = (regexp === regSub) ? digit[k].replace(/~/g, '') : digit[k].replace(/\^/g, '');
            for (var j = 0; j < digitSpecific.length; j++) {
                convertedText += (regexp === regSub) ? unicodeSub[digitSpecific[j]] : unicodeSup[digitSpecific[j]];
            }
            k++;
        }
        else {
            convertedText += title[i];
        }
    }
    return convertedText.trim();
}
/**
 * Method to reset the blazor templates.
 */
function blazorTemplatesReset(control) {
    for (var i = 0; i < control.annotations.length; i++) {
        resetBlazorTemplate((control.element.id + '_Annotation_' + i).replace(/[^a-zA-Z0-9]/g, ''), 'ContentTemplate');
    }
    //This reset the tooltip templates
    resetBlazorTemplate(control.element.id + '_tooltipparent_template' + '_blazorTemplate', 'Template');
    //Datalabel templates reset
    resetBlazorTemplate(control.element.id + '_DataLabel');
}
/** @private */
var CustomizeOption = /** @__PURE__ @class */ (function () {
    function CustomizeOption(id) {
        this.id = id;
    }
    return CustomizeOption;
}());
/** @private */
var StackValues = /** @__PURE__ @class */ (function () {
    function StackValues(startValue, endValue) {
        this.startValues = startValue;
        this.endValues = endValue;
    }
    return StackValues;
}());
/** @private */
var RectOption = /** @__PURE__ @class */ (function (_super) {
    __extends$1(RectOption, _super);
    function RectOption(id, fill, border, opacity, rect, rx, ry, transform, dashArray) {
        var _this = _super.call(this, id, fill, border.width, border.color, opacity, dashArray) || this;
        _this.y = rect.y;
        _this.x = rect.x;
        _this.height = rect.height;
        _this.width = rect.width;
        _this.rx = rx ? rx : 0;
        _this.ry = ry ? ry : 0;
        _this.transform = transform ? transform : '';
        _this.stroke = (border.width !== 0 && _this.stroke !== '') ? border.color === null ? '' : border.color : 'transparent';
        return _this;
    }
    return RectOption;
}(PathOption));
/** @private */
var ImageOption = /** @__PURE__ @class */ (function () {
    function ImageOption(height, width, href, x, y, id, visibility, preserveAspectRatio) {
        this.height = height;
        this.width = width;
        this.href = href;
        this.x = x;
        this.y = y;
        this.id = id;
        this.visibility = visibility;
        this.preserveAspectRatio = preserveAspectRatio;
    }
    return ImageOption;
}());
/** @private */
var CircleOption = /** @__PURE__ @class */ (function (_super) {
    __extends$1(CircleOption, _super);
    function CircleOption(id, fill, border, opacity, cx, cy, r) {
        var _this = _super.call(this, id, fill, border.width, border.color, opacity) || this;
        _this.cy = cy;
        _this.cx = cx;
        _this.r = r;
        return _this;
    }
    return CircleOption;
}(PathOption));
/** @private */
var PolygonOption = /** @__PURE__ @class */ (function () {
    function PolygonOption(id, points, fill) {
        this.id = id;
        this.points = points;
        this.fill = fill;
    }
    return PolygonOption;
}());
/** @private */
var ChartLocation = /** @__PURE__ @class */ (function () {
    function ChartLocation(x, y) {
        this.x = x;
        this.y = y;
    }
    return ChartLocation;
}());
/** @private */
var LabelLocation = /** @__PURE__ @class */ (function () {
    function LabelLocation(x, y) {
        this.x = 0;
        this.y = 0;
        this.x = x;
        this.y = y;
    }
    return LabelLocation;
}());
/** @private */
var Thickness = /** @__PURE__ @class */ (function () {
    function Thickness(left, right, top, bottom) {
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
    }
    return Thickness;
}());
/** @private */
var ColorValue = /** @__PURE__ @class */ (function () {
    function ColorValue(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
    }
    return ColorValue;
}());
/** @private */
var PointData = /** @__PURE__ @class */ (function () {
    function PointData(point, series, index) {
        if (index === void 0) { index = 0; }
        this.point = point;
        this.series = series;
        this.lierIndex = index;
    }
    return PointData;
}());
/** @private */
var AccPointData = /** @__PURE__ @class */ (function () {
    function AccPointData(point, series, index) {
        if (index === void 0) { index = 0; }
        this.point = point;
        this.series = series;
        this.index = index;
    }
    return AccPointData;
}());
/** @private */
var Point3D = /** @__PURE__ @class */ (function () {
    /** @private */
    function Point3D(point, series) {
        this.point = point;
        this.series = series;
    }
    return Point3D;
}());
/** @private */
var ControlPoints = /** @__PURE__ @class */ (function () {
    function ControlPoints(controlPoint1, controlPoint2) {
        this.controlPoint1 = controlPoint1;
        this.controlPoint2 = controlPoint2;
    }
    return ControlPoints;
}());
/** @private */
function getColorByValue(colorMap, value) {
    var color = '';
    var rbgColorValue;
    if (Number(value) === colorMap.start) {
        color = colorMap.colors[0];
    }
    else if (Number(value) === colorMap.end) {
        color = colorMap.colors[colorMap.colors.length - 1];
    }
    else {
        rbgColorValue = getGradientColor(Number(value), colorMap);
        color = convertToHexCode(rbgColorValue);
    }
    return color;
}
/** @private */
function getGradientColor(value, colorMap) {
    var previousOffset = colorMap.start;
    var nextOffset = colorMap.end;
    var percent = 0;
    var full = nextOffset - previousOffset;
    var midColor;
    percent = (value - previousOffset) / full;
    var previousColor;
    var nextColor;
    if (colorMap.colors.length <= 2) {
        previousColor = colorMap.colors[0].charAt(0) === '#' ? colorMap.colors[0] : colorNameToHex(colorMap.colors[0]);
        nextColor = colorMap.colors[colorMap.colors.length - 1].charAt(0) === '#' ?
            colorMap.colors[colorMap.colors.length - 1] : colorNameToHex(colorMap.colors[colorMap.colors.length - 1]);
    }
    else {
        previousColor = colorMap.colors[0].charAt(0) === '#' ? colorMap.colors[0] : colorNameToHex(colorMap.colors[0]);
        nextColor = colorMap.colors[colorMap.colors.length - 1].charAt(0) === '#' ?
            colorMap.colors[colorMap.colors.length - 1] : colorNameToHex(colorMap.colors[colorMap.colors.length - 1]);
        var a = full / (colorMap.colors.length - 1);
        var b = void 0;
        var c = void 0;
        var length_2 = colorMap.colors.length - 1;
        var splitColorValueOffset = [];
        var splitColor = {};
        for (var j = 1; j < length_2; j++) {
            c = j * a;
            b = previousOffset + c;
            splitColor = { b: b, color: colorMap.colors[j] };
            splitColorValueOffset.push(splitColor);
        }
        for (var i = 0; i < splitColorValueOffset.length; i++) {
            if (previousOffset <= value && value <= splitColorValueOffset[i]['b'] && i === 0) {
                midColor = splitColorValueOffset[i]['color'].charAt(0) === '#' ?
                    splitColorValueOffset[i]['color'] : colorNameToHex(splitColorValueOffset[i]['color']);
                nextColor = midColor;
                percent = value <= splitColorValueOffset[i]['b'] ? 1 - Math.abs((value - splitColorValueOffset[i]['b']) / a)
                    : (value - splitColorValueOffset[i]['b']) / a;
            }
            else if (splitColorValueOffset[i]['b'] <= value && value <= nextOffset && i === (splitColorValueOffset.length - 1)) {
                midColor = splitColorValueOffset[i]['color'].charAt(0) === '#' ?
                    splitColorValueOffset[i]['color'] : colorNameToHex(splitColorValueOffset[i]['color']);
                previousColor = midColor;
                percent = value < splitColorValueOffset[i]['b'] ?
                    1 - Math.abs((value - splitColorValueOffset[i]['b']) / a) : (value - splitColorValueOffset[i]['b']) / a;
            }
            if (i !== splitColorValueOffset.length - 1 && i < splitColorValueOffset.length) {
                if (splitColorValueOffset[i]['b'] <= value && value <= splitColorValueOffset[i + 1]['b']) {
                    midColor = splitColorValueOffset[i]['color'].charAt(0) === '#' ?
                        splitColorValueOffset[i]['color'] : colorNameToHex(splitColorValueOffset[i]['color']);
                    previousColor = midColor;
                    nextColor = splitColorValueOffset[i + 1]['color'].charAt(0) === '#' ?
                        splitColorValueOffset[i + 1]['color'] : colorNameToHex(splitColorValueOffset[i + 1]['color']);
                    percent = Math.abs((value - splitColorValueOffset[i + 1]['b'])) / a;
                }
            }
        }
    }
    return getPercentageColor(percent, previousColor, nextColor);
}
/** @private */
function getPercentageColor(percent, previous, next) {
    var nextColor = next.split('#')[1];
    var prevColor = previous.split('#')[1];
    var r = getPercentage(percent, parseInt(prevColor.substr(0, 2), 16), parseInt(nextColor.substr(0, 2), 16));
    var g = getPercentage(percent, parseInt(prevColor.substr(2, 2), 16), parseInt(nextColor.substr(2, 2), 16));
    var b = getPercentage(percent, parseInt(prevColor.substr(4, 2), 16), parseInt(nextColor.substr(4, 2), 16));
    return new ColorValue(r, g, b);
}
/** @private */
function getPercentage(percent, previous, next) {
    var full = next - previous;
    return Math.round((previous + (full * percent)));
}
/** @private */
function getTextAnchor(alignment, enableRTL) {
    switch (alignment) {
        case 'Near':
            return enableRTL ? 'end' : 'start';
        case 'Far':
            return enableRTL ? 'start' : 'end';
        default:
            return 'middle';
    }
}

/**
 * Specifies Chart Themes
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var Theme;
(function (Theme) {
    /** @private */
    Theme.stockEventFont = {
        size: '13px',
        fontWeight: '400',
        color: null,
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
})(Theme || (Theme = {}));
/** @private */
function getSeriesColor(theme) {
    var palette;
    switch (theme) {
        case 'Fabric':
            palette = ['#4472c4', '#ed7d31', '#ffc000', '#70ad47', '#5b9bd5',
                '#c1c1c1', '#6f6fe2', '#e269ae', '#9e480e', '#997300'];
            break;
        case 'Bootstrap4':
            palette = ['#a16ee5', '#f7ce69', '#55a5c2', '#7ddf1e', '#ff6ea6',
                '#7953ac', '#b99b4f', '#407c92', '#5ea716', '#b91c52'];
            break;
        case 'Bootstrap':
            palette = ['#a16ee5', '#f7ce69', '#55a5c2', '#7ddf1e', '#ff6ea6',
                '#7953ac', '#b99b4f', '#407c92', '#5ea716', '#b91c52'];
            break;
        case 'HighContrastLight':
        case 'HighContrast':
            palette = ['#79ECE4', '#E98272', '#DFE6B6', '#C6E773', '#BA98FF',
                '#FA83C3', '#00C27A', '#43ACEF', '#D681EF', '#D8BC6E'];
            break;
        case 'MaterialDark':
            palette = ['#9ECB08', '#56AEFF', '#C57AFF', '#61EAA9', '#EBBB3E',
                '#F45C5C', '#8A77FF', '#63C7FF', '#FF84B0', '#F7C928'];
            break;
        case 'FabricDark':
            palette = ['#4472c4', '#ed7d31', '#ffc000', '#70ad47', '#5b9bd5',
                '#c1c1c1', '#6f6fe2', '#e269ae', '#9e480e', '#997300'];
            break;
        case 'BootstrapDark':
            palette = ['#a16ee5', '#f7ce69', '#55a5c2', '#7ddf1e', '#ff6ea6',
                '#7953ac', '#b99b4f', '#407c92', '#5ea716', '#b91c52'];
            break;
        case 'Tailwind':
            palette = ['#5A61F6', '#65A30D', '#334155', '#14B8A6', '#8B5CF6',
                '#0369A1', '#F97316', '#9333EA', '#F59E0B', '#15803D'];
            break;
        case 'TailwindDark':
            palette = ['#8B5CF6', '#22D3EE', '#F87171', '#4ADE80', '#E879F9',
                '#FCD34D', '#F97316', '#2DD4BF', '#F472B6', '#10B981'];
            break;
        case 'Bootstrap5':
            palette = ['#6355C7', '#FFB400', '#2196F5', '#F7523F', '#963C70',
                '#4BE0BC', '#FD7400', '#C9E422', '#DE3D8A', '#162F88'];
            break;
        case 'Bootstrap5Dark':
            palette = ['#8F80F4', '#FFD46D', '#6CBDFF', '#FF7F71', '#FF6DB3',
                '#63F5D2', '#FCAA65', '#ECFF77', '#EF8EFF', '#5F82FD'];
            break;
        case 'FluentDark':
            palette = ['#1AC9E6', '#DA4CB2', '#EDBB40', '#AF4BCF', '#FF7266',
                '#1BD565', '#EE993D', '#5887FF', '#EC548D', '#7D39C0'];
            break;
        case 'Fluent':
            palette = ['#1AC9E6', '#DA4CB2', '#EDBB40', '#AF4BCF', '#FF7266',
                '#1BD565', '#EE993D', '#5887FF', '#EC548D', '#7D39C0'];
            break;
        case 'Material3':
            palette = ['#6355C7', '#00AEE0', '#FFB400', '#F7523F', '#963C70',
                '#FD7400', '#4BE0BC', '#2196F5', '#DE3D8A', '#162F88'];
            break;
        case 'Material3Dark':
            palette = ['#4EAAFF', '#FA4EAB', '#FFF500', '#17EA58', '#38FFE7',
                '#FF9E45', '#B3F32F', '#B93CE4', '#FC5664', '#9B55FF'];
            break;
        default:
            palette = ['#00bdae', '#404041', '#357cd2', '#e56590', '#f8b883',
                '#70ad47', '#dd8abd', '#7f84e8', '#7bb4eb', '#ea7a57'];
            break;
    }
    return palette;
}
/** @private */
// tslint:disable-next-line:max-func-body-length
function getThemeColor(theme, canvas) {
    var style;
    var darkBackground = theme === 'MaterialDark' ? '#383838' : (theme === 'FabricDark' ? '#242424' : '#1b1b1b');
    switch (theme) {
        case 'HighContrastLight':
        case 'HighContrast':
            style = {
                axisLabel: '#ffffff',
                axisTitle: '#ffffff',
                axisLine: '#ffffff',
                majorGridLine: '#BFBFBF',
                minorGridLine: '#969696',
                majorTickLine: '#BFBFBF',
                minorTickLine: '#969696',
                chartTitle: '#ffffff',
                legendLabel: '#ffffff',
                background: canvas ? '#000000' : 'transparent',
                areaBorder: '#ffffff',
                errorBar: '#ffffff',
                crosshairLine: '#ffffff',
                crosshairFill: '#ffffff',
                crosshairLabel: '#000000',
                tooltipFill: '#ffffff',
                tooltipBoldLabel: '#000000',
                tooltipLightLabel: '#000000',
                tooltipHeaderLine: '#969696',
                markerShadow: '#BFBFBF',
                selectionRectFill: 'rgba(255, 217, 57, 0.3)',
                selectionRectStroke: '#ffffff',
                selectionCircleStroke: '#FFD939',
                tabColor: '#FFD939',
                bearFillColor: '#2ecd71',
                bullFillColor: '#e74c3d',
                toolkitSelectionColor: '#FFD939',
                toolkitFill: '#737373',
                toolkitIconRectOverFill: 'transparent',
                toolkitIconRectSelectionFill: 'transparent',
                toolkitIconRect: new Rect(0, 0, 16, 16),
                chartTitleFont: {
                    color: '#FFFFFF', fontFamily: 'Segoe UI'
                },
                axisLabelFont: {
                    color: '#969696', fontFamily: 'Segoe UI'
                },
                legendTitleFont: {
                    color: '#FFFFFF', fontFamily: 'Segoe UI'
                },
                legendLabelFont: {
                    color: '#969696', fontFamily: 'Segoe UI'
                },
                tooltipLabelFont: {
                    color: '#000000', fontFamily: 'Segoe UI'
                },
                axisTitleFont: {
                    color: '#FFFFFF', fontFamily: 'Segoe UI'
                },
                datalabelFont: {
                    color: '#969696', fontFamily: 'Segoe UI'
                },
                chartSubTitleFont: {
                    color: '#FFFFFF', fontFamily: 'Segoe UI'
                },
                crosshairLabelFont: {
                    color: '#000000', fontFamily: 'Segoe UI'
                },
                stripLineLabelFont: {
                    color: '#969696', fontFamily: 'Segoe UI'
                }
            };
            break;
        case 'MaterialDark':
        case 'FabricDark':
        case 'BootstrapDark':
            style = {
                axisLabel: '#DADADA', axisTitle: '#ffffff',
                axisLine: ' #6F6C6C',
                majorGridLine: '#414040',
                minorGridLine: '#514F4F',
                majorTickLine: '#414040',
                minorTickLine: ' #4A4848',
                chartTitle: '#ffffff',
                legendLabel: '#DADADA',
                background: canvas ? darkBackground : 'transparent',
                areaBorder: ' #9A9A9A',
                errorBar: '#ffffff',
                crosshairLine: '#F4F4F4',
                crosshairFill: theme === 'MaterialDark' ? '#F4F4F4' : theme === 'FabricDark' ? '#A19F9D' : '#F0F0F0',
                crosshairLabel: '#282727',
                tooltipFill: '#F4F4F4',
                tooltipBoldLabel: '#282727',
                tooltipLightLabel: '#333232',
                tooltipHeaderLine: '#9A9A9A',
                markerShadow: null,
                selectionRectFill: 'rgba(56,169,255, 0.1)',
                selectionRectStroke: '#38A9FF',
                selectionCircleStroke: '#282727',
                tabColor: theme === 'MaterialDark' ? '#00B0FF' : theme === 'FabricDark' ? '#0074CC' : '#0070F0',
                bearFillColor: '#2ecd71',
                bullFillColor: '#e74c3d',
                toolkitSelectionColor: theme === 'MaterialDark' ? '#00B0FF' : theme === 'FabricDark' ? '#0074CC' : '#0070F0',
                toolkitFill: '#737373',
                toolkitIconRectOverFill: 'transparent',
                toolkitIconRectSelectionFill: 'transparent',
                toolkitIconRect: new Rect(0, 0, 16, 16),
                chartTitleFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.87)' : theme === 'FabricDark' ? '#DADADA' : '#FFFFFF', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                axisLabelFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : theme === 'FabricDark' ? '#A19F9D' : '#CED4DA', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                legendTitleFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.87)' : theme === 'FabricDark' ? '#DADADA' : '#FFFFFF', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                legendLabelFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : theme === 'FabricDark' ? '#A19F9D' : '#676767', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                tooltipLabelFont: {
                    color: theme === 'MaterialDark' ? 'rgba(18, 18, 18, 1)' : theme === 'FabricDark' ? '#DADADA' : '#1A1A1A', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                axisTitleFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.87)' : theme === 'FabricDark' ? '#DADADA' : '#FFFFFF', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                datalabelFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : theme === 'FabricDark' ? '#A19F9D' : '#676767', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                chartSubTitleFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.87)' : theme === 'FabricDark' ? '#DADADA' : '#FFFFFF', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                crosshairLabelFont: {
                    color: theme === 'MaterialDark' ? 'rgba(18, 18, 18, 1)' : theme === 'FabricDark' ? '#DADADA' : '#1A1A1A', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                stripLineLabelFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.24)' : theme === 'FabricDark' ? '#6F6C6C' : '#414141', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                }
            };
            break;
        case 'Bootstrap4':
            style = {
                axisLabel: '#212529', axisTitle: '#212529', axisLine: '#CED4DA', majorGridLine: '#CED4DA',
                minorGridLine: '#DEE2E6', majorTickLine: '#ADB5BD', minorTickLine: '#CED4DA', chartTitle: '#212529', legendLabel: '#212529',
                background: canvas ? '#FFFFFF' : 'transparent', areaBorder: '#DEE2E6', errorBar: '#000000', crosshairLine: '#6C757D', crosshairFill: '#212529',
                crosshairLabel: '#FFFFFF', tooltipFill: '#020202', tooltipBoldLabel: 'rgba(255,255,255)',
                tooltipLightLabel: 'rgba(255,255,255, 0.9)', tooltipHeaderLine: 'rgba(255,255,255, 0.2)', markerShadow: null,
                selectionRectFill: 'rgba(255,255,255, 0.1)', selectionRectStroke: 'rgba(0, 123, 255)', selectionCircleStroke: '#495057', tabColor: '#007BFF', bearFillColor: '#2ecd71', bullFillColor: '#e74c3d',
                toolkitSelectionColor: '#007BFF',
                toolkitFill: '#495057',
                toolkitIconRectOverFill: 'transparent',
                toolkitIconRectSelectionFill: 'transparent',
                toolkitIconRect: new Rect(-5, -5, 26, 26),
                chartTitleFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                },
                axisLabelFont: {
                    color: '#495057', fontFamily: 'Helvetica'
                },
                legendTitleFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                },
                legendLabelFont: {
                    color: '#666666', fontFamily: 'Helvetica'
                },
                tooltipLabelFont: {
                    color: '#F9FAFB', fontFamily: 'Helvetica'
                },
                axisTitleFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                },
                datalabelFont: {
                    color: '#495057', fontFamily: 'Helvetica'
                },
                chartSubTitleFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                },
                crosshairLabelFont: {
                    color: '#F9FAFB', fontFamily: 'Helvetica'
                },
                stripLineLabelFont: {
                    color: '#6C757D', fontFamily: 'Helvetica'
                }
            };
            break;
        case 'Tailwind':
            style = {
                axisLabel: '#6B728', axisTitle: '#374151',
                axisLine: ' #D1D5DB',
                majorGridLine: '#E5E7EB',
                minorGridLine: '#E5E7EB',
                majorTickLine: '#D1D5DB',
                minorTickLine: ' #D1D5DB',
                chartTitle: '#374151',
                legendLabel: '#374151',
                background: canvas ? 'rgba(255,255,255, 0.0)' : 'transparent',
                areaBorder: ' #E5E7EB',
                errorBar: '#374151',
                crosshairLine: '#1F2937',
                crosshairFill: '#111827',
                crosshairLabel: '#F9FAFB',
                tooltipFill: '#111827',
                tooltipBoldLabel: '#D1D5DB',
                tooltipLightLabel: '#F9FAFB',
                tooltipHeaderLine: '#6B7280',
                markerShadow: null,
                selectionRectFill: 'rgba(79,70,229, 0.1)',
                selectionRectStroke: '#4F46E5',
                selectionCircleStroke: '#6B7280',
                tabColor: '#4F46E5',
                bearFillColor: '#2ecd71',
                bullFillColor: '#e74c3d',
                toolkitSelectionColor: '#4F46E5',
                toolkitFill: '#6B7280',
                toolkitIconRectOverFill: 'transparent',
                toolkitIconRectSelectionFill: 'transparent',
                toolkitIconRect: new Rect(0, 0, 16, 16),
                chartTitleFont: {
                    color: '#374151', fontFamily: 'Inter'
                },
                axisLabelFont: {
                    color: '#6B7280', fontFamily: 'Inter'
                },
                legendTitleFont: {
                    color: '#374151', fontFamily: 'Inter'
                },
                legendLabelFont: {
                    color: '#374151', fontFamily: 'Inter'
                },
                tooltipLabelFont: {
                    color: '#F9FAFB', fontFamily: 'Inter'
                },
                axisTitleFont: {
                    color: '#374151', fontFamily: 'Inter'
                },
                datalabelFont: {
                    color: '#6B7280', fontFamily: 'Inter'
                },
                chartSubTitleFont: {
                    color: '#374151', fontFamily: 'Inter'
                },
                crosshairLabelFont: {
                    color: '#F9FAFB', fontFamily: 'Inter'
                },
                stripLineLabelFont: {
                    color: '#D1D5DB', fontFamily: 'Inter'
                }
            };
            break;
        case 'TailwindDark':
            style = {
                axisLabel: '#9CA3AF', axisTitle: '#9CA3AF',
                axisLine: ' #4B5563',
                majorGridLine: '#374151',
                minorGridLine: '#374151',
                majorTickLine: '#4B5563',
                minorTickLine: ' #4B5563',
                chartTitle: '#D1D5DB',
                legendLabel: '#D1D5DB',
                background: canvas ? '#1f2937' : 'transparent',
                areaBorder: ' #374151',
                errorBar: '#ffffff',
                crosshairLine: '#9CA3AF',
                crosshairFill: '#F9FAFB',
                crosshairLabel: '#1F2937',
                tooltipFill: '#F9FAFB',
                tooltipBoldLabel: '#6B7280',
                tooltipLightLabel: '#1F2937',
                tooltipHeaderLine: '#9CA3AF',
                markerShadow: null,
                selectionRectFill: 'rgba(34,211,238, 0.1)',
                selectionRectStroke: '#22D3EE',
                selectionCircleStroke: '#282727',
                tabColor: '#22D3EE',
                bearFillColor: '#2ecd71',
                bullFillColor: '#e74c3d',
                toolkitSelectionColor: '#22D3EE',
                toolkitFill: '#D1D5DB',
                toolkitIconRectOverFill: 'transparent',
                toolkitIconRectSelectionFill: 'transparent',
                toolkitIconRect: new Rect(0, 0, 16, 16),
                chartTitleFont: {
                    color: '#D1D5DB', fontFamily: 'Inter'
                },
                axisLabelFont: {
                    color: '#9CA3AF', fontFamily: 'Inter'
                },
                legendTitleFont: {
                    color: '#D1D5DB', fontFamily: 'Inter'
                },
                legendLabelFont: {
                    color: '#D1D5DB', fontFamily: 'Inter'
                },
                tooltipLabelFont: {
                    color: '#1F2937', fontFamily: 'Inter'
                },
                axisTitleFont: {
                    color: '#D1D5DB', fontFamily: 'Inter'
                },
                datalabelFont: {
                    color: '#9CA3AF', fontFamily: 'Inter'
                },
                chartSubTitleFont: {
                    color: '#D1D5DB', fontFamily: 'Inter'
                },
                crosshairLabelFont: {
                    color: '#1F2937', fontFamily: 'Inter'
                },
                stripLineLabelFont: {
                    color: '#6B7280', fontFamily: 'Inter'
                }
            };
            break;
        case 'Bootstrap5':
            style = {
                axisLabel: '#495057',
                axisTitle: '#343A40',
                axisLine: '#D1D5DB',
                majorGridLine: '#E5E7EB',
                minorGridLine: '#E5E7EB',
                majorTickLine: '#D1D5DB',
                minorTickLine: ' #D1D5DB',
                chartTitle: '#343A40',
                legendLabel: '#343A40',
                background: canvas ? '#FFFFFF' : 'transparent',
                areaBorder: ' #DEE2E6',
                errorBar: '#1F2937',
                crosshairLine: '#1F2937',
                crosshairFill: '#212529',
                crosshairLabel: '#F9FAFB',
                tooltipFill: '#212529',
                tooltipBoldLabel: '#F9FAFB',
                tooltipLightLabel: '#F9FAFB',
                tooltipHeaderLine: '#9CA3AF',
                markerShadow: null,
                selectionRectFill: 'rgba(79,70,229, 0.1)',
                selectionRectStroke: '#4F46E5',
                selectionCircleStroke: '#6B7280',
                tabColor: '#0D6EFD',
                bearFillColor: '#2ecd71',
                bullFillColor: '#e74c3d',
                toolkitSelectionColor: '#0D6EFD',
                toolkitFill: '#737373',
                toolkitIconRectOverFill: 'transparent',
                toolkitIconRectSelectionFill: 'transparent',
                toolkitIconRect: new Rect(0, 0, 16, 16),
                chartTitleFont: {
                    color: '#343A40', fontFamily: 'Helvetica'
                },
                axisLabelFont: {
                    color: '#495057', fontFamily: 'Helvetica'
                },
                legendTitleFont: {
                    color: '#343A40', fontFamily: 'Helvetica'
                },
                legendLabelFont: {
                    color: '#343A40', fontFamily: 'Helvetica'
                },
                tooltipLabelFont: {
                    color: '#F9FAFB', fontFamily: 'Helvetica'
                },
                axisTitleFont: {
                    color: '#343A40', fontFamily: 'Helvetica'
                },
                datalabelFont: {
                    color: '#495057', fontFamily: 'Helvetica'
                },
                chartSubTitleFont: {
                    color: '#343A40', fontFamily: 'Helvetica'
                },
                crosshairLabelFont: {
                    color: '#F9FAFB', fontFamily: 'Helvetica'
                },
                stripLineLabelFont: {
                    color: '#ADB5BD', fontFamily: 'Helvetica'
                }
            };
            break;
        case 'Bootstrap5Dark':
            style = {
                axisLabel: '#CED4DA',
                axisTitle: '#E9ECEF',
                axisLine: '#495057',
                majorGridLine: '#343A40',
                minorGridLine: '#343A40',
                majorTickLine: '#495057',
                minorTickLine: ' #495057',
                chartTitle: '#E9ECEF',
                legendLabel: '#E9ECEF',
                background: canvas ? '#212529' : 'transparent',
                areaBorder: ' #444C54',
                errorBar: '#ADB5BD',
                crosshairLine: '#ADB5BD',
                crosshairFill: '#E9ECEF',
                crosshairLabel: '#212529',
                tooltipFill: '#E9ECEF',
                tooltipBoldLabel: '#212529',
                tooltipLightLabel: '#212529',
                tooltipHeaderLine: '#ADB5BD',
                markerShadow: null,
                selectionRectFill: 'rgba(79,70,229, 0.1)',
                selectionRectStroke: '#4F46E5',
                selectionCircleStroke: '#6B7280',
                tabColor: '#0D6EFD',
                bearFillColor: '#2ecd71',
                bullFillColor: '#e74c3d',
                toolkitSelectionColor: '#0D6EFD',
                toolkitFill: '#737373',
                toolkitIconRectOverFill: 'transparent',
                toolkitIconRectSelectionFill: 'transparent',
                toolkitIconRect: new Rect(0, 0, 16, 16),
                chartTitleFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                },
                axisLabelFont: {
                    color: '#CED4DA', fontFamily: 'Helvetica'
                },
                legendTitleFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                },
                legendLabelFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                },
                tooltipLabelFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                },
                axisTitleFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                },
                datalabelFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                },
                chartSubTitleFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                },
                crosshairLabelFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                },
                stripLineLabelFont: {
                    color: '#6C757D', fontFamily: 'Helvetica'
                }
            };
            break;
        case 'Fluent':
            style = {
                axisLabel: '#3B3A39',
                axisTitle: '#201F1E',
                axisLine: '#D2D0CE',
                majorGridLine: '#EDEBE9',
                minorGridLine: '#EDEBE9',
                majorTickLine: '#D2D0CE',
                minorTickLine: ' #D2D0CE',
                chartTitle: '#201F1E',
                legendLabel: '#323130',
                background: canvas ? '#FFFFFF' : 'transparent',
                areaBorder: '#EDEBE9',
                errorBar: '#A19F9D',
                crosshairLine: '#A19F9D',
                crosshairFill: '#FFFFFF',
                crosshairLabel: '#323130',
                tooltipFill: '#FFFFFF',
                tooltipBoldLabel: '#323130',
                tooltipLightLabel: '#323130',
                tooltipHeaderLine: '#D2D0CE',
                markerShadow: null,
                selectionRectFill: 'rgba(79,70,229, 0.1)',
                selectionRectStroke: '#4F46E5',
                selectionCircleStroke: '#6B7280',
                tabColor: '#0078D4',
                bearFillColor: '#2ecd71',
                bullFillColor: '#e74c3d',
                toolkitSelectionColor: '#0078D4',
                toolkitFill: '#A19F9D',
                toolkitIconRectOverFill: 'transparent',
                toolkitIconRectSelectionFill: 'transparent',
                toolkitIconRect: new Rect(0, 0, 16, 16),
                chartTitleFont: {
                    color: '#201F1E', fontFamily: 'Segoe UI'
                },
                axisLabelFont: {
                    color: '#3B3A39', fontFamily: 'Segoe UI'
                },
                legendTitleFont: {
                    color: '#201F1E', fontFamily: 'Segoe UI'
                },
                legendLabelFont: {
                    color: '#49454E', fontFamily: 'Segoe UI'
                },
                tooltipLabelFont: {
                    color: '#323130', fontFamily: 'Segoe UI'
                },
                axisTitleFont: {
                    color: '#201F1E', fontFamily: 'Segoe UI'
                },
                datalabelFont: {
                    color: '#3B3A39', fontFamily: 'Segoe UI'
                },
                chartSubTitleFont: {
                    color: '#323129', fontFamily: 'Segoe UI'
                },
                crosshairLabelFont: {
                    color: '#323130', fontFamily: 'Segoe UI'
                },
                stripLineLabelFont: {
                    color: '#A19F9D', fontFamily: 'Segoe UI'
                }
            };
            break;
        case 'FluentDark':
            style = {
                axisLabel: '#C8C6C4',
                axisTitle: '#F3F2F1',
                axisLine: '#3B3A39',
                majorGridLine: '#414040',
                minorGridLine: '#414040',
                majorTickLine: '#3B3A39',
                minorTickLine: '#3B3A39',
                chartTitle: '#F3F2F1',
                legendLabel: '#D2D0CE',
                background: canvas ? '#383838' : 'transparent',
                areaBorder: '#414040',
                errorBar: '#D2D0CE',
                crosshairLine: '#D2D0CE',
                crosshairFill: '#323130',
                crosshairLabel: '#F3F2F1',
                tooltipFill: '#252423',
                tooltipBoldLabel: '#F3F2F1',
                tooltipLightLabel: '#F3F2F1',
                tooltipHeaderLine: '#3B3A39',
                markerShadow: null,
                selectionRectFill: 'rgba(79,70,229, 0.1)',
                selectionRectStroke: '#4F46E5',
                selectionCircleStroke: '#6B7280',
                tabColor: '#0078D4',
                bearFillColor: '#2ecd71',
                bullFillColor: '#e74c3d',
                toolkitSelectionColor: '#0078D4',
                toolkitFill: '#484644',
                toolkitIconRectOverFill: 'transparent',
                toolkitIconRectSelectionFill: 'transparent',
                toolkitIconRect: new Rect(0, 0, 16, 16),
                chartTitleFont: {
                    color: '#C8C6C4', fontFamily: 'Segoe UI'
                },
                axisLabelFont: {
                    color: '#C8C6C4', fontFamily: 'Segoe UI'
                },
                legendTitleFont: {
                    color: '#F3F2F1', fontFamily: 'Segoe UI'
                },
                legendLabelFont: {
                    color: '#D2D0CE', fontFamily: 'Segoe UI'
                },
                tooltipLabelFont: {
                    color: '#F3F2F1', fontFamily: 'Segoe UI'
                },
                axisTitleFont: {
                    color: '#F3F2F2', fontFamily: 'Segoe UI'
                },
                datalabelFont: {
                    color: '#D2D0CE', fontFamily: 'Segoe UI'
                },
                chartSubTitleFont: {
                    color: '#F3F2F1', fontFamily: 'Segoe UI'
                },
                crosshairLabelFont: {
                    color: '#F3F2F1', fontFamily: 'Segoe UI'
                },
                stripLineLabelFont: {
                    color: '#484644', fontFamily: 'Segoe UI'
                }
            };
            break;
        case 'Material3':
            style = {
                axisLabel: '#1E192B',
                axisTitle: '#1C1B1F',
                axisLine: '#C4C7C5',
                majorGridLine: '#C4C7C5',
                minorGridLine: '#C4C7C5',
                majorTickLine: '#C4C7C5',
                minorTickLine: ' #C4C7C5',
                chartTitle: '#1C1B1F',
                legendLabel: '#49454E',
                background: canvas ? '#FFFFFF' : 'transparent',
                areaBorder: '#E7E0EC',
                errorBar: '#79747E',
                crosshairLine: '#49454E',
                crosshairFill: '#313033',
                crosshairLabel: '#F4EFF4',
                tooltipFill: '#313033',
                tooltipBoldLabel: '#F4EFF4',
                tooltipLightLabel: '#F4EFF4',
                tooltipHeaderLine: '#F4EFF4',
                markerShadow: null,
                selectionRectFill: 'rgb(98, 0, 238, 0.06)',
                selectionRectStroke: '#6200EE',
                selectionCircleStroke: '#79747E',
                tabColor: '#49454E',
                bearFillColor: '#5887FF',
                bullFillColor: '#F7523F',
                toolkitSelectionColor: '#49454E',
                toolkitFill: '#49454E',
                toolkitIconRectOverFill: '#EADDFF',
                toolkitIconRectSelectionFill: '#EADDFF',
                toolkitIconRect: new Rect(-4, -5, 26, 26),
                histogram: '#D21020',
                chartTitleFont: {
                    color: '#1C1B1F', fontFamily: 'Roboto'
                },
                axisLabelFont: {
                    color: '#1E192B', fontFamily: 'Roboto'
                },
                legendTitleFont: {
                    color: '#1C1B1F', fontFamily: 'Roboto'
                },
                legendLabelFont: {
                    color: '#49454E', fontFamily: 'Roboto'
                },
                tooltipLabelFont: {
                    color: '#F4EFF4', fontFamily: 'Roboto'
                },
                axisTitleFont: {
                    color: '#1C1B1F', fontFamily: 'Roboto'
                },
                datalabelFont: {
                    color: '#49454E', fontFamily: 'Roboto'
                },
                chartSubTitleFont: {
                    color: '#49454E', fontFamily: 'Roboto'
                },
                crosshairLabelFont: {
                    color: '#F4EFF4', fontFamily: 'Roboto'
                },
                stripLineLabelFont: {
                    color: '#79747E', fontFamily: 'Roboto'
                }
            };
            break;
        case 'Material3Dark':
            style = {
                axisLabel: '#E6E1E5',
                axisTitle: '#E6E1E5',
                axisLine: '#49454F',
                majorGridLine: '#444746',
                minorGridLine: '#444746',
                majorTickLine: '#444746',
                minorTickLine: ' #444746',
                chartTitle: '#E6E1E5',
                legendLabel: '#CAC4D0',
                background: canvas ? '#FFFFFF' : 'transparent',
                areaBorder: '#49454F',
                errorBar: '#938F99',
                crosshairLine: '#CAC4D0',
                crosshairFill: '#E6E1E5',
                crosshairLabel: '#313033',
                tooltipFill: '#E6E1E5',
                tooltipBoldLabel: '#313033',
                tooltipLightLabel: '#313033',
                tooltipHeaderLine: '#313033',
                markerShadow: null,
                selectionRectFill: 'rgba(78, 170, 255, 0.06)',
                selectionRectStroke: '#4EAAFF',
                selectionCircleStroke: '#938F99',
                tabColor: '#CAC4D0',
                bearFillColor: '#B3F32F',
                bullFillColor: '#FF9E45',
                toolkitSelectionColor: '#CAC4D0',
                toolkitFill: '#CAC4D0',
                toolkitIconRectOverFill: '#4F378B',
                toolkitIconRectSelectionFill: '#4F378B',
                toolkitIconRect: new Rect(-4, -5, 26, 26),
                histogram: '#FF9E45',
                chartTitleFont: {
                    color: '#E6E1E5', fontFamily: 'Roboto'
                },
                axisLabelFont: {
                    color: '#CAC4D0', fontFamily: 'Roboto'
                },
                legendTitleFont: {
                    color: '#E6E1E5', fontFamily: 'Roboto'
                },
                legendLabelFont: {
                    color: '#CAC4D0', fontFamily: 'Roboto'
                },
                tooltipLabelFont: {
                    color: '#313033', fontFamily: 'Roboto'
                },
                axisTitleFont: {
                    color: '#E6E1E5', fontFamily: 'Roboto'
                },
                datalabelFont: {
                    color: '#CAC4D0', fontFamily: 'Roboto'
                },
                chartSubTitleFont: {
                    color: '#CAC4D0', fontFamily: 'Roboto'
                },
                crosshairLabelFont: {
                    color: '#313033', fontFamily: 'Roboto'
                },
                stripLineLabelFont: {
                    color: '#938F99', fontFamily: 'Roboto'
                }
            };
            break;
        default:
            style = {
                axisLabel: '#686868',
                axisTitle: '#424242',
                axisLine: '#b5b5b5',
                majorGridLine: '#dbdbdb',
                minorGridLine: '#eaeaea',
                majorTickLine: '#b5b5b5',
                minorTickLine: '#d6d6d6',
                chartTitle: '#424242',
                legendLabel: '#353535',
                background: canvas ? '#FFFFFF' : 'transparent',
                areaBorder: 'Gray',
                errorBar: '#000000',
                crosshairLine: '#4f4f4f',
                crosshairFill: theme === 'Material' ? '#000816' : theme === 'Fabric' ? '#FFFFFF' : '#212529',
                crosshairLabel: '#e5e5e5',
                tooltipFill: '#000816',
                tooltipBoldLabel: '#ffffff',
                tooltipLightLabel: '#dbdbdb',
                tooltipHeaderLine: '#ffffff',
                markerShadow: null,
                selectionRectFill: 'rgba(41, 171, 226, 0.1)',
                selectionRectStroke: '#29abe2',
                selectionCircleStroke: '#29abe2',
                tabColor: theme === 'Material' ? '#ff4081' : theme === 'Fabric' ? '#0078D6' : '#317AB9',
                bearFillColor: '#2ecd71',
                bullFillColor: '#e74c3d',
                toolkitSelectionColor: theme === 'Material' ? '#ff4081' : theme === 'Fabric' ? '#0078D6' : '#317AB9',
                toolkitFill: '#737373',
                toolkitIconRectOverFill: 'transparent',
                toolkitIconRectSelectionFill: 'transparent',
                toolkitIconRect: new Rect(0, 0, 16, 16),
                chartTitleFont: {
                    color: theme === 'Material' ? 'rgba(0, 0, 0, 1)' : theme === 'Fabric' ? '#333333' : '#212529', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
                },
                axisLabelFont: {
                    color: theme === 'Material' ? 'rgba(97, 97, 97, 1)' : theme === 'Fabric' ? '#666666' : '#676767', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
                },
                legendTitleFont: {
                    color: theme === 'Material' ? 'rgba(0, 0, 0, 1)' : theme === 'Fabric' ? '#333333' : '#212529', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
                },
                legendLabelFont: {
                    color: theme === 'Material' ? 'rgba(97, 97, 97, 1)' : theme === 'Fabric' ? '#666666' : '#666666', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
                },
                tooltipLabelFont: {
                    color: theme === 'Material' ? 'rgba(249, 250, 251, 1)' : theme === 'Fabric' ? '#333333' : '#F9FAFB', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
                },
                axisTitleFont: {
                    color: theme === 'Material' ? 'rgba(0, 0, 0, 1)' : theme === 'Fabric' ? '#333333' : '#212529', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
                },
                datalabelFont: {
                    color: theme === 'Material' ? 'rgba(97, 97, 97, 1)' : theme === 'Fabric' ? '#666666' : '#676767', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
                },
                chartSubTitleFont: {
                    color: theme === 'Material' ? 'rgba(0, 0, 0, 1)' : theme === 'Fabric' ? '#333333' : '#212529', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
                },
                crosshairLabelFont: {
                    color: theme === 'Material' ? 'rgba(249, 250, 251, 1)' : theme === 'Fabric' ? '#333333' : '#F9FAFB', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
                },
                stripLineLabelFont: {
                    color: theme === 'Material' ? 'rgba(158, 158, 158, 1)' : theme === 'Fabric' ? '#A6A6A6' : '#676767', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
                }
            };
            break;
    }
    return style;
}
/** @private */
function getScrollbarThemeColor(theme) {
    var scrollStyle;
    switch (theme) {
        case 'HighContrastLight':
            scrollStyle = {
                backRect: '#333',
                thumb: '#bfbfbf',
                circle: '#fff',
                circleHover: '#685708',
                arrow: '#333',
                grip: '#333',
                arrowHover: '#fff',
                backRectBorder: '#969696'
            };
            break;
        case 'Bootstrap':
            scrollStyle = {
                backRect: '#f5f5f5',
                thumb: '#e6e6e6',
                circle: '#fff',
                circleHover: '#eee',
                arrow: '#8c8c8c',
                grip: '#8c8c8c'
            };
            break;
        case 'Fabric':
            scrollStyle = {
                backRect: '#f8f8f8',
                thumb: '#eaeaea',
                circle: '#fff',
                circleHover: '#eaeaea',
                arrow: '#a6a6a6',
                grip: '#a6a6a6'
            };
            break;
        case 'MaterialDark':
            scrollStyle = {
                backRect: '#424242',
                thumb: '#616161',
                circle: '#757575',
                circleHover: '#616161',
                arrow: '#BDBDBD',
                grip: '#BDBDBD'
            };
            break;
        case 'FabricDark':
            scrollStyle = {
                backRect: '#282727',
                thumb: '#333232',
                circle: '#4A4848',
                circleHover: '#514F4F',
                arrow: '#ADB5BD',
                grip: '#DADADA'
            };
            break;
        case 'BootstrapDark':
            scrollStyle = {
                backRect: '#2A2A2A',
                thumb: '#313131',
                circle: '#414141',
                circleHover: '#484848',
                arrow: '#DADADA',
                grip: '#FFFFFF'
            };
            break;
        case 'Bootstrap5Dark':
            scrollStyle = {
                backRect: '#282D31',
                thumb: '#3B4248',
                circle: '#495057',
                circleHover: '#6C757D',
                arrow: '#A19F9D',
                grip: '#ADB5BD'
            };
            break;
        case 'HighContrast':
            scrollStyle = {
                backRect: '#757575',
                thumb: '#BFBFBF',
                circle: '#FFFFFF',
                circleHover: '#FFFFFF',
                arrow: '#ADB5BD',
                grip: '#969696'
            };
            break;
        case 'TailwindDark':
            scrollStyle = {
                backRect: '#6B7280',
                thumb: '#374151',
                circle: '#4B5563',
                circleHover: '#4B5563',
                arrow: '#ADB5BD',
                grip: '#D1D5DB'
            };
            break;
        case 'Fluent':
            scrollStyle = {
                backRect: '#F3F2F1',
                thumb: '#E1DFDD',
                circle: '#FFFFFF',
                circleHover: '#E1DFDD',
                arrow: '#605E5C',
                grip: '#605E5C'
            };
            break;
        case 'FluentDark':
            scrollStyle = {
                backRect: '#252423',
                thumb: '#323130',
                circle: '#3B3A39',
                circleHover: '#3B3A39',
                arrow: '#ADB5BD',
                grip: '#A19F9D'
            };
            break;
        case 'Material3':
            scrollStyle = {
                backRect: 'rgba(103, 80, 164, 0.05)',
                thumb: ' rgba(103, 80, 164, 0.14)',
                circle: '#FFFFFF',
                circleHover: '#E1DFDD',
                arrow: '#49454E',
                grip: '#49454E'
            };
            break;
        case 'Material3Dark':
            scrollStyle = {
                backRect: 'rgba(208, 188, 255, 0.05)',
                thumb: 'rgba(208, 188, 255, 0.14)',
                circle: '#FFFFFF',
                circleHover: '#E1DFDD',
                arrow: '#CAC4D0',
                grip: '#CAC4D0'
            };
            break;
        default:
            scrollStyle = {
                backRect: '#f5f5f5',
                thumb: '#e0e0e0',
                circle: '#fff',
                circleHover: '#eee',
                arrow: '#9e9e9e',
                grip: '#9e9e9e'
            };
            break;
    }
    return scrollStyle;
}

/**
 * Specifies the Cartesian Axis Layout.
 */
var axisPadding = 10;
var CartesianAxisLayoutPanel = /** @__PURE__ @class */ (function () {
    /** @private */
    function CartesianAxisLayoutPanel(chartModule) {
        this.chart = chartModule;
        this.padding = 5;
    }
    /**
     * Measure the axis size.
     *
     * @returns {void}
     * @private
     */
    CartesianAxisLayoutPanel.prototype.measureAxis = function (rect) {
        var chart = this.chart;
        var chartAreaWidth = chart.chartArea.width ? stringToNumber(chart.chartArea.width, chart.availableSize.width) : null;
        this.crossAt(chart);
        this.seriesClipRect = new Rect(rect.x, rect.y, rect.width, rect.height);
        this.initialClipRect = rect;
        this.leftSize = 0;
        this.rightSize = 0;
        this.topSize = 0;
        this.bottomSize = 0;
        //Measure Axis size with initial Rect
        this.measureRowAxis(chart, this.initialClipRect);
        this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));
        this.measureColumnAxis(chart, this.initialClipRect);
        this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));
        if (!this.chart.delayRedraw) {
            this.calculateAxisSize(this.initialClipRect);
        }
        this.leftSize = 0;
        this.rightSize = 0;
        this.topSize = 0;
        this.bottomSize = 0;
        //Measure Axis size with series Rect
        this.measureRowAxis(chart, this.initialClipRect);
        this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));
        this.measureColumnAxis(chart, this.initialClipRect);
        this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));
        if (chartAreaWidth) {
            this.calculateFixedChartArea(chart, chartAreaWidth);
        }
        if (!this.chart.delayRedraw) {
            chart.refreshAxis();
            this.calculateAxisSize(this.seriesClipRect);
        }
    };
    CartesianAxisLayoutPanel.prototype.calculateFixedChartArea = function (chart, chartAreaWidth) {
        this.seriesClipRect.width = chartAreaWidth;
        this.seriesClipRect.x = chart.availableSize.width - chart.margin.right - chartAreaWidth -
            (chart.legendSettings.position === 'Right' ? chart.legendModule.legendBounds.width : 0);
        for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {
            var item = _a[_i];
            this.seriesClipRect.x -= sum(item.farSizes);
        }
    };
    CartesianAxisLayoutPanel.prototype.measureRowAxis = function (chart, rect) {
        var row;
        this.calculateRowSize(rect);
        for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {
            var item = _a[_i];
            row = item;
            row.nearSizes = [];
            row.farSizes = [];
            row.insideNearSizes = [];
            row.insideFarSizes = [];
            this.arrangeAxis(row);
            this.measureDefinition(row, chart, new Size(chart.availableSize.width, row.computedHeight));
            if (this.leftSize < sum(row.nearSizes)) {
                this.leftSize = sum(row.nearSizes);
            }
            if (this.rightSize < sum(row.farSizes)) {
                this.rightSize = sum(row.farSizes);
            }
        }
    };
    CartesianAxisLayoutPanel.prototype.measureColumnAxis = function (chart, rect) {
        var column;
        this.calculateColumnSize(rect);
        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {
            var item = _a[_i];
            column = item;
            column.farSizes = [];
            column.nearSizes = [];
            column.insideNearSizes = [];
            column.insideFarSizes = [];
            this.arrangeAxis(column);
            this.measureDefinition(column, chart, new Size(column.computedWidth, chart.availableSize.height));
            if (this.bottomSize < sum(column.nearSizes)) {
                this.bottomSize = sum(column.nearSizes);
            }
            if (this.topSize < sum(column.farSizes)) {
                this.topSize = sum(column.farSizes);
            }
        }
    };
    /**
     * Measure the column and row in chart.
     *
     * @returns {void}
     * @private
     */
    CartesianAxisLayoutPanel.prototype.measureDefinition = function (definition, chart, size) {
        var ele;
        for (var _i = 0, _a = definition.axes; _i < _a.length; _i++) {
            var axis = _a[_i];
            ele = axis.scrollbarSettings.height;
            axis.scrollBarHeight = chart.scrollBarModule && chart.zoomModule && chart.zoomSettings.enableScrollbar &&
                axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) ? ele : 0;
            axis.scrollBarHeight = chart.scrollBarModule && (chart.zoomModule && chart.zoomSettings.enableScrollbar &&
                axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0)
                || axis.scrollbarSettings.enable) ? ele : 0;
            axis.getModule(chart);
            axis.baseModule.calculateRangeAndInterval(size, axis);
            definition.computeSize(axis, axis.scrollBarHeight, definition, chart);
        }
        if (definition.farSizes.length > 0) {
            definition.farSizes[definition.farSizes.length - 1] -= axisPadding;
        }
        if (definition.nearSizes.length > 0) {
            definition.nearSizes[definition.nearSizes.length - 1] -= axisPadding;
        }
    };
    /**
     * Measure the axis.
     *
     * @returns {void}
     * @private
     */
    CartesianAxisLayoutPanel.prototype.calculateAxisSize = function (rect) {
        var chart = this.chart;
        var row;
        var column;
        var definition;
        var axis;
        var nearCount = 0;
        var farCount = 0;
        var size = 0;
        var x;
        var y;
        var axisOffset;
        this.calculateRowSize(rect);
        for (var i = 0, len = chart.rows.length; i < len; i++) {
            row = chart.rows[i];
            nearCount = 0;
            farCount = 0;
            for (var j = 0, len_1 = row.axes.length; j < len_1; j++) {
                axis = row.axes[j];
                axisOffset = axis.plotOffset;
                if (axis.rect.height === 0) {
                    axis.rect.height = row.computedHeight;
                    size = 0;
                    for (var k = i + 1, len_2 = i + axis.span; k < len_2; k++) {
                        definition = chart.rows[k];
                        size += definition.computedHeight;
                    }
                    axis.rect.y = (row.computedTop - size) + (axis.plotOffsetTop ? axis.plotOffsetTop : axisOffset);
                    axis.rect.height = (axis.rect.height + size) -
                        (this.getAxisOffsetValue(axis.plotOffsetTop, axis.plotOffsetBottom, axis.plotOffset));
                    axis.rect.width = 0;
                }
                if (axis.isAxisOpposedPosition) {
                    if (axis.labelPosition === 'Inside' && axis.orientation === 'Vertical') {
                        x = rect.x + rect.width - sum(subArray(row.insideFarSizes, farCount));
                    }
                    else {
                        x = rect.x + rect.width + sum(subArray(row.farSizes, farCount));
                    }
                    axis.rect.x = axis.rect.x >= x ? axis.rect.x : x;
                    farCount++;
                }
                else {
                    if (axis.labelPosition === 'Inside' && axis.orientation === 'Vertical') {
                        x = rect.x + sum(subArray(row.insideNearSizes, nearCount));
                    }
                    else {
                        x = rect.x - sum(subArray(row.nearSizes, nearCount));
                    }
                    axis.rect.x = axis.rect.x <= x ? axis.rect.x : x;
                    nearCount++;
                }
            }
        }
        this.calculateColumnSize(rect);
        for (var i = 0, len = chart.columns.length; i < len; i++) {
            column = chart.columns[i];
            nearCount = 0;
            farCount = 0;
            for (var j = 0, len_3 = column.axes.length; j < len_3; j++) {
                axis = column.axes[j];
                axisOffset = axis.plotOffset;
                if (axis.rect.width === 0) {
                    for (var k = i, len_4 = (i + axis.span); k < len_4; k++) {
                        definition = chart.columns[k];
                        axis.rect.width += definition.computedWidth;
                    }
                    axis.rect.x = column.computedLeft + (axis.plotOffsetLeft ? axis.plotOffsetLeft : axisOffset);
                    axis.rect.width -= (this.getAxisOffsetValue(axis.plotOffsetLeft, axis.plotOffsetRight, axis.plotOffset));
                    axis.rect.height = 0;
                }
                if (axis.isAxisOpposedPosition) {
                    if (axis.labelPosition === 'Inside' && axis.orientation === 'Horizontal') {
                        y = rect.y + sum(subArray(column.insideFarSizes, farCount));
                    }
                    else {
                        y = rect.y - sum(subArray(column.farSizes, farCount));
                    }
                    axis.rect.y = axis.rect.y <= y ? axis.rect.y : y;
                    farCount++;
                }
                else {
                    if (axis.labelPosition === 'Inside' && axis.orientation === 'Horizontal') {
                        y = rect.y + rect.height - sum(subArray(column.insideNearSizes, nearCount));
                    }
                    else {
                        y = rect.y + rect.height + sum(subArray(column.nearSizes, nearCount));
                    }
                    axis.rect.y = axis.rect.y >= y ? axis.rect.y : y;
                    nearCount++;
                }
            }
        }
    };
    /**
     * Measure the axis.
     *
     * @returns {void}
     * @private
     */
    CartesianAxisLayoutPanel.prototype.measure = function () {
        var chart = this.chart;
        var row;
        var column;
        var definition;
        var actualIndex;
        var span;
        for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {
            var axis = _a[_i];
            //definition.Axes = axis;
            if (axis.orientation === 'Vertical') {
                chart.verticalAxes.push(axis);
                actualIndex = this.getActualRow(axis);
                row = chart.rows[actualIndex];
                this.pushAxis(row, axis);
                span = ((actualIndex + axis.span) > chart.rows.length ? chart.rows.length : (actualIndex + axis.span));
                for (var j = actualIndex + 1; j < span; j++) {
                    definition = chart.rows[j];
                    definition.axes[row.axes.length - 1] = axis;
                    chart.rows[j] = definition;
                }
                chart.rows[actualIndex] = row;
            }
            else {
                chart.horizontalAxes.push(axis);
                actualIndex = this.getActualColumn(axis);
                column = chart.columns[actualIndex];
                this.pushAxis(column, axis);
                span = ((actualIndex + axis.span) > chart.columns.length ? chart.columns.length : (actualIndex + axis.span));
                for (var j = actualIndex + 1; j < span; j++) {
                    definition = chart.columns[j];
                    definition.axes[column.axes.length - 1] = axis;
                    chart.columns[j] = definition;
                }
                chart.columns[actualIndex] = column;
            }
            axis.isRTLEnabled = chart.enableRtl;
            axis.setIsInversedAndOpposedPosition();
        }
    };
    CartesianAxisLayoutPanel.prototype.getAxisOffsetValue = function (position1, position2, plotOffset) {
        var rangeOffset = position1 ? (position1 + (position2 ? position2 :
            plotOffset)) : (position2 ? position2 + plotOffset : 2 * plotOffset);
        return rangeOffset;
    };
    CartesianAxisLayoutPanel.prototype.crossAt = function (chart) {
        for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {
            var axis = _a[_i];
            if (axis.crossesAt === null) {
                continue;
            }
            if (!axis.crossesInAxis) {
                if (chart.requireInvertedAxis) {
                    axis.crossInAxis = ((axis.orientation === 'Horizontal')) ? chart.primaryXAxis : chart.primaryYAxis;
                }
                else {
                    axis.crossInAxis = ((axis.orientation === 'Horizontal')) ? chart.primaryYAxis : chart.primaryXAxis;
                }
                axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);
                continue;
            }
            else {
                for (var i = 2, len = chart.axisCollections.length; i < len; i++) {
                    if (axis.crossesInAxis === chart.axisCollections[i].name) {
                        axis.crossInAxis = chart.axisCollections[i];
                        axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);
                        continue;
                    }
                }
            }
        }
    };
    CartesianAxisLayoutPanel.prototype.updateCrossAt = function (axis, crossAt) {
        switch (axis.valueType) {
            case 'DateTime':
                var option = {
                    skeleton: 'full',
                    type: 'dateTime'
                };
                var dateParser = this.chart.intl.getDateParser(option);
                var dateFormatter = this.chart.intl.getDateFormat(option);
                return Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({ val: crossAt }).val))));
            case 'Category':
                return parseFloat(crossAt) ? parseFloat(crossAt) : axis.labels.indexOf(crossAt);
            case 'Logarithmic':
                return logBase(crossAt, axis.logBase);
            default:
                return crossAt;
        }
    };
    CartesianAxisLayoutPanel.prototype.pushAxis = function (definition, axis) {
        for (var i = 0, len = definition.axes.length; i <= len; i++) {
            if (!definition.axes[i]) {
                definition.axes[i] = axis;
                break;
            }
        }
    };
    CartesianAxisLayoutPanel.prototype.arrangeAxis = function (definition) {
        var axisCollection = [];
        for (var i = 0, len = definition.axes.length; i <= len; i++) {
            if (definition.axes[i]) {
                axisCollection.push(definition.axes[i]);
            }
        }
        definition.axes = axisCollection;
    };
    CartesianAxisLayoutPanel.prototype.getActualColumn = function (axis) {
        var actualLength = this.chart.columns.length;
        var pos = axis.columnIndex;
        var result = pos >= actualLength ? actualLength - 1 : (pos < 0 ? 0 : pos);
        return result;
    };
    CartesianAxisLayoutPanel.prototype.getActualRow = function (axis) {
        var actualLength = this.chart.rows.length;
        var pos = axis.rowIndex;
        var result = pos >= actualLength ? actualLength - 1 : (pos < 0 ? 0 : pos);
        return result;
    };
    /**
     * Measure the row size.
     *
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.calculateRowSize = function (rect) {
        /*! Calculate row size */
        var chart = this.chart;
        var row;
        var rowTop = rect.y + rect.height;
        var height = 0;
        var remainingHeight = Math.max(0, rect.height);
        for (var i = 0, len = chart.rows.length; i < len; i++) {
            row = chart.rows[i];
            if (row.height.indexOf('%') !== -1) {
                height = Math.min(remainingHeight, (rect.height * parseInt(row.height, 10) / 100));
            }
            else {
                height = Math.min(remainingHeight, parseInt(row.height, 10));
            }
            height = (i !== (len - 1)) ? height : remainingHeight;
            row.computedHeight = height;
            rowTop -= height;
            row.computedTop = rowTop;
            remainingHeight -= height;
        }
    };
    /**
     * Measure the row size.
     *
     * @param {Rect} rect rect
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.calculateColumnSize = function (rect) {
        /*! Calculate column size */
        var chart = this.chart;
        var column;
        var columnLeft = rect.x;
        var width = 0;
        var remainingWidth = Math.max(0, rect.width);
        for (var i = 0, len = chart.columns.length; i < len; i++) {
            column = chart.columns[i];
            if (column.width.indexOf('%') !== -1) {
                width = Math.min(remainingWidth, (rect.width * parseInt(column.width, 10) / 100));
            }
            else {
                width = Math.min(remainingWidth, parseInt(column.width, 10));
            }
            width = (i !== (len - 1)) ? width : remainingWidth;
            column.computedWidth = width;
            column.computedLeft = columnLeft;
            columnLeft += width;
            remainingWidth -= width;
        }
    };
    /**
     * To render the axis element.
     *
     * @returns {void}
     * @private
     */
    // tslint:disable-next-line:max-func-body-length
    CartesianAxisLayoutPanel.prototype.renderAxes = function () {
        var chart = this.chart;
        var axis;
        var axisElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisInsideCollection' });
        var axisLineElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisOutsideCollection' });
        if (axisLineElement) {
            axisLineElement.setAttribute('aria-hidden', 'true');
        }
        var outsideElement;
        var isInside;
        for (var i = 0, len = chart.axisCollections.length; i < len; i++) {
            var axisVisibility = true;
            axis = chart.axisCollections[i];
            this.element = chart.renderer.createGroup({ id: chart.element.id + 'AxisGroup' + i + 'Inside' });
            if (this.element) {
                this.element.setAttribute('aria-hidden', 'true');
            }
            outsideElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisGroup' + i + 'Outside' });
            if (outsideElement) {
                outsideElement.setAttribute('aria-hidden', 'true');
            }
            for (var _i = 0, _a = axis.series; _i < _a.length; _i++) {
                var series = _a[_i];
                if (axis.name === series.yAxisName || axis.name === series.xAxisName) {
                    axisVisibility = series.visible;
                    if (series.category === 'Pareto' && !series.paretoOptions.showAxis && series.type === 'Line') {
                        axisVisibility = false;
                    }
                    if (!axisVisibility) {
                        continue;
                    }
                    else {
                        break;
                    }
                }
            }
            if (!axisVisibility) {
                continue;
            }
            isInside = this.findAxisPosition(axis);
            if (axis.orientation === 'Horizontal') {
                axis.updateCrossValue();
                if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {
                    this.drawAxisLine(axis, i, axis.plotOffset, 0, 0, 0, axis.plotOffsetLeft, axis.plotOffsetRight, isInside ? outsideElement : this.element, axis.updatedRect);
                }
                if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0 || axis.minorTickLines.width > 0 || axis.minorGridLines.width > 0) {
                    this.drawXAxisGridLine(axis, i, (isInside || axis.tickPosition === 'Inside') ? outsideElement : this.element, axis.updatedRect);
                }
                if (axis.visible && axis.internalVisibility) {
                    this.drawXAxisLabels(axis, i, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));
                    this.drawXAxisBorder(axis, i, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));
                    this.drawXAxisTitle(axis, i, isInside ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));
                }
            }
            else {
                axis.updateCrossValue();
                if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {
                    this.drawAxisLine(axis, i, 0, axis.plotOffset, axis.plotOffsetBottom, axis.plotOffsetTop, 0, 0, isInside ? outsideElement : this.element, axis.updatedRect);
                }
                if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0 || axis.minorTickLines.width > 0 || axis.minorGridLines.width > 0) {
                    this.drawYAxisGridLine(axis, i, (isInside || axis.tickPosition === 'Inside') ? outsideElement : this.element, axis.updatedRect);
                }
                if (axis.visible && axis.internalVisibility) {
                    this.drawYAxisLabels(axis, i, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));
                    this.drawYAxisBorder(axis, i, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));
                    this.drawYAxisTitle(axis, i, isInside ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));
                }
            }
            if (!this.chart.enableCanvas) {
                axisElement.appendChild(this.element);
                if (outsideElement && outsideElement.childNodes.length > 0) {
                    axisLineElement.appendChild(outsideElement);
                }
            }
            if (chart.scrollBarModule && ((chart.zoomSettings.enableScrollbar && axis.enableScrollbarOnZooming) ||
                axis.scrollbarSettings.enable)) {
                this.renderScrollbar(chart, axis);
            }
        }
        this.element = chart.renderer.createGroup({ id: chart.element.id + 'DefinitionLine' });
        for (var j = 0, len = chart.rows.length; j < len; j++) {
            var row = chart.rows[j];
            if (row.border.color) {
                this.drawBottomLine(row, j, true);
            }
        }
        for (var j = 0, len = chart.columns.length; j < len; j++) {
            var column = chart.columns[j];
            if (column.border.color) {
                this.drawBottomLine(column, j, false);
            }
        }
        if (!this.chart.enableCanvas) {
            axisElement.appendChild(this.element);
        }
        appendChildElement(chart.enableCanvas, chart.svgObject, axisElement, chart.redraw);
        return axisLineElement;
    };
    /**
     * To render the axis scrollbar
     *
     * @param {Chart} chart chart
     * @param {Axis} axis axis
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.renderScrollbar = function (chart, axis) {
        var isZoomed = isNullOrUndefined(chart.zoomModule) ? false : chart.zoomModule.isZoomed;
        if (((isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0)) || (axis.scrollbarSettings.enable &&
            (axis.zoomFactor <= 1 || axis.zoomPosition >= 0))) &&
            (!axis.zoomingScrollBar.isScrollUI)) {
            if (!chart.scrollElement) {
                chart.scrollElement = redrawElement(chart.redraw, chart.element.id + '_scrollElement') || createElement('div', { id: chart.element.id + '_scrollElement' });
            }
            appendChildElement(false, chart.scrollElement, axis.zoomingScrollBar.render(true), true);
        }
        else if (axis.zoomFactor === 1 && axis.zoomPosition === 0 && axis.zoomingScrollBar.svgObject && !axis.scrollbarSettings.enable) {
            axis.zoomingScrollBar.destroy();
        }
        else if (axis.zoomingScrollBar.svgObject) {
            axis.zoomingScrollBar.svgObject.style.top = (axis.isAxisOpposedPosition && axis.orientation === 'Horizontal' ? -16 : 0)
                + axis.rect.y + Math.max(0.5, axis.lineStyle.width / 2) + 'px';
            axis.zoomingScrollBar.svgObject.style.left = (axis.isAxisOpposedPosition && axis.orientation !== 'Horizontal' ? 16 : 0)
                + axis.rect.x - (axis.orientation === 'Vertical' ? axis.scrollbarSettings.height : 0) + 'px';
        }
        if (axis.zoomingScrollBar.isScrollUI) {
            axis.zoomingScrollBar.isScrollUI = false;
        }
    };
    /**
     * To find the axis position
     *
     * @param {Axis} axis axis
     * @returns {boolean} axis position
     */
    CartesianAxisLayoutPanel.prototype.findAxisPosition = function (axis) {
        return axis.crossAt !== null && axis.isInside(axis.crossInAxis.visibleRange);
    };
    /**
     * To render the bootom line of the columns and rows
     *
     * @param {Row | Column} definition definition
     * @param {number} index index
     * @param {boolean} isRow isRow
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.drawBottomLine = function (definition, index, isRow) {
        var chart = this.chart;
        var optionsLine = {};
        var x1;
        var x2;
        var y1;
        var y2;
        var definitionName;
        if (isRow) {
            definition = definition;
            y1 = y2 = definition.computedTop + definition.computedHeight;
            x1 = this.seriesClipRect.x;
            x2 = x1 + this.seriesClipRect.width;
            definitionName = 'Row';
        }
        else {
            definition = definition;
            x1 = x2 = definition.computedLeft;
            y1 = this.seriesClipRect.y;
            y2 = y1 + this.seriesClipRect.height;
            definitionName = 'Column';
        }
        optionsLine = {
            'id': chart.element.id + '_AxisBottom_' + definitionName + index,
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2,
            'stroke-width': definition.border.width,
            'stroke': definition.border.color
        };
        this.htmlObject = chart.renderer.drawLine(optionsLine);
        this.element.appendChild(this.htmlObject);
    };
    /**
     * To render the axis line
     *
     * @param {Axis} axis axis
     * @param {number} index index
     * @param {number} plotX plotX
     * @param {number} plotY plotY
     * @param {Element} parent parent
     * @param {Rect} rect rect
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.drawAxisLine = function (axis, index, plotX, plotY, plotBottom, plotTop, plotLeft, plotRight, parent, rect) {
        var chart = this.chart;
        var optionsLine = {};
        var element = getElement$1(chart.element.id + 'AxisLine_' + index);
        var direction = element ? element.getAttribute('d') : '';
        element = null;
        optionsLine = {
            'id': chart.element.id + 'AxisLine_' + index,
            'd': 'M ' + (rect.x - plotX - plotLeft) + ' ' + (rect.y - plotY - plotTop) +
                ' L ' + (rect.x + rect.width + plotX + plotRight) + ' ' + (rect.y + rect.height + plotY + plotBottom),
            'stroke-dasharray': axis.lineStyle.dashArray,
            'stroke-width': axis.lineStyle.width,
            'stroke': axis.lineStyle.color || chart.themeStyle.axisLine
        };
        this.htmlObject = chart.renderer.drawPath(optionsLine);
        appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction);
    };
    /**
     * To render the yAxis grid line
     *
     * @param {Axis} axis axis
     * @param {number} index index
     * @param {Element} parent parent
     * @param {Rect} rect rect
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.drawYAxisGridLine = function (axis, index, parent, rect) {
        var isLogAxis = axis.valueType === 'Logarithmic';
        var isCategoryAxis = axis.valueType.indexOf('Category') > -1;
        var tempInterval;
        var pointY = 0;
        var majorGrid = '';
        var majorTick = '';
        var minorGridDirection;
        var isOpposed = axis.isAxisOpposedPosition;
        var tickSize = isOpposed ? axis.majorTickLines.height : -axis.majorTickLines.height;
        var axisLineSize = (isOpposed) ? axis.lineStyle.width * 0.5 : -axis.lineStyle.width * 0.5;
        var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ?
            0.5 : 0;
        var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? isOpposed ? axis.scrollBarHeight :
            -axis.scrollBarHeight : 0;
        var isTickInside = axis.tickPosition === 'Inside';
        var ticks = isTickInside ? (rect.x - tickSize - axisLineSize) : (rect.x + tickSize + axisLineSize + scrollBarHeight);
        var length = axis.visibleLabels.length;
        var chartThemeStyle = this.chart.themeStyle;
        if (axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks' && length > 0 && !this.chart.stockChart) {
            length += 1;
        }
        var minorGridLines = axis.minorGridLines;
        var minorTickLines = axis.minorTickLines;
        //Gridlines
        for (var i = 0; i < length; i++) {
            tempInterval = !axis.visibleLabels[i] ? (axis.visibleLabels[i - 1].value + axis.visibleRange.interval) - ticksbwtLabel
                : axis.visibleLabels[i].value - ticksbwtLabel;
            pointY = valueToCoefficient(tempInterval, axis) * rect.height;
            pointY = (pointY * -1) + (rect.y + rect.height);
            if (pointY >= rect.y && (rect.y + rect.height) >= pointY) {
                if ((inside(tempInterval, axis.visibleRange)) || this.isBorder(axis, i, pointY)) {
                    majorGrid = 'M ' + this.seriesClipRect.x + ' ' + (pointY) +
                        ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + pointY;
                    this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray);
                }
                majorTick = 'M ' + (rect.x + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + ' ' + pointY +
                    ' L ' + (ticks) + ' ' + pointY;
                this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine);
                if ((minorGridLines.width > 0 || minorTickLines.width > 0) && axis.minorTicksPerInterval > 0) {
                    if (i === 0 && isZoomSet(axis) && !isLogAxis && !isCategoryAxis) {
                        this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);
                    }
                    minorGridDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);
                    this.renderGridLine(axis, index, minorGridDirection[0], minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, minorGridLines.dashArray);
                    this.renderGridLine(axis, index, minorGridDirection[1], minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine);
                    if (i === length - 1 && isZoomSet(axis) && isLogAxis && !isCategoryAxis) {
                        this.renderMinorGridOnZooming(axis, (tempInterval + axis.visibleRange.interval), rect, i, index, chartThemeStyle, parent);
                    }
                }
            }
        }
    };
    /**
     * To check the border of the axis
     *
     * @param {Axis} axis axis
     * @param {number} index index
     * @param {number} value value
     * @returns {boolean} check the border of the axis
     */
    CartesianAxisLayoutPanel.prototype.isBorder = function (axis, index, value) {
        var border = this.chart.chartArea.border;
        var rect = this.seriesClipRect;
        var orientation = axis.orientation;
        var start = (orientation === 'Horizontal') ? rect.x : rect.y;
        var size = (orientation === 'Horizontal') ? rect.width : rect.height;
        var startIndex = (orientation === 'Horizontal') ? 0 : axis.visibleLabels.length - 1;
        var endIndex = (orientation === 'Horizontal') ? axis.visibleLabels.length - 1 : 0;
        if (axis.plotOffset > 0) {
            return true;
        }
        else if ((value === start || value === (start + size)) && (border.width <= 0 || border.color === 'transparent')) {
            return true;
        }
        else if ((value !== start && index === startIndex) || (value !== (start + size) && index === endIndex)) {
            return true;
        }
        return false;
    };
    /**
     * To render the yAxis label
     *
     * @param {Axis} axis axis
     * @param {number} index index
     * @param {Element} parent parent
     * @param {Rect} rect rect
     * @returns {void}
     * @private
     */
    CartesianAxisLayoutPanel.prototype.drawYAxisLabels = function (axis, index, parent, rect) {
        var chart = this.chart;
        var label;
        var pointX = 0;
        var pointY = 0;
        var elementSize;
        var labelSpace = axis.labelPadding;
        var options;
        var isAxisBreakLabel;
        var isLabelInside = axis.labelPosition === 'Inside';
        var isOpposed = axis.isAxisOpposedPosition;
        var RotatedWidth;
        var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;
        var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;
        var angle = axis.angle % 360;
        var isVerticalAngle = (angle === -90 || angle === 90 || angle === 270 || angle === -270);
        padding += (isVerticalAngle) ? (isLabelInside ? 5 : -5) : 0;
        padding = (isOpposed) ? padding : -padding;
        var labelElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisLabels' + index });
        var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight * (isOpposed ? 1 : -1) : 0;
        var textHeight;
        var textPadding;
        var maxLineWidth;
        var pixel = 10;
        var isInverse = axis.isAxisInverse;
        var previousEnd = isInverse ? rect.y : (rect.y + rect.height);
        var labelPadding;
        var intervalLength;
        var labelHeight;
        var yAxisLabelX;
        var isLabelOnAxisLineLeft = ((!isOpposed && !isLabelInside) || (isOpposed && isLabelInside));
        if (isLabelInside) {
            labelPadding = !isLabelOnAxisLineLeft ? -padding : padding;
        }
        else {
            labelPadding = !isLabelOnAxisLineLeft ? -padding + (chart.enableRtl ? -scrollBarHeight : scrollBarHeight) : padding + (chart.enableRtl ? -scrollBarHeight : scrollBarHeight);
        }
        var sizeWidth = [];
        var breakLabelSizeWidth = [];
        axis.visibleLabels.map(function (item) {
            sizeWidth.push(item.size['width']);
            breakLabelSizeWidth.push(item.breakLabelSize['width']);
        });
        var LabelMaxWidth = Math.max.apply(Math, sizeWidth);
        var breakLabelMaxWidth = Math.max.apply(Math, breakLabelSizeWidth);
        RotatedWidth = LabelMaxWidth;
        if (angle >= -45 && angle <= 45 && angle !== 0) {
            RotatedWidth = LabelMaxWidth * Math.cos(angle * Math.PI / 180);
            if (RotatedWidth < 0) {
                RotatedWidth = -RotatedWidth;
            }
        }
        for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {
            label = axis.visibleLabels[i];
            isAxisBreakLabel = isBreakLabel(axis.visibleLabels[i].originalText);
            elementSize = isAxisBreakLabel ? axis.visibleLabels[i].breakLabelSize : axis.visibleLabels[i].size;
            pointY = (valueToCoefficient(axis.visibleLabels[i].value, axis) * rect.height) + (chart.stockChart ? 7 : 0);
            pointY = Math.floor((pointY * -1) + (rect.y + rect.height));
            textHeight = ((elementSize.height / 8) * axis.visibleLabels[i].text.length / 2);
            textPadding = (chart.requireInvertedAxis && axis.labelPosition === 'Inside') ? 0 : ((elementSize.height / 4) * 3) + 3;
            intervalLength = rect.height / axis.visibleLabels.length;
            labelHeight = ((axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle !== 0 &&
                elementSize.width > intervalLength) ? intervalLength : elementSize.width;
            pointY = (isAxisBreakLabel ? (axis.labelPosition === 'Inside' ? (pointY - (elementSize.height / 2) - textHeight + textPadding)
                : (pointY - textHeight)) : (axis.labelPosition === 'Inside' ? pointY + textPadding : pointY));
            if (axis.labelPosition === 'Inside' && ((i === 0 && !axis.isInversed) || (i === len - 1 && axis.isInversed))) {
                if (chart.stockChart) {
                    pointY -= (textPadding);
                }
                else {
                    pointY -= (textPadding - ((chart.requireInvertedAxis && axis.labelPosition === 'Inside') ? 0 : (axis.opposedPosition ? -padding : padding)));
                }
            }
            if (axis.majorGridLines.width > axis.majorTickLines.width) {
                maxLineWidth = axis.majorGridLines.width;
            }
            else {
                maxLineWidth = axis.majorTickLines.width;
            }
            if (axis.labelStyle.textAlignment === 'Far') {
                pointY = pointY - maxLineWidth - pixel;
            }
            else if (axis.labelStyle.textAlignment === 'Near') {
                pointY = pointY + maxLineWidth + pixel;
            }
            else if (axis.labelStyle.textAlignment === 'Center') {
                // eslint-disable-next-line no-self-assign
                pointY = pointY;
            }
            // label X value adjustment (Start)
            if (isLabelInside) {
                yAxisLabelX = labelPadding + ((angle === 0 ? elementSize.width : (isAxisBreakLabel ? breakLabelMaxWidth : LabelMaxWidth)) / 2);
            }
            else {
                yAxisLabelX = labelPadding - ((angle === 0 ? elementSize.width : (isAxisBreakLabel ? breakLabelMaxWidth : RotatedWidth)) / 2);
            }
            pointX = isOpposed ? (rect.x - yAxisLabelX) : (rect.x + yAxisLabelX);
            if (isVerticalAngle) {
                pointX += (isOpposed) ? -10 : 10;
            }
            yAxisLabelX = labelPadding;
            options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, 'middle', label.text, '', 'middle', angle);
            switch (axis.edgeLabelPlacement) {
                case 'None':
                    break;
                case 'Hide':
                    if (((i === 0 || (isInverse && i === len - 1)) && options.y > rect.y) ||
                        (((i === len - 1) || (isInverse && i === 0)) && options.y - elementSize.height * 0.5 < rect.y)) {
                        options.text = '';
                    }
                    break;
                case 'Shift':
                    if ((i === 0 || (isInverse && i === len - 1)) && options.y > rect.y + rect.height) {
                        options.y = pointY = rect.y + rect.height;
                    }
                    else if (((i === len - 1) || (isInverse && i === 0)) && (options.y < rect.y)) {
                        options.y = pointY = rect.y + elementSize.height * 0.5;
                    }
                    break;
            }
            // ------- Hide Calculation (Start) -------------
            var previousYValue = options.y;
            var currentYValue = options.y - labelHeight;
            if (isAxisBreakLabel) {
                previousYValue = (options.y - (labelHeight / 2));
                currentYValue = options.y + (labelHeight / 2);
            }
            if ((angle === 90 || angle === 270) && axis.labelIntersectAction === 'Hide' && i !== 0 &&
                (!isInverse ? previousYValue >= previousEnd : currentYValue <= previousEnd)) {
                continue;
            }
            previousEnd = isInverse ? previousYValue : currentYValue;
            // ------- Hide Calculation (End) -------------
            options.transform = 'rotate(' + angle + ',' + pointX + ',' + pointY + ')';
            textElement$1(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, false, chart.redraw, true, true, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisLabelFont);
        }
        if (!this.chart.enableCanvas) {
            if (!chart.delayRedraw) {
                appendChildElement(chart.enableCanvas, parent, labelElement, chart.redraw);
            }
            else if (axis.visible && axis.internalVisibility) {
                this.createZoomingLabel(this.chart, labelElement, axis, index, rect);
            }
        }
    };
    /**
     * To get X value based on lineBreakAlignment for Y axis line break labels only.
     *
     * @param {number} x text x position
     * @param {Axis} axis y axis values
     * @param {number} textWidth axis label width
     * @returns {number} returns suitable axis label x position
     */
    CartesianAxisLayoutPanel.prototype.getAxisLabelXvalue = function (x, axis, textWidth) {
        var anchor = axis.lineBreakAlignment;
        var isLabelInside = axis.labelPosition === 'Inside';
        var isOpposed = axis.isAxisOpposedPosition;
        if ((isOpposed && isLabelInside) || (!isOpposed && !isLabelInside)) {
            return (anchor === 'Right' ? x : (anchor === 'Center' ? (x - textWidth / 2) : (x - textWidth)));
        }
        else {
            return (anchor === 'Left' ? x : (anchor === 'Center' ? (x + textWidth / 2) : (x + textWidth)));
        }
    };
    /**
     * To render the yAxis label border.
     *
     * @param {Axis} axis axis
     * @param {number} index index
     * @param {Element} parent parent
     * @param {Rect} rect rect
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.drawYAxisBorder = function (axis, index, parent, rect) {
        if (axis.border.width > 0) {
            var startY = void 0;
            var pointY = void 0;
            var scrollBarHeight = axis.labelPosition === 'Outside' ? axis.scrollBarHeight : 0;
            var isOpposed = axis.isAxisOpposedPosition;
            scrollBarHeight = (isOpposed ? 1 : -1) * scrollBarHeight;
            var gap = (rect.height / axis.visibleRange.delta) * (axis.valueType === 'DateTime' ? axis.dateTimeInterval
                : axis.visibleRange.interval);
            var endY = void 0;
            var length_1 = axis.maxLabelSize.width + 10 + ((axis.tickPosition === axis.labelPosition) ?
                axis.majorTickLines.height : 0);
            var labelBorder = '';
            var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ? -0.5 : 0;
            var endX = ((isOpposed && axis.labelPosition === 'Inside') || (!isOpposed
                && axis.labelPosition === 'Outside')) ? rect.x - length_1 + scrollBarHeight : rect.x + length_1 + scrollBarHeight;
            for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {
                pointY = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);
                pointY = (axis.isAxisInverse ? (1 - pointY) : pointY) * rect.height;
                if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {
                    startY = (pointY * -1) + (rect.y + rect.height);
                    endY = (pointY * -1) - (gap) + (rect.y + rect.height);
                }
                else {
                    startY = (pointY * -1) + gap / 2 + (rect.y + rect.height);
                    endY = (pointY * -1) - gap / 2 + (rect.y + rect.height);
                }
                switch (axis.border.type) {
                    case 'Rectangle':
                    case 'WithoutTopBorder':
                        if (startY > (rect.y + rect.height)) {
                            labelBorder += ('M' + ' ' + endX + ' ' + (rect.y + rect.height) + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');
                        }
                        else if (Math.floor(rect.y) > (endY)) {
                            labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX
                                + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + (rect.y) + ' ');
                        }
                        else {
                            labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX +
                                ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');
                            if (i === axis.visibleLabels.length - 1) {
                                labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY + ' ' + 'L' + ' ' +
                                    endX + ' ' + endY + ' ');
                            }
                        }
                        break;
                    case 'WithoutTopandBottomBorder':
                        if (!(startY > rect.y + rect.height) && !((endY) < Math.floor(rect.y))) {
                            labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX +
                                ' ' + startY + ' ' + 'M' + ' ' + endX + ' ' + endY + ' ' +
                                'L' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY);
                        }
                        break;
                }
            }
            labelBorder += (axis.border.type === 'Rectangle') ? ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + rect.y + ' ' + 'L' + ' ' +
                (rect.x + scrollBarHeight) + ' ' + (rect.y + rect.height) + ' ') : '';
            if (labelBorder !== '') {
                this.createAxisBorderElement(axis, index, labelBorder, parent);
            }
        }
        for (var i = 0; i < this.chart.visibleSeries.length; i++) {
            if (axis.multiLevelLabels.length > 0 && this.chart.multiLevelLabelModule && this.chart.visibleSeries[i].visible) {
                this.chart.multiLevelLabelModule.renderYAxisMultiLevelLabels(axis, index, parent, rect);
                break;
            }
        }
    };
    /**
     * To render the yAxis title
     *
     * @param {Axis} axis axis
     * @param {number} index index
     * @param {Element} parent parent
     * @param {Rect} rect rect
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.drawYAxisTitle = function (axis, index, parent, rect) {
        if (axis.title) {
            var chart = this.chart;
            var isRotated = false;
            var isOpposed = axis.isAxisOpposedPosition;
            var labelRotation = (axis.titleRotation == null ? (isOpposed ? 90 : -90) : axis.titleRotation) % 360;
            var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + axis.titlePadding) +
                (axis.labelPosition === 'Inside' ? 0 :
                    (axis.maxLabelSize.width + axis.multiLevelLabelHeight + this.padding));
            padding = isOpposed ? padding + axis.scrollBarHeight : -padding - axis.scrollBarHeight;
            if ((labelRotation !== -90 && !isOpposed) || (labelRotation !== 90 && isOpposed)) {
                padding += axis.isAxisOpposedPosition ? axis.titleSize.width / 2 + axis.labelPadding : -axis.titleSize.width / 2 - axis.labelPadding;
                isRotated = true;
            }
            var x = rect.x + padding;
            var y = void 0;
            var anchor = void 0;
            if (axis.titleStyle.textAlignment === 'Center') {
                anchor = 'middle';
                y = rect.y + rect.height * 0.5;
            }
            else if (axis.titleStyle.textAlignment === 'Near') {
                anchor = axis.opposedPosition ? 'end' : 'start';
                y = rect.height + rect.y;
            }
            else {
                anchor = axis.opposedPosition ? 'start' : 'end';
                y = rect.y;
            }
            var titleSize = (axis.titleSize.height * (axis.titleCollection.length - 1));
            var options = new TextOption(chart.element.id + '_AxisTitle_' + index, x, y + (isRotated ? -titleSize : -axis.labelPadding - titleSize), anchor, axis.titleCollection, 'rotate(' + labelRotation + ',' + (x) + ',' + (y) + ')', null, labelRotation);
            var element = textElement$1(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitleFont.color, parent, null, null, null, null, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisTitleFont);
            element.setAttribute('aria-hidden', 'true');
        }
    };
    /**
     * xAxis grid line calculation performed here
     *
     * @param {Axis} axis axis
     * @param {number} index index
     * @param {Element} parent parent
     * @param {Rect} rect rect
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.drawXAxisGridLine = function (axis, index, parent, rect) {
        var isLogAxis = axis.valueType === 'Logarithmic';
        var isCategoryAxis = axis.valueType.indexOf('Category') > -1;
        var tempInterval;
        var pointX = 0;
        var majorGrid = '';
        var majorTick = '';
        var minorDirection;
        var isOpposed = axis.isAxisOpposedPosition;
        var tickSize = (isOpposed) ? -axis.majorTickLines.height : axis.majorTickLines.height;
        var axisLineSize = (isOpposed) ? -axis.lineStyle.width * 0.5 : axis.lineStyle.width * 0.5;
        var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? isOpposed ? -axis.scrollBarHeight :
            axis.scrollBarHeight : 0;
        var ticksbwtLabel = (axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks' && !this.chart.stockChart) ?
            0.5 : 0;
        var length = axis.visibleLabels.length;
        var isTickInside = axis.tickPosition === 'Inside';
        var ticks = isTickInside ? (rect.y - tickSize - axisLineSize) : (rect.y + tickSize + axisLineSize + scrollBarHeight);
        var chartThemeStyle = this.chart.themeStyle;
        if (axis.valueType.indexOf('Category') > -1 && length > 0 && axis.labelPlacement === 'BetweenTicks' && !this.chart.stockChart) {
            length += 1;
        }
        //Gridlines
        for (var i = 0; i < length; i++) {
            if (axis.valueType !== 'DateTimeCategory') {
                tempInterval = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel
                    : (axis.visibleLabels[i - 1].value + axis.visibleRange.interval) - ticksbwtLabel;
            }
            else {
                tempInterval = axis.visibleLabels[i] ?
                    axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleRange.max;
            }
            pointX = (valueToCoefficient(tempInterval, axis) * rect.width) + rect.x;
            if (pointX >= rect.x && (rect.x + rect.width) >= pointX) {
                if (inside(tempInterval, axis.visibleRange) || this.isBorder(axis, i, pointX)) {
                    majorGrid = 'M ' + pointX + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height) +
                        ' L ' + pointX + ' ' + this.seriesClipRect.y;
                    this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray);
                }
                majorTick = 'M ' + (pointX) + ' ' + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0))
                    + ' L ' + (pointX) + ' ' + ticks;
                this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine);
                if (axis.minorTicksPerInterval > 0 && (axis.minorGridLines.width > 0 || axis.minorTickLines.width > 0)) {
                    if (i === 0 && isZoomSet(axis) && !isLogAxis && !isCategoryAxis) {
                        this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);
                    }
                    minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);
                    this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray);
                    this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine);
                    if (i === length - 1 && isZoomSet(axis) && isLogAxis && !isCategoryAxis) {
                        this.renderMinorGridOnZooming(axis, (tempInterval + axis.visibleRange.interval), rect, i, index, chartThemeStyle, parent);
                    }
                }
            }
        }
    };
    /**
     * To render missing minor grid lines while zooming
     *
     * @param {Axis} axis axis
     * @param {number} tempInterval tempInterval
     * @param {Rect} rect rect
     * @param {number} i i
     * @param {number} index index
     * @param {IThemeStyle} chartThemeStyle chartThemeStyle
     * @param {Element} parent parent
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.renderMinorGridOnZooming = function (axis, tempInterval, rect, i, index, chartThemeStyle, parent) {
        var minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i, true);
        this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', -1, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray);
        this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', -1, parent, chartThemeStyle.minorTickLine);
    };
    /**
     * To calcualte the axis minor line
     *
     * @param {Axis} axis axis
     * @param {number} tempInterval tempInterval
     * @param {Rect} rect rect
     * @param {number} labelIndex labelIndex
     * @param {boolean} isFirstLabel isFirstLabel
     * @returns {string[]} axis minor line path
     */
    CartesianAxisLayoutPanel.prototype.drawAxisMinorLine = function (axis, tempInterval, rect, labelIndex, isFirstLabel) {
        var value = tempInterval;
        var coor = 0;
        var position = 0;
        var range = axis.visibleRange;
        var isTickInside = axis.tickPosition === 'Inside';
        var direction = [];
        var tickSize = axis.isAxisOpposedPosition ? -axis.minorTickLines.height : axis.minorTickLines.height;
        var logStart;
        var logEnd;
        var logInterval = 1;
        var logPosition = 1;
        var ticksX = isTickInside ? (rect.y - tickSize) : (rect.y + tickSize);
        var ticksY = isTickInside ? (rect.x + tickSize) : (rect.x - tickSize);
        var minorGird = '';
        var minorTick = '';
        var isInverse = axis.isAxisInverse;
        if (axis.valueType === 'Logarithmic') {
            logStart = Math.pow(axis.logBase, value - range.interval);
            logEnd = Math.pow(axis.logBase, value);
            logInterval = (logEnd - logStart) / (axis.minorTicksPerInterval + 1);
            logPosition = logStart + logInterval;
        }
        if (axis.orientation === 'Horizontal') {
            for (var j = 0; j < axis.minorTicksPerInterval; j++) {
                value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);
                logPosition += logInterval;
                if (inside(value, range)) {
                    position = ((value - range.min) / (range.max - range.min));
                    position = Math.ceil((isInverse ? (1 - position) : position) * rect.width);
                    coor = (Math.floor(position + rect.x));
                    minorGird = minorGird.concat('M' + ' ' + coor + ' ' + (this.seriesClipRect.y)
                        + 'L ' + coor + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height));
                    coor = (Math.floor(position + rect.x));
                    minorTick = minorTick.concat('M' + ' ' + coor + ' ' + (rect.y)
                        + 'L ' + coor + ' ' + (ticksX + axis.scrollBarHeight));
                }
            }
        }
        else {
            for (var j = 0; j < axis.minorTicksPerInterval; j++) {
                value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);
                if (inside(value, range)) {
                    position = ((value - range.min) / (range.max - range.min));
                    position = Math.ceil(((isInverse ? (1 - position) : position)) * rect.height) * -1; // For inversed axis
                    coor = (Math.floor(position + rect.y + rect.height));
                    minorGird = minorGird.concat('M' + ' ' + (this.seriesClipRect.x) + ' ' + coor
                        + 'L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + coor + ' ');
                    coor = (Math.floor(position + rect.y + rect.height));
                    minorTick = minorTick.concat('M' + ' ' + rect.x + ' ' + coor + 'L ' + (ticksY - axis.scrollBarHeight) +
                        ' ' + coor + ' ');
                }
                logPosition += logInterval;
            }
        }
        direction.push(minorGird);
        direction.push(minorTick);
        return direction;
    };
    /**
     * To find the numeric value of the log
     *
     * @param {Axis} axis axis
     * @param {number} logPosition logPosition
     * @param {number} value value
     * @param {number} labelIndex labelIndex
     * @param {boolean} isFirstLabel isFirstLabel
     * @returns {number} value
     */
    CartesianAxisLayoutPanel.prototype.findLogNumeric = function (axis, logPosition, value, labelIndex, isFirstLabel) {
        var range = axis.visibleRange;
        var tempValue;
        if (axis.valueType === 'Logarithmic') {
            value = logBase(logPosition, axis.logBase);
        }
        else if (axis.valueType === 'DateTime') {
            tempValue = axis.dateTimeInterval / (axis.minorTicksPerInterval + 1);
            value = isFirstLabel ? (value - tempValue) : (value + tempValue);
        }
        else if (axis.valueType === 'DateTimeCategory') {
            var padding = axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;
            value += ((axis.visibleLabels[labelIndex + 1] ?
                axis.visibleLabels[labelIndex + 1].value - padding : axis.visibleRange.max) -
                (axis.visibleLabels[labelIndex] ?
                    axis.visibleLabels[labelIndex].value - padding : axis.visibleRange.min)) /
                (axis.minorTicksPerInterval + 1);
        }
        else {
            tempValue = range.interval / (axis.minorTicksPerInterval + 1);
            value = isFirstLabel ? (value - tempValue) : (value + tempValue);
        }
        return value;
    };
    /**
     * To render the xAxis Labels
     *
     * @param {Axis} axis axis
     * @param {number} index index
     * @param {Element} parent parent
     * @param {Rect} rect rect
     * @returns {void}
     * @private
     */
    CartesianAxisLayoutPanel.prototype.drawXAxisLabels = function (axis, index, parent, rect) {
        var chart = this.chart;
        var pointX = 0;
        var pointY = 0;
        var labelSpace = axis.labelPadding;
        var labelHeight;
        var elementSize;
        var labelPadding;
        var anchor;
        var pixel = 10;
        var labelElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisLabels' + index });
        var islabelInside = axis.labelPosition === 'Inside';
        var isOpposed = axis.isAxisOpposedPosition;
        var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;
        var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;
        var angle = axis.angle % 360;
        var isHorizontalAngle = (angle === 0 || angle === -180 || angle === 180);
        var options;
        var labelWidth;
        var isInverse = axis.isAxisInverse;
        var isLeft;
        var previousEnd = isInverse ? (rect.x + rect.width) : rect.x;
        var width = 0;
        var length = axis.visibleLabels.length;
        var intervalLength;
        var label;
        var isAxisBreakLabel;
        var scrollBarHeight = axis.scrollbarSettings.enable || (!islabelInside && isNullOrUndefined(axis.crossesAt)
            && (axis.zoomFactor < 1 || axis.zoomPosition > 0)) ? axis.scrollBarHeight : 0;
        var newPoints = [];
        var isRotatedLabelIntersect = false;
        var textPoints = [];
        var rotatedLabelSize = new Size(0, 0);
        padding += (angle === 90 || angle === 270 || angle === -90 || angle === -270) ? (islabelInside ? 5 : -5) : 0;
        var isLabelUnderAxisLine = ((!isOpposed && !islabelInside) || (isOpposed && islabelInside));
        var isEndAnchor = isLabelUnderAxisLine ?
            ((360 >= angle && angle >= 180) || (-1 >= angle && angle >= -180)) :
            ((1 <= angle && angle <= 180) || (-181 >= angle && angle >= -360));
        for (var i = 0, len = length; i < len; i++) {
            label = axis.visibleLabels[i];
            isAxisBreakLabel = isBreakLabel(label.originalText) || (axis.labelIntersectAction === 'Wrap' && label.text.length > 1);
            pointX = (valueToCoefficient(label.value, axis) * rect.width) + rect.x;
            elementSize = label.size;
            intervalLength = rect.width / length;
            labelWidth = isAxisBreakLabel ? label.breakLabelSize.width : elementSize.width;
            width = ((axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle === 0 &&
                labelWidth > intervalLength) ? intervalLength : labelWidth;
            labelHeight = elementSize.height / 4;
            pointX -= (isAxisBreakLabel || angle !== 0) ? 0 : (width / 2);
            // label X value adjustment for label rotation (Start)
            if (angle !== 0) {
                if (isAxisBreakLabel) {
                    pointX -= axis.lineBreakAlignment === 'Left' ? (label.breakLabelSize.width / 2) : axis.lineBreakAlignment === 'Right' ?
                        -(label.breakLabelSize.width / 2) : 0;
                }
                else {
                    pointX -= (angle === -90 || angle === 270 ? -labelHeight : (angle === 90 || angle === -270) ? labelHeight : 0);
                }
            }
            // label X value adjustment for label rotation (End)
            if (axis.labelStyle.textAlignment === 'Far') {
                pointX = pointX + width - pixel;
            }
            else if (axis.labelStyle.textAlignment === 'Near') {
                pointX = pointX - width + pixel;
            }
            else if (axis.labelStyle.textAlignment === 'Center') {
                // eslint-disable-next-line no-self-assign
                pointX = pointX;
            }
            // For line break label alignment like left, right & center in angle 0
            if (isAxisBreakLabel && axis.lineBreakAlignment !== 'Center' && angle === 0) {
                pointX += axis.lineBreakAlignment === 'Left' ? -(width / 2) : (width / 2);
            }
            var paddingForBreakLabel = isAxisBreakLabel ?
                (isHorizontalAngle ? (axis.opposedPosition || islabelInside ? 0 : elementSize.height) : (label.breakLabelSize.width / 2)) : 0;
            padding = isAxisBreakLabel ? (tickSpace + labelSpace + axis.lineStyle.width * 0.5) : padding;
            // label Y value adjustment (Start)
            if (islabelInside && angle) {
                if (isAxisBreakLabel) {
                    pointY = isOpposed ? (rect.y + padding + (paddingForBreakLabel)) : (rect.y - padding - (paddingForBreakLabel));
                }
                else {
                    pointY = isOpposed ? (rect.y + padding + labelHeight) : (rect.y - padding - labelHeight);
                }
            }
            else {
                if (isAxisBreakLabel) {
                    labelPadding = !isLabelUnderAxisLine ? -(padding + scrollBarHeight + (paddingForBreakLabel)) :
                        padding + scrollBarHeight + (angle ? paddingForBreakLabel : (3 * labelHeight));
                }
                else {
                    labelPadding = !isLabelUnderAxisLine ?
                        -(padding + scrollBarHeight + (angle ? labelHeight : (label.index > 1 ? (2 * labelHeight) : 0))) :
                        padding + scrollBarHeight + ((angle ? 1 : 3) * labelHeight);
                }
                pointY = (rect.y + (labelPadding * label.index));
            }
            // label Y value adjustment (End)
            if (isAxisBreakLabel) {
                anchor = this.getAnchor(axis); // for break label self alignment
            }
            else {
                anchor = (chart.enableRtl) ? ((isEndAnchor) ? '' : 'end') : (chart.isRtlEnabled || isEndAnchor) ? 'end' : '';
            }
            options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, anchor);
            if (angle !== 0) {
                rotatedLabelSize = rotateTextSize(label.labelStyle, label.originalText, angle, chart);
                isLeft = ((angle < 0 && angle > -90) || (angle < -180 && angle > -270) || (angle > 90 && angle < 180) || (angle > 270 && angle < 360));
            }
            if (axis.edgeLabelPlacement) {
                switch (axis.edgeLabelPlacement) {
                    case 'None':
                        break;
                    case 'Hide':
                        if (((i === 0 || (isInverse && i === len - 1)) && options.x < rect.x) ||
                            ((i === len - 1 || (isInverse && i === 0)) && (options.x + (angle === 0 ? width : rotatedLabelSize.width) > rect.x + rect.width))) {
                            continue;
                        }
                        break;
                    case 'Shift':
                        if ((i === 0 || (isInverse && i === len - 1)) && (options.x < rect.x || (angle !== 0 && isLeft && options.x - rotatedLabelSize.width <= rect.x) || (axis.lineBreakAlignment === 'Center' && options.x - (label.size.width / label.text.length) / 2 < rect.x && angle === 0))) {
                            intervalLength -= (rect.x - options.x);
                            if (anchor === '' && !isInverse && angle === 0) {
                                if (options.x <= 0) {
                                    pointX = options.x = 0;
                                }
                                else {
                                    pointX = options.x;
                                }
                                intervalLength = rect.width / length;
                            }
                            else if (isLeft && angle !== 0) {
                                intervalLength = rect.width / length;
                                if (intervalLength > rect.x + rotatedLabelSize.width) {
                                    options.x = pointX = rect.x + rotatedLabelSize.width;
                                }
                                else {
                                    options.x = pointX = rect.x + intervalLength - padding;
                                }
                            }
                            else if (isAxisBreakLabel && axis.lineBreakAlignment === 'Center' && axis.labelPlacement === 'OnTicks' && angle === 0) {
                                var maxWidth = 0;
                                for (var i_1 = 0; i_1 < label.text.length; i_1++) {
                                    var breakLabelWidth = measureText(label.text[i_1], axis.labelStyle, chart.themeStyle.axisLabelFont).width;
                                    if (breakLabelWidth > maxWidth) {
                                        maxWidth = breakLabelWidth;
                                    }
                                }
                                options.x = pointX = rect.x + maxWidth / 2;
                            }
                            else if (!(anchor === 'start' && options.x > 0)) {
                                options.x = pointX = !isHorizontalAngle ? rect.x + padding : rect.x;
                            }
                        }
                        else if ((i === len - 1 || (isInverse && i === 0)) && (((options.x + width) > rect.x + rect.width && anchor !== 'end' && angle === 0) || (angle !== 0 && !isLeft && (options.x + rotatedLabelSize.width) > rect.x + rect.width) || (anchor === 'end' && options.x > rect.x + rect.width))) {
                            if (elementSize.width > intervalLength && axis.labelIntersectAction === 'Trim' && angle === 0) {
                                intervalLength -= (options.x + width - (rect.x + rect.width));
                            }
                            else if (angle !== 0) {
                                if (rotatedLabelSize.width < intervalLength) {
                                    intervalLength = rotatedLabelSize.width;
                                }
                            }
                            else {
                                intervalLength = width;
                            }
                            if (angle !== 0) {
                                options.x = pointX = rect.x + rect.width - intervalLength + padding;
                            }
                            else {
                                options.x = pointX = !isHorizontalAngle ? rect.x + rect.width - intervalLength / 2 : rect.x + rect.width - intervalLength;
                            }
                        }
                        break;
                }
            }
            options.text = this.getLabelText(label, axis, intervalLength);
            options.labelRotation = angle;
            // ------- Hide Calculation (Start) -------------
            // Currect label actual start value (Start)
            var xValue = void 0;
            var xValue2 = void 0;
            if (isAxisBreakLabel && angle === 0) {
                if (axis.lineBreakAlignment === 'Right') {
                    xValue = (options.x - width);
                    xValue2 = options.x;
                }
                else if (axis.lineBreakAlignment === 'Center') {
                    xValue = (options.x - (width / 2));
                    xValue2 = options.x + (width / 2);
                }
                else {
                    xValue = options.x;
                    xValue2 = options.x + width;
                }
            }
            else {
                xValue = options.x;
                xValue2 = options.x + width;
            }
            // Currect label actual start value (End)
            if (angle === 0 && axis.labelIntersectAction === 'Hide' && i !== 0 &&
                (!isInverse ? xValue <= previousEnd : xValue2 >= previousEnd)) {
                continue;
            }
            // Previous label actual end value (Start)
            if (isAxisBreakLabel) {
                if (axis.lineBreakAlignment === 'Right') {
                    previousEnd = isInverse ? (options.x - width) : options.x;
                }
                else if (axis.lineBreakAlignment === 'Center') {
                    previousEnd = isInverse ? (options.x - (width / 2)) : options.x + (width / 2);
                }
                else {
                    previousEnd = isInverse ? options.x : options.x + width;
                }
            }
            else {
                previousEnd = isInverse ? options.x : options.x + width;
            }
            // Previous label actual end value (End)
            // ------- Hide Calculation (End) -------------
            // label Rotataion calculation (Start)
            if (angle !== 0) {
                var height = void 0;
                var rect_1 = void 0;
                if (isAxisBreakLabel) {
                    var xAdjustment = 0;
                    var yAdjustment = 0;
                    height = (label.breakLabelSize.height);
                    yAdjustment = (label.breakLabelSize.height) - 4; // 4 for label bound correction
                    // xAdjustment (Start)
                    if (axis.lineBreakAlignment === 'Center') {
                        xAdjustment = -(label.breakLabelSize.width / 2);
                    }
                    else if (axis.lineBreakAlignment === 'Right') {
                        xAdjustment = -label.breakLabelSize.width;
                    }
                    // xAdjustment (End)
                    if (isLabelUnderAxisLine) {
                        yAdjustment = (label.breakLabelSize.height) / (options.text.length + 1);
                    }
                    rect_1 = new Rect(options.x + xAdjustment, options.y - (yAdjustment), label.breakLabelSize.width, height);
                }
                else {
                    height = (pointY) - (options.y - ((label.size.height / 2)));
                    rect_1 = new Rect(options.x, options.y - ((label.size.height / 2) - 5), label.size.width, height);
                }
                var rectCoordinates = this.getRectanglePoints(rect_1);
                var rectCenterX = isAxisBreakLabel ? rect_1.x + (rect_1.width / 2) : pointX;
                var rectCenterY = isAxisBreakLabel ? rect_1.y + (rect_1.height / 2) : (pointY - (height / 2));
                if (isAxisBreakLabel) {
                    options.transform = 'rotate(' + angle + ',' + rectCenterX + ',' + rectCenterY + ')';
                }
                else {
                    options.transform = 'rotate(' + angle + ',' + pointX + ',' + pointY + ')';
                }
                newPoints.push(getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle));
                isRotatedLabelIntersect = false;
                if (axis.labelIntersectAction !== 'None') {
                    for (var index_1 = i; index_1 > 0; index_1--) {
                        if (newPoints[i] && newPoints[index_1 - 1] && isRotatedRectIntersect(newPoints[i], newPoints[index_1 - 1])) {
                            isRotatedLabelIntersect = true;
                            newPoints[i] = null;
                            break;
                        }
                    }
                }
                var rotateAngle = ((angle > 0 && angle < 90) || (angle > 180 && angle < 270) || (angle < -90 && angle > -180) || (angle < -270 && angle > -360));
                var textRect = new Rect(options.x, options.y - (elementSize.height / 2 + padding / 2), label.size.width, height);
                var textRectCoordinates = this.getRectanglePoints(textRect);
                var rectPoints = [];
                rectPoints.push(new ChartLocation(rotateAngle ? this.chart.availableSize.width : this.padding, axis.rect.y));
                rectPoints.push(new ChartLocation(rotateAngle ? this.chart.availableSize.width : this.padding, axis.rect.y + axis.maxLabelSize.height));
                textPoints.push(getRotatedRectangleCoordinates(textRectCoordinates, rectCenterX, rectCenterY, angle));
                var newRect = new Rect(0, axis.rect.y, this.chart.availableSize.width, axis.maxLabelSize.height * 2);
                for (var k = 0; k < textPoints[i].length; k++) {
                    if (!axis.opposedPosition && !withInBounds(textPoints[i][k].x, textPoints[i][k].y, newRect) && typeof options.text === 'string') {
                        var interSectPoint = this.calculateIntersection(textPoints[i][0], textPoints[i][1], rectPoints[0], rectPoints[1]);
                        var rectPoint1 = rotateAngle ? this.chart.availableSize.width - pointX : pointX;
                        var rectPoint2 = interSectPoint.y - axis.rect.y;
                        var trimValue = Math.sqrt((rectPoint1 * rectPoint1) + (rectPoint2 * rectPoint2));
                        options.text = textTrim(trimValue, label.text, label.labelStyle, chart.enableRtl, chart.themeStyle.axisLabelFont);
                    }
                }
            }
            // label Rotataion calculation (End)
            textElement$1(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, (axis.isAxisOpposedPosition !== (axis.labelPosition === 'Inside')), chart.redraw, true, null, null, null, label.size, isRotatedLabelIntersect, chart.enableCanvas, null, chart.themeStyle.axisLabelFont);
        }
        if (!this.chart.enableCanvas) {
            if (!chart.delayRedraw) {
                parent.appendChild(labelElement);
            }
            else if (axis.visible && axis.internalVisibility) {
                this.createZoomingLabel(this.chart, labelElement, axis, index, rect);
            }
        }
    };
    CartesianAxisLayoutPanel.prototype.calculateIntersection = function (p1, p2, p3, p4) {
        var c2x = p3.x - p4.x;
        var c3x = p1.x - p2.x;
        var c2y = p3.y - p4.y;
        var c3y = p1.y - p2.y;
        var d = c3x * c2y - c3y * c2x;
        var u1 = p1.x * p2.y - p1.y * p2.x;
        var u4 = p3.x * p4.y - p3.y * p4.x;
        var px = (u1 * c2x - c3x * u4) / d;
        var py = (u1 * c2y - c3y * u4) / d;
        var p = { x: px, y: py };
        return p;
    };
    /**
     * To get text anchor value for line break labels.
     *
     * @param {Axis} axis axis model
     * @returns {string} returns text anchor
     */
    CartesianAxisLayoutPanel.prototype.getAnchor = function (axis) {
        return (axis.lineBreakAlignment === 'Center' ? 'middle' : (this.chart.enableRtl) ? (axis.lineBreakAlignment === 'Left' ? 'end' : 'start') : (axis.lineBreakAlignment === 'Left' ? 'start' : 'end'));
    };
    /**
     * Get rect coordinates
     *
     * @param {Rect} rect rect
     * @returns {ChartLocation[]} rectangle points
     */
    CartesianAxisLayoutPanel.prototype.getRectanglePoints = function (rect) {
        var point1 = new ChartLocation(rect.x, rect.y);
        var point2 = new ChartLocation(rect.x + rect.width, rect.y);
        var point3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);
        var point4 = new ChartLocation(rect.x, rect.y + rect.height);
        return [point1, point2, point3, point4];
    };
    /**
     * To get axis label text
     *
     * @param {VisibleLabels} label label
     * @param {Axis} axis axis
     * @param {number} intervalLength intervalLength
     * @returns {string | string[]} label or label collection
     */
    CartesianAxisLayoutPanel.prototype.getLabelText = function (label, axis, intervalLength) {
        if (isBreakLabel(label.originalText)) {
            var result = [];
            var str = void 0;
            for (var index = 0; index < label.text.length; index++) {
                str = this.findAxisLabel(axis, label.text[index], intervalLength);
                result.push(str);
            }
            return result;
        }
        else {
            return this.findAxisLabel(axis, label.text, intervalLength);
        }
    };
    /**
     * To render the x-axis label border.
     *
     * @param {Axis} axis axis
     * @param {number} index index
     * @param {Element} parent parent
     * @param {Rect} axisRect axisRect
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.drawXAxisBorder = function (axis, index, parent, axisRect) {
        if (axis.border.width > 0) {
            var scrollBarHeight = axis.labelPosition === 'Outside' ? axis.scrollBarHeight : 0;
            var isOpposed = axis.isAxisOpposedPosition;
            var startX = void 0;
            var startY = axisRect.y + ((isOpposed ? -1 : 1) * scrollBarHeight);
            var padding = 10;
            var pointX = void 0;
            var gap = (axisRect.width / axis.visibleRange.delta) * (axis.valueType === 'DateTime' ? axis.dateTimeInterval
                : axis.visibleRange.interval);
            var endX = void 0;
            var length_2 = axis.maxLabelSize.height +
                ((axis.tickPosition === axis.labelPosition) ? axis.majorTickLines.height : 0);
            var labelBorder = '';
            var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ? -0.5 : 0;
            var endY = ((isOpposed && axis.labelPosition === 'Inside') ||
                (!isOpposed && axis.labelPosition === 'Outside')) ?
                (axisRect.y + length_2 + padding + scrollBarHeight) : (axisRect.y - length_2 - padding - scrollBarHeight);
            for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {
                pointX = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);
                pointX = (axis.isAxisInverse ? (1 - pointX) : pointX) * axisRect.width;
                if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {
                    startX = pointX + axisRect.x;
                    endX = pointX + (gap) + axisRect.x;
                }
                else {
                    startX = pointX - gap * 0.5 + axisRect.x;
                    endX = pointX + gap * 0.5 + axisRect.x;
                }
                switch (axis.border.type) {
                    case 'Rectangle':
                    case 'WithoutTopBorder':
                        if (startX < axisRect.x && axis.labelPlacement !== 'OnTicks') {
                            labelBorder += ('M' + ' ' + axisRect.x + ' ' + endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');
                        }
                        else if (Math.floor(endX) > axisRect.width + axisRect.x && !(axis.visibleLabels.length === 1) && !(i === axis.visibleLabels.length - 1)) {
                            labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' +
                                'L' + ' ' + (axisRect.width + axisRect.x) + ' ' + endY + ' ');
                        }
                        else {
                            startX = (i === 0 && axis.labelPlacement === 'OnTicks') ? axisRect.x : startX;
                            endX = ((i === axis.visibleLabels.length - 1) && axis.labelPlacement === 'OnTicks') ? endX - gap * 0.5 : endX;
                            labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' +
                                endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');
                            if (i === 0) {
                                labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' +
                                    'M ' + startX + ' ' + endY + ' L ' + (axisRect.x) + ' ' + endY);
                            }
                            if (i === axis.visibleLabels.length - 1) {
                                labelBorder += ('M' + ' ' + endX + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ' +
                                    'M ' + endX + ' ' + endY + ' L ' + (axisRect.width + axisRect.x) + ' ' + endY);
                            }
                        }
                        break;
                    case 'WithoutTopandBottomBorder':
                        if (!(startX < axisRect.x) && !(Math.floor(endX) > axisRect.width + axisRect.x)) {
                            labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' +
                                'M ' + endX + ' ' + startY + ' L ' + endX + ' ' + endY);
                        }
                        break;
                }
            }
            labelBorder += (axis.border.type === 'Rectangle' ? ('M ' + ' ' + axisRect.x + ' ' + startY + 'L' + ' ' +
                (axisRect.x + axisRect.width) + ' ' + startY) : '');
            if (labelBorder !== '') {
                this.createAxisBorderElement(axis, index, labelBorder, parent);
            }
        }
        for (var i = 0; i < this.chart.visibleSeries.length; i++) {
            if (this.chart.multiLevelLabelModule && axis.multiLevelLabels.length > 0 && this.chart.visibleSeries[i].visible) {
                this.chart.multiLevelLabelModule.renderXAxisMultiLevelLabels(axis, index, parent, axisRect);
                break;
            }
        }
    };
    /**
     * To create border element of the axis
     *
     * @param {Axis} axis axis
     * @param {number} index index
     * @param {string} labelBorder labelBorder
     * @param {Element} parent parent
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.createAxisBorderElement = function (axis, index, labelBorder, parent) {
        var element = getElement$1(this.chart.element.id + '_BorderLine_' + index);
        var direction = element ? element.getAttribute('d') : '';
        var borderElement = this.chart.renderer.drawPath(new PathOption(this.chart.element.id + '_BorderLine_' + index, 'transparent', axis.border.width, axis.border.color || this.chart.themeStyle.axisLine, 1, '', labelBorder));
        borderElement.style.pointerEvents = 'none';
        appendChildElement(this.chart.enableCanvas, parent, borderElement, this.chart.redraw, false, 'x', 'y', null, direction, true);
    };
    /**
     * To find the axis label of the intersect action
     *
     * @param {Axis} axis axis
     * @param {string} label label
     * @param {number} width width
     * @returns {string} label
     */
    CartesianAxisLayoutPanel.prototype.findAxisLabel = function (axis, label, width) {
        return (axis.labelIntersectAction === 'Trim' ?
            ((axis.angle % 360 === 0 && !axis.enableTrim) ? textTrim(width, label, axis.labelStyle, this.chart.enableRtl, this.chart.themeStyle.axisLabelFont) : label) : label);
    };
    /**
     * X-Axis Title function performed
     *
     * @param {Axis} axis axis
     * @param {number} index index
     * @param {Element} parent parent
     * @param {Rect} rect rect
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.drawXAxisTitle = function (axis, index, parent, rect) {
        if (axis.title) {
            var chart = this.chart;
            var elementSize = measureText(axis.title, axis.titleStyle, this.chart.themeStyle.axisTitleFont);
            var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight : 0;
            var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + axis.titlePadding) +
                (axis.labelPosition === 'Inside' ? 0 :
                    axis.maxLabelSize.height + axis.multiLevelLabelHeight + axis.labelPadding);
            var titleSize = (axis.titleSize.height * (axis.titleCollection.length - 1));
            padding = axis.isAxisOpposedPosition ? -(padding + elementSize.height / 4 + scrollBarHeight + titleSize) : (padding + (3 *
                elementSize.height / 4) + scrollBarHeight);
            var labelRotation = axis.titleRotation ? axis.titleRotation : 0;
            var x = void 0;
            var y = rect.y + padding;
            var anchor = void 0;
            if (axis.titleStyle.textAlignment === 'Center') {
                anchor = 'middle';
                x = rect.x + rect.width * 0.5;
            }
            else if (axis.titleStyle.textAlignment === 'Near') {
                anchor = 'start';
                x = rect.x;
            }
            else {
                anchor = 'end';
                x = rect.x + rect.width;
            }
            if (labelRotation !== 0) {
                y += axis.opposedPosition ? -(axis.titleSize.height / 2 + elementSize.height / 4) :
                    axis.titleSize.height / 2 - elementSize.height / 4;
            }
            var options = new TextOption(chart.element.id + '_AxisTitle_' + index, x, y, anchor, axis.titleCollection, 'rotate(' + labelRotation + ',' + (x) + ',' + (y) + ')', null, labelRotation);
            var element = textElement$1(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitleFont.color, parent, null, null, null, null, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisTitleFont);
            element.setAttribute('aria-hidden', 'true');
        }
    };
    /**
     * To render the axis grid and tick lines(Both Major and Minor)
     *
     * @param {Axis} axis axis
     * @param {number} index index
     * @param {string} gridDirection gridDirection
     * @param {MajorTickLinesModel | MinorTickLinesModel | MajorGridLinesModel | MinorGridLinesModel} gridModel gridModel
     * @param {string} gridId gridId
     * @param {number} gridIndex gridIndex
     * @param {Element} parent parent
     * @param {string} themeColor themeColor
     * @param {string} dashArray dashArray
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.renderGridLine = function (axis, index, gridDirection, gridModel, gridId, gridIndex, parent, themeColor, dashArray) {
        if (dashArray === void 0) { dashArray = null; }
        var chart = this.chart;
        var direction;
        var element;
        if (gridModel.width > 0 && axis.visible && axis.internalVisibility && gridDirection) {
            element = getElement$1(chart.element.id + gridId + index + '_' + gridIndex);
            direction = element ? element.getAttribute('d') : null;
            element = null;
            this.htmlObject = chart.renderer.drawPath(new PathOption(chart.element.id + gridId + index + '_' + gridIndex, 'transparent', gridModel.width, gridModel.color || themeColor, null, dashArray, gridDirection));
            appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction, true);
        }
    };
    /**
     * To Find the parent node of the axis
     *
     * @param {string} elementId elementId
     * @param {Element} label label
     * @param {number} index index
     * @returns {Element} parent node of the axis
     */
    CartesianAxisLayoutPanel.prototype.findParentNode = function (elementId, label, index) {
        if (document.getElementById(elementId + 'AxisGroup' + index + 'Inside').contains(document.getElementById(label.id))) {
            return document.getElementById(elementId + 'AxisGroup' + index + 'Inside');
        }
        else {
            return document.getElementById(elementId + 'AxisGroup' + index + 'Outside');
        }
    };
    /**
     * Create Zooming Labels Function Called here
     *
     * @param {Chart} chart chart
     * @param {Element} labelElement labelElement
     * @param {Axis} axis axis
     * @param {number} index index
     * @param {Rect} rect rect
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.createZoomingLabel = function (chart, labelElement, axis, index, rect) {
        var parentNode = this.findParentNode(chart.element.id, labelElement, index);
        labelElement.setAttribute('opacity', '0.3');
        var zoomElement = chart.renderer.createGroup({
            id: chart.element.id + 'AxisLabels_Zoom' + index
        });
        zoomElement = createZoomingLabels(chart, axis, zoomElement, index, axis.orientation === 'Vertical', rect);
        parentNode.replaceChild(labelElement, document.getElementById(labelElement.id));
        if (getElement$1(chart.element.id + 'AxisLabels_Zoom' + index)) {
            parentNode.replaceChild(zoomElement, document.getElementById(zoomElement.id));
        }
        else {
            parentNode.appendChild(zoomElement);
        }
    };
    return CartesianAxisLayoutPanel;
}());

/**
 * To get the data on mouse move.
 *
 * @private
 */
var ChartData = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for the data.
     *
     * @private
     */
    function ChartData(chart) {
        /** @private */
        this.currentPoints = [];
        /** @private */
        this.previousPoints = [];
        this.insideRegion = false;
        this.commonXvalues = [];
        this.chart = chart;
        this.lierIndex = 0;
    }
    /**
     * Method to get the Data.
     *
     * @private
     */
    ChartData.prototype.getData = function () {
        var chart = this.chart;
        var point = null;
        var series = null;
        var width;
        var height;
        var mouseX;
        var mouseY;
        for (var len = chart.visibleSeries.length, i = len - 1; i >= 0; i--) {
            series = chart.visibleSeries[i];
            width = (series.type === 'Scatter' || series.drawType === 'Scatter' || (series.marker.visible))
                ? (series.marker.height + 5) / 2 : 0;
            height = (series.type === 'Scatter' || series.drawType === 'Scatter' || (series.marker.visible))
                ? (series.marker.width + 5) / 2 : 0;
            mouseX = chart.mouseX;
            mouseY = chart.mouseY;
            if (series.dragSettings.enable && series.isRectSeries) {
                if (!(series.type === 'Bar' && chart.isTransposed) && (chart.isTransposed || series.type === 'Bar')) {
                    var markerWidth = series.marker.width / 2;
                    mouseX = series.yAxis.isAxisInverse ? mouseX + markerWidth : mouseX - markerWidth;
                }
                else {
                    var markerHeight = series.marker.height / 2;
                    mouseY = series.yAxis.isAxisInverse ? mouseY - markerHeight : mouseY + markerHeight;
                }
            }
            if (series.visible && withInBounds(mouseX, mouseY, series.clipRect, width, height)) {
                point = this.getRectPoint(series, series.clipRect, mouseX, mouseY);
            }
            if (point) {
                return new PointData(point, series);
            }
        }
        return new PointData(point, series);
    };
    ChartData.prototype.isSelected = function (chart) {
        return ((chart.selectionMode.indexOf('Drag') > -1 || chart.selectionMode.indexOf('Lasso') > -1) && chart.selectionModule &&
            chart.selectionModule.rectPoints !== null);
    };
    ChartData.prototype.getRectPoint = function (series, rect, x, y) {
        var chart = this.chart;
        var fromCenterX;
        var fromCenterY;
        var clickAngle;
        var arcAngle = 0;
        var startAngle;
        var endAngle;
        var distanceFromCenter;
        if (chart.isScrolling) {
            return null;
        }
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var point = _a[_i];
            if (!point.regionData) {
                if (!point.regions || !point.regions.length) {
                    continue;
                }
            }
            if (point.regionData && this.chart.chartAreaType === 'PolarRadar' && series.drawType.indexOf('Column') > -1) {
                fromCenterX = x - (series.clipRect.width / 2 + series.clipRect.x);
                fromCenterY = y - (series.clipRect.height / 2 + series.clipRect.y);
                arcAngle = 2 * Math.PI * (point.regionData.currentXPosition < 0 ? 1 + point.regionData.currentXPosition
                    : point.regionData.currentXPosition);
                clickAngle = (Math.atan2(fromCenterY, fromCenterX) + 0.5 * Math.PI - arcAngle) % (2 * Math.PI);
                clickAngle = clickAngle < 0 ? 2 * Math.PI + clickAngle : clickAngle;
                clickAngle = clickAngle + 2 * Math.PI * series.chart.primaryXAxis.startAngle;
                startAngle = point.regionData.startAngle;
                startAngle -= arcAngle;
                startAngle = startAngle < 0 ? 2 * Math.PI + startAngle : startAngle;
                endAngle = point.regionData.endAngle;
                endAngle -= arcAngle;
                endAngle = endAngle < 0 ? 2 * Math.PI + endAngle : endAngle;
                distanceFromCenter = Math.sqrt(Math.pow(Math.abs(fromCenterX), 2) + Math.pow(Math.abs(fromCenterY), 2));
                if (clickAngle >= startAngle && clickAngle <= endAngle &&
                    (((distanceFromCenter >= point.regionData.innerRadius && distanceFromCenter <= point.regionData.radius) ||
                        (distanceFromCenter <= point.regionData.innerRadius && distanceFromCenter >= point.regionData.radius))
                        && distanceFromCenter <= series.chart.radius)) {
                    return point;
                }
            }
            if ((series.dragSettings.enable && series.isRectSeries) || (series.isRectSeries && series.marker.visible)) {
                if (this.isPointInThresholdRegion(x, y, point, rect, series)) {
                    this.insideRegion = true;
                    return point;
                }
            }
            if (!this.insideRegion && this.checkRegionContainsPoint(point.regions, rect, x, y)) {
                return point;
            }
            else if (this.insideRegion && this.checkRegionContainsPoint(point.regions, rect, x, y)) {
                return point;
            }
        }
        return null;
    };
    /**
     * Checks whether the region contains a point
     */
    ChartData.prototype.checkRegionContainsPoint = function (regionRect, rect, x, y) {
        var _this = this;
        return regionRect.some(function (region, index) {
            _this.lierIndex = index;
            return withInBounds(x, y, new Rect((_this.chart.chartAreaType === 'Cartesian' ? rect.x : 0) + region.x, (_this.chart.chartAreaType === 'Cartesian' ? rect.y : 0) + region.y, region.width, region.height));
        });
    };
    /**
     * To check the point in threshold region for column and bar series
     *
     * @param {number} x X coordinate
     * @param {number} y Y coodinate
     * @param {Points} point point
     * @param {Rect} rect point rect region
     * @param {Series} series series
     */
    ChartData.prototype.isPointInThresholdRegion = function (x, y, point, rect, series) {
        var _this = this;
        var isBar = series.type === 'Bar';
        var isInversed = series.yAxis.isAxisInverse;
        var isTransposed = series.chart.isTransposed;
        var heightValue = 10;
        var yValue = 0;
        var xValue = 0;
        var width;
        var height = width = 2 * heightValue;
        if (isInversed && isTransposed) {
            if (isBar) {
                yValue = point.regions[0].height - heightValue;
                width = point.regions[0].width;
            }
            else {
                xValue = -heightValue;
                height = point.regions[0].height;
            }
        }
        else if (isInversed || point.yValue < 0) {
            if (isBar) {
                xValue = -heightValue;
                height = point.regions[0].height;
            }
            else {
                yValue = point.regions[0].height - heightValue;
                width = point.regions[0].width;
            }
        }
        else if (isTransposed) {
            if (isBar) {
                yValue = -heightValue;
                width = point.regions[0].width;
            }
            else {
                xValue = point.regions[0].width - heightValue;
                height = point.regions[0].height;
            }
        }
        else {
            if (isBar) {
                xValue = point.regions[0].width - heightValue;
                height = point.regions[0].height;
            }
            else {
                yValue = -heightValue;
                width = point.regions[0].width;
            }
        }
        return point.regions.some(function (region) {
            return withInBounds(x, y, new Rect((_this.chart.chartAreaType === 'Cartesian' ? rect.x : 0) + region.x + xValue, (_this.chart.chartAreaType === 'Cartesian' ? rect.y : 0) + region.y + yValue, width, height));
        });
    };
    /**
     * @private
     */
    ChartData.prototype.getClosest = function (series, value, xvalues) {
        var closest;
        var data;
        var xData = xvalues ? xvalues : series.xData;
        var xLength = xData.length;
        var leftSideNearest = 0.5;
        var rightSideNearest = 0.5;
        if (series.xAxis.valueType === 'DateTime' && series.points.length === 1) {
            leftSideNearest = series.xAxis.visibleRange.min;
            rightSideNearest = series.xAxis.visibleRange.max;
            for (var index = 0; index < series.chart.visibleSeries.length; index++) {
                var visibleSeries = series.chart.visibleSeries[index];
                if (visibleSeries.xMin >= leftSideNearest && visibleSeries.xMin < series.xMin) {
                    leftSideNearest = visibleSeries.xMin + 0.1;
                }
                if (visibleSeries.xMax <= rightSideNearest && visibleSeries.xMax > series.xMax) {
                    rightSideNearest = visibleSeries.xMax - 0.1;
                }
                if (visibleSeries.points.length > 1) {
                    if (visibleSeries.xMax >= leftSideNearest && visibleSeries.xMax < series.xMin) {
                        leftSideNearest = visibleSeries.xMax + 0.1;
                    }
                    if (visibleSeries.xMin <= rightSideNearest && visibleSeries.xMin > series.xMax) {
                        rightSideNearest = visibleSeries.xMin - 0.1;
                    }
                }
            }
            if (leftSideNearest !== series.xAxis.visibleRange.min) {
                leftSideNearest = Math.abs(series.xMin - leftSideNearest) / 2;
            }
            if (rightSideNearest !== series.xAxis.visibleRange.max) {
                rightSideNearest = Math.abs(series.xMax - rightSideNearest) / 2;
            }
        }
        if (value >= series.xMin - leftSideNearest && value <= series.xMax + rightSideNearest) {
            for (var i = 0; i < xLength; i++) {
                data = xData[i];
                if (closest == null || Math.abs(data - value) < Math.abs(closest - value)) {
                    closest = data;
                }
            }
        }
        var isDataExist = series.xData.indexOf(closest) !== -1;
        if (isDataExist) {
            return closest;
        }
        else {
            return null;
        }
    };
    ChartData.prototype.binarySearch = function (target, list) {
        var first = 0;
        var last = list.length;
        var position = -1;
        var found = false;
        var middle;
        while (found === false && first <= last) {
            middle = Math.floor((first + last) / 2);
            if (list[middle].xValue === target) {
                found = true;
                position = middle;
            }
            else if (list[middle].xValue > target) {
                last = middle - 1;
            }
            else {
                first = middle + 1;
            }
        }
        return position !== -1 ? list[position] : null;
    };
    ChartData.prototype.getClosestX = function (chart, series, xvalues) {
        var value;
        var rect = series.clipRect;
        if (chart.mouseX <= rect.x + rect.width && chart.mouseX >= rect.x) {
            if (!chart.requireInvertedAxis) {
                value = getValueXByPoint(chart.mouseX - rect.x, rect.width, series.xAxis);
            }
            else {
                value = getValueYByPoint(chart.mouseY - rect.y, rect.height, series.xAxis);
            }
        }
        var closest = this.getClosest(series, value, xvalues);
        var point = ((closest || closest === 0) && series.points.length > 0) ? this.binarySearch(closest, sort(series.points, ['xValue'])) : null;
        if (point && point.visible) {
            if (!(this.chart.chartAreaType === 'Cartesian' && ((series.category == 'Indicator' && series.name == 'Histogram') ||
                (point.symbolLocations && point.symbolLocations.length > 0 && point.symbolLocations[0].x >= 0 && point.symbolLocations[0].x <= rect.width)))) {
                return null;
            }
            return new PointData(point, series);
        }
        return null;
    };
    /**
     * Merge all visible series X values for shared tooltip (EJ2-47072)
     *
     * @param visibleSeries
     * @private
     */
    ChartData.prototype.mergeXvalues = function (visibleSeries) {
        if (visibleSeries.length && (!this.commonXvalues.length || (this.commonXvalues.length !== visibleSeries[0].xData.length))) {
            this.commonXvalues = visibleSeries[0].xData;
            for (var index = 1; index < visibleSeries.length; index++) {
                this.commonXvalues = this.getDistinctValues(this.commonXvalues, visibleSeries[index].xData);
            }
        }
        return this.commonXvalues;
    };
    ChartData.prototype.commonXValue = function (visibleSeries) {
        var commonXValues = [];
        for (var j = 0; j < visibleSeries.length; j++) {
            for (var i = 0; (visibleSeries[j].points && i < visibleSeries[j].points.length); i++) {
                var point = visibleSeries[j].points[i];
                if (point && (point.index === 0 || point.index === visibleSeries[j].points.length - 1 ||
                    (point.symbolLocations && point.symbolLocations.length > 0))) {
                    commonXValues.push(point.xValue);
                }
            }
        }
        return commonXValues;
    };
    ChartData.prototype.getDistinctValues = function (first, second) {
        if (first === void 0) { first = []; }
        if (second === void 0) { second = []; }
        var intial = {};
        var result = [];
        var index;
        for (index = 0; index < first.length; index++) {
            var temp = first[index];
            if (!intial[temp]) {
                intial[temp] = true;
                result.push(temp);
            }
        }
        for (index = 0; index < second.length; index++) {
            var temp = second[index];
            if (!intial[temp]) {
                intial[temp] = true;
                result.push(temp);
            }
        }
        return result;
    };
    return ChartData;
}());

var __extends$5 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable max-len */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable valid-jsdoc */
/**
 * Configures the data label in the series.
 */
var DataLabelSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$5(DataLabelSettings, _super);
    function DataLabelSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$4([
        Property(false)
    ], DataLabelSettings.prototype, "visible", void 0);
    __decorate$4([
        Property(true)
    ], DataLabelSettings.prototype, "showZero", void 0);
    __decorate$4([
        Property(null)
    ], DataLabelSettings.prototype, "name", void 0);
    __decorate$4([
        Property('transparent')
    ], DataLabelSettings.prototype, "fill", void 0);
    __decorate$4([
        Property(null)
    ], DataLabelSettings.prototype, "format", void 0);
    __decorate$4([
        Property(1)
    ], DataLabelSettings.prototype, "opacity", void 0);
    __decorate$4([
        Property(0)
    ], DataLabelSettings.prototype, "angle", void 0);
    __decorate$4([
        Property(false)
    ], DataLabelSettings.prototype, "enableRotation", void 0);
    __decorate$4([
        Property('Auto')
    ], DataLabelSettings.prototype, "position", void 0);
    __decorate$4([
        Property(5)
    ], DataLabelSettings.prototype, "rx", void 0);
    __decorate$4([
        Property(5)
    ], DataLabelSettings.prototype, "ry", void 0);
    __decorate$4([
        Property('Center')
    ], DataLabelSettings.prototype, "alignment", void 0);
    __decorate$4([
        Complex({ width: null, color: null }, Border)
    ], DataLabelSettings.prototype, "border", void 0);
    __decorate$4([
        Complex({ left: 5, right: 5, top: 5, bottom: 5 }, Margin)
    ], DataLabelSettings.prototype, "margin", void 0);
    __decorate$4([
        Complex({ size: '12px', color: null, fontStyle: 'Normal', fontWeight: '400', fontFamily: null }, Font)
    ], DataLabelSettings.prototype, "font", void 0);
    __decorate$4([
        Property(null)
    ], DataLabelSettings.prototype, "template", void 0);
    __decorate$4([
        Property('Hide')
    ], DataLabelSettings.prototype, "labelIntersectAction", void 0);
    return DataLabelSettings;
}(ChildProperty));
/**
 *  Configures the marker in the series.
 */
var MarkerSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$5(MarkerSettings, _super);
    function MarkerSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$4([
        Property(false)
    ], MarkerSettings.prototype, "visible", void 0);
    __decorate$4([
        Property(null)
    ], MarkerSettings.prototype, "shape", void 0);
    __decorate$4([
        Property('')
    ], MarkerSettings.prototype, "imageUrl", void 0);
    __decorate$4([
        Property(5)
    ], MarkerSettings.prototype, "height", void 0);
    __decorate$4([
        Property(false)
    ], MarkerSettings.prototype, "isFilled", void 0);
    __decorate$4([
        Property(5)
    ], MarkerSettings.prototype, "width", void 0);
    __decorate$4([
        Complex({ width: 2, color: null }, Border)
    ], MarkerSettings.prototype, "border", void 0);
    __decorate$4([
        Complex({ x: 0, y: 0 }, Offset)
    ], MarkerSettings.prototype, "offset", void 0);
    __decorate$4([
        Property(null)
    ], MarkerSettings.prototype, "fill", void 0);
    __decorate$4([
        Property(true)
    ], MarkerSettings.prototype, "allowHighlight", void 0);
    __decorate$4([
        Property(1)
    ], MarkerSettings.prototype, "opacity", void 0);
    __decorate$4([
        Complex({}, DataLabelSettings)
    ], MarkerSettings.prototype, "dataLabel", void 0);
    return MarkerSettings;
}(ChildProperty));
/**
 *  Configures the pareto in the series.
 */
var ParetoOptions = /** @__PURE__ @class */ (function (_super) {
    __extends$5(ParetoOptions, _super);
    function ParetoOptions() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$4([
        Property(null)
    ], ParetoOptions.prototype, "fill", void 0);
    __decorate$4([
        Property(1)
    ], ParetoOptions.prototype, "width", void 0);
    __decorate$4([
        Property('0')
    ], ParetoOptions.prototype, "dashArray", void 0);
    __decorate$4([
        Complex(null, MarkerSettings)
    ], ParetoOptions.prototype, "marker", void 0);
    __decorate$4([
        Property(true)
    ], ParetoOptions.prototype, "showAxis", void 0);
    return ParetoOptions;
}(ChildProperty));
/**
 * Points model for the series.
 *
 * @public
 */
var Points = /** @__PURE__ @class */ (function () {
    function Points() {
        /** point symbol location. */
        this.symbolLocations = null;
        /** point region. */
        this.regions = null;
        /** point percentage value. */
        this.percentage = null;
        /** point region data. */
        this.regionData = null;
        /** To know the point is selected. */
        this.isSelect = false;
        /** point marker. */
        this.marker = {
            visible: false
        };
        /**
         * To identify point y value with in the range.
         *
         * @private
         */
        this.isPointInRange = true;
        /** vertical error value for the point. */
        this.verticalError = null;
        /** vertical negative error value for the point. */
        this.verticalNegativeError = null;
        /** horizontal error value for the point. */
        this.horizontalError = null;
        /** horizontal negative error value for the point. */
        this.horizontalNegativeError = null;
        /** vertical positive error value for the point. */
        this.verticalPositiveError = null;
        /** horizontal positive error value for the point. */
        this.horizontalPositiveError = null;
    }
    return Points;
}());
/**
 * Defines the behavior of the Trendlines
 */
var Trendline = /** @__PURE__ @class */ (function (_super) {
    __extends$5(Trendline, _super);
    function Trendline() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** @private */
        _this.clipRect = new Rect(0, 0, 0, 0);
        return _this;
    }
    /** @private */
    Trendline.prototype.setDataSource = function (series, chart) {
        if (series) {
            this.points = series.points;
        }
        chart.trendLineModule.initDataSource(this);
        chart.visibleSeriesCount++;
    };
    __decorate$4([
        Property('')
    ], Trendline.prototype, "name", void 0);
    __decorate$4([
        Property('')
    ], Trendline.prototype, "dashArray", void 0);
    __decorate$4([
        Property(true)
    ], Trendline.prototype, "visible", void 0);
    __decorate$4([
        Property('Linear')
    ], Trendline.prototype, "type", void 0);
    __decorate$4([
        Property(2)
    ], Trendline.prototype, "period", void 0);
    __decorate$4([
        Property(2)
    ], Trendline.prototype, "polynomialOrder", void 0);
    __decorate$4([
        Property(0)
    ], Trendline.prototype, "backwardForecast", void 0);
    __decorate$4([
        Property(0)
    ], Trendline.prototype, "forwardForecast", void 0);
    __decorate$4([
        Complex({}, Animation$1)
    ], Trendline.prototype, "animation", void 0);
    __decorate$4([
        Complex({}, MarkerSettings)
    ], Trendline.prototype, "marker", void 0);
    __decorate$4([
        Property(true)
    ], Trendline.prototype, "enableTooltip", void 0);
    __decorate$4([
        Property(null)
    ], Trendline.prototype, "intercept", void 0);
    __decorate$4([
        Property('')
    ], Trendline.prototype, "fill", void 0);
    __decorate$4([
        Property(1)
    ], Trendline.prototype, "width", void 0);
    __decorate$4([
        Property('SeriesType')
    ], Trendline.prototype, "legendShape", void 0);
    return Trendline;
}(ChildProperty));
/**
 * Configures Error bar in series.
 */
var ErrorBarCapSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$5(ErrorBarCapSettings, _super);
    function ErrorBarCapSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$4([
        Property(1)
    ], ErrorBarCapSettings.prototype, "width", void 0);
    __decorate$4([
        Property(10)
    ], ErrorBarCapSettings.prototype, "length", void 0);
    __decorate$4([
        Property(null)
    ], ErrorBarCapSettings.prototype, "color", void 0);
    __decorate$4([
        Property(1)
    ], ErrorBarCapSettings.prototype, "opacity", void 0);
    return ErrorBarCapSettings;
}(ChildProperty));
var ChartSegment = /** @__PURE__ @class */ (function (_super) {
    __extends$5(ChartSegment, _super);
    function ChartSegment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$4([
        Property(null)
    ], ChartSegment.prototype, "value", void 0);
    __decorate$4([
        Property(null)
    ], ChartSegment.prototype, "color", void 0);
    __decorate$4([
        Property('0')
    ], ChartSegment.prototype, "dashArray", void 0);
    return ChartSegment;
}(ChildProperty));
/**
 * Error bar settings
 *
 * @public
 */
var ErrorBarSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$5(ErrorBarSettings, _super);
    function ErrorBarSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$4([
        Property(false)
    ], ErrorBarSettings.prototype, "visible", void 0);
    __decorate$4([
        Property('Fixed')
    ], ErrorBarSettings.prototype, "type", void 0);
    __decorate$4([
        Property('Both')
    ], ErrorBarSettings.prototype, "direction", void 0);
    __decorate$4([
        Property('Vertical')
    ], ErrorBarSettings.prototype, "mode", void 0);
    __decorate$4([
        Property(null)
    ], ErrorBarSettings.prototype, "color", void 0);
    __decorate$4([
        Property(1)
    ], ErrorBarSettings.prototype, "verticalError", void 0);
    __decorate$4([
        Property(1)
    ], ErrorBarSettings.prototype, "width", void 0);
    __decorate$4([
        Property(1)
    ], ErrorBarSettings.prototype, "horizontalError", void 0);
    __decorate$4([
        Property(3)
    ], ErrorBarSettings.prototype, "verticalPositiveError", void 0);
    __decorate$4([
        Property(3)
    ], ErrorBarSettings.prototype, "verticalNegativeError", void 0);
    __decorate$4([
        Property(1)
    ], ErrorBarSettings.prototype, "horizontalPositiveError", void 0);
    __decorate$4([
        Property(1)
    ], ErrorBarSettings.prototype, "horizontalNegativeError", void 0);
    __decorate$4([
        Complex(null, ErrorBarCapSettings)
    ], ErrorBarSettings.prototype, "errorBarCap", void 0);
    __decorate$4([
        Property('')
    ], ErrorBarSettings.prototype, "errorBarColorMapping", void 0);
    return ErrorBarSettings;
}(ChildProperty));
/**
 * Defines the common behavior of Series and Technical Indicators
 */
var SeriesBase = /** @__PURE__ @class */ (function (_super) {
    __extends$5(SeriesBase, _super);
    function SeriesBase() {
        /**
         * The DataSource field that contains the x value.
         * It is applicable for series and technical indicators
         *
         * @default ''
         */
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.rangeColorPoints = [];
        _this.isAdvancedColor = undefined;
        /** @private */
        _this.currentViewData = [];
        /** @private */
        _this.clipRect = new Rect(0, 0, 0, 0);
        /** @private */
        _this.seriesType = 'XY';
        _this.isRectTypeSeries = false;
        return _this;
    }
    /**
     * Process data for the series.
     *
     * @hidden
     */
    SeriesBase.prototype.processJsonData = function () {
        var i = 0;
        var point = new Points();
        var xName = (this instanceof Series && this.type === 'Histogram') ? 'x' : this.xName;
        var textMappingName = this instanceof Series && this.marker.dataLabel.name ?
            this.marker.dataLabel.name : '';
        if (this instanceof Series) {
            if ((this.type === 'Waterfall' || this.type === 'Histogram')) {
                this.currentViewData = this.chart[firstToLowerCase(this.type) + 'SeriesModule'].
                    processInternalData(extend([], this.currentViewData, null, true), this);
            }
            if (this.category === 'Pareto') {
                if (this.type === 'Line') {
                    this.currentViewData = this.chart.paretoSeriesModule.performCumulativeCalculation(this.currentViewData, this);
                }
            }
            this.isRectTypeSeries = this.type.indexOf('Column') > -1 || this.type.indexOf('Bar') > -1
                || this.type.indexOf('Histogram') > -1;
        }
        var len = (this.currentViewData || []).length;
        this.points = [];
        this.xMin = Infinity;
        this.xMax = -Infinity;
        this.yMin = Infinity;
        this.yMax = -Infinity;
        this.sizeMax = -Infinity;
        this.getSeriesType();
        if (this.xAxis.valueType === 'Category') {
            while (i < len) {
                point = this.dataPoint(i, textMappingName, xName);
                this.pushCategoryData(point, i, point.x);
                this.pushData(point, i);
                this.setEmptyPoint(point, i);
                this.rangeColorsInterior(point);
                i++;
            }
        }
        else if (this.xAxis.valueType.indexOf('DateTime') > -1) {
            var option = {
                skeleton: 'full',
                type: 'dateTime'
            };
            var dateParser = this.chart.intl.getDateParser(option);
            var dateFormatter = this.chart.intl.getDateFormat(option);
            while (i < len) {
                point = this.dataPoint(i, textMappingName, xName);
                if (!isNullOrUndefined(point.x) && point.x !== '') {
                    point.x = new Date(DataUtil.parse.parseJson({ val: point.x }).val);
                    if (this.xAxis.valueType === 'DateTime') {
                        point.xValue = Date.parse(point.x.toString());
                    }
                    else {
                        // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                        this.chart.isBlazor ? this.pushCategoryData(point, i, Date.parse(point.x.toString()).toString()) :
                            this.pushCategoryData(point, i, Date.parse(dateParser(dateFormatter(point.x))).toString());
                    }
                    this.pushData(point, i);
                    this.setEmptyPoint(point, i);
                    //this.rangeColorsInterior(point);
                }
                else {
                    point.visible = false;
                }
                i++;
            }
        }
        else {
            while (i < len) {
                point = this.dataPoint(i, textMappingName, xName);
                point.xValue = point.x;
                this.pushData(point, i);
                this.setEmptyPoint(point, i);
                i++;
            }
        }
        if (this instanceof Series && !(this.chart.stockChart && this.xAxis.valueType === 'DateTimeCategory')) {
            if (this.type.indexOf('Spline') > -1 || (this.drawType.indexOf('Spline') > -1 && this.chart.chartAreaType === 'PolarRadar')) {
                var isArea = (this.type.indexOf('Area') > -1 || this.drawType.indexOf('Area') > -1);
                var isRange = this.type.indexOf('Range') > -1;
                this.chart['spline' + (isArea ? isRange ? 'RangeArea' : 'Area' : '') + 'SeriesModule'].findSplinePoint(this);
            }
            else if (this.type.indexOf('Histogram') > -1 && (this.xAxis.maximum || this.xAxis.minimum)) {
                this.chart['histogramSeriesModule'].calculateBinValues(this);
            }
            if (this.type.indexOf('Histogram') > -1 && this.points.length === 1) {
                this.xMin = this.xMin - this.histogramValues.binWidth;
                this.xMax = this.xMax + this.histogramValues.binWidth;
            }
        }
    };
    SeriesBase.prototype.rangeColorsInterior = function (point) {
        if (this.chart.rangeColorSettings && this.chart.rangeColorSettings.length > 0 && this.chart.visibleSeries.length === 1 &&
            (this.chart.series[0].type === 'Column' || this.chart.series[0].type === 'Bar' ||
                this.chart.series[0].type === 'Scatter' || this.chart.series[0].type === 'Bubble')) {
            if (!this.rangeColorPoints[point.interior]) {
                this.rangeColorPoints[point.interior] = [];
            }
            else if (this.rangeColorPoints[point.interior] !== undefined) {
                this.rangeColorPoints[point.interior].push(point);
            }
        }
    };
    SeriesBase.prototype.pushData = function (point, i) {
        point.index = i;
        point.yValue = point.y;
        point.series = this;
        // To find the min, max for the axis range.
        this.xMin = Math.min(this.xMin, point.xValue);
        this.xMax = Math.max(this.xMax, point.xValue);
        this.xData.push(point.xValue);
    };
    /** @private */
    SeriesBase.prototype.dataPoint = function (i, textMappingName, xName) {
        this.points[i] = new Points();
        var point = this.points[i];
        var currentViewData = this.currentViewData[i];
        var getObjectValueByMappingString = this.enableComplexProperty ? getValue : this.getObjectValue;
        point.x = getObjectValueByMappingString(xName, currentViewData);
        point.high = getObjectValueByMappingString(this.high, currentViewData);
        point.low = getObjectValueByMappingString(this.low, currentViewData);
        point.open = getObjectValueByMappingString(this.open, currentViewData);
        point.close = getObjectValueByMappingString(this.close, currentViewData);
        point.volume = getObjectValueByMappingString(this.volume, currentViewData);
        point.interior = getObjectValueByMappingString(this.pointColorMapping, currentViewData);
        if (this instanceof Series) {
            if (this.errorBar.visible) {
                point.errorBarColor = getObjectValueByMappingString(this.errorBar.errorBarColorMapping, currentViewData);
                point.verticalError = typeof this.errorBar.verticalError == 'string' ? getObjectValueByMappingString(this.errorBar.verticalError, currentViewData) : this.errorBar.verticalError;
                point.horizontalError = typeof this.errorBar.horizontalError == 'string' ? getObjectValueByMappingString(this.errorBar.horizontalError, currentViewData) : this.errorBar.horizontalError;
                point.verticalNegativeError = typeof this.errorBar.verticalNegativeError == 'string' ? getObjectValueByMappingString(this.errorBar.verticalNegativeError, currentViewData) : this.errorBar.verticalNegativeError;
                point.verticalPositiveError = typeof this.errorBar.verticalPositiveError == 'string' ? getObjectValueByMappingString(this.errorBar.verticalPositiveError, currentViewData) : this.errorBar.verticalPositiveError;
                point.horizontalNegativeError = typeof this.errorBar.horizontalNegativeError == 'string' ? getObjectValueByMappingString(this.errorBar.horizontalNegativeError, currentViewData) : this.errorBar.horizontalNegativeError;
                point.horizontalPositiveError = typeof this.errorBar.horizontalPositiveError == 'string' ? getObjectValueByMappingString(this.errorBar.horizontalPositiveError, currentViewData) : this.errorBar.horizontalPositiveError;
            }
            point.y = getObjectValueByMappingString(this.yName, currentViewData);
            point.size = getObjectValueByMappingString(this.size, currentViewData);
            point.text = getObjectValueByMappingString(textMappingName, currentViewData);
            point.tooltip = getObjectValueByMappingString(this.tooltipMappingName, currentViewData);
            if (this.isAdvancedColorSupported()) {
                this.rangeColorName = this.colorName.length > 0 ? this.colorName : this.yName;
                point.colorValue = getObjectValueByMappingString(this.rangeColorName, currentViewData);
                point.interior = this.getPointFillColor(point.interior, point.colorValue);
            }
        }
        return point;
    };
    SeriesBase.prototype.isAdvancedColorSupported = function () {
        if (isNullOrUndefined(this.isAdvancedColor)) {
            if (this.chart.rangeColorSettings && this.chart.rangeColorSettings.length > 0 &&
                (this.chart.series[0].type === 'Column' || this.chart.series[0].type === 'Bar' ||
                    this.chart.series[0].type === 'Scatter' || this.chart.series[0].type === 'Bubble')) {
                this.isAdvancedColor = true;
            }
            else {
                this.isAdvancedColor = false;
            }
        }
        return this.isAdvancedColor;
    };
    SeriesBase.prototype.getPointFillColor = function (pointFill, value) {
        var color = pointFill;
        if (value && this.chart.rangeColorSettings && this.chart.rangeColorSettings.length > 0) {
            for (var _i = 0, _a = this.chart.rangeColorSettings; _i < _a.length; _i++) {
                var rangeMap = _a[_i];
                if (value >= rangeMap.start && value <= rangeMap.end) {
                    if (rangeMap.colors.length > 1) {
                        color = getColorByValue(rangeMap, value);
                    }
                    else {
                        color = rangeMap.colors[0];
                    }
                }
            }
        }
        return color;
    };
    SeriesBase.prototype.getObjectValue = function (mappingName, data) {
        return data[mappingName];
    };
    /**
     * To set empty point value based on empty point mode
     *
     * @private
     */
    SeriesBase.prototype.setEmptyPoint = function (point, i) {
        if (!this.findVisibility(point)) {
            point.visible = true;
            return null;
        }
        point.isEmpty = true;
        var mode = this instanceof Series && point.isPointInRange ? this.emptyPointSettings.mode : 'Drop';
        switch (mode) {
            case 'Zero':
                point.visible = true;
                if (this instanceof Series && this.seriesType.indexOf('HighLow') > -1) {
                    point.high = point.low = 0;
                    if (this.seriesType.indexOf('HighLowOpenClose') > -1) {
                        point.open = point.close = 0;
                    }
                }
                else {
                    point.y = point.yValue = this.yData[i] = 0;
                }
                break;
            case 'Average':
                if (this instanceof Series) {
                    if (this.seriesType.indexOf('HighLow') > -1) {
                        point.high = (isNullOrUndefined(point.high) || isNaN(+point.high)) ? this.getAverage(this.high, i) : point.high;
                        point.low = (isNullOrUndefined(point.low) || isNaN(+point.low)) ? this.getAverage(this.low, i) : point.low;
                        if (this.seriesType.indexOf('HighLowOpenClose') > -1) {
                            point.open = (isNullOrUndefined(point.open) || isNaN(+point.open)) ? this.getAverage(this.open, i) : point.open;
                            point.close = (isNullOrUndefined(point.close) || isNaN(+point.close)) ? this.getAverage(this.close, i) :
                                point.close;
                        }
                    }
                    else {
                        point.y = point.yValue = this.yData[i] = this.getAverage(this.yName, i);
                    }
                }
                point.visible = true;
                break;
            case 'Drop':
            case 'Gap':
                this.yData[i] = null;
                point.visible = false;
                break;
        }
    };
    SeriesBase.prototype.findVisibility = function (point) {
        var type = this instanceof Series ? this.seriesType : 'HighLowOpenClose';
        var yValues;
        var yAxisMin = this.yAxis.minimum;
        var yAxisMax = this.yAxis.maximum;
        switch (type) {
            case 'XY':
                if (this.chart.chartAreaType === 'PolarRadar' && ((!isNullOrUndefined(yAxisMin) && point.yValue < yAxisMin) ||
                    (!isNullOrUndefined(yAxisMax) && point.yValue > yAxisMax))) {
                    point.isPointInRange = false;
                    return true;
                }
                this.setXYMinMax(point.yValue);
                this.yData.push(point.yValue);
                if (this instanceof Series && this.type === 'Bubble') {
                    this.sizeMax = Math.max(this.sizeMax, (isNullOrUndefined(point.size) || isNaN(+point.size)) ? this.sizeMax
                        : point.size);
                }
                return isNullOrUndefined(point.x) || (isNullOrUndefined(point.y) || isNaN(+point.y));
            case 'HighLow':
                this.setHiloMinMax(point.high, point.low);
                return isNullOrUndefined(point.x) || (isNullOrUndefined(point.low) || isNaN(+point.low)) ||
                    (isNullOrUndefined(point.high) || isNaN(+point.high));
            case 'HighLowOpenClose':
                this.setHiloMinMax(point.high, point.low);
                return isNullOrUndefined(point.x) || (isNullOrUndefined(point.low) || isNaN(+point.low)) ||
                    (isNullOrUndefined(point.open) || isNaN(+point.open)) || (isNullOrUndefined(point.close) || isNaN(+point.close))
                    || (isNullOrUndefined(point.high) || isNaN(+point.high));
            case 'BoxPlot':
                yValues = (point.y || [null]).filter(function (value) {
                    return !isNullOrUndefined(value) && !isNaN(value);
                }).sort(function (a, b) {
                    return a - b;
                });
                point.y = yValues;
                this.yMin = Math.min(this.yMin, Math.min.apply(Math, yValues));
                this.yMax = Math.max(this.yMax, Math.max.apply(Math, yValues));
                return !yValues.length;
        }
    };
    /**
     * To get Y min max for the provided point seriesType XY
     */
    SeriesBase.prototype.setXYMinMax = function (yValue) {
        var isLogAxis = (this.yAxis.valueType === 'Logarithmic' || this.xAxis.valueType === 'Logarithmic');
        var isNegativeValue = yValue < 0 || this.yAxis.rangePadding === 'None';
        var seriesMinY;
        if (this.isRectTypeSeries && !setRange(this.yAxis)) {
            seriesMinY = ((isLogAxis ? (yValue) : isNegativeValue ? yValue : 0));
        }
        else {
            seriesMinY = yValue;
        }
        this.yMin = isLogAxis ?
            Math.min(this.yMin, (isNullOrUndefined(seriesMinY) || isNaN(seriesMinY) || (seriesMinY === 0) ||
                (seriesMinY.toString() === '0') || (seriesMinY.toString() === '')) ? this.yMin : seriesMinY) :
            Math.min(this.yMin, (isNullOrUndefined(seriesMinY) || isNaN(seriesMinY)) ? this.yMin : seriesMinY);
        this.yMax = Math.max(this.yMax, (isNullOrUndefined(yValue) || isNaN(yValue)) ? this.yMax : yValue);
    };
    /**
     * To get Y min max for the provided point seriesType XY
     */
    SeriesBase.prototype.setHiloMinMax = function (high, low) {
        this.yMin = Math.min(this.yMin, Math.min((isNullOrUndefined(low) || isNaN(low)) ? this.yMin : low, (isNullOrUndefined(high) || isNaN(high)) ? this.yMin : high));
        this.yMax = Math.max(this.yMax, Math.max((isNullOrUndefined(low) || isNaN(low)) ? this.yMax : low, (isNullOrUndefined(high) || isNaN(high)) ? this.yMax : high));
    };
    /**
     * Finds the type of the series
     *
     * @private
     */
    SeriesBase.prototype.getSeriesType = function () {
        var type;
        if (this instanceof Series) {
            var seriesType = this.chart.chartAreaType === 'PolarRadar' ? this.drawType : this.type;
            if (seriesType) {
                switch (seriesType) {
                    case 'RangeColumn':
                    case 'RangeArea':
                    case 'RangeStepArea':
                    case 'SplineRangeArea':
                    case 'Hilo':
                        type = 'HighLow';
                        break;
                    case 'HiloOpenClose':
                    case 'Candle':
                        type = 'HighLowOpenClose';
                        break;
                    case 'BoxAndWhisker':
                        type = 'BoxPlot';
                        break;
                    default:
                        type = 'XY';
                }
            }
        }
        this.seriesType = type;
    };
    /** @private */
    SeriesBase.prototype.pushCategoryData = function (point, index, pointX) {
        if (!this.chart.tooltip.shared) {
            if (!this.visible) {
                return null;
            }
        }
        if (!this.xAxis.isIndexed) {
            if (this.xAxis.indexLabels[pointX] === undefined) {
                this.xAxis.indexLabels[pointX] = this.xAxis.labels.length;
                this.xAxis.labels.push(pointX);
            }
            point.xValue = this.xAxis.indexLabels[pointX];
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
            this.xAxis.labels[index] ? this.xAxis.labels[index] += ', ' + pointX :
                this.xAxis.labels.push(pointX);
            point.xValue = index;
        }
    };
    /**
     * To find average of given property
     */
    SeriesBase.prototype.getAverage = function (member, i, data) {
        if (data === void 0) { data = this.currentViewData; }
        var previous = data[i - 1] ? (data[i - 1][member] || 0) : 0;
        var next = data[i + 1] ? (data[i + 1][member] || 0) : 0;
        return (previous + next) / 2;
    };
    /**
     * To find the control points for spline.
     *
     * @returns {void}
     * @private
     */
    SeriesBase.prototype.refreshDataManager = function (chart) {
        var _this = this;
        this.chart = chart;
        var dataSource;
        var isAngular = 'isAngular';
        if (chart[isAngular]) {
            dataSource = Object.keys(this.dataSource).length ? this.dataSource : chart.dataSource;
        }
        else {
            dataSource = this.dataSource || chart.dataSource;
        }
        if (!(dataSource instanceof DataManager) && isNullOrUndefined(this.query)) {
            this.dataManagerSuccess({ result: dataSource, count: dataSource.length }, false);
            return;
        }
        var dataManager = this.dataModule.getData(this.dataModule.generateQuery().requiresCount());
        dataManager.then(function (e) { return _this.dataManagerSuccess(e); });
    };
    SeriesBase.prototype.dataManagerSuccess = function (e, isRemoteData) {
        if (isRemoteData === void 0) { isRemoteData = true; }
        this.currentViewData = e.count ? e.result : [];
        this.chart.allowServerDataBinding = false;
        if (this instanceof Series) {
            if (this.chart.stockChart) {
                this.chart.stockChart.series[this.index].localData = this.currentViewData;
            }
            var argsData = {
                name: seriesRender, series: this, data: this.currentViewData, fill: this.interior
            };
            this.chart.trigger(seriesRender, argsData);
            this.interior = argsData.fill;
            this.currentViewData = argsData.data;
        }
        if (this.chart.stockChart && !(this instanceof Series)) {
            this.currentViewData = this.chart.stockChart.findCurrentData(this.chart.stockChart.series[0].localData, this.chart.stockChart.series[0].xName);
        }
        this.processJsonData();
        this.recordsCount = e.count;
        this.refreshChart(isRemoteData);
        this.currentViewData = null;
    };
    SeriesBase.prototype.refreshChart = function (isRemoteData) {
        var chart = this.chart;
        if (this instanceof Series) {
            chart.visibleSeriesCount += isRemoteData ? 1 : 0;
        }
        chart.refreshTechnicalIndicator(this);
        if (this instanceof Series && this.category !== 'TrendLine') {
            for (var _i = 0, _a = this.trendlines; _i < _a.length; _i++) {
                var trendline = _a[_i];
                trendline.setDataSource(this, chart);
            }
        }
        //if (chart.visibleSeries.length === (chart.visibleSeriesCount - chart.indicators.length)) {
        if (chart.visibleSeries.length === (chart.visibleSeriesCount)) {
            chart.refreshBound();
            chart.trigger('loaded', { chart: chart.isBlazor ? {} : chart });
            if (this.chart.stockChart && this.chart.stockChart.initialRender) {
                this.chart.stockChart.initialRender = false;
                this.chart.stockChart.stockChartDataManagerSuccess();
            }
        }
        if (this instanceof Series) {
            chart.visibleSeriesCount += isRemoteData ? 0 : 1;
        }
    };
    __decorate$4([
        Property('')
    ], SeriesBase.prototype, "xName", void 0);
    __decorate$4([
        Property('')
    ], SeriesBase.prototype, "colorName", void 0);
    __decorate$4([
        Property('')
    ], SeriesBase.prototype, "high", void 0);
    __decorate$4([
        Property('')
    ], SeriesBase.prototype, "low", void 0);
    __decorate$4([
        Property('')
    ], SeriesBase.prototype, "open", void 0);
    __decorate$4([
        Property('')
    ], SeriesBase.prototype, "close", void 0);
    __decorate$4([
        Property('')
    ], SeriesBase.prototype, "volume", void 0);
    __decorate$4([
        Property('')
    ], SeriesBase.prototype, "pointColorMapping", void 0);
    __decorate$4([
        Property(true)
    ], SeriesBase.prototype, "visible", void 0);
    __decorate$4([
        Property(null)
    ], SeriesBase.prototype, "xAxisName", void 0);
    __decorate$4([
        Property(null)
    ], SeriesBase.prototype, "yAxisName", void 0);
    __decorate$4([
        Complex(null, Animation$1)
    ], SeriesBase.prototype, "animation", void 0);
    __decorate$4([
        Property(null)
    ], SeriesBase.prototype, "fill", void 0);
    __decorate$4([
        Property(1)
    ], SeriesBase.prototype, "width", void 0);
    __decorate$4([
        Property('')
    ], SeriesBase.prototype, "dashArray", void 0);
    __decorate$4([
        Property('')
    ], SeriesBase.prototype, "dataSource", void 0);
    __decorate$4([
        Property()
    ], SeriesBase.prototype, "query", void 0);
    __decorate$4([
        Collection([], ChartSegment)
    ], SeriesBase.prototype, "segments", void 0);
    __decorate$4([
        Property('X')
    ], SeriesBase.prototype, "segmentAxis", void 0);
    __decorate$4([
        Property(false)
    ], SeriesBase.prototype, "enableComplexProperty", void 0);
    return SeriesBase;
}(ChildProperty));
/**
 * Configures the series in charts.
 *
 * @public
 */
var Series = /** @__PURE__ @class */ (function (_super) {
    __extends$5(Series, _super);
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    function Series(parent, propName, defaultValue, isArray) {
        var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;
        _this.visibleSeriesCount = 0;
        /** @private */
        _this.category = 'Series';
        /** @private */
        _this.isRectSeries = false;
        /** @private */
        _this.drawPoints = [];
        /** @private */
        _this.lowDrawPoints = [];
        /** @private */
        _this.delayedAnimation = false;
        /** @private */
        _this.rangeColorName = _this.colorName.length > 0 ? _this.colorName : _this.yName;
        return _this;
    }
    /**
     * Refresh the axis label.
     *
     * @returns {void}
     * @private
     */
    Series.prototype.refreshAxisLabel = function () {
        if (this.xAxis.valueType !== 'Category') {
            return null;
        }
        this.xAxis.labels = [];
        this.xAxis.indexLabels = {};
        for (var _i = 0, _a = this.xAxis.series; _i < _a.length; _i++) {
            var item = _a[_i];
            if (item.visible && item.category !== 'TrendLine') {
                item.xMin = Infinity;
                item.xMax = -Infinity;
                for (var _b = 0, _c = item.points; _b < _c.length; _b++) {
                    var point = _c[_b];
                    item.pushCategoryData(point, point.index, point.x);
                    item.xMin = Math.min(item.xMin, point.xValue);
                    item.xMax = Math.max(item.xMax, point.xValue);
                }
            }
        }
    };
    /**
     * To get the series collection.
     *
     * @returns {void}
     * @private
     */
    Series.prototype.findSeriesCollection = function (column, row, isStack) {
        var seriesCollection = [];
        for (var _i = 0, _a = row.axes; _i < _a.length; _i++) {
            var rowAxis = _a[_i];
            for (var _b = 0, _c = rowAxis.series; _b < _c.length; _b++) {
                var rowSeries = _c[_b];
                for (var _d = 0, _e = column.axes; _d < _e.length; _d++) {
                    var axis = _e[_d];
                    for (var _f = 0, _g = axis.series; _f < _g.length; _f++) {
                        var series = _g[_f];
                        if (series === rowSeries && series.visible && this.rectSeriesInChart(series, isStack)) {
                            seriesCollection.push(series);
                        }
                    }
                }
            }
        }
        return seriesCollection;
    };
    /**
     * To get the column type series.
     *
     * @returns {void}
     * @private
     */
    Series.prototype.rectSeriesInChart = function (series, isStack) {
        var type = (series.type).toLowerCase();
        return (type.indexOf('column') !== -1 || type.indexOf('bar') !== -1 || type.indexOf('histogram') !== -1 ||
            type.indexOf('hiloopenclose') !== -1 || type.indexOf('candle') !== -1 || type.indexOf('pareto') !== -1 ||
            type.indexOf('hilo') !== -1 || series.drawType.indexOf('Column') !== -1 ||
            type.indexOf('waterfall') !== -1 || type.indexOf('boxandwhisker') !== -1 || isStack);
    };
    /**
     * To calculate the stacked values.
     *
     * @returns {void}
     * @private
     */
    Series.prototype.calculateStackedValue = function (isStacking100, chart) {
        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {
            var columnItem = _a[_i];
            for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {
                var item = _c[_b];
                this.calculateStackingValues(this.findSeriesCollection(columnItem, item, true), isStacking100);
            }
        }
    };
    Series.prototype.calculateStackingValues = function (seriesCollection, isStacking100) {
        var startValues;
        var endValues;
        var yValues = [];
        var lastPositive = [];
        var lastNegative = [];
        var stackingGroup;
        var lastValue;
        var value;
        var frequencies = [];
        if (isStacking100) {
            frequencies = this.findFrequencies(seriesCollection);
        }
        var groupingValues = [];
        var visiblePoints = [];
        for (var i = 0; i < seriesCollection.length; i++) {
            var series = seriesCollection[i];
            if (!groupingValues[series.stackingGroup]) {
                groupingValues[series.stackingGroup] = [];
                groupingValues[series.stackingGroup].push(series);
            }
            else if (groupingValues[series.stackingGroup] !== undefined) {
                groupingValues[series.stackingGroup].push(series);
            }
        }
        var keys = Object.keys(groupingValues);
        for (var k = 0; k < keys.length; k++) {
            var stackingSeies = [];
            var stackedValues = [];
            var seriesCollection_2 = groupingValues[keys[k]];
            for (var _i = 0, seriesCollection_1 = seriesCollection_2; _i < seriesCollection_1.length; _i++) {
                var series = seriesCollection_1[_i];
                if (series.type.indexOf('Stacking') !== -1 || (series.drawType.indexOf('Stacking') !== -1 &&
                    (series.chart.chartAreaType === 'PolarRadar'))) {
                    stackingGroup = (series.type.indexOf('StackingArea') !== -1) ? 'StackingArea100' :
                        (series.type.indexOf('StackingLine') !== -1) ? 'StackingLine100' : series.stackingGroup;
                    if (!lastPositive[stackingGroup]) {
                        lastPositive[stackingGroup] = [];
                        lastNegative[stackingGroup] = [];
                    }
                    yValues = series.yData;
                    startValues = [];
                    endValues = [];
                    stackingSeies.push(series);
                    visiblePoints = getVisiblePoints(series);
                    for (var j = 0, pointsLength = visiblePoints.length; j < pointsLength; j++) {
                        lastValue = 0;
                        value = +yValues[j]; // Fix for chart not rendering while y value is given as string issue
                        if (lastPositive[stackingGroup][visiblePoints[j].xValue] === undefined) {
                            lastPositive[stackingGroup][visiblePoints[j].xValue] = 0;
                        }
                        if (lastNegative[stackingGroup][visiblePoints[j].xValue] === undefined) {
                            lastNegative[stackingGroup][visiblePoints[j].xValue] = 0;
                        }
                        if (isStacking100) {
                            value = value / frequencies[stackingGroup][visiblePoints[j].xValue] * 100;
                            value = !isNaN(value) ? value : 0;
                            visiblePoints[j].percentage = +(value.toFixed(2));
                        }
                        else {
                            stackedValues[j] = stackedValues[j] ? stackedValues[j] + Math.abs(value) : Math.abs(value);
                        }
                        if (value >= 0) {
                            lastValue = lastPositive[stackingGroup][visiblePoints[j].xValue];
                            lastPositive[stackingGroup][visiblePoints[j].xValue] += value;
                        }
                        else {
                            lastValue = lastNegative[stackingGroup][visiblePoints[j].xValue];
                            lastNegative[stackingGroup][visiblePoints[j].xValue] += value;
                        }
                        startValues.push(lastValue);
                        endValues.push(value + lastValue);
                        if (isStacking100 && (endValues[j] > 100)) {
                            endValues[j] = 100;
                        }
                    }
                    series.stackedValues = new StackValues(startValues, endValues);
                    var isLogAxis = series.yAxis.valueType === 'Logarithmic';
                    var isColumnBarType = (series.type.indexOf('Column') !== -1 || series.type.indexOf('Bar') !== -1);
                    series.yMin = isLogAxis && isColumnBarType && series.yMin < 1 ? series.yMin : (series.yAxis.startFromZero && series.yAxis.rangePadding === 'Auto' && series.yMin >= 0) ? 0 : parseFloat((Math.min.apply(0, isStacking100 ? startValues : endValues)).toFixed(10));
                    series.yMax = Math.max.apply(0, endValues);
                    if (series.yMin > Math.min.apply(0, endValues)) {
                        series.yMin = (isStacking100) ? -100 :
                            isLogAxis && isColumnBarType && series.yMin < 1 ? series.yMin : Math.min.apply(0, endValues);
                    }
                    if (series.yMax < Math.max.apply(0, startValues)) {
                        series.yMax = 0;
                    }
                }
            }
            this.findPercentageOfStacking(stackingSeies, stackedValues, isStacking100);
        }
    };
    Series.prototype.findPercentageOfStacking = function (stackingSeies, values, isStacking100) {
        for (var _i = 0, stackingSeies_1 = stackingSeies; _i < stackingSeies_1.length; _i++) {
            var item = stackingSeies_1[_i];
            if (isStacking100) {
                return null;
            }
            for (var _a = 0, _b = getVisiblePoints(item); _a < _b.length; _a++) {
                var point = _b[_a];
                point.percentage = Math.abs(+(point.y / values[point.index] * 100).toFixed(2));
            }
        }
    };
    Series.prototype.findFrequencies = function (seriesCollection) {
        var frequencies = [];
        var stackingGroup;
        var visiblePoints = [];
        for (var _i = 0, seriesCollection_3 = seriesCollection; _i < seriesCollection_3.length; _i++) {
            var series = seriesCollection_3[_i];
            series.yAxis.isStack100 = series.type.indexOf('100') !== -1 ? true : false;
            visiblePoints = getVisiblePoints(series);
            if (series.type.indexOf('Stacking') !== -1) {
                stackingGroup = (series.type.indexOf('StackingArea') !== -1) ? 'StackingArea100' :
                    (series.type.indexOf('StackingLine') !== -1) ? 'StackingLine100' : series.stackingGroup;
                if (!frequencies[stackingGroup]) {
                    frequencies[stackingGroup] = [];
                }
                for (var j = 0, pointsLength = visiblePoints.length; j < pointsLength; j++) {
                    if (frequencies[stackingGroup][visiblePoints[j].xValue] === undefined) {
                        frequencies[stackingGroup][visiblePoints[j].xValue] = 0;
                    }
                    if (series.yData[j] > 0) {
                        frequencies[stackingGroup][visiblePoints[j].xValue] += series.yData[j];
                    }
                    else {
                        frequencies[stackingGroup][visiblePoints[j].xValue] -= series.yData[j];
                    }
                }
            }
        }
        return frequencies;
    };
    /* private dataManagerFailure(e: { result: Object[] }): void {
         this.currentViewData = [];
         this.refreshChart();
     }*/
    /** @private */
    Series.prototype.renderSeries = function (chart) {
        if (this.chart.stockChart && this.xAxis.valueType === 'DateTimeCategory') {
            for (var i = 0; i < this.points.length; i++) {
                var index = this.xAxis.labels.indexOf(Date.parse(this.points[i].x.toString()).toString());
                this.points[i].xValue = index;
                if (chart.series.length > 1) {
                    this.xData[i] = index;
                    this.xMin = (this.xMin > index) ? index : this.xMin;
                    this.xMax = (this.xMax < index) ? index : this.xMax;
                }
            }
            if (this instanceof Series && this.type.indexOf('Spline') > -1) {
                var isArea = this.type.indexOf('Area') > -1;
                var isRange = this.type.indexOf('Range') > -1;
                this.chart['spline' + (isArea ? isRange ? 'RangeArea' : 'Area' : '') + 'SeriesModule'].findSplinePoint(this);
            }
        }
        var seriesType = firstToLowerCase(this.type);
        seriesType = seriesType.replace('100', '');
        if (chart[seriesType + 'SeriesModule']) {
            if (this.category !== 'Indicator' && this.category !== 'TrendLine') {
                this.createSeriesElements(chart);
            }
            this.visiblePoints = getVisiblePoints(this);
            chart[seriesType + 'SeriesModule'].render(this, this.xAxis, this.yAxis, chart.requireInvertedAxis);
            if (this.category !== 'Indicator') {
                if (this.errorBar.visible) {
                    this.chart.errorBarModule.render(this);
                }
                if (this.marker.dataLabel.visible) {
                    chart.dataLabelModule.render(this, this.chart, this.marker.dataLabel);
                }
                this.appendSeriesElement(chart.seriesElements, chart);
            }
            if (!this.chart.enableCanvas) {
                this.performAnimation(chart, seriesType, this.errorBar, this.marker, this.marker.dataLabel);
            }
        }
    };
    /**
     * To create seris element.
     *
     * @returns {void}
     * @private
     */
    Series.prototype.createSeriesElements = function (chart) {
        if (this.category !== 'Indicator') {
            var elementId = chart.element.id;
            // 8 for extend border value 5 for extend size value
            var explodeValue = this.marker.border.width + 8 + 5;
            var render = (this.type === 'Bubble') || (!this.marker.visible && chart.tooltip.shared && chart.enableCanvas) ?
                chart.svgRenderer : chart.renderer;
            var index = this.index === undefined ? this.category : this.index;
            var markerHeight = void 0;
            var markerWidth = void 0;
            var options = void 0;
            if (this.type === 'Scatter' || this.drawType === 'Scatter') {
                markerHeight = (this.marker.height + explodeValue) / 2;
                markerWidth = (this.marker.width + explodeValue) / 2;
            }
            else {
                markerHeight = 0;
                markerWidth = 0;
            }
            if (chart.chartAreaType === 'PolarRadar') {
                var markerMaxValue = (this.drawType === 'Scatter') ? Math.max(this.marker.width, this.marker.height) : 0;
                options = new CircleOption(elementId + '_ChartSeriesClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, this.clipRect.width / 2 + this.clipRect.x, this.clipRect.height / 2 + this.clipRect.y, chart.radius + markerMaxValue);
                this.clipRectElement = appendClipElement(chart.redraw, options, render, 'drawCircularClipPath');
            }
            else {
                options = new RectOption(elementId + '_ChartSeriesClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, {
                    x: (this.xAxis.columnIndex === 0) ? -markerWidth : 0, y: (this.yAxis.rowIndex === chart.rows.length - 1) ? -markerHeight : 0,
                    width: this.clipRect.width + (this.xAxis.columnIndex === chart.columns.length - 1 ? markerWidth * 2 : markerWidth),
                    height: this.clipRect.height + (this.yAxis.rowIndex === 0 ? markerHeight * 2 : markerHeight)
                });
                this.clipRectElement = appendClipElement(chart.redraw, options, render);
            }
            var transform = chart.chartAreaType === 'Cartesian' ? 'translate(' + this.clipRect.x + ',' + (this.clipRect.y) + ')' : '';
            this.symbolElement = null;
            this.seriesElement = render.createGroup({
                'id': elementId + 'SeriesGroup' + index,
                'transform': transform,
                'clip-path': 'url(#' + elementId + '_ChartSeriesClipRect_' + index + ')'
            });
            if (this.seriesElement) {
                this.seriesElement.setAttribute('role', 'region');
                this.seriesElement.setAttribute('aria-label', (this.name + ',' + this.type + ' series with ' + this.points.length + ' data points'));
                this.seriesElement.setAttribute('aria-hidden', 'false');
            }
            if (!this.chart.enableCanvas || this.type === 'Bubble') {
                this.seriesElement.setAttribute('tabindex', index === 0 ? '0' : !this.checkTabindex(chart.visibleSeries, index) ? '0' : '');
                this.seriesElement.setAttribute('style', 'outline: none');
                this.seriesElement.appendChild(this.clipRectElement);
            }
        }
    };
    Series.prototype.checkTabindex = function (visibleSeries, index) {
        for (var i = 0; i < index; i++) {
            if (visibleSeries[i].visible)
                return true;
        }
        return false;
    };
    /**
     * To append the series.
     *
     * @returns {void}
     * @private
     */
    Series.prototype.appendSeriesElement = function (element, chart) {
        var marker = this.marker;
        var dataLabel = marker.dataLabel;
        var redraw = chart.redraw;
        if (this.category !== 'TrendLine') {
            appendChildElement(chart.enableCanvas, chart.seriesElements, this.seriesElement, redraw);
            var errorBar = this.errorBar;
            if (errorBar.visible) {
                if (chart.chartAreaType === 'PolarRadar') {
                    appendChildElement(chart.enableCanvas, chart.seriesElements, this.seriesElement, redraw);
                }
                else {
                    appendChildElement(chart.enableCanvas, chart.seriesElements, this.errorBarElement, redraw);
                }
            }
        }
        if (marker.visible && (chart.chartAreaType === 'Cartesian' ||
            ((this.drawType !== 'Scatter') && chart.chartAreaType === 'PolarRadar')) && this.type !== 'Scatter' &&
            this.type !== 'Bubble' && this.type !== 'Candle' && this.type !== 'Hilo' && this.type !== 'HiloOpenClose' && this.symbolElement) {
            appendChildElement(chart.enableCanvas, chart.seriesElements, this.symbolElement, redraw);
        }
        if (dataLabel.visible && this.textElement) {
            appendChildElement(chart.enableCanvas, chart.dataLabelElements, this.shapeElement, redraw);
            appendChildElement(chart.enableCanvas, chart.dataLabelElements, this.textElement, redraw);
        }
        if (!chart.enableCanvas && chart.dataLabelElements.hasChildNodes()) {
            chart.seriesElements.appendChild(chart.dataLabelElements);
        }
    };
    /**
     * To perform animation for chart series.
     *
     * @returns {void}
     * @private
     */
    Series.prototype.performAnimation = function (chart, type, errorBar, marker, dataLabel) {
        if (((this.animation.enable && animationMode != 'Disable') || animationMode === 'Enable') && chart.animateSeries && (!chart.stockChart || !chart.stockChart.isStockChartRendered)) {
            chart[type + 'SeriesModule'].doAnimation(this);
            if (errorBar.visible) {
                chart.errorBarModule.doErrorBarAnimation(this);
            }
            if (marker.visible) {
                chart.markerRender.doMarkerAnimation(this);
            }
            //to datalabel animation disabled for edge and IE
            if (dataLabel.visible && Browser.info.name !== 'edge' && !Browser.isIE) {
                chart.dataLabelModule.doDataLabelAnimation(this);
            }
        }
    };
    /**
     * To set border color for empty point
     *
     * @private
     */
    Series.prototype.setPointColor = function (point, color) {
        color = point.interior || color;
        return point.isEmpty ? (this.emptyPointSettings.fill || color) : color;
    };
    /**
     * To set border color for empty point
     *
     * @private
     */
    Series.prototype.setBorderColor = function (point, border) {
        border.width = point.isEmpty ? (this.emptyPointSettings.border.width || border.width) : border.width;
        border.color = point.isEmpty ? (this.emptyPointSettings.border.color || border.color) : border.color;
        return border;
    };
    __decorate$4([
        Property('')
    ], Series.prototype, "name", void 0);
    __decorate$4([
        Property('')
    ], Series.prototype, "yName", void 0);
    __decorate$4([
        Property('Line')
    ], Series.prototype, "drawType", void 0);
    __decorate$4([
        Property(true)
    ], Series.prototype, "isClosed", void 0);
    __decorate$4([
        Property(null)
    ], Series.prototype, "bearFillColor", void 0);
    __decorate$4([
        Property(null)
    ], Series.prototype, "bullFillColor", void 0);
    __decorate$4([
        Property(false)
    ], Series.prototype, "enableSolidCandles", void 0);
    __decorate$4([
        Property('')
    ], Series.prototype, "size", void 0);
    __decorate$4([
        Property(null)
    ], Series.prototype, "binInterval", void 0);
    __decorate$4([
        Property(false)
    ], Series.prototype, "showNormalDistribution", void 0);
    __decorate$4([
        Property('')
    ], Series.prototype, "stackingGroup", void 0);
    __decorate$4([
        Complex({ color: null, width: 0 }, Border)
    ], Series.prototype, "border", void 0);
    __decorate$4([
        Property(1)
    ], Series.prototype, "opacity", void 0);
    __decorate$4([
        Property(0)
    ], Series.prototype, "zOrder", void 0);
    __decorate$4([
        Property('')
    ], Series.prototype, "groupName", void 0);
    __decorate$4([
        Property('Line')
    ], Series.prototype, "type", void 0);
    __decorate$4([
        Complex(null, ErrorBarSettings)
    ], Series.prototype, "errorBar", void 0);
    __decorate$4([
        Complex(null, MarkerSettings)
    ], Series.prototype, "marker", void 0);
    __decorate$4([
        Complex(null, ParetoOptions)
    ], Series.prototype, "paretoOptions", void 0);
    __decorate$4([
        Complex({}, DragSettings)
    ], Series.prototype, "dragSettings", void 0);
    __decorate$4([
        Collection([], Trendline)
    ], Series.prototype, "trendlines", void 0);
    __decorate$4([
        Property(true)
    ], Series.prototype, "enableTooltip", void 0);
    __decorate$4([
        Property('')
    ], Series.prototype, "tooltipFormat", void 0);
    __decorate$4([
        Property('')
    ], Series.prototype, "tooltipMappingName", void 0);
    __decorate$4([
        Property('SeriesType')
    ], Series.prototype, "legendShape", void 0);
    __decorate$4([
        Property('')
    ], Series.prototype, "legendImageUrl", void 0);
    __decorate$4([
        Property(null)
    ], Series.prototype, "selectionStyle", void 0);
    __decorate$4([
        Property(null)
    ], Series.prototype, "unSelectedStyle", void 0);
    __decorate$4([
        Property(null)
    ], Series.prototype, "nonHighlightStyle", void 0);
    __decorate$4([
        Property(1)
    ], Series.prototype, "minRadius", void 0);
    __decorate$4([
        Property(3)
    ], Series.prototype, "maxRadius", void 0);
    __decorate$4([
        Property('Natural')
    ], Series.prototype, "splineType", void 0);
    __decorate$4([
        Property(0.5)
    ], Series.prototype, "cardinalSplineTension", void 0);
    __decorate$4([
        Complex(null, EmptyPointSettings)
    ], Series.prototype, "emptyPointSettings", void 0);
    __decorate$4([
        Property(true)
    ], Series.prototype, "showMean", void 0);
    __decorate$4([
        Property('Normal')
    ], Series.prototype, "boxPlotMode", void 0);
    __decorate$4([
        Property(null)
    ], Series.prototype, "columnWidth", void 0);
    __decorate$4([
        Property(null)
    ], Series.prototype, "columnWidthInPixel", void 0);
    __decorate$4([
        Property('Rectangle')
    ], Series.prototype, "columnFacet", void 0);
    __decorate$4([
        Property(0)
    ], Series.prototype, "columnSpacing", void 0);
    __decorate$4([
        Property('#C64E4A')
    ], Series.prototype, "negativeFillColor", void 0);
    __decorate$4([
        Property('#4E81BC')
    ], Series.prototype, "summaryFillColor", void 0);
    __decorate$4([
        Property()
    ], Series.prototype, "intermediateSumIndexes", void 0);
    __decorate$4([
        Property()
    ], Series.prototype, "sumIndexes", void 0);
    __decorate$4([
        Property('Left')
    ], Series.prototype, "step", void 0);
    __decorate$4([
        Complex({ color: 'black', width: 2 }, Connector)
    ], Series.prototype, "connector", void 0);
    __decorate$4([
        Complex(null, CornerRadius)
    ], Series.prototype, "cornerRadius", void 0);
    return Series;
}(SeriesBase));

/**
 * data module is used to generate query and dataSource
 */
var Data = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for data module
     *
     * @param dataSource
     * @param query
     * @param dataSource
     * @param query
     * @private
     */
    function Data(dataSource, query) {
        this.initDataManager(dataSource, query);
    }
    /**
     * The function used to initialize dataManager and query
     *
     * @param dataSource
     * @param query
     * @param dataSource
     * @param query
     * @returns {void}
     * @private
     */
    Data.prototype.initDataManager = function (dataSource, query) {
        this.dataManager = dataSource instanceof DataManager ? dataSource : new DataManager(dataSource);
        this.query = query instanceof Query ? query : new Query();
    };
    /**
     * The function used to generate updated Query from chart model
     *
     * @returns {void}
     * @private
     */
    Data.prototype.generateQuery = function () {
        var query = this.query.clone();
        return query;
    };
    /**
     * The function used to get dataSource by executing given Query
     *
     * @param  {Query} query - A Query that specifies to generate dataSource
     * @returns {void}
     * @private
     */
    Data.prototype.getData = function (dataQuery) {
        var _this = this;
        if (this.dataManager.ready) {
            var dataManagerDeferred_1 = new Deferred();
            var ready = this.dataManager.ready;
            ready.then(function () {
                _this.dataManager.executeQuery(dataQuery).then(function (result) {
                    dataManagerDeferred_1.resolve(result);
                });
            }).catch(function (e) { dataManagerDeferred_1.reject(e); });
            return dataManagerDeferred_1.promise;
        }
        else {
            return this.dataManager.executeQuery(dataQuery);
        }
    };
    return Data;
}());

var __extends$7 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/check-param-names */
/* eslint-disable jsdoc/require-param-type */
/* eslint-disable jsdoc/require-param */
/* eslint-disable jsdoc/require-param-description */
/* eslint-disable valid-jsdoc */
/**
 * Marker Module used to render the marker for line type series.
 */
var MarkerExplode = /** @__PURE__ @class */ (function (_super) {
    __extends$7(MarkerExplode, _super);
    /**
     * Constructor for the marker module.
     *
     * @private
     */
    function MarkerExplode(chart) {
        var _this = _super.call(this, chart) || this;
        _this.elementId = chart.element.id;
        _this.commonXvalues = [];
        return _this;
    }
    /**
     * @hidden
     */
    MarkerExplode.prototype.addEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
        this.chart.on(Browser.touchEndEvent, this.mouseUpHandler, this);
    };
    /**
     * @hidden
     */
    MarkerExplode.prototype.removeEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.off(Browser.touchMoveEvent, this.mouseMoveHandler);
        this.chart.off(Browser.touchEndEvent, this.mouseUpHandler);
    };
    /**
     * @hidden
     */
    MarkerExplode.prototype.mouseUpHandler = function () {
        var chart = this.chart;
        if (chart.isTouch && !chart.crosshair.enable && !this.isSelected(chart)) {
            this.markerMove(true);
        }
    };
    /**
     * @hidden
     */
    MarkerExplode.prototype.mouseMoveHandler = function () {
        var chart = this.chart;
        if ((chart.highlightMode !== 'None' || (chart.tooltip.enable)) && (!chart.isTouch || chart.startMove) && !this.isSelected(chart)) {
            this.markerMove(false);
        }
    };
    MarkerExplode.prototype.markerMove = function (remove$$1) {
        var _this = this;
        var chart = this.chart;
        this.currentPoints = [];
        var data;
        var previous;
        var explodeSeries;
        var series;
        if (!chart.tooltip.shared || !chart.tooltip.enable) {
            data = this.getData();
            series = data.series;
            previous = this.previousPoints[0];
            explodeSeries = series && ((series.type === 'Bubble' || series.drawType === 'Scatter' || series.type === 'Scatter') ||
                (((series.type !== 'Candle') && (series.type !== 'Hilo') && (series.type !== 'HiloOpenClose')) &&
                    (series.marker.visible && series.marker.width !== 0 && series.marker.height !== 0)));
            data.lierIndex = this.lierIndex;
            if (data.point && explodeSeries && ((!previous || (previous.point !== data.point)) ||
                (previous && previous.lierIndex > 3 && previous.lierIndex !== this.lierIndex))) {
                this.currentPoints.push(data);
            }
            if (data.point && explodeSeries && chart.isPointMouseDown) {
                this.currentPoints.push(data);
            }
        }
        else {
            if (!withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {
                return null;
            }
            if (chart.tooltip.enable) {
                var pointData = chart.chartAreaType === 'PolarRadar' ? this.getData() : null;
                if (!this.chart.tooltip.showNearestPoint) {
                    this.currentPoints = this.chart.tooltipModule.currentPoints;
                }
                else {
                    for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
                        var chartSeries = _a[_i];
                        if (!chartSeries.enableTooltip || chartSeries.category === 'Indicator') {
                            continue;
                        }
                        if (chart.chartAreaType === 'Cartesian' && chartSeries.visible) {
                            data = this.getClosestX(chart, chartSeries, this.commonXValue(this.chart.visibleSeries));
                        }
                        else if (chart.chartAreaType === 'PolarRadar' && chartSeries.visible && pointData.point !== null) {
                            data = new PointData(chartSeries.points[pointData.point.index], chartSeries);
                        }
                        if (data) {
                            this.currentPoints.push(data);
                            data = null;
                        }
                    }
                }
            }
        }
        var length = this.previousPoints.length;
        if (this.currentPoints.length > 0 || (length > 0 && chart.tooltip.shared)) {
            if (length === 0 || chart.isPointMouseDown || (length > 0 && (this.currentPoints.length == 0 || (this.previousPoints[0].point !== this.currentPoints[0].point)))) {
                if (length > 0) {
                    for (var _b = 0, _c = this.previousPoints; _b < _c.length; _b++) {
                        var previousPoint = _c[_b];
                        if (!isNullOrUndefined(previousPoint)) {
                            this.removeHighlightedMarker(previousPoint.series, previousPoint.point);
                        }
                    }
                }
                var _loop_1 = function (data_1) {
                    if ((data_1 && data_1.point) || ((series.type !== 'Candle') &&
                        (series.type !== 'Hilo') && (series.type !== 'HiloOpenClose'))) {
                        stopTimer(this_1.markerExplode);
                        this_1.isRemove = true;
                        data_1.point.symbolLocations.map(function (location, index) {
                            if (data_1.series.marker.allowHighlight && (!data_1.series.isRectSeries || data_1.point.marker.visible)) {
                                _this.drawTrackBall(data_1.series, data_1.point, location, index);
                            }
                        });
                    }
                };
                var this_1 = this;
                for (var _d = 0, _e = this.currentPoints; _d < _e.length; _d++) {
                    var data_1 = _e[_d];
                    _loop_1(data_1);
                }
                this.previousPoints = extend([], this.currentPoints, null, true);
            }
        }
        if (!chart.tooltip.enable && ((this.currentPoints.length === 0 && this.isRemove) || (remove$$1 && this.isRemove) ||
            !withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect))) {
            this.isRemove = false;
            if (!isNullOrUndefined(this.previousPoints[0])) {
                this.markerExplode = +setTimeout(function () {
                    if (_this.previousPoints[0]) {
                        _this.removeHighlightedMarker(_this.previousPoints[0].series, _this.previousPoints[0].point);
                    }
                }, 2000);
            }
        }
        this.currentPoints = [];
    };
    MarkerExplode.prototype.animationDuration = function () {
        var duration = 200;
        if (this.chart.maxPointCount > 100) {
            duration = 10;
        }
        else if (this.chart.maxPointCount > 50) {
            duration = 100;
        }
        return duration;
    };
    MarkerExplode.prototype.drawTrackBall = function (series, point, location, index) {
        var marker = point.marker;
        var seriesMarker = series.marker;
        var shape = marker.shape || seriesMarker.shape || 'Circle';
        var svg;
        if (shape === 'None' || shape === 'Image') {
            return null;
        }
        var element = series.symbolElement || series.seriesElement;
        var className;
        if (this.chart.highlightModule && this.chart.highlightMode !== 'None') {
            className = this.chart.highlightModule.generateStyle(series);
        }
        if (this.chart.selectionModule && this.chart.selectionMode !== 'None') {
            className = this.chart.selectionModule.generateStyle(series);
        }
        var symbolId = this.elementId + '_Series_' + series.index + '_Point_' + point.index + '_Trackball' +
            (index ? index : '');
        var size = new Size((marker.width || seriesMarker.width) + 3, (marker.height || seriesMarker.height) + 3);
        var border = (marker.border || series.border);
        var explodeSeries = (series.type === 'BoxAndWhisker' || series.type === 'Bubble' || series.type === 'Scatter');
        var borderColor = (border.color && border.color !== 'transparent') ? border.color :
            marker.fill || point.interior || (explodeSeries ? point.color : series.interior);
        var colorValue = convertHexToColor(colorNameToHex(borderColor));
        var borderWidth = marker.border ? marker.border.width : seriesMarker.border.width;
        var markerShadow = series.chart.themeStyle.markerShadow ||
            'rgba(' + colorValue.r + ',' + colorValue.g + ',' + colorValue.b + ',0.2)';
        var markerElement = document.getElementById(this.elementId + '_Series_' + series.index + '_Point_' +
            point.index + '_Symbol');
        if (!isNullOrUndefined(markerElement)) {
            markerElement.setAttribute('visibility', 'hidden');
        }
        if (this.chart.enableCanvas) {
            var trackElement = document.getElementById(this.chart.element.id + '_Secondary_Element');
            svg = this.chart.svgRenderer.createSvg({
                id: this.chart.element.id + '_trackball_svg',
                width: this.chart.availableSize.width,
                height: this.chart.availableSize.height
            });
            svg.style.cssText = 'position: absolute; pointer-events: none';
            trackElement.appendChild(svg);
        }
        for (var i = 0; i < 2; i++) {
            var options = new PathOption(symbolId + '_' + i, i ? (marker.fill || point.color || (explodeSeries ? series.interior : '#ffffff')) : 'transparent', borderWidth + (i ? 0 : 8), i ? borderColor : markerShadow, (marker.opacity || seriesMarker.opacity), null, null);
            var symbol = drawSymbol(location, shape, size, marker.imageUrl, options, '', this.chart.svgRenderer, series.clipRect);
            // incident: 252450 point click selection not working while maker explode
            //symbol.setAttribute('style', 'pointer-events:none');
            symbol.setAttribute('class', this.elementId + '_EJ2-Trackball_Series_' + series.index + '_Point_' + point.index);
            var selectionId = element.id.indexOf('Symbol') !== -1 ? '_Symbol' : '';
            var seletionElem = document.getElementById(this.elementId + '_Series_' + series.index + '_Point_' +
                point.index + selectionId);
            if (className !== '' && !isNullOrUndefined(className) && !isNullOrUndefined(seletionElem) &&
                seletionElem.hasAttribute('class') && (className === seletionElem.getAttribute('class'))) {
                symbol.classList.add(className);
            }
            symbol.setAttribute('clip-path', element.getAttribute('clip-path'));
            symbol.setAttribute('transform', element.getAttribute('transform'));
            if (this.chart.enableCanvas) {
                svg.appendChild(symbol);
            }
            else {
                this.chart.svgObject.appendChild(symbol);
            }
        }
        this.doAnimation(series, point, false);
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    MarkerExplode.prototype.doAnimation = function (series, point, endAnimate) {
        if (endAnimate === void 0) { endAnimate = false; }
        var duration = this.animationDuration();
        var delay = series.animation.delay;
        var rectElements = document.getElementsByClassName(this.elementId + '_EJ2-Trackball_Series_' + series.index + '_Point_' + point.index);
        for (var i = 0, len = rectElements.length; i < len; i++) {
            this.trackballAnimate(rectElements[i], delay, duration, series, point.index, point.symbolLocations[0], false, endAnimate);
        }
    };
    /**
     * Animation Effect Calculation End
     *
     * @private
     */
    MarkerExplode.prototype.trackballAnimate = function (elements, delays, durations, series, pointIndex, point, isLabel, endAnimate) {
        var centerX = point.x;
        var centerY = point.y;
        var clipX = (series.type !== 'Polar' && series.type !== 'Radar') ? series.clipRect.x : 0;
        var clipY = (series.type !== 'Polar' && series.type !== 'Radar') ? series.clipRect.y : 0;
        var height = 0;
        //(<HTMLElement>elements).style.visibility = 'hidden';
        var transform = elements.getAttribute('transform');
        new Animation({}).animate(elements, {
            duration: durations,
            delay: delays,
            progress: function (args) {
                if (args.timeStamp > args.delay) {
                    args.element.style.visibility = 'visible';
                    height = ((args.timeStamp - args.delay) / args.duration);
                    elements.setAttribute('transform', 'translate(' + (centerX + clipX)
                        + ' ' + (centerY + clipY) + ') scale(1) translate(' + (-centerX) + ' ' + (-centerY) + ')');
                }
            },
            end: function () {
                elements.style.visibility = '';
                elements.setAttribute('transform', transform);
                if (!isLabel && (pointIndex === series.points.length - 1)) {
                    series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });
                }
                if (endAnimate) {
                    remove(elements);
                }
            }
        });
    };
    /**
     * @param series
     * @param point
     * @param fadeOut
     * @param series
     * @param point
     * @param fadeOut
     * @param series
     * @param point
     * @param fadeOut
     * @hidden
     */
    MarkerExplode.prototype.removeHighlightedMarker = function (series, point, fadeOut) {
        if (series === void 0) { series = null; }
        if (point === void 0) { point = null; }
        if (fadeOut === void 0) { fadeOut = false; }
        if (!isNullOrUndefined(series) && !isNullOrUndefined(point)) {
            var markerElement = document.getElementById(this.elementId + '_Series_' + series.index + '_Point_' +
                point.index + '_Symbol');
            var trackballElements = document.getElementsByClassName(this.elementId + '_EJ2-Trackball_Series_' + series.index + '_Point_' + point.index);
            for (var i = 0, len = trackballElements.length; i < len; i++) {
                remove(trackballElements[0]);
            }
            if (!isNullOrUndefined(markerElement)) {
                markerElement.setAttribute('visibility', 'visible');
            }
        }
        else {
            for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
                var point_1 = _a[_i];
                var elements = document.getElementsByClassName(this.elementId + '_EJ2-Trackball_Series_' + series.index + '_Point_' + point_1.index);
                var markerElement = document.getElementById(this.elementId + '_Series_' + series.index + '_Point_' +
                    point_1.index + '_Symbol');
                for (var i = 0, len = elements.length; i < len; i++) {
                    if (!isNullOrUndefined(markerElement)) {
                        markerElement.setAttribute('visibility', 'visible');
                    }
                    remove(elements[0]);
                }
            }
        }
        if (fadeOut) {
            this.previousPoints = [];
        }
    };
    return MarkerExplode;
}(ChartData));

var __extends$6 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
var markerShapes = ["Circle", "Triangle", "Diamond", "Rectangle", "Pentagon", "InvertedTriangle", "VerticalLine", "Cross", "Plus", "HorizontalLine"];
/**
 * Marker module used to render the marker for line type series.
 */
var Marker = /** @__PURE__ @class */ (function (_super) {
    __extends$6(Marker, _super);
    /**
     * Constructor for the marker module.
     *
     * @private
     */
    function Marker(chart) {
        var _this = _super.call(this, chart) || this;
        _this.addEventListener();
        return _this;
    }
    /**
     * Render the marker for series.
     *
     * @returns {void}
     * @private
     */
    Marker.prototype.render = function (series) {
        var _this = this;
        var redraw = series.chart.redraw;
        this.createElement(series, redraw);
        var _loop_1 = function (point) {
            if (point.visible && point.symbolLocations && point.symbolLocations.length) {
                point.symbolLocations.map(function (location, index) {
                    if (series.marker.shape !== 'None') {
                        _this.renderMarker(series, point, location, index, redraw);
                    }
                });
            }
        };
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var point = _a[_i];
            _loop_1(point);
        }
    };
    Marker.prototype.renderMarker = function (series, point, location, index, redraw) {
        var seriesIndex = series.index === undefined ? series.category : series.index;
        var marker = series.marker;
        series.marker.shape = series.marker.shape ? series.marker.shape : markerShapes[seriesIndex % 10];
        var border = {
            color: marker.border.color,
            width: marker.border.width
        };
        var borderColor = marker.border.color;
        var previousLocation;
        var previousPath;
        var circlePath;
        var shapeOption;
        location.x = location.x + marker.offset.x;
        location.y = location.y - marker.offset.y;
        var isBoxPlot = series.type === 'BoxAndWhisker';
        var fill = marker.fill || ((isBoxPlot || series.marker.isFilled) ? point.interior || series.interior : '#ffffff');
        var markerElement;
        var parentElement = isBoxPlot ?
            findlElement(series.seriesElement.childNodes, 'Series_' + series.index + '_Point_' + point.index)
            : series.symbolElement;
        border.color = borderColor || series.setPointColor(point, series.interior);
        var symbolId = this.elementId + '_Series_' + seriesIndex + '_Point_' + point.index + '_Symbol' +
            (index ? index : '');
        var argsData = {
            cancel: false, name: pointRender, series: series, point: point,
            fill: point.isEmpty ? (series.emptyPointSettings.fill || fill) : fill,
            border: {
                color: series.type === 'BoxAndWhisker' ?
                    (!isNullOrUndefined(borderColor) && borderColor !== 'transparent') ? borderColor :
                        getSaturationColor(fill, -0.6)
                    : border.color,
                width: border.width
            },
            height: marker.height, width: marker.width, shape: marker.shape
        };
        argsData.border = series.setBorderColor(point, { width: argsData.border.width, color: argsData.border.color });
        if (!series.isRectSeries || series.type === 'BoxAndWhisker') {
            this.chart.trigger(pointRender, argsData);
            point.color = argsData.fill;
        }
        point.color = argsData.fill;
        if (!argsData.cancel) {
            var y = void 0;
            if (series.type === 'RangeArea' || series.type === 'RangeColumn' || series.drawType === 'RangeColumn'
                || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea') {
                y = index ? point.low : point.high;
            }
            else if (isBoxPlot) {
                y = point.outliers[index];
            }
            else {
                y = point.y;
            }
            var markerFill = argsData.point.marker.fill || argsData.fill;
            var markerBorder = void 0;
            if (!isNullOrUndefined(argsData.point.marker.border)) {
                markerBorder = {
                    color: argsData.point.marker.border.color || argsData.border.color,
                    width: argsData.point.marker.border.width || argsData.border.width
                };
            }
            else {
                markerBorder = { color: argsData.border.color, width: argsData.border.width };
            }
            var markerWidth = argsData.point.marker.width || argsData.width;
            var markerHeight = argsData.point.marker.height || argsData.height;
            var markerOpacity = argsData.point.marker.opacity || marker.opacity;
            var markerShape = argsData.point.marker.shape || argsData.shape;
            var imageURL = argsData.point.marker.imageUrl || marker.imageUrl;
            shapeOption = new PathOption(symbolId, markerFill, markerBorder.width, markerBorder.color, markerOpacity, null);
            if ((parentElement !== undefined && parentElement !== null) || this.chart.enableCanvas) {
                if (redraw && getElement$1(shapeOption.id)) {
                    markerElement = getElement$1(shapeOption.id);
                    circlePath = markerShape === 'Circle' ? 'c' : '';
                    previousLocation = {
                        x: +markerElement.getAttribute(circlePath + 'x'), y: +markerElement.getAttribute(circlePath + 'y')
                    };
                    previousPath = markerElement.getAttribute('d');
                }
                markerElement = drawSymbol(location, markerShape, new Size(markerWidth, markerHeight), imageURL, shapeOption, point.x.toString() + ':' + y.toString(), this.chart.renderer, series.clipRect);
                if (markerElement) {
                    markerElement.setAttribute('role', 'img');
                    markerElement.setAttribute('aria-label', (point.x + ': ' + point.y + ', ' + series.name));
                }
                appendChildElement(this.chart.enableCanvas, parentElement, markerElement, redraw, true, circlePath + 'x', circlePath + 'y', previousLocation, previousPath, false, false, null, series.chart.duration);
            }
            point.marker = {
                border: markerBorder, fill: markerFill, height: markerHeight,
                visible: true, shape: markerShape, width: markerWidth, imageUrl: imageURL
            };
        }
        else {
            location = null;
            point.marker = {
                visible: false
            };
        }
    };
    Marker.prototype.createElement = function (series, redraw) {
        var markerClipRect;
        var marker = series.marker;
        // 8 for extend border value 5 for extend size value
        var explodeValue = marker.border.width + 8 + 5;
        var render = series.chart.svgRenderer;
        var index = series.index === undefined ? series.category : series.index;
        var options;
        var transform = series.chart.chartAreaType === 'Cartesian' ? 'translate(' + series.clipRect.x + ',' + (series.clipRect.y) + ')' : '';
        if (marker.visible) {
            var markerHeight = (marker.height + explodeValue) / 2;
            var markerWidth = (marker.width + explodeValue) / 2;
            if (series.chart.chartAreaType === 'Cartesian') {
                var isZoomed = series.xAxis.zoomFactor < 1 || series.xAxis.zoomPosition > 0;
                options = new RectOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, {
                    x: isZoomed ? 0 : -markerWidth, y: -markerHeight,
                    width: series.clipRect.width + (isZoomed ? 0 : markerWidth * 2),
                    height: series.clipRect.height + markerHeight * 2
                });
                markerClipRect = appendClipElement(redraw, options, render);
            }
            else {
                options = new CircleOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, series.clipRect.width / 2 + series.clipRect.x, series.clipRect.height / 2 + series.clipRect.y, series.chart.radius + Math.max(markerHeight, markerWidth));
                markerClipRect = appendClipElement(redraw, options, render, 'drawCircularClipPath');
            }
            options = {
                'id': this.elementId + 'SymbolGroup' + index,
                'transform': transform,
                'clip-path': 'url(#' + this.elementId + '_ChartMarkerClipRect_' + index + ')'
            };
            series.symbolElement = render.createGroup(options);
            series.symbolElement.appendChild(markerClipRect);
            if (this.chart.enableCanvas) {
                var element = document.getElementById(this.chart.element.id + '_tooltip_svg');
                element.appendChild(series.symbolElement);
            }
        }
    };
    Marker.prototype.getRangeLowPoint = function (region, series) {
        var x = region.x;
        var y = region.y;
        if (series.chart.requireInvertedAxis) {
            y += region.height / 2;
            x += series.yAxis.isAxisInverse ? region.width : 0;
        }
        else {
            y += series.yAxis.isAxisInverse ? 0 : region.height;
            x += region.width / 2;
        }
        return { x: x, y: y };
    };
    /**
     * Animates the marker.
     *
     * @returns {void}
     * @private
     */
    Marker.prototype.doMarkerAnimation = function (series) {
        if (!(series.type === 'Scatter' || series.type === 'Bubble' || series.type === 'Candle' || series.type === 'Hilo' ||
            series.type === 'HiloOpenClose' || (series.chart.chartAreaType === 'PolarRadar' && (series.drawType === 'Scatter')))) {
            var markerElements = series.symbolElement.childNodes;
            var delay = series.animation.delay + (series.animation.duration === 0 && animationMode === 'Enable' ? 1000 : series.animation.duration);
            var duration = series.chart.animated ? series.chart.duration : 200;
            var j = 1;
            var incFactor = (series.type === 'RangeArea' || series.type === 'RangeColumn' || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea') ? 2 : 1;
            for (var i = 0; i < series.points.length; i++) {
                if (series.points[i].symbolLocations) {
                    if (!series.points[i].symbolLocations.length || !markerElements[j]) {
                        continue;
                    }
                    markerAnimate(markerElements[j], delay, duration, series, i, series.points[i].symbolLocations[0], false);
                    if (incFactor === 2) {
                        var lowPoint = this.getRangeLowPoint(series.points[i].regions[0], series);
                        markerAnimate(markerElements[j + 1], delay, duration, series, i, lowPoint, false);
                    }
                    j += incFactor;
                }
            }
        }
    };
    return Marker;
}(MarkerExplode));

var __extends$8 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable max-len */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * Configures the legends in charts.
 */
var LegendSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$8(LegendSettings, _super);
    function LegendSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$5([
        Property(true)
    ], LegendSettings.prototype, "visible", void 0);
    __decorate$5([
        Property(null)
    ], LegendSettings.prototype, "height", void 0);
    __decorate$5([
        Property(null)
    ], LegendSettings.prototype, "width", void 0);
    __decorate$5([
        Complex({ x: 0, y: 0 }, Location)
    ], LegendSettings.prototype, "location", void 0);
    __decorate$5([
        Property('Auto')
    ], LegendSettings.prototype, "position", void 0);
    __decorate$5([
        Property('Series')
    ], LegendSettings.prototype, "mode", void 0);
    __decorate$5([
        Property(8)
    ], LegendSettings.prototype, "padding", void 0);
    __decorate$5([
        Property(null)
    ], LegendSettings.prototype, "itemPadding", void 0);
    __decorate$5([
        Property('Center')
    ], LegendSettings.prototype, "alignment", void 0);
    __decorate$5([
        Complex({ fontFamily: null, size: "14px", fontStyle: 'Normal', fontWeight: '400', color: null }, Font)
    ], LegendSettings.prototype, "textStyle", void 0);
    __decorate$5([
        Property(10)
    ], LegendSettings.prototype, "shapeHeight", void 0);
    __decorate$5([
        Property(10)
    ], LegendSettings.prototype, "shapeWidth", void 0);
    __decorate$5([
        Complex({}, Border)
    ], LegendSettings.prototype, "border", void 0);
    __decorate$5([
        Complex({ left: 0, right: 0, top: 0, bottom: 0 }, Margin)
    ], LegendSettings.prototype, "margin", void 0);
    __decorate$5([
        Complex({ left: 0, right: 0, top: 0, bottom: 0 }, ContainerPadding)
    ], LegendSettings.prototype, "containerPadding", void 0);
    __decorate$5([
        Property(8)
    ], LegendSettings.prototype, "shapePadding", void 0);
    __decorate$5([
        Property('transparent')
    ], LegendSettings.prototype, "background", void 0);
    __decorate$5([
        Property(1)
    ], LegendSettings.prototype, "opacity", void 0);
    __decorate$5([
        Property(true)
    ], LegendSettings.prototype, "toggleVisibility", void 0);
    __decorate$5([
        Property(false)
    ], LegendSettings.prototype, "enableHighlight", void 0);
    __decorate$5([
        Property(null)
    ], LegendSettings.prototype, "description", void 0);
    __decorate$5([
        Property(3)
    ], LegendSettings.prototype, "tabIndex", void 0);
    __decorate$5([
        Property(null)
    ], LegendSettings.prototype, "title", void 0);
    __decorate$5([
        Complex({ fontFamily: null, size: "14px", fontStyle: 'Normal', fontWeight: '600', color: null }, Font)
    ], LegendSettings.prototype, "titleStyle", void 0);
    __decorate$5([
        Property('Top')
    ], LegendSettings.prototype, "titlePosition", void 0);
    __decorate$5([
        Property('Normal')
    ], LegendSettings.prototype, "textWrap", void 0);
    __decorate$5([
        Property('Ellipsis')
    ], LegendSettings.prototype, "textOverflow", void 0);
    __decorate$5([
        Property(100)
    ], LegendSettings.prototype, "maximumTitleWidth", void 0);
    __decorate$5([
        Property(null)
    ], LegendSettings.prototype, "maximumLabelWidth", void 0);
    __decorate$5([
        Property(true)
    ], LegendSettings.prototype, "enablePages", void 0);
    __decorate$5([
        Property(false)
    ], LegendSettings.prototype, "isInversed", void 0);
    __decorate$5([
        Property(false)
    ], LegendSettings.prototype, "reverse", void 0);
    return LegendSettings;
}(ChildProperty));
/**
 * Legend base class for Chart and Accumulation chart.
 *
 * @private
 */
var BaseLegend = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for the dateTime module.
     *
     * @private
     */
    function BaseLegend(chart) {
        this.maxItemHeight = 0;
        this.rowHeights = [];
        this.pageHeights = [];
        this.columnHeights = [];
        this.pageXCollections = []; // pages of x locations
        this.chartRowCount = 1;
        this.legendTitleCollections = [];
        this.legendRegions = [];
        this.pagingRegions = [];
        this.chart = chart;
        this.legend = chart.legendSettings;
        this.legendID = chart.element.id + '_chart_legend';
        this.isChartControl = (chart.getModuleName() === 'chart' || chart.getModuleName() === 'chart3d');
        this.isAccChartControl = (chart.getModuleName() === 'accumulationchart');
        this.isBulletChartControl = (chart.getModuleName() === 'bulletChart');
        this.isStockChartControl = (chart.getModuleName() === 'stockChart');
        this.bulletChart = this.chart;
        this.fivePixel = 5;
        this.rowCount = 0;
        this.pageButtonSize = 8;
        this.maxColumns = 0;
        this.maxWidth = 0;
        this.currentPage = 1;
        this.backwardArrowOpacity = 0;
        this.forwardArrowOpacity = 1;
        this.arrowWidth = (2 * (this.fivePixel + this.pageButtonSize + this.fivePixel));
        this.arrowHeight = this.arrowWidth;
        this.isTop = false;
        this.isTitle = false;
        this.currentPageNumber = 1;
    }
    
    /**
     * Calculate the bounds for the legends.
     *
     * @returns {void}
     * @private
     */
    BaseLegend.prototype.calculateLegendBounds = function (rect, availableSize, maxLabelSize) {
        var legend = this.legend;
        var defaultValue = (this.isBulletChartControl) ? '40%' : '20%';
        this.getPosition(legend.position, availableSize);
        this.legendBounds = new Rect(rect.x, rect.y, 0, 0);
        this.isVertical = (this.position === 'Left' || this.position === 'Right');
        this.itemPadding = this.legend.itemPadding ? this.legend.itemPadding : this.isVertical ? this.legend.padding : 20;
        if (this.isVertical) {
            this.legendBounds.height = stringToNumber(legend.height, availableSize.height - (rect.y - this.chart.margin.top)) || rect.height;
            this.legendBounds.width = stringToNumber(legend.width || defaultValue, availableSize.width);
        }
        else {
            this.legendBounds.width = stringToNumber(legend.width, availableSize.width) || rect.width;
            this.legendBounds.height = stringToNumber(legend.height || defaultValue, availableSize.height);
        }
        if (this.chart.getModuleName() === 'chart3d') {
            this.library.get3DLegendBounds(availableSize, this.legendBounds, legend);
        }
        else {
            this.library.getLegendBounds(availableSize, this.legendBounds, legend);
        }
        if (!this.isBulletChartControl) {
            this.legendBounds.width += (this.legend.containerPadding.left + this.legend.containerPadding.right);
            this.legendBounds.height += (this.legend.containerPadding.top + this.legend.containerPadding.bottom);
        }
        this.getLocation(this.position, legend.alignment, this.legendBounds, rect, availableSize, maxLabelSize);
    };
    /**
     * To find legend position based on available size for chart and accumulation chart
     *
     * @param position
     * @param availableSize
     * @param position
     * @param availableSize
     * @returns {void}
     */
    BaseLegend.prototype.getPosition = function (position, availableSize) {
        var chart = this.chart;
        var accumulation = this.chart;
        if (this.isChartControl || this.isBulletChartControl || this.isStockChartControl) {
            this.position = (position !== 'Auto') ? position : 'Bottom';
        }
        else {
            if (position === 'Auto' && ((chart || accumulation).visibleSeries && (chart || accumulation).visibleSeries[0].type === 'Funnel' || (chart || accumulation).visibleSeries[0].type === 'Pyramid')) {
                position = 'Top';
            }
            this.position = (position !== 'Auto') ? position :
                (availableSize.width > availableSize.height ? 'Right' : 'Bottom');
        }
    };
    /**
     * To set bounds for chart and accumulation chart
     *
     * @param computedWidth
     * @param computedHeight
     * @param legend
     * @param legendBounds
     * @param computedWidth
     * @param computedHeight
     * @param legend
     * @param legendBounds
     * @param computedWidth
     * @param computedHeight
     * @param legend
     * @param legendBounds
     * @param computedWidth
     * @param computedHeight
     * @param legend
     * @param legendBounds
     * @returns {void}
     */
    BaseLegend.prototype.setBounds = function (computedWidth, computedHeight, legend, legendBounds) {
        var titleHeight = legend.title && legend.titlePosition === 'Top' ? this.legendTitleSize.height + this.fivePixel : 0;
        if (this.isVertical && this.isPaging && !legend.enablePages && !this.isBulletChartControl) {
            titleHeight = legend.title && legend.titlePosition === 'Top' ? this.legendTitleSize.height + this.fivePixel : 0;
            titleHeight += (this.pageButtonSize + this.fivePixel);
        }
        computedWidth = Math.min(computedWidth, legendBounds.width);
        computedHeight = Math.min(computedHeight, legendBounds.height);
        if (legend.mode === 'Gradient') {
            legendBounds.width = legend.width ? legendBounds.width : this.isVertical ? computedWidth : 0.75 * legendBounds.width;
            legendBounds.height = legend.height ? legendBounds.height : this.isVertical ? 0.75 * legendBounds.height : computedHeight;
        }
        else {
            legendBounds.width = !legend.width ? computedWidth : legendBounds.width;
            legendBounds.height = !legend.height ? computedHeight : legendBounds.height;
        }
        if (!this.isBulletChartControl) {
            if (this.isTop && legend.titleStyle.textOverflow !== 'None') {
                this.calculateLegendTitle(legend, legendBounds);
                legendBounds.height += legend.titleStyle.textOverflow === 'Wrap' && this.legendTitleCollections.length > 1 ?
                    (this.legendTitleSize.height - (this.legendTitleSize.height / this.legendTitleCollections.length)) : 0;
            }
        }
        this.rowCount = Math.max(1, Math.ceil((legendBounds.height - legend.padding - titleHeight) /
            (this.maxItemHeight + legend.padding)));
    };
    /**
     * To find legend location based on position, alignment for chart and accumulation chart
     *
     * @param position
     * @param alignment
     * @param legendBounds
     * @param rect
     * @param availableSize
     * @param maxLabelSize
     * @param position
     * @param alignment
     * @param legendBounds
     * @param rect
     * @param availableSize
     * @param maxLabelSize
     * @param position
     * @param alignment
     * @param legendBounds
     * @param rect
     * @param availableSize
     * @param maxLabelSize
     * @param position
     * @param alignment
     * @param legendBounds
     * @param rect
     * @param availableSize
     * @param maxLabelSize
     * @param position
     * @param alignment
     * @param legendBounds
     * @param rect
     * @param availableSize
     * @param maxLabelSize
     * @param position
     * @param alignment
     * @param legendBounds
     * @param rect
     * @param availableSize
     * @param maxLabelSize
     */
    BaseLegend.prototype.getLocation = function (position, alignment, legendBounds, rect, availableSize, maxLabelSize) {
        var padding = this.legend.border.width;
        var isBulletChart = this.isBulletChartControl;
        var bulletChart = this.bulletChart;
        var labelIns = bulletChart.labelPosition === 'Inside';
        var ticklIns = bulletChart.tickPosition === 'Inside';
        var isVertical = bulletChart.orientation === 'Vertical';
        var categoryFieldValue = (isBulletChart && bulletChart.categoryField !== '') ?
            maxLabelSize.width + this.chart.border.width + padding * 3 : 0;
        var marginBottom = this.chart.margin.bottom;
        var legendHeight = legendBounds.height + padding + this.legend.margin.top + this.legend.margin.bottom;
        var legendWidth = legendBounds.width + padding + this.legend.margin.left + this.legend.margin.right;
        if (position === 'Bottom') {
            legendBounds.x = this.alignLegend(legendBounds.x, availableSize.width, legendBounds.width, alignment);
            legendBounds.y = rect.y + (rect.height - legendHeight) + padding + this.legend.margin.top;
            legendBounds.y += (isBulletChart && !bulletChart.opposedPosition && !labelIns && !ticklIns
                && !isVertical) ? bulletChart.majorTickLines.height + marginBottom + this.legend.border.width + padding * 2 :
                (isVertical && bulletChart.categoryField !== '') ? maxLabelSize.height + padding * 2 : 0;
            subtractThickness(rect, new Thickness(0, 0, 0, legendHeight));
        }
        else if (position === 'Top') {
            var axisTextSize = void 0;
            if (this.isChartControl) {
                axisTextSize = measureText('100', this.chart.verticalAxes[0].labelStyle, this.chart.themeStyle.legendLabelFont);
            }
            legendBounds.x = this.alignLegend(legendBounds.x, availableSize.width, legendBounds.width, alignment);
            legendBounds.y = rect.y + padding + this.legend.margin.top;
            legendBounds.y -= (isBulletChart && bulletChart.opposedPosition && !labelIns && !ticklIns &&
                !isVertical) ? bulletChart.majorTickLines.height + this.chart.margin.top : 0;
            legendHeight -= (isBulletChart) ? -padding * 2 : (this.isChartControl ? -padding * 2 - axisTextSize.height / 2 : 0);
            subtractThickness(rect, new Thickness(0, 0, legendHeight, 0));
        }
        else if (position === 'Right') {
            legendBounds.x = rect.x + (rect.width - legendBounds.width) - this.legend.margin.right;
            legendBounds.y = rect.y + this.alignLegend(0, availableSize.height - (rect.y + marginBottom), legendBounds.height, alignment);
            legendWidth += (isBulletChart && bulletChart.opposedPosition && !labelIns && !ticklIns &&
                isVertical) ? (this.chart.margin.left + this.chart.margin.right + bulletChart.majorTickLines.height) : 0;
            subtractThickness(rect, new Thickness(0, legendWidth, 0, 0));
        }
        else if (position === 'Left') {
            legendBounds.x = legendBounds.x + this.legend.margin.left;
            legendBounds.y = rect.y + this.alignLegend(0, availableSize.height - (rect.y + marginBottom), legendBounds.height, alignment);
            legendWidth += (isBulletChart && !bulletChart.opposedPosition && !labelIns && !ticklIns &&
                isVertical) ? (legendBounds.x - this.chart.margin.left + padding + bulletChart.majorTickLines.height) :
                (bulletChart.orientation !== 'Vertical' && bulletChart.categoryField !== '') ? categoryFieldValue : 0;
            subtractThickness(rect, new Thickness(legendWidth, 0, 0, 0));
        }
        else {
            legendBounds.x = this.legend.location.x;
            legendBounds.y = this.legend.location.y;
            subtractThickness(rect, new Thickness(0, 0, 0, 0));
        }
    };
    /**
     * To find legend alignment for chart and accumulation chart
     *
     * @param start
     * @param size
     * @param legendSize
     * @param alignment
     * @param start
     * @param size
     * @param legendSize
     * @param alignment
     * @param start
     * @param size
     * @param legendSize
     * @param alignment
     * @param start
     * @param size
     * @param legendSize
     * @param alignment
     */
    BaseLegend.prototype.alignLegend = function (start, size, legendSize, alignment) {
        switch (alignment) {
            case 'Far':
                start = (size - legendSize) - start;
                break;
            case 'Center':
                start = ((size - legendSize) / 2);
                break;
        }
        return start;
    };
    /**
     * Renders the legend.
     *
     * @param chart
     * @param legend
     * @param legendBounds
     * @param redraw
     * @param chart
     * @param legend
     * @param legendBounds
     * @param redraw
     * @param chart
     * @param legend
     * @param legendBounds
     * @param redraw
     * @param chart
     * @param legend
     * @param legendBounds
     * @param redraw
     * @returns {void}
     * @private
     */
    BaseLegend.prototype.renderLegend = function (chart, legend, legendBounds, redraw) {
        var titleHeight = 0;
        var titlePlusArrowWidth = 0;
        var pagingLegendBounds = new Rect(0, 0, 0, 0);
        var requireLegendBounds = new Rect(0, 0, 0, 0);
        var firstLegend = this.findFirstLegendPosition(this.legendCollections);
        var padding = legend.padding;
        this.itemPadding = this.isBulletChartControl ? legend.padding : this.itemPadding;
        var isPaging = legend.enablePages;
        var titlePosition = legend.titlePosition;
        var upArrowHeight = this.isPaging && !legend.enablePages && this.isVertical ? this.pageButtonSize : 0;
        var legendGroup = chart.renderer.createGroup({ id: this.legendID + '_g' });
        var legendTranslateGroup = this.createLegendElements(chart, legendBounds, legendGroup, legend, this.legendID, redraw);
        this.legendRegions = [];
        this.chartRowCount = 1;
        var maxHeight = 0;
        titleHeight = !this.isTitle ? 0 : (this.isTop || this.isVertical ? this.legendTitleSize.height : 0);
        if (this.isChartControl || (this.isAccChartControl && !this.isVertical)) {
            var pageCount = 1;
            var rowHeights = this.rowHeights[0] + padding;
            for (var i = 1; i < this.rowHeights.length; i++) {
                if ((rowHeights + this.rowHeights[i] + padding) > (this.legendBounds.height - this.pageButtonSize - this.maxItemHeight / 2)) {
                    this.pageHeights[pageCount - 1] = rowHeights + titleHeight;
                    pageCount++;
                    rowHeights = 0;
                }
                rowHeights += (this.rowHeights[i] + (this.isVertical ? this.itemPadding : padding));
            }
            this.pageHeights[pageCount - 1] = rowHeights + titleHeight;
            this.totalPages = pageCount;
        }
        for (var i = 0; i < this.legendCollections.length; i++) {
            if (this.legendCollections[i].text !== '') {
                maxHeight = Math.max(this.legendCollections[i].textSize.height, maxHeight);
                break;
            }
            else {
                continue;
            }
        }
        if (!this.isChartControl && !this.isAccChartControl) {
            this.maxItemHeight = Math.max(maxHeight, legend.shapeHeight);
        }
        // For new legend navigation
        if (!isPaging && this.isPaging && !this.isVertical) {
            titlePlusArrowWidth = !this.isTitle ? 0 : titlePosition === 'Left' ? this.legendTitleSize.width : 0;
            titlePlusArrowWidth += (this.pageButtonSize + (2 * this.fivePixel));
        }
        else if (this.isTitle && !this.isPaging && !this.isVertical) {
            titlePlusArrowWidth = titlePosition === ((!this.isRtlEnable) ? 'Left' : 'Right') ? (this.fivePixel + this.legendTitleSize.width) : 0;
        }
        if (chart.legendSettings.mode === 'Gradient' && this.legendCollections.length > 1) {
            this.getLinearLegend(legendBounds, chart, legend, legendTranslateGroup);
            this.totalPages = 1;
        }
        else if (firstLegend !== this.legendCollections.length) {
            var legendSeriesGroup = void 0; // legendItem group for each series group element
            var count = 0;
            var previousLegend = this.legendCollections[firstLegend];
            // starting shape center x,y position && to resolve lint error used new line for declaration
            var startPadding = this.isBulletChartControl ? 0 : titlePlusArrowWidth + padding + (legend.shapeWidth / 2) + legend.containerPadding.left;
            var xLocation = this.isBulletChartControl ? legendBounds.x + titlePlusArrowWidth + padding + (legend.shapeWidth / 2) :
                (!this.isRtlEnable) ? legendBounds.x + startPadding : legendBounds.x + ((this.chart.getModuleName() === 'accumulationchart' && this.isVertical) ? this.maxWidth : legendBounds.width) - startPadding;
            var start = new ChartLocation(xLocation, this.isBulletChartControl ? legendBounds.y + titleHeight + upArrowHeight + padding + (this.maxItemHeight / 2) :
                legendBounds.y + titleHeight + upArrowHeight + padding + (this.maxItemHeight / 2) + legend.containerPadding.top);
            var anchor = chart.isRtlEnabled || chart.enableRtl ? 'end' : 'start';
            var textOptions = new TextOption('', start.x, start.y, anchor);
            var textPadding = legend.shapePadding + this.itemPadding + legend.shapeWidth;
            //  initialization for totalPages legend click totalpage again calculate
            this.totalPages = this.totalPages = (this.isAccChartControl || this.isChartControl || this.isBulletChartControl || this.isStockChartControl) ? this.totalPages : 0;
            this.pageXCollections = [];
            this.legendCollections[firstLegend].location = start;
            var legendIndex = void 0;
            if (!legend.enablePages && this.isPaging) {
                var x = start.x - this.fivePixel;
                var y = start.y - this.fivePixel;
                var leftSpace = this.isTitle && !this.isVertical && titlePosition === 'Left' ?
                    this.legendTitleSize.width + this.fivePixel : 0;
                var bottomSapce = this.isVertical ? (this.pageButtonSize) + Math.abs(y - legendBounds.y) : 0;
                var rightSpace = this.isTitle && !this.isVertical && titlePosition === 'Right' ?
                    this.legendTitleSize.width + this.fivePixel : 0;
                rightSpace += this.isVertical ? 0 : (this.fivePixel + this.pageButtonSize + this.fivePixel);
                pagingLegendBounds = new Rect(x, y, legendBounds.width - rightSpace - leftSpace, legendBounds.height - bottomSapce);
                requireLegendBounds = pagingLegendBounds;
            }
            else {
                requireLegendBounds = legendBounds;
            }
            var legendOption = void 0;
            for (var i = 0; i < this.legendCollections.length; i++) {
                legendOption = this.legendCollections[i];
                legendIndex = !this.isReverse ? count : (this.legendCollections.length - 1) - count;
                if (this.chart.getModuleName() === 'accumulationchart') {
                    legendOption.fill = (this.chart || this.chart || this.chart || this.chart).visibleSeries[0].points[legendOption.pointIndex].color;
                }
                if (this.chart.getModuleName() === 'stockChart') {
                    legendOption.type = this.chart.visibleSeries[count].type;
                }
                this.accessbilityText = (this.isBulletChartControl) ? 'Legend of bullet chart' + '' + legendOption.text
                    : 'Click to show or hide the ' + legendOption.text + ' series';
                if (legendOption.render && legendOption.text && legendOption.text !== '') {
                    legendSeriesGroup = chart.renderer.createGroup({
                        id: this.legendID + this.generateId(legendOption, '_g_', legendIndex)
                    });
                    if (legendSeriesGroup) {
                        legendSeriesGroup.setAttribute('tabindex', i === 0 ? '0' : '');
                        legendSeriesGroup.setAttribute('aria-label', legend.description || (legendOption.text + ' series is ' + (legendOption.visible ? 'showing, press enter to hide the ' : 'hidden, press enter to show the ') + legendOption.text + ' series'));
                        legendSeriesGroup.setAttribute('role', 'button');
                        legendSeriesGroup.setAttribute('aria-pressed', legendOption.visible ? 'true' : 'false');
                    }
                    this.library.getRenderPoint(legendOption, start, textPadding, previousLegend, requireLegendBounds, count, firstLegend);
                    this.renderSymbol(legendOption, legendSeriesGroup, legendIndex);
                    this.renderText(chart, legendOption, legendSeriesGroup, textOptions, count, legendIndex);
                    if (legendSeriesGroup) {
                        legendSeriesGroup.style.cssText =
                            'pointer-events: bounding-box; cursor: ' + ((!legend.toggleVisibility && (chart.selectionMode === 'None' ||
                                chart.highlightMode === 'None' ||
                                chart.selectionMode === 'None') || this.isBulletChartControl) ? 'auto' : 'pointer');
                    }
                    if (legendTranslateGroup) {
                        legendTranslateGroup.appendChild(legendSeriesGroup);
                    }
                    previousLegend = legendOption;
                }
                count++;
            }
            this.totalPages = (this.isPaging && !this.isBulletChartControl && !this.legend.enablePages && !this.isVertical &&
                this.totalPages > this.chartRowCount) ? this.chartRowCount : this.totalPages;
            if (this.isPaging && this.totalPages > 1) {
                this.renderPagingElements(chart, legendBounds, textOptions, legendGroup);
            }
            else {
                this.totalPages = 1;
            }
        }
        appendChildElement(chart.enableCanvas, chart.svgObject, legendGroup, redraw);
    };
    /** @private */
    BaseLegend.prototype.getLinearLegend = function (legendBounds, chart, legend, legendTranslateGroup) {
        var xmlns = 'http://www.w3.org/2000/svg';
        var previousLegend = this.legendCollections[0];
        var nextLegend = this.legendCollections[1];
        var defElement = this.chart.renderer.createDefs();
        var gradientLegendCount = 0;
        var linerGradientEle = document.createElementNS(xmlns, 'linearGradient');
        var opacity = 1;
        var fillColors = [];
        var numberItems = [];
        if (legend.title) {
            if (!this.isVertical) {
                if (legend.titlePosition === 'Left') {
                    legendBounds.x += this.legendTitleSize.width;
                    legendBounds.width -= this.legendTitleSize.width;
                }
                else if (legend.titlePosition === 'Right') {
                    legendBounds.width -= this.legendTitleSize.width;
                }
                else if (legend.titlePosition === 'Top') {
                    legendBounds.y += this.legendTitleSize.height;
                    legendBounds.height -= this.legendTitleSize.height;
                }
            }
            else {
                legendBounds.y += this.legendTitleSize.height;
                legendBounds.height -= this.legendTitleSize.height;
            }
        }
        for (var _i = 0, _a = this.chart.rangeColorSettings; _i < _a.length; _i++) {
            var colorMap = _a[_i];
            if (numberItems.indexOf(colorMap.start) < 0) {
                numberItems.push(colorMap.start);
            }
            if (colorMap.colors.length > 2) {
                var diffValue = (colorMap.end - colorMap.start);
                var colorsLength = colorMap.colors.length - 1;
                if (diffValue > 0) {
                    diffValue = diffValue / colorsLength;
                    for (var index = 1; index < colorsLength; index++) {
                        var calculatedValue = colorMap.start + (diffValue * index);
                        numberItems.push(calculatedValue);
                    }
                }
                else {
                    for (var index = 1; index < colorsLength; index++) {
                        numberItems.push(colorMap.start);
                    }
                }
            }
            if (numberItems.indexOf(colorMap.end) < 0) {
                numberItems.push(colorMap.end);
            }
            for (var _b = 0, _c = colorMap.colors; _b < _c.length; _b++) {
                var fillColor = _c[_b];
                if (fillColors.indexOf(fillColor) < 0) {
                    fillColors.push(fillColor);
                }
            }
            if (colorMap.colors.length > 0 && colorMap.colors.length < 2) {
                fillColors.push(colorMap.colors[0]);
            }
        }
        var x1 = this.isRtlEnable && !this.isVertical ? '100%' : '0%';
        var x2 = this.isVertical || this.isRtlEnable ? '0%' : '100%';
        var y2 = this.isVertical ? '100%' : '0%';
        linerGradientEle.setAttribute('id', this.generateId(previousLegend, 'linearGradient', gradientLegendCount));
        linerGradientEle.setAttribute('x1', x1);
        linerGradientEle.setAttribute('y1', '0%');
        linerGradientEle.setAttribute('x2', x2);
        linerGradientEle.setAttribute('y2', y2);
        var full = numberItems[numberItems.length - 1] - numberItems[0];
        for (var b = 0; b < fillColors.length; b++) {
            var offsetValue = numberItems[b] - numberItems[0];
            offsetValue = offsetValue / full;
            var stopEle = document.createElementNS(xmlns, 'stop');
            stopEle.setAttribute('offset', offsetValue.toString());
            stopEle.setAttribute('stop-color', fillColors[b]);
            stopEle.setAttribute('stop-opacity', opacity.toString());
            linerGradientEle.appendChild(stopEle);
        }
        var startLabel = previousLegend.text.toString();
        var endLabel = nextLegend.text.toString();
        var startTextSize = measureText(startLabel, legend.textStyle, this.chart.themeStyle.legendLabelFont);
        var endTextSize = measureText(endLabel, legend.textStyle, this.chart.themeStyle.legendLabelFont);
        var textWidth = startTextSize.width > endTextSize.width ? startTextSize.width : endTextSize.width;
        var textHeight = startTextSize.height > endTextSize.height ? startTextSize.height : endTextSize.height;
        var otherSpaces = (2 * textWidth) + (4 * legend.padding);
        var linearBarWidth = legendBounds.width;
        var linearBarHeight = legendBounds.height;
        var xValue = legendBounds.x + textWidth + (2 * legend.padding);
        var yValue = legendBounds.y + legend.padding;
        var startLabelY;
        var endLabelY;
        var startLabelX;
        var endLabelX;
        if (this.isVertical) {
            otherSpaces = (2 * textHeight) + (4 * legend.padding);
            linearBarWidth = legendBounds.width - (2 * legend.padding);
            linearBarHeight = legendBounds.height - otherSpaces;
            xValue = legendBounds.x + legend.padding;
            yValue = legendBounds.y + textHeight + (2 * legend.padding);
            startLabelY = legendBounds.y + legend.padding + textHeight;
            endLabelY = yValue + linearBarHeight + textHeight;
            startLabelX = (legendBounds.x + (legendBounds.width * 0.5)) - (textWidth * 0.5);
            endLabelX = startLabelX;
            if (linearBarWidth > 30) {
                var diffWidth = linearBarWidth - 30;
                linearBarWidth = 30;
                xValue = xValue + (diffWidth / 2);
            }
        }
        else {
            linearBarWidth = legendBounds.width - otherSpaces;
            linearBarHeight = legendBounds.height - (2 * legend.padding);
            startLabelX = legendBounds.x + ((!this.isRtlEnable) ? legend.padding + (textWidth - startTextSize.width) :
                linearBarWidth + (3 * legend.padding) + textWidth);
            endLabelX = legendBounds.x + ((!this.isRtlEnable) ? linearBarWidth + (3 * legend.padding) + textWidth :
                legend.padding + (textWidth - endTextSize.width));
            startLabelY = legendBounds.y + (legendBounds.height * 0.5) + (textHeight * 0.25);
            endLabelY = startLabelY;
            if (linearBarHeight > 30) {
                var diffHeight = linearBarHeight - 30;
                linearBarHeight = 30;
                yValue = yValue + (diffHeight / 2);
            }
        }
        var anchor = chart.enableRtl ? 'end' : '';
        var textOptions = new TextOption('', startLabelX, startLabelY, anchor, startLabel);
        var hiddenColor = '#D3D3D3';
        textOptions.id = this.legendID + this.generateId(previousLegend, '_text_', 1);
        var fontcolor = previousLegend.visible ? legend.textStyle.color || chart.themeStyle.legendLabelFont.color : hiddenColor;
        var isCanvas = this.isStockChartControl ? false : this.chart.enableCanvas;
        textElement$1(chart.renderer, textOptions, legend.textStyle, fontcolor, legendTranslateGroup, false, false, false, false, 
        // tslint:disable-next-line:align
        null, this.currentPageNumber && isCanvas ?
            new Rect(0, -this.translatePage(isCanvas, null, this.currentPageNumber - 1, this.currentPageNumber), 0, 0) : null, null, null, null, null, this.chart.themeStyle.legendLabelFont);
        textOptions = new TextOption('', endLabelX, endLabelY, anchor, endLabel);
        textOptions.id = this.legendID + this.generateId(previousLegend, '_text_', 2);
        textElement$1(chart.renderer, textOptions, legend.textStyle, fontcolor, legendTranslateGroup, false, false, false, false, 
        // tslint:disable-next-line:align
        null, this.currentPageNumber && isCanvas ?
            new Rect(0, -this.translatePage(isCanvas, null, this.currentPageNumber - 1, this.currentPageNumber), 0, 0) : null, null, null, null, null, this.chart.themeStyle.legendLabelFont);
        var gradientLegend = chart.renderer.drawRectangle({
            width: linearBarWidth,
            height: linearBarHeight,
            x: xValue,
            y: yValue,
            fill: 'url(#' + this.generateId(previousLegend, 'linearGradient', gradientLegendCount) + ')'
        });
        defElement.appendChild(linerGradientEle);
        legendTranslateGroup.appendChild(defElement);
        legendTranslateGroup.appendChild(gradientLegend);
    };
    /**
     * To find first valid legend text index for chart and accumulation chart
     *
     * @param legendCollection
     * @returns {number}
     * @private
     */
    BaseLegend.prototype.findFirstLegendPosition = function (legendCollection) {
        var count = 0;
        for (var _i = 0, legendCollection_1 = legendCollection; _i < legendCollection_1.length; _i++) {
            var legend = legendCollection_1[_i];
            if (legend.render && legend.text && legend.text !== '') {
                break;
            }
            count++;
        }
        return count;
    };
    /**
     * To get the legend title text width and height.
     *
     * @param legend
     * @param legendBounds
     */
    BaseLegend.prototype.calculateLegendTitle = function (legend, legendBounds) {
        if (legend.title) {
            this.isTop = legend.titlePosition === 'Top';
            var padding = legend.titleStyle.textOverflow === 'Trim' ? 2 * legend.padding : 0;
            if (this.isTop || this.isVertical) {
                this.legendTitleCollections = getTitle(legend.title, legend.titleStyle, (legendBounds.width - padding), this.chart.enableRtl, this.chart.themeStyle.legendTitleFont);
            }
            else {
                this.legendTitleCollections[0] = textTrim(legend.maximumTitleWidth, legend.title, legend.titleStyle, this.chart.enableRtl, this.chart.themeStyle.legendTitleFont);
            }
            var text = this.isTop ? legend.title : this.legendTitleCollections[0];
            this.legendTitleSize = measureText(text, legend.titleStyle, this.chart.themeStyle.legendTitleFont);
            this.legendTitleSize.height *= this.legendTitleCollections.length;
        }
        else {
            this.legendTitleSize = new Size(0, 0);
        }
    };
    /**
     * Render the legend title
     *
     * @param chart
     * @param legend
     * @param legendBounds
     * @param legendGroup
     */
    BaseLegend.prototype.renderLegendTitle = function (chart, legend, legendBounds, legendGroup) {
        var padding = legend.padding;
        var alignment = legend.titleStyle.textAlignment;
        this.isTop = legend.titlePosition === 'Top';
        var anchor = getTextAnchor(legend.titleStyle.textAlignment, chart.enableRtl);
        var x = titlePositionX(legendBounds, legend.titleStyle);
        anchor = this.isTop || this.isVertical ? anchor : (chart.enableRtl) ? 'end' : '';
        x = alignment === 'Near' ? (x + padding) : alignment === 'Far' ? (x - padding) : x;
        x = (this.isTop || this.isVertical) ? x : ((legendBounds.x) + (legend.titlePosition === 'Left' ? 5 :
            (legendBounds.width - this.legendTitleSize.width - 5)));
        var topPadding = (legendBounds.height / 2) + (this.legendTitleSize.height / 4);
        var y = legendBounds.y + (!this.isTop && !this.isVertical ? topPadding :
            (this.legendTitleSize.height / this.legendTitleCollections.length));
        var legendTitleTextOptions = new TextOption(this.legendID + '_title', x, y, anchor, this.legendTitleCollections);
        textElement$1(chart.renderer, legendTitleTextOptions, legend.titleStyle, legend.titleStyle.color || this.chart.themeStyle.legendTitleFont.color, legendGroup, null, null, null, null, null, null, null, null, null, null, this.chart.themeStyle.legendTitleFont);
    };
    /**
     * To create legend rendering elements for chart and accumulation chart
     *
     * @param chart
     * @param legendBounds
     * @param legendGroup
     * @param legend
     * @param id
     * @param redraw
     */
    BaseLegend.prototype.createLegendElements = function (chart, legendBounds, legendGroup, legend, id, redraw) {
        var padding = legend.padding;
        var options = new RectOption(id + '_element', legend.background, legend.border, legend.opacity, legendBounds);
        var legendItemsGroup = chart.renderer.createGroup({ id: id + '_collections' });
        var isCanvas = this.isStockChartControl ? false : chart.enableCanvas;
        var clippath = chart.renderer.createClipPath({ id: id + '_clipPath' });
        options.width = (this.isRtlEnable && this.chart.getModuleName() === 'accumulationchart' && this.isVertical) ? this.maxWidth : legendBounds.width;
        if (legendGroup) {
            legendGroup.appendChild(chart.renderer.drawRectangle(options));
        }
        else {
            chart.renderer.drawRectangle(options);
        }
        if (legend.title) {
            this.renderLegendTitle(chart, legend, legendBounds, legendGroup);
        }
        if (!isCanvas) {
            legendGroup.appendChild(legendItemsGroup);
        }
        this.legendTranslateGroup = chart.renderer.createGroup({ id: id + '_translate_g' });
        if (!isCanvas) {
            legendItemsGroup.appendChild(this.legendTranslateGroup);
        }
        options.y += (this.isTop ? this.legendTitleSize.height : 0);
        options.id += '_clipPath_rect';
        options.width = ((!this.isChartControl && chart.getModuleName() !== 'bulletChart' && !this.isStockChartControl) && this.isVertical) ? this.maxWidth - padding + legend.containerPadding.left + legend.containerPadding.right
            : legendBounds.width;
        if (!isCanvas) {
            this.clipRect = chart.renderer.drawRectangle(options);
            clippath.appendChild(this.clipRect);
        }
        else {
            this.pagingClipRect = options;
        }
        appendChildElement(isCanvas, chart.svgObject, clippath, redraw);
        if (!isCanvas) {
            legendItemsGroup.style.cssText = 'clip-path:url(#' + clippath.id + ')';
        }
        return this.legendTranslateGroup;
    };
    /**
     * To render legend symbols for chart and accumulation chart
     *
     * @param legendOption
     * @param group
     * @param i
     * @param legendOption
     * @param group
     * @param i
     * @param legendOption
     * @param group
     * @param i
     */
    BaseLegend.prototype.renderSymbol = function (legendOption, group, legendIndex) {
        var control = this.isBulletChartControl ? this.chart : null;
        var symbolColor = legendOption.visible ? legendOption.fill : '#D3D3D3';
        var isStrokeWidth = (this.chart.getModuleName() === 'chart' || this.chart.getModuleName() === 'stockChart') && (((legendOption.shape === 'SeriesType') &&
            (legendOption.type.toLowerCase().indexOf('line') > -1) && (legendOption.type.toLowerCase().indexOf('area') === -1)) ||
            ((legendOption.shape === 'HorizontalLine') || (legendOption.shape === 'VerticalLine') || (legendOption.shape === 'Cross')));
        var isCustomBorder = (this.chart.getModuleName() === 'chart' || this.chart.getModuleName() === 'stockChart') &&
            (legendOption.type === 'Scatter' || legendOption.type === 'Bubble');
        var isCanvas = this.isStockChartControl ? false : this.chart.enableCanvas;
        var borderColor;
        var shape = (legendOption.shape === 'SeriesType') ? legendOption.type : legendOption.shape;
        var strokewidth = isStrokeWidth ? (this.legend.mode === 'Series' ?
            this.chart.visibleSeries[legendIndex].width : this.chart.visibleSeries[0].width) :
            (this.isBulletChartControl && legendOption.shape === 'Multiply') ? 4 : 1;
        var regionPadding;
        shape = shape === 'Scatter' ? legendOption.markerShape : shape;
        if (isCustomBorder && legendIndex < this.chart.visibleSeries.length) {
            var series = this.chart.visibleSeries[legendIndex];
            var seriesBorder = series.border;
            var isLineShapemarker = shape === 'HorizontalLine' || shape === 'VerticalLine';
            borderColor = isLineShapemarker ? symbolColor : seriesBorder.color ? seriesBorder.color : symbolColor;
            strokewidth = isLineShapemarker ? series.width : seriesBorder.width ? seriesBorder.width : 1;
        }
        var symbolOption = new PathOption(this.legendID + this.generateId(legendOption, '_shape_', legendIndex), symbolColor, strokewidth, (isCustomBorder ? borderColor : symbolColor), this.legend.opacity, legendOption.dashArray, '');
        var textSize = measureText(legendOption.text, this.legend.textStyle, this.chart.themeStyle.legendLabelFont);
        var x = this.legend.isInversed && !this.isRtlEnable ? legendOption.location.x + textSize.width + this.legend.shapePadding
            : legendOption.location.x;
        var y = legendOption.location.y;
        if (!isCanvas) {
            group.appendChild(drawSymbol({ x: x, y: y }, shape, new Size(this.legend.shapeWidth, this.legend.shapeHeight), legendOption.url, symbolOption, this.accessbilityText, this.chart.renderer, null, this.isBulletChartControl, control));
        }
        else {
            regionPadding = -this.translatePage(isCanvas, null, this.currentPageNumber - 1, this.currentPageNumber);
            drawSymbol({ x: x, y: y }, shape, new Size(this.legend.shapeWidth, this.legend.shapeHeight), '', symbolOption, this.accessbilityText, this.chart.renderer, this.currentPageNumber ? new Rect(0, regionPadding, 0, 0) : null, this.isBulletChartControl, control);
            this.legendRegions.push({
                rect: new Rect(legendOption.location.x, legendOption.location.y, this.legend.shapeWidth, this.legend.shapeHeight + regionPadding), index: legendIndex
            });
        }
        if (shape === 'Line' && legendOption.markerVisibility && legendOption.markerShape !== 'Image' ||
            (legendOption.type === 'Doughnut' && shape === 'Doughnut')) {
            symbolOption.id = this.legendID + this.generateId(legendOption, '_shape_marker_', legendIndex);
            shape = legendOption.type === 'Doughnut' ? 'Circle' : legendOption.markerShape;
            symbolOption.fill = legendOption.type === 'Doughnut' ? '#FFFFFF' : symbolOption.fill;
            if (!isCanvas) {
                group.appendChild(drawSymbol({ x: x, y: y }, shape, new Size(this.legend.shapeWidth / 2, this.legend.shapeHeight / 2), '', symbolOption, this.accessbilityText, null, null, this.isBulletChartControl, control));
            }
            else {
                drawSymbol({ x: x, y: y }, shape, new Size(this.legend.shapeWidth / 2, this.legend.shapeHeight / 2), '', symbolOption, this.accessbilityText, this.chart.renderer, this.currentPageNumber ?
                    new Rect(0, -this.translatePage(isCanvas, null, this.currentPageNumber - 1, this.currentPageNumber), 0, 0) : null, this.isBulletChartControl, control);
            }
        }
    };
    /**
     * To render legend text for chart and accumulation chart
     *
     * @param chart
     * @param legendOption
     * @param group
     * @param textOptions
     * @param i
     * @param chart
     * @param legendOption
     * @param group
     * @param textOptions
     * @param i
     * @param chart
     * @param legendOption
     * @param group
     * @param textOptions
     * @param i
     * @param chart
     * @param legendOption
     * @param group
     * @param textOptions
     * @param i
     * @param chart
     * @param legendOption
     * @param group
     * @param textOptions
     * @param i
     */
    BaseLegend.prototype.renderText = function (chart, legendOption, group, textOptions, i, legendIndex) {
        var legend = chart.legendSettings;
        var hiddenColor = '#D3D3D3';
        var fontcolor = legendOption.visible ? legend.textStyle.color || chart.themeStyle.legendLabelFont.color : hiddenColor;
        var isCanvas = this.isStockChartControl ? false : this.chart.enableCanvas;
        textOptions.id = this.legendID + this.generateId(legendOption, '_text_', legendIndex);
        textOptions.text = legendOption.textCollection.length > 0 ? legendOption.textCollection : legendOption.text;
        if (legend.isInversed && !this.isRtlEnable) {
            textOptions.x = legendOption.location.x - (legend.shapeWidth / 2);
        }
        else if (this.isRtlEnable) {
            var textWidth = measureText(legendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont).width;
            textOptions.x = legendOption.location.x - ((legendOption.textCollection.length > 1 ? textWidth / legendOption.textCollection.length : textWidth) + legend.shapeWidth / 2 + legend.shapePadding);
        }
        else {
            textOptions.x = legendOption.location.x + (legend.shapeWidth / 2) + legend.shapePadding;
        }
        textOptions.y = legendOption.location.y + this.maxItemHeight / 4;
        var element = textElement$1(chart.renderer, textOptions, legend.textStyle, fontcolor, group, false, false, false, false, null, this.currentPageNumber && isCanvas ?
            new Rect(0, -this.translatePage(isCanvas, null, this.currentPageNumber - 1, this.currentPageNumber), 0, 0) : null, null, null, null, null, this.chart.themeStyle.legendLabelFont);
        if (isCanvas) {
            var textSize = measureText(legendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont);
            this.legendRegions[i].rect.y = textOptions.y < this.legendRegions[i].rect.y ? textOptions.y : this.legendRegions[i].rect.y;
            this.legendRegions[i].rect.width += textSize.width;
            this.legendRegions[i].rect.height = textSize.height;
            this.legendRegions[i].rect.y -= textSize.height * 0.5;
            this.legendRegions[i].rect.x -= (this.isRtlEnable) ? this.legendRegions[i].rect.width : 0;
        }
    };
    /**
     * To render legend paging elements for chart and accumulation chart
     *
     * @param chart
     * @param bounds
     * @param textOption
     * @param legendGroup
     * @param chart
     * @param bounds
     * @param textOption
     * @param legendGroup
     * @param chart
     * @param bounds
     * @param textOption
     * @param legendGroup
     * @param chart
     * @param bounds
     * @param textOption
     * @param legendGroup
     */
    // tslint:disable-next-line:max-func-body-length
    BaseLegend.prototype.renderPagingElements = function (chart, bounds, textOption, legendGroup) {
        var paginggroup = chart.renderer.createGroup({ id: this.legendID + '_navigation' });
        var isCanvas = this.isStockChartControl ? false : chart.enableCanvas;
        var titleHeight = this.isBulletChartControl ? 0 : this.legendTitleSize.height;
        var grayColor = (this.chart.theme.indexOf('Dark') > -1 || this.chart.theme.indexOf('Contrast') > -1) ? '#FFFFFF' : '#545454';
        var legend = chart.legendSettings; // to solve parameter lint error, legend declaration is here
        var padding = 8; // const padding for paging elements
        var pageUp = this.legendID + (!this.isRtlEnable ? '_pageup' : '_pagedown');
        var pageDown = this.legendID + (!this.isRtlEnable ? '_pagedown' : '_pageup');
        var symbolOption = new PathOption(pageUp, 'transparent', 5, grayColor, 1, '', '');
        var iconSize = this.pageButtonSize;
        // Page left arrow drawing calculation started here
        var rowCount = !legend.enablePages && this.isPaging && !this.isVertical && !this.isBulletChartControl ? 1 :
            (this.rowCount - 1);
        var titleWidth = this.isTitle && legend.titlePosition === 'Left' ? this.legendTitleSize.width : 0;
        this.pagingRegions = [];
        this.backwardArrowOpacity = this.currentPage !== 1 ? 1 : 0;
        this.forwardArrowOpacity = this.currentPage === this.totalPages ? 0 : 1;
        if (!isCanvas) {
            legendGroup.appendChild(paginggroup);
        }
        if (!this.isChartControl && !this.isAccChartControl) {
            if (this.isBulletChartControl || this.isStockChartControl || !this.isVertical) {
                this.totalPages = Math.ceil(this.totalPages / Math.max(1, this.rowCount - 1));
            }
            else {
                this.totalPages = Math.ceil(this.totalPages / this.maxColumns);
            }
        }
        if (paginggroup) {
            paginggroup.style.cursor = 'pointer';
        }
        if ((this.isChartControl || this.isAccChartControl) && !(!legend.enablePages && this.isPaging)) {
            this.clipPathHeight = this.pageHeights[0];
        }
        else {
            this.clipPathHeight = (rowCount * (this.maxItemHeight + legend.padding));
        }
        //this.clipPathHeight = !(this.isChartControl) ? (rowCount * (this.maxItemHeight + legend.padding)) : this.columnHeights[0];
        if (!isCanvas) {
            this.clipRect.setAttribute('height', this.clipPathHeight.toString());
        }
        else {
            //paging clipRect only for canvas mode
            this.pagingClipRect.height = this.legendBounds.height - this.clipPathHeight -
                (this.pagingClipRect.y - this.legendBounds.y) - legend.border.width;
            this.pagingClipRect.y = this.pagingClipRect.y + this.clipPathHeight;
            this.pagingClipRect.x += legend.border.width;
            this.pagingClipRect.width -= (legend.border.width + legend.border.width / 2);
            this.chart.renderer.clearRect(new Rect(this.pagingClipRect.x, this.pagingClipRect.y, this.pagingClipRect.width, this.pagingClipRect.height));
        }
        var pageTextElement;
        var x = (bounds.x + iconSize / 2);
        var y = bounds.y + this.clipPathHeight + ((titleHeight + bounds.height - this.clipPathHeight) / 2);
        if (this.isPaging && !legend.enablePages && !this.isVertical && !this.isBulletChartControl) {
            x = (bounds.x + this.pageButtonSize + titleWidth);
            y = legend.title && this.isTop ? (bounds.y + padding + titleHeight + (iconSize / 1) + 0.5) :
                (bounds.y + padding + iconSize + 0.5);
        }
        var size = measureText(this.totalPages + '/' + this.totalPages, legend.textStyle, this.chart.themeStyle.legendLabelFont);
        var translateX = (this.isRtlEnable) ? legend.border.width + (iconSize / 2) : bounds.width - (2 * (iconSize + padding) + padding + size.width);
        if (!isCanvas) {
            if (this.isVertical && !legend.enablePages && !this.isBulletChartControl) {
                x = bounds.x + (bounds.width / 2);
                y = bounds.y + (iconSize / 2) + (padding / 2) + titleHeight;
                symbolOption.opacity = this.backwardArrowOpacity;
                paginggroup.appendChild(drawSymbol({ x: x, y: y }, 'UpArrow', new Size(iconSize, iconSize), '', symbolOption, 'UpArrow'));
            }
            else {
                symbolOption.opacity = this.isBulletChartControl ? symbolOption.opacity :
                    (legend.enablePages ? 1 : !this.isRtlEnable ? this.backwardArrowOpacity : this.forwardArrowOpacity);
                paginggroup.appendChild(drawSymbol({ x: x, y: y }, 'LeftArrow', new Size(iconSize, iconSize), '', symbolOption, 'LeftArrow'));
            }
        }
        else {
            drawSymbol({ x: x, y: y }, 'LeftArrow', new Size(iconSize, iconSize), '', symbolOption, 'LeftArrow', this.chart.renderer, new Rect(translateX, 0, 0, 0));
        }
        this.pagingRegions.push(new Rect(!this.isRtlEnable ? x + bounds.width - (2 * (iconSize + padding) + padding + size.width) - iconSize * 0.5 : x, y - iconSize * 0.5, iconSize, iconSize));
        // Page numbering rendering calculation started here
        textOption.x = x + (iconSize / 2) + padding;
        textOption.y = y + (size.height / 4);
        textOption.id = this.legendID + '_pagenumber';
        textOption.text = !this.isRtlEnable ? '1/' + this.totalPages : this.totalPages + '/1';
        var color = (this.chart.theme.indexOf('Dark') > -1 || this.chart.theme.indexOf('Contrast') > -1) ? '#FFFFFF' : legend.textStyle.color || this.chart.themeStyle.legendLabelFont.color;
        if (isCanvas && this.totalNoOfPages) {
            textOption.text = !this.isRtlEnable ? this.currentPageNumber + '/' + this.totalNoOfPages : this.totalNoOfPages + '/' + this.currentPageNumber;
        }
        if (legend.enablePages || this.isBulletChartControl) {
            pageTextElement = textElement$1(chart.renderer, textOption, legend.textStyle, color, paginggroup, false, false, false, false, null, new Rect(translateX, 0, 0, 0), null, null, null, null, this.chart.themeStyle.legendLabelFont);
        }
        // Page right arrow rendering calculation started here
        x = textOption.x + padding + (iconSize / 2) + size.width;
        if (this.isPaging && !legend.enablePages && !this.isVertical) {
            x = (bounds.x + bounds.width - (this.isBulletChartControl ? this.fivePixel : 0) - this.pageButtonSize - (legend.title && legend.titlePosition === 'Right' ?
                this.legendTitleSize.width + this.fivePixel : 0));
        }
        symbolOption.id = pageDown;
        symbolOption.opacity = !legend.enablePages ? !this.isRtlEnable ? this.forwardArrowOpacity : this.backwardArrowOpacity : 1;
        if (!isCanvas) {
            if (this.isVertical && !legend.enablePages && !this.isBulletChartControl) {
                x = bounds.x + (bounds.width / 2);
                y = bounds.y + bounds.height - (iconSize / 2);
                paginggroup.appendChild(drawSymbol({ x: x, y: y }, 'DownArrow', new Size(iconSize, iconSize), '', symbolOption, 'DownArrow'));
            }
            else {
                paginggroup.appendChild(drawSymbol({ x: x, y: y }, 'RightArrow', new Size(iconSize, iconSize), '', symbolOption, 'RightArrow'));
            }
        }
        else {
            drawSymbol({ x: x, y: y }, 'RightArrow', new Size(iconSize, iconSize), '', symbolOption, 'RightArrow', this.chart.renderer, new Rect(translateX, 0, 0, 0));
        }
        this.pagingRegions.push(new Rect(!this.isRtlEnable ? x + (bounds.width - (2 * (iconSize + padding) + padding + size.width) - iconSize * 0.5) : x, y - iconSize * 0.5, iconSize, iconSize));
        if (!isCanvas && (legend.enablePages || this.isBulletChartControl)) {
            //placing the navigation buttons and page numbering in legend right corner
            paginggroup.setAttribute('transform', 'translate(' + translateX + ', ' + 0 + ')');
        }
        else {
            if (this.currentPageNumber === 1 && this.calTotalPage && (legend.enablePages || this.isBulletChartControl)) {
                this.totalNoOfPages = this.totalPages;
                this.calTotalPage = false;
            }
            if (!legend.enablePages && !this.isBulletChartControl) { // For new legend page navigation
                this.translatePage(isCanvas, null, this.currentPage - 1, this.currentPage, legend);
            }
        }
        if (legend.enablePages || this.isBulletChartControl) {
            this.translatePage(isCanvas, pageTextElement, this.currentPage - 1, this.currentPage, legend);
        }
    };
    BaseLegend.prototype.getPageHeight = function (pageHeights, pageCount) {
        var sum$$1 = 0;
        for (var i = 0; i < pageCount; i++) {
            sum$$1 += pageHeights[i];
        }
        return sum$$1;
    };
    /**
     * To translate legend pages for chart and accumulation chart
     *
     * @param pagingText
     * @param page
     * @param pageNumber
     * @param legend
     * @param pagingText
     * @param page
     * @param pageNumber
     * @param legend
     * @param pagingText
     * @param page
     * @param pageNumber
     * @param legend
     * @param pagingText
     * @param page
     * @param pageNumber
     * @param legend
     */
    BaseLegend.prototype.translatePage = function (isCanvas, pagingText, page, pageNumber, legend) {
        var size = (this.isChartControl || this.isAccChartControl) ? (page ? this.getPageHeight(this.pageHeights, page) : 0) : ((this.clipPathHeight) * page);
        if (!isCanvas && (this.isChartControl || this.isAccChartControl)) {
            this.clipRect.setAttribute('height', this.pageHeights[page].toString());
            if (this.isAccChartControl && this.isPaging && !legend.enablePages && this.isVertical) {
                this.clipRect.setAttribute('height', this.legendBounds.height.toString());
            }
        }
        var translate = 'translate(0,-' + size + ')';
        if (!this.isChartControl && !this.isBulletChartControl && !this.isStockChartControl && this.isVertical) {
            var pageX = this.pageXCollections[page * this.maxColumns];
            size = (!this.isRtlEnable) ? pageX - this.legendBounds.x : (this.legendBounds.x + this.maxWidth) - pageX;
            size = size < 0 ? 0 : size; // to avoid small pixel variation
            translate = ((!this.isRtlEnable) ? 'translate(-' : 'translate(') + size + ',0)';
        }
        if (!this.chart.enableCanvas) {
            this.legendTranslateGroup.setAttribute('transform', translate);
        }
        if (!this.chart.enableCanvas && (legend.enablePages || this.isBulletChartControl)) {
            pagingText.textContent = (pageNumber) + '/' + this.totalPages;
        }
        this.currentPage = pageNumber;
        return size;
    };
    /**
     * To change legend pages for chart and accumulation chart
     *
     * @param event
     * @param pageUp
     * @param event
     * @param pageUp
     */
    BaseLegend.prototype.changePage = function (event, pageUp) {
        var legend = this.chart.legendSettings;
        var backwardArrow = document.getElementById(this.legendID + '_pageup');
        var forwardArrow = document.getElementById(this.legendID + '_pagedown');
        var isCanvas = this.isStockChartControl ? false : this.chart.enableCanvas;
        var pageText = (legend.enablePages || this.isBulletChartControl) ?
            document.getElementById(this.legendID + '_pagenumber') : null;
        var page = (legend.enablePages || this.isBulletChartControl) ? parseInt(pageText.textContent.split('/')[0], 10) :
            this.currentPage;
        if (pageUp && page > 1) {
            this.translatePage(isCanvas, pageText, (page - 2), (page - 1), legend);
        }
        else if (!pageUp && page < this.totalPages) {
            this.translatePage(isCanvas, pageText, page, (page + 1), legend);
        }
        if (this.isPaging && !legend.enablePages && !this.isBulletChartControl) {
            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
            this.currentPage === this.totalPages ? this.hideArrow(forwardArrow) : this.showArrow(forwardArrow);
            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
            this.currentPage === 1 ? this.hideArrow(backwardArrow) : this.showArrow(backwardArrow);
        }
    };
    /**
     * To hide the backward and forward arrow
     *
     * @param arrowElement
     */
    BaseLegend.prototype.hideArrow = function (arrowElement) {
        arrowElement.setAttribute('opacity', '0');
    };
    /**
     * To show the  backward and forward arrow
     *
     * @param arrowElement
     */
    BaseLegend.prototype.showArrow = function (arrowElement) {
        arrowElement.setAttribute('opacity', '1');
    };
    /**
     * To find legend elements id based on chart or accumulation chart
     *
     * @param option
     * @param prefix
     * @param count
     * @param option
     * @param prefix
     * @param count
     * @param option
     * @param prefix
     * @param count
     * @private
     */
    BaseLegend.prototype.generateId = function (option, prefix, count) {
        if (this.isChartControl || this.isStockChartControl) {
            return prefix + count;
        }
        else {
            return prefix + option.pointIndex;
        }
    };
    /**
     * To show or hide trimmed text tooltip for legend.
     *
     * @param event
     * @returns {void}
     * @private
     */
    BaseLegend.prototype.move = function (event) {
        var _this = this;
        var x = this.chart.mouseX;
        var y = this.chart.mouseY;
        if (event.target.textContent.indexOf('...') > -1) {
            var targetId = event.target.id.split(this.legendID + '_text_');
            if (targetId.length === 2) {
                var index = parseInt(targetId[1], 10);
                var element = this.chart.element;
                if (!isNaN(index)) {
                    if (this.chart.isTouch) {
                        removeElement$1(this.chart.element.id + '_EJ2_Legend_Tooltip');
                    }
                    if (this.isChartControl) {
                        showTooltip(this.chart.series[index].name, x, y, element.offsetWidth, element.id + '_EJ2_Legend_Tooltip', getElement$1(this.chart.element.id + '_Secondary_Element'));
                    }
                    else {
                        showTooltip(this.chart.visibleSeries[0].points[index].x.toString(), x + 10, y + 10, element.offsetWidth, element.id + '_EJ2_Legend_Tooltip', getElement$1(this.chart.element.id + '_Secondary_Element'));
                    }
                }
            }
        }
        else {
            removeElement$1(this.chart.element.id + '_EJ2_Legend_Tooltip');
        }
        if (this.chart.isTouch) {
            clearTimeout(this.clearTooltip);
            this.clearTooltip = +setTimeout(function () { removeElement$1(_this.chart.element.id + '_EJ2_Legend_Tooltip'); }, 1000);
        }
    };
    return BaseLegend;
}());
/**
 * Class for legend options
 *
 * @private
 */
var LegendOptions = /** @__PURE__ @class */ (function () {
    function LegendOptions(text, fill, shape, visible, type, url, markerShape, markerVisibility, pointIndex, seriesIndex, dashArray) {
        this.location = { x: 0, y: 0 };
        this.textCollection = [];
        this.text = text;
        this.fill = fill;
        this.shape = shape;
        this.url = url;
        this.visible = visible;
        this.type = type;
        this.markerVisibility = markerVisibility;
        this.markerShape = markerShape;
        this.pointIndex = pointIndex;
        this.seriesIndex = seriesIndex;
        this.dashArray = dashArray;
    }
    return LegendOptions;
}());

var __extends$9 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
// eslint-disable-next-line @typescript-eslint/triple-slash-reference
/// <reference path='../series/chart-series-model.d.ts' />
/**
 * Defines how to represent the market trend using technical indicators
 */
var TechnicalIndicator = /** @__PURE__ @class */ (function (_super) {
    __extends$9(TechnicalIndicator, _super);
    function TechnicalIndicator() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** @private */
        _this.clipRect = new Rect(0, 0, 0, 0);
        return _this;
    }
    /** @private */
    TechnicalIndicator.prototype.setDataSource = function (series, chart) {
        if (series) {
            this.xData = series.xData;
            this.yData = series.yData;
            this.points = series.points;
        }
        var type = firstToLowerCase(this.type);
        if (this.visible) {
            chart[type + 'IndicatorModule'].initDataSource(this, chart);
        }
        chart.visibleSeriesCount += this.targetSeries.length;
    };
    __decorate$6([
        Property('Sma')
    ], TechnicalIndicator.prototype, "type", void 0);
    __decorate$6([
        Property(14)
    ], TechnicalIndicator.prototype, "period", void 0);
    __decorate$6([
        Property(14)
    ], TechnicalIndicator.prototype, "kPeriod", void 0);
    __decorate$6([
        Property(3)
    ], TechnicalIndicator.prototype, "dPeriod", void 0);
    __decorate$6([
        Property(80)
    ], TechnicalIndicator.prototype, "overBought", void 0);
    __decorate$6([
        Property(20)
    ], TechnicalIndicator.prototype, "overSold", void 0);
    __decorate$6([
        Property(2)
    ], TechnicalIndicator.prototype, "standardDeviation", void 0);
    __decorate$6([
        Property('Close')
    ], TechnicalIndicator.prototype, "field", void 0);
    __decorate$6([
        Property(12)
    ], TechnicalIndicator.prototype, "slowPeriod", void 0);
    __decorate$6([
        Property(26)
    ], TechnicalIndicator.prototype, "fastPeriod", void 0);
    __decorate$6([
        Property(true)
    ], TechnicalIndicator.prototype, "showZones", void 0);
    __decorate$6([
        Complex({ color: '#ff9933', width: 2 }, Connector)
    ], TechnicalIndicator.prototype, "macdLine", void 0);
    __decorate$6([
        Property('Both')
    ], TechnicalIndicator.prototype, "macdType", void 0);
    __decorate$6([
        Property('#2ecd71')
    ], TechnicalIndicator.prototype, "macdPositiveColor", void 0);
    __decorate$6([
        Property('#e74c3d')
    ], TechnicalIndicator.prototype, "macdNegativeColor", void 0);
    __decorate$6([
        Property('rgba(211,211,211,0.25)')
    ], TechnicalIndicator.prototype, "bandColor", void 0);
    __decorate$6([
        Complex({ color: '#ffb735', width: 1 }, Connector)
    ], TechnicalIndicator.prototype, "upperLine", void 0);
    __decorate$6([
        Complex({ color: '#f2ec2f', width: 1 }, Connector)
    ], TechnicalIndicator.prototype, "lowerLine", void 0);
    __decorate$6([
        Complex({ color: '#f2ec2f', width: 1 }, Connector)
    ], TechnicalIndicator.prototype, "periodLine", void 0);
    __decorate$6([
        Property('')
    ], TechnicalIndicator.prototype, "seriesName", void 0);
    return TechnicalIndicator;
}(SeriesBase));

var PrintUtils = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for chart and accumulation annotation
     *
     * @param control
     */
    function PrintUtils(control) {
        this.control = control;
    }
    /**
     * To print the accumulation and chart elements.
     *
     * @param elements
     */
    PrintUtils.prototype.print = function (elements) {
        this.printWindow = window.open('', 'print', 'height=' + window.outerHeight + ',width=' + window.outerWidth + ',tabbar=no');
        this.printWindow.moveTo(0, 0);
        this.printWindow.resizeTo(screen.availWidth, screen.availHeight);
        var argsData = {
            cancel: false, htmlContent: this.getHTMLContent(elements), name: beforePrint
        };
        this.control.trigger(beforePrint, argsData);
        if (!argsData.cancel) {
            print(argsData.htmlContent, this.printWindow);
        }
    };
    /**
     * To get the html string of the chart and accumulation
     *
     * @param elements
     * @private
     */
    PrintUtils.prototype.getHTMLContent = function (elements) {
        var div = createElement('div');
        if (elements) {
            if (elements instanceof Array) {
                for (var j = 0; j < elements.length; j++) {
                    var value = elements[j];
                    div.appendChild(getElement$1(value).cloneNode(true));
                }
            }
            else if (elements instanceof Element) {
                div.appendChild(elements.cloneNode(true));
            }
            else {
                div.appendChild(getElement$1(elements).cloneNode(true));
            }
        }
        else {
            div.appendChild(this.control.element.cloneNode(true));
        }
        for (var index = 0; index < div.children.length; index++) {
            var backgroundColor = (this.control.theme.indexOf('Dark') > -1 || this.control.theme === 'HighContrast') ? 'rgba(0, 0, 0, 1)' : 'rgba(255, 255, 255, 1)';
            var svg = div.children[index];
            for (var childIndex = 0; childIndex < svg.children.length; childIndex++) {
                var actualBackgroundColor = void 0;
                var isSVG = false;
                if (svg.id.indexOf('_stockChart_svg') > -1) {
                    actualBackgroundColor = svg.children[0].getAttribute('fill');
                    isSVG = true;
                }
                else if (svg.children[childIndex].id.indexOf('_svg') > -1) {
                    actualBackgroundColor = svg.children[childIndex].children[0].getAttribute('fill');
                    isSVG = true;
                }
                if (isSVG) {
                    actualBackgroundColor = actualBackgroundColor === 'transparent' ? backgroundColor : actualBackgroundColor;
                    svg.children[childIndex].children[0].setAttribute('fill', actualBackgroundColor);
                }
            }
            div[index] = svg;
        }
        return div;
    };
    return PrintUtils;
}());

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable jsdoc/valid-types */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable jsdoc/require-param-type */
/* eslint-disable jsdoc/require-returns-description */
/* eslint-disable @typescript-eslint/no-this-alias */
/* eslint-disable curly */
/* eslint-disable @typescript-eslint/tslint/config */
/* eslint-disable no-case-declarations */
/* eslint-disable max-len */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * Configures the RangeColorSetting in the chart.
 */
var RangeColorSetting = /** @__PURE__ @class */ (function (_super) {
    __extends(RangeColorSetting, _super);
    function RangeColorSetting() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        Property()
    ], RangeColorSetting.prototype, "start", void 0);
    __decorate([
        Property()
    ], RangeColorSetting.prototype, "end", void 0);
    __decorate([
        Property([])
    ], RangeColorSetting.prototype, "colors", void 0);
    __decorate([
        Property('')
    ], RangeColorSetting.prototype, "label", void 0);
    return RangeColorSetting;
}(ChildProperty));
/**
 * Configures the crosshair in the chart.
 */
var CrosshairSettings = /** @__PURE__ @class */ (function (_super) {
    __extends(CrosshairSettings, _super);
    function CrosshairSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        Property(false)
    ], CrosshairSettings.prototype, "enable", void 0);
    __decorate([
        Property('')
    ], CrosshairSettings.prototype, "dashArray", void 0);
    __decorate([
        Complex({ color: null, width: 1 }, Border)
    ], CrosshairSettings.prototype, "line", void 0);
    __decorate([
        Property('Both')
    ], CrosshairSettings.prototype, "lineType", void 0);
    __decorate([
        Property('')
    ], CrosshairSettings.prototype, "verticalLineColor", void 0);
    __decorate([
        Property('')
    ], CrosshairSettings.prototype, "horizontalLineColor", void 0);
    __decorate([
        Property(1)
    ], CrosshairSettings.prototype, "opacity", void 0);
    return CrosshairSettings;
}(ChildProperty));
/**
 * Configures the zooming behavior for the chart.
 */
var ZoomSettings = /** @__PURE__ @class */ (function (_super) {
    __extends(ZoomSettings, _super);
    function ZoomSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        Property(false)
    ], ZoomSettings.prototype, "enableSelectionZooming", void 0);
    __decorate([
        Property(false)
    ], ZoomSettings.prototype, "enablePinchZooming", void 0);
    __decorate([
        Property(false)
    ], ZoomSettings.prototype, "showToolbar", void 0);
    __decorate([
        Property(false)
    ], ZoomSettings.prototype, "enableMouseWheelZooming", void 0);
    __decorate([
        Property(true)
    ], ZoomSettings.prototype, "enableDeferredZooming", void 0);
    __decorate([
        Property('XY')
    ], ZoomSettings.prototype, "mode", void 0);
    __decorate([
        Property(['Zoom', 'ZoomIn', 'ZoomOut', 'Pan', 'Reset'])
    ], ZoomSettings.prototype, "toolbarItems", void 0);
    __decorate([
        Property(false)
    ], ZoomSettings.prototype, "enablePan", void 0);
    __decorate([
        Property(false)
    ], ZoomSettings.prototype, "enableScrollbar", void 0);
    return ZoomSettings;
}(ChildProperty));
/**
 * Represents the Chart control.
 * ```html
 * <div id="chart"/>
 * <script>
 *   var chartObj = new Chart({ isResponsive : true });
 *   chartObj.appendTo("#chart");
 * </script>
 * ```
 *
 * @public
 */
var Chart = /** @__PURE__ @class */ (function (_super) {
    __extends(Chart, _super);
    /**
     * Constructor for creating the widget
     *
     * @hidden
     */
    function Chart(options, element) {
        var _this = _super.call(this, options, element) || this;
        /** @private */
        _this.rotatedDataLabelCollections = [];
        /** @public */
        _this.animated = false;
        /** @private */
        _this.isPointMouseDown = false;
        /** @private */
        _this.isScrolling = false;
        /** @private */
        _this.checkResize = 0;
        /** @private */
        _this.visible = 0;
        /** @private */
        _this.clickCount = 0;
        /** @private */
        _this.maxPointCount = 0;
        /** @private */
        _this.singleClickTimer = 0;
        /** @private */
        _this.chartAreaType = 'Cartesian';
        /** @private */
        _this.isRtlEnabled = false;
        /** @private */
        _this.scaleX = 1;
        /** @private */
        _this.scaleY = 1;
        _this.isCrosshair = true;
        _this.chartid = 57723;
        /** @private */
        _this.isLegendClicked = false;
        _this.isZoomed = false;
        _this.previousTargetId = '';
        _this.currentPointIndex = 0;
        _this.currentSeriesIndex = 0;
        _this.currentLegendIndex = 0;
        _this.previousPageX = null;
        _this.previousPageY = null;
        _this.allowPan = false;
        setValue('mergePersistData', _this.mergePersistChartData, _this);
        return _this;
    }
    /**
     * To manage persist chart data
     */
    Chart.prototype.mergePersistChartData = function () {
        var data = window.localStorage.getItem(this.getModuleName() + this.element.id);
        if (!(isNullOrUndefined(data) || (data === ''))) {
            var dataObj = JSON.parse(data);
            var keys = Object.keys(dataObj);
            this.isProtectedOnChange = true;
            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                var key = keys_1[_i];
                if ((typeof this[key] === 'object') && !isNullOrUndefined(this[key])) {
                    extend(this[key], dataObj[key]);
                }
                else {
                    this[key] = dataObj[key];
                }
            }
            this.isProtectedOnChange = false;
        }
    };
    /**
     *
     * @param elementId
     * Return the proper ID when the special character exist in the ID
     */
    Chart.prototype.isIdHasSpecialCharacter = function (elementId) {
        var regex = /^[A-Za-z ]+$/;
        var numberRegex = /^[0-9 ]+$/;
        var childElementId = '';
        if (!regex.test(elementId)) {
            var start = 0;
            if (numberRegex.test(elementId[0])) {
                childElementId += ('\\3' + elementId[0]);
                start = 1;
            }
            for (var i = start; i < elementId.length; i++) {
                if (!regex.test(elementId[i]) && elementId.indexOf('-') === -1 &&
                    elementId.indexOf('_') === -1 && elementId.indexOf('\\') === -1 && !numberRegex.test(elementId[i])) {
                    childElementId += ('\\' + elementId[i]);
                }
                else {
                    childElementId += elementId[i];
                }
            }
            return childElementId;
        }
        else {
            return elementId;
        }
    };
    /**
     * Initialize the event handler.
     */
    Chart.prototype.preRender = function () {
        this.element.id = this.isIdHasSpecialCharacter(this.element.id);
        // It is used for checking blazor framework or not.
        var blazor = 'Blazor';
        this.isBlazor = window[blazor];
        this.allowServerDataBinding = false;
        this.markerIndex = 0;
        this.unWireEvents();
        this.initPrivateVariable();
        this.setCulture();
        this.wireEvents();
        if (this.stockChart) {
            if (this.stockChart.tooltip.header === null) {
                this.tooltip.header = '<b>${point.x}</b>';
            }
            if (this.stockChart.tooltip.format === null) {
                this.tooltip.format = 'High : <b>${point.high}</b><br/>Low :' +
                    ' <b>${point.low}</b><br/>Open : <b>${point.open}</b><br/>Close : <b>${point.close}</b>';
            }
        }
        this.element.setAttribute('dir', this.enableRtl ? 'rtl' : '');
    };
    Chart.prototype.initPrivateVariable = function () {
        this.animateSeries = true;
        this.delayRedraw = false;
        this.dragY = null;
        this.horizontalAxes = [];
        this.verticalAxes = [];
        this.refreshAxis();
        this.refreshDefinition(this.rows);
        this.refreshDefinition(this.columns);
        if (this.tooltipModule) {
            this.tooltipModule.previousPoints = [];
        }
        this.element.setAttribute('role', 'region');
        this.element.setAttribute('tabindex', '0');
        this.element.setAttribute('aria-label', this.description || this.title + '. Syncfusion interactive chart.');
        if (!(this.element.classList.contains("e-chart-focused"))) {
            this.element.setAttribute('class', this.element.getAttribute('class') + ' e-chart-focused');
        }
        if (this.element.id === '') {
            var collection = document.getElementsByClassName('e-chart').length;
            var elementid = 'chart_' + this.chartid + '_' + collection;
            while (document.getElementById(elementid)) {
                collection++;
                elementid = 'chart_' + this.chartid + '_' + collection;
            }
            this.element.id = 'chart_' + this.chartid + '_' + collection;
        }
        //seperate ID to differentiate chart and stock chart
        this.svgId = this.stockChart ? this.stockChart.element.id + '_stockChart_chart' :
            this.element.id + (this.enableCanvas ? '_canvas' : '_svg');
    };
    /**
     * To Initialize the control rendering.
     */
    Chart.prototype.render = function () {
        var _this = this;
        this.svgRenderer = new SvgRenderer(this.element.id);
        var loadEventData = {
            chart: this.isBlazor ? {} : this, theme: this.theme, name: load, cancel: false
        };
        if (!this.stockChart) {
            /**
             * Load event for the chart will be triggered only chart componet, if this is stock chart, load event did not triggered.
             */
            this.trigger(load, loadEventData, function () {
                if (!loadEventData.cancel) {
                    _this.cartesianChartRendering(loadEventData);
                }
            });
        }
        else {
            // The fix is specific for nextjs app, as window is set as not defined for server side application like nextjs.
            this.isRtlEnabled = (window.getComputedStyle(document.querySelector('body')).direction === 'rtl');
            this.cartesianChartRendering(loadEventData);
        }
        this.applyZoomkit();
    };
    Chart.prototype.cartesianChartRendering = function (beforeRenderData) {
        this.theme = this.isBlazor ? beforeRenderData.theme : this.theme;
        this.setTheme();
        this.createChartSvg();
        this.markerRender = new Marker(this);
        this.calculateAreaType();
        this.calculateVisibleSeries();
        this.initTechnicalIndicators();
        this.initTrendLines();
        this.calculateVisibleAxis();
        this.processData();
        this.renderComplete();
        this.mouseMoveEvent();
        this.allowServerDataBinding = true;
    };
    /**
     * Gets the localized label by locale keyword.
     *
     * @param  {string} key key
     * @returns {string} localized label
     */
    Chart.prototype.getLocalizedLabel = function (key) {
        return this.localeObject.getConstant(key);
    };
    /**
     * Animate the series bounds.
     *
     * @private
     */
    Chart.prototype.animate = function (duration) {
        this.redraw = true;
        this.animated = true; //used to set duration as 1000 for animation at default 300
        this.duration = duration ? duration : 1000;
        if (this.tooltipModule) {
            this.tooltipModule.removeHighlightedMarker(this.tooltipModule.previousPoints, true);
        }
        else if (this.markerRender.previousPoints) {
            for (var previousPoint = 0; previousPoint < this.markerRender.previousPoints.length; previousPoint++)
                this.markerRender.removeHighlightedMarker(this.markerRender.previousPoints[previousPoint].series, this.markerRender.previousPoints[previousPoint].point);
        }
    };
    /**
     * Refresh the chart bounds.
     *
     * @private
     */
    Chart.prototype.refreshBound = function () {
        this.rotatedDataLabelCollections = [];
        if (this.legendModule && this.legendSettings.visible) {
            this.legendModule.getLegendOptions(this.visibleSeries, this);
        }
        /**
         * I264230, EJ2-36761
         * Issue: Tooltip doesnot appears after zooming and hovering on same point
         * Root cause: While performing zoom, previous points in tooltip restore.
         * Fix: previous points set to empty array
         */
        if (this.tooltip.enable && this.tooltipModule) {
            this.tooltipModule.previousPoints = [];
        }
        this.calculateStackValues();
        this.calculateBounds();
        //this prevents the initial rendering of stock chart
        if (this.stockChart && !this.stockChart.rangeFound) {
            if (this.stockChart.enablePeriodSelector || this.stockChart.enableSelector) {
                return null;
            }
        }
        this.renderElements();
        removeElement$1('chartmeasuretext');
        this.removeSelection();
        if (this.markerRender) {
            this.markerRender.mergeXvalues(this.visibleSeries);
        }
    };
    /**
     * To calcualte the stack values
     */
    Chart.prototype.calculateStackValues = function () {
        var series;
        var isCalculateStacking = false;
        for (var i = 0, len = this.visibleSeries.length; i < len; i++) {
            series = this.visibleSeries[i];
            series.position = series.rectCount = undefined;
            if (((series.type.indexOf('Stacking') !== -1) || (series.drawType.indexOf('Stacking') !== -1
                && this.chartAreaType === 'PolarRadar')) && !isCalculateStacking) {
                series.calculateStackedValue(series.type.indexOf('100') > -1, this);
                isCalculateStacking = true;
            }
        }
    };
    Chart.prototype.removeSelection = function () {
        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            if (series.visible) {
                for (var _b = 0, _c = series.points; _b < _c.length; _b++) {
                    var point = _c[_b];
                    point.isSelect = false;
                }
            }
        }
        if (getElement$1(this.element.id + '_ej2_drag_multi_group')) {
            if (this.selectionMode.indexOf('Drag') > -1) {
                this.selectionModule.filterArray = [];
            }
            removeElement$1(this.element.id + '_ej2_drag_multi_group');
            this.selectionModule.calculateDragSelectedElements(this, new Rect(0, 0, 0, 0), true);
        }
        else if (getElement$1(this.element.id + '_ej2_drag_group')) {
            if (this.selectionMode !== 'Lasso') {
                this.selectionModule.filterArray = [];
            }
            removeElement$1(this.element.id + '_ej2_drag_group');
            this.selectionModule.calculateDragSelectedElements(this, new Rect(0, 0, 0, 0), true);
        }
    };
    Chart.prototype.renderElements = function () {
        this.renderBorder();
        this.renderTitle();
        this.renderAreaBorder();
        this.renderSeriesElements(this.renderAxes());
        this.renderLegend();
        this.applyZoomkit();
        this.performSelection();
        this.setSecondaryElementPosition();
        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
            var value = _a[_i];
            updateBlazorTemplate(this.element.id + '_DataLabel', 'Template', value.marker.dataLabel);
        }
        this.renderAnnotation();
    };
    /**
     * To render the legend
     *
     * @private
     */
    Chart.prototype.renderAxes = function () {
        this.yAxisElements = this.renderer.createGroup({ id: this.element.id + 'yAxisCollection' });
        var axisElement;
        if (this.rows.length > 0 && this.columns.length > 0) {
            axisElement = this.chartAxisLayoutPanel.renderAxes();
        }
        if (this.stripLineModule) {
            this.stripLineModule.renderStripLine(this, 'Behind', this.axisCollections);
        }
        return axisElement;
    };
    /**
     * To render the legend
     */
    Chart.prototype.renderLegend = function () {
        if (this.legendModule && this.legendModule.legendCollections.length && this.legendSettings.visible) {
            this.legendModule.calTotalPage = true;
            var borderWidth = this.legendSettings.border.width;
            var bounds = this.legendModule.legendBounds;
            var rect = new Rect(bounds.x, bounds.y, bounds.width, bounds.height);
            if (this.enableCanvas) {
                rect = new Rect(rect.x - borderWidth / 2, rect.y - borderWidth / 2, rect.width + borderWidth, rect.height + borderWidth);
                this.renderer.canvasClip(rect);
            }
            this.legendModule.renderLegend(this, this.legendSettings, bounds);
            if (this.enableCanvas) {
                this.renderer.canvasRestore();
            }
        }
        if (!this.redraw) {
            if (!this.stockChart) {
                this.element.appendChild(this.svgObject);
            }
            else {
                if (!getElement$1(this.stockChart.chartObject.id)) {
                    this.stockChart.mainObject.appendChild(this.svgObject);
                }
            }
        }
    };
    /**
     * To set the left and top position for data label template for center aligned chart
     */
    Chart.prototype.setSecondaryElementPosition = function () {
        var element = getElement$1(this.element.id + '_Secondary_Element');
        if (!element) {
            return;
        }
        var rect = this.element.getBoundingClientRect();
        var svgRect = getElement$1(this.svgId).getBoundingClientRect();
        element.style.left = Math.max(svgRect.left - rect.left, 0) + 'px';
        element.style.top = Math.max(svgRect.top - rect.top, 0) + 'px';
    };
    Chart.prototype.initializeModuleElements = function () {
        this.dataLabelCollections = [];
        var elementId = this.element.id;
        if (this.series.length) {
            this.seriesElements = this.svgRenderer.createGroup({ id: elementId + 'SeriesCollection' });
        }
        if (this.indicators.length) {
            this.indicatorElements = this.renderer.createGroup({ id: elementId + 'IndicatorCollection' });
        }
        if (this.hasTrendlines()) {
            this.trendLineElements = this.renderer.createGroup({ id: elementId + 'TrendLineCollection' });
        }
        this.dataLabelElements = this.renderer.createGroup({ id: elementId + 'DataLabelCollection' });
    };
    Chart.prototype.hasTrendlines = function () {
        var isTrendline;
        for (var _i = 0, _a = this.series; _i < _a.length; _i++) {
            var series = _a[_i];
            isTrendline = series.trendlines.length ? true : false;
            if (isTrendline) {
                break;
            }
        }
        return isTrendline;
    };
    Chart.prototype.renderSeriesElements = function (axisElement) {
        // Initialize the series elements values
        this.initializeModuleElements();
        var elementId = this.element.id;
        if (this.element.tagName !== 'g') {
            var tooltipDiv = redrawElement(this.redraw, elementId + '_Secondary_Element') ||
                this.createElement('div');
            tooltipDiv.id = elementId + '_Secondary_Element';
            tooltipDiv.style.cssText = 'position: relative';
            appendChildElement(false, this.element, tooltipDiv, this.redraw);
        }
        // For canvas
        if (this.enableCanvas) {
            var tooltipdiv = document.getElementById(elementId + '_Secondary_Element');
            tooltipdiv = !tooltipdiv ? this.createElement('div', { id: elementId + '_Secondary_Element',
                attrs: { 'style': 'position: relative; left:0px; top:0px' } }) : tooltipdiv;
            var svg = this.svgRenderer.createSvg({
                id: elementId + '_tooltip_svg',
                width: this.availableSize.width,
                height: this.availableSize.height
            });
            svg.style.cssText = 'position: absolute; pointer-events: none';
            tooltipdiv.appendChild(svg);
        }
        // For userInteraction
        if (this.tooltip.enable) {
            appendChildElement(this.enableCanvas, this.svgObject, this.renderer.createGroup({ id: elementId + '_UserInteraction', style: 'pointer-events:none;' }), this.redraw);
        }
        if (this.rows.length > 0 && this.columns.length > 0) {
            this.initializeIndicator();
            this.initializeTrendLine();
            this.renderSeries();
            // Trendline is append to DOM after the series
            if (this.trendLineElements) {
                appendChildElement(this.enableCanvas, this.svgObject, this.trendLineElements, this.redraw);
            }
            this.appendElementsAfterSeries(axisElement);
        }
    };
    /**
     * @private
     */
    Chart.prototype.renderSeries = function () {
        var visibility;
        if (this.enableCanvas) {
            // To clip the series rect for canvas
            this.renderer.canvasClip(this.chartAxisLayoutPanel.seriesClipRect);
        }
        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
            var item = _a[_i];
            if (item.category === 'TrendLine') {
                visibility = this.series[item.sourceIndex].trendlines[item.index].visible;
            }
            else {
                visibility = item.visible;
            }
            if (visibility) {
                this.visible++;
                findClipRect(item, this.enableCanvas);
                if (this.enableCanvas) {
                    // To render scatter and bubble series in canvas
                    this.renderCanvasSeries(item);
                }
                item.renderSeries(this);
            }
        }
        if (this.enableCanvas) {
            this.renderer.canvasRestore();
        }
        this.visible = 0;
        var options = {
            'id': this.element.id + '_ChartAreaClipRect_',
            'x': this.chartAxisLayoutPanel.seriesClipRect.x,
            'y': this.chartAxisLayoutPanel.seriesClipRect.y,
            'width': this.chartAxisLayoutPanel.seriesClipRect.width,
            'height': this.chartAxisLayoutPanel.seriesClipRect.height,
            'fill': 'transparent',
            'stroke-width': 1,
            'stroke': 'Gray'
        };
        if (!this.seriesElements) {
            return;
        }
        var clipRectElement;
        if (this.chartAreaType === 'PolarRadar') {
            clipRectElement = appendClipElement(this.redraw, options, this.renderer, 'drawCircularClipPath');
        }
        else {
            clipRectElement = appendClipElement(this.redraw, options, this.renderer);
        }
        if (!this.enableCanvas) {
            this.seriesElements.appendChild(clipRectElement);
        }
        var seriesSvg = document.getElementById(this.element.id + '_series_svg');
        if (seriesSvg) {
            appendChildElement(false, seriesSvg, this.seriesElements, this.redraw);
        }
        else {
            appendChildElement(this.enableCanvas, this.svgObject, this.seriesElements, this.redraw);
        }
    };
    Chart.prototype.renderCanvasSeries = function (item) {
        var svgElement;
        // eslint-disable-next-line prefer-const
        svgElement = (this.enableCanvas) ?
            svgElement : this.svgObject;
        var canvas = (this.enableCanvas) ?
            false : this.enableCanvas;
    };
    Chart.prototype.initializeIndicator = function () {
        for (var _i = 0, _a = this.indicators; _i < _a.length; _i++) {
            var indicator = _a[_i];
            if (this[firstToLowerCase(indicator.type) + 'IndicatorModule']) {
                this[firstToLowerCase(indicator.type) + 'IndicatorModule'].createIndicatorElements(this, indicator, indicator.index);
            }
        }
        if (this.indicatorElements) {
            appendChildElement(this.enableCanvas, this.svgObject, this.indicatorElements, this.redraw);
        }
    };
    Chart.prototype.initializeTrendLine = function () {
        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            if (series.trendlines.length) {
                this.trendLineModule.getTrendLineElements(series, this);
            }
        }
    };
    Chart.prototype.appendElementsAfterSeries = function (axisElement) {
        if (this.chartAreaType === 'PolarRadar') {
            appendChildElement(this.enableCanvas, this.svgObject, this.yAxisElements, this.redraw);
        }
        appendChildElement(this.enableCanvas, this.svgObject, axisElement, this.redraw);
        if ((this.zoomModule && this.zoomSettings.enableScrollbar && this.scrollElement.childElementCount) ||
            (this.scrollElement && this.scrollElement.childElementCount)) {
            appendChildElement(false, getElement$1(this.element.id + '_Secondary_Element'), this.scrollElement, this.redraw);
        }
        if (this.stripLineModule) {
            this.stripLineModule.renderStripLine(this, 'Over', this.axisCollections);
        }
        if (!this.tooltip.enable) {
            appendChildElement(this.enableCanvas, this.svgObject, this.renderer.createGroup({ id: this.element.id + '_UserInteraction', style: 'pointer-events:none;' }), this.redraw);
        }
        if (this.stockChart) {
            this.stockChart.calculateStockEvents();
        }
    };
    Chart.prototype.applyZoomkit = function () {
        /**
         * Issue: Zoomkit not visible after performing refresh()
         * Fix: this method called without checking `zoomModule.isZoomed`
         */
        if (this.chartAreaType === 'PolarRadar') {
            return;
        }
        if (!this.redraw && this.zoomModule && (!this.zoomSettings.enablePan || this.zoomModule.performedUI || this.zoomSettings.showToolbar)) {
            this.zoomModule.applyZoomToolkit(this, this.axisCollections);
        }
    };
    /**
     * Render annotation perform here
     *
     * @private
     */
    Chart.prototype.renderAnnotation = function () {
        if (this.annotationModule) {
            //for stock chart, stock chart's id is added to render the annotations
            this.annotationModule.renderAnnotations(getElement$1((this.stockChart ? this.stockChart.element.id : this.element.id) + '_Secondary_Element'));
        }
    };
    Chart.prototype.performSelection = function () {
        var selectedDataIndexes = [];
        if (this.selectionModule) {
            selectedDataIndexes = extend([], this.selectionModule.selectedDataIndexes, null, true);
            this.selectionModule.invokeSelection(this);
        }
        if (this.highlightModule) {
            this.highlightModule.invokeHighlight(this);
        }
        if (selectedDataIndexes.length > 0) {
            this.selectionModule.selectedDataIndexes = selectedDataIndexes;
            this.selectionModule.redrawSelection(this, this.selectionMode);
        }
    };
    Chart.prototype.processData = function (render) {
        if (render === void 0) { render = true; }
        this.visibleSeriesCount = 0;
        var check = true;
        var prevPointCount = 0;
        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            if (!series.visible && !this.legendSettings.visible) {
                this.visibleSeriesCount++;
                continue;
            }
            if (series.category !== 'Indicator' && series.category !== 'TrendLine') {
                this.initializeDataModule(series);
            }
        }
        for (var _b = 0, _c = this.indicators; _b < _c.length; _b++) {
            var indicator = _c[_b];
            if (indicator.dataSource) {
                var techIndicator = indicator;
                this.initializeDataModule(techIndicator);
                check = false;
            }
        }
        if (render && (!this.visibleSeries.length || this.visibleSeriesCount === this.visibleSeries.length && check)) {
            this.refreshBound();
            this.trigger('loaded', { chart: this.isBlazor ? {} : this });
        }
        if (!this.stockChart && this.visibleSeries.length > 0) {
            for (var _d = 0, _e = this.visibleSeries; _d < _e.length; _d++) {
                var series = _e[_d];
                if (!isNullOrUndefined(series.points)) {
                    this.maxPointCount = Math.max(prevPointCount, series.points.length);
                    prevPointCount = series.points.length;
                }
            }
        }
    };
    Chart.prototype.initializeDataModule = function (series) {
        series.xData = [];
        series.yData = [];
        var dataSource;
        var isAngular = 'isAngular';
        if (this[isAngular]) {
            dataSource = Object.keys(series.dataSource).length ? series.dataSource : this.dataSource;
        }
        else {
            dataSource = series.dataSource || this.dataSource;
        }
        series.dataModule = new Data(dataSource, series.query);
        series.points = [];
        series.refreshDataManager(this);
    };
    Chart.prototype.calculateBounds = function () {
        var margin = this.margin;
        // Title Height;
        var titleHeight = 0;
        var subTitleHeight = 0;
        var padding = this.titleStyle.position === 'Top' || (this.titleStyle.position === 'Bottom' && !this.legendSettings.visible) ? 15 : 5;
        var left = margin.left + this.border.width;
        var width = this.availableSize.width - left - margin.right - this.border.width;
        var elementSpacing = 0;
        this.titleCollection = [];
        this.subTitleCollection = [];
        if (this.title) {
            this.titleCollection = getTitle(this.title, this.titleStyle, width, this.enableRtl, this.themeStyle.chartTitleFont);
            titleHeight = (measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont).height * this.titleCollection.length) + padding;
            if (this.subTitle) {
                this.subTitleCollection = getTitle(this.subTitle, this.subTitleStyle, width, this.enableRtl, this.themeStyle.chartSubTitleFont);
                subTitleHeight = (measureText(this.subTitle, this.subTitleStyle, this.themeStyle.chartSubTitleFont).height * this.subTitleCollection.length) +
                    padding;
            }
        }
        else if (this.legendSettings.position !== 'Top' && this.border.width) {
            elementSpacing = 10;
        }
        var top = margin.top + elementSpacing + this.border.width + this.chartArea.border.width * 0.5;
        var height = this.availableSize.height - top - this.border.width - margin.bottom;
        var marginTotal = subTitleHeight + titleHeight + this.titleStyle.border.width + this.subTitleStyle.border.width;
        switch (this.titleStyle.position) {
            case 'Top':
                top += marginTotal;
                height -= marginTotal;
                break;
            case 'Bottom':
                height -= marginTotal;
                break;
            case 'Left':
                left += marginTotal;
                width -= marginTotal;
                break;
            case 'Right':
                left -= (this.titleStyle.border.width + this.subTitleStyle.border.width);
                width -= marginTotal;
                break;
        }
        if (this.stockChart && this.stockChart.legendSettings.visible && this.stockChart.stockLegendModule) {
            if (this.stockChart.legendSettings.position === 'Top') {
                top += this.stockChart.stockLegendModule.legendBounds.height;
            }
            else if (this.stockChart.legendSettings.position === 'Left') {
                left += this.stockChart.stockLegendModule.legendBounds.width;
            }
        }
        this.initialClipRect = new Rect(left, top, width, height);
        if (this.legendModule && this.legendSettings.visible) {
            this.legendModule.calculateLegendBounds(this.initialClipRect, this.availableSize, null);
        }
        this.chartAxisLayoutPanel.measureAxis(this.initialClipRect);
    };
    /**
     * Handles the print method for chart control.
     */
    Chart.prototype.print = function (id) {
        var exportChart = new PrintUtils(this);
        var width = this.width;
        if (this.getModuleName() == 'chart' && parseInt(this.width) >= 80 && this.width.indexOf('%') > -1) {
            this.width = '80%';
            this.dataBind();
        }
        exportChart.print(id);
        if (this.getModuleName() == 'chart' && parseInt(this.width) >= 80 && this.width.indexOf('%') > -1) {
            this.width = width;
            this.dataBind();
        }
    };
    /**
     * Defines the trendline initialization
     */
    Chart.prototype.initTrendLines = function () {
        this.isProtectedOnChange = true;
        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            var trendIndex = 0;
            for (var _b = 0, _c = series.trendlines; _b < _c.length; _b++) {
                var trendline = _c[_b];
                var trendLine = trendline;
                if (this.trendLineModule) {
                    trendLine.index = trendIndex;
                    trendLine.sourceIndex = series.index;
                    this.trendLineModule.initSeriesCollection(trendLine, this);
                    if (trendLine.targetSeries) {
                        trendLine.targetSeries.xAxisName = series.xAxisName;
                        trendLine.targetSeries.yAxisName = series.yAxisName;
                        this.visibleSeries.push(trendLine.targetSeries);
                    }
                }
                trendIndex++;
            }
        }
        this.isProtectedOnChange = false;
    };
    Chart.prototype.calculateAreaType = function () {
        var series = this.series[0];
        this.chartArea.border.width = this.stockChart ? 0 : this.chartArea.border.width;
        if (series) {
            this.requireInvertedAxis = ((series.type.indexOf('Bar') !== -1) && !this.isTransposed) ||
                ((series.type.indexOf('Bar') === -1) && this.isTransposed && this.chartAreaType !== 'PolarRadar');
        }
        this.chartAxisLayoutPanel = this.chartAreaType === 'PolarRadar' ? (this.polarSeriesModule || this.radarSeriesModule)
            : new CartesianAxisLayoutPanel(this);
    };
    /**
     * Calculate the visible axis
     *
     * @private
     */
    Chart.prototype.calculateVisibleAxis = function () {
        var axis;
        var axes = [this.primaryXAxis, this.primaryYAxis];
        axes = this.chartAreaType === 'Cartesian' ? axes.concat(this.axes) : axes;
        if (this.paretoSeriesModule && this.series[0].type === 'Pareto') {
            axes = axes.concat(this.paretoSeriesModule.paretoAxes);
        }
        this.axisCollections = [];
        if (this.zoomModule) {
            this.zoomModule.isPanning = this.zoomModule.isAxisZoomed(axes) && this.zoomSettings.enablePan;
            this.svgObject.setAttribute('cursor', this.zoomModule.isPanning ? 'pointer' : 'auto');
            if (this.scrollBarModule) {
                this.scrollBarModule.axes = axes;
            }
        }
        if (this.scrollSettingEnabled) {
            if (this.scrollBarModule) {
                this.scrollBarModule.axes = axes;
            }
        }
        for (var i = 0, len = axes.length; i < len; i++) {
            axis = axes[i];
            axis.series = [];
            axis.labels = [];
            axis.indexLabels = {};
            axis.orientation = (i == 0) ? (this.requireInvertedAxis ? 'Vertical' : 'Horizontal') :
                (i == 1) ? (this.requireInvertedAxis ? 'Horizontal' : 'Vertical') : axis.orientation;
            for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
                var series = _a[_i];
                this.initAxis(series, axis, true);
                if (series.category == 'Pareto' && series.type == 'Line' && series.yAxis) {
                    series.yAxis.internalVisibility = series.paretoOptions.showAxis;
                }
            }
            for (var _b = 0, _c = this.indicators; _b < _c.length; _b++) {
                var indicator = _c[_b];
                this.initAxis(indicator, axis, false);
            }
            if (this.scrollBarModule && !axis.zoomingScrollBar) {
                this.scrollBarModule.injectTo(axis, this);
            }
            if (axis.orientation != null) {
                this.axisCollections.push(axis);
            }
        }
        if (this.rows.length > 0 && this.columns.length > 0) {
            this.chartAxisLayoutPanel.measure();
        }
    };
    Chart.prototype.initAxis = function (series, axis, isSeries) {
        if (series.xAxisName === axis.name || (series.xAxisName == null && axis.name === 'primaryXAxis')) {
            axis.orientation = this.requireInvertedAxis ? 'Vertical' : 'Horizontal';
            series.xAxis = axis;
            if (isSeries) {
                axis.series.push(series);
            }
        }
        else if (series.yAxisName === axis.name || (series.yAxisName == null && axis.name === 'primaryYAxis')) {
            axis.orientation = this.requireInvertedAxis ? 'Horizontal' : 'Vertical';
            series.yAxis = axis;
            if (isSeries) {
                axis.series.push(series);
            }
        }
    };
    Chart.prototype.initTechnicalIndicators = function () {
        var i = 0;
        for (var _i = 0, _a = this.indicators; _i < _a.length; _i++) {
            var indicator = _a[_i];
            var techIndicator = indicator;
            var type = firstToLowerCase(techIndicator.type);
            if (this[type + 'IndicatorModule']) {
                techIndicator.index = i;
                this[type + 'IndicatorModule'].initSeriesCollection(techIndicator, this);
                for (var _b = 0, _c = techIndicator.targetSeries; _b < _c.length; _b++) {
                    var targetSeries = _c[_b];
                    if (indicator.seriesName || indicator.dataSource) {
                        this.visibleSeries.push(targetSeries);
                    }
                }
            }
            i++;
        }
    };
    /** @private */
    Chart.prototype.refreshTechnicalIndicator = function (series) {
        if (this.indicators.length) {
            var targetIndicator = null;
            if (series instanceof Series && series.category !== 'Indicator') {
                for (var _i = 0, _a = this.indicators; _i < _a.length; _i++) {
                    var indicator = _a[_i];
                    if (indicator.seriesName === series.name && !indicator.dataSource) {
                        targetIndicator = indicator;
                        targetIndicator.setDataSource(series, this);
                    }
                }
            }
            else if (series instanceof TechnicalIndicator) {
                targetIndicator = series;
                targetIndicator.setDataSource(series instanceof Series ? series : null, this);
            }
        }
    };
    Chart.prototype.calculateVisibleSeries = function () {
        var series;
        this.visibleSeries = [];
        var colors = this.palettes.length ? this.palettes : getSeriesColor(this.theme);
        var count = colors.length;
        var seriesCollection = this.series.sort(function (a, b) { return a.zOrder - b.zOrder; });
        for (var i = 0, len = seriesCollection.length; i < len; i++) {
            series = seriesCollection[i];
            // for y axis label issue during chart navigation
            series.category = seriesCollection[0].type === 'Pareto' ? 'Pareto' : 'Series';
            series.index = i;
            series.interior = series.fill || colors[i % count];
            if (!series.marker.shape && (series.marker.visible || series.type === 'Scatter' || series.drawType === 'Scatter')) {
                series.marker.shape = markerShapes[this.markerIndex % 10];
                this.markerIndex++;
            }
            if (this.isSecondaryAxis(series.xAxis)) {
                series.xAxis.internalVisibility = series.xAxis.series.some(function (value) { return (value.visible); });
            }
            if (this.isSecondaryAxis(series.yAxis)) {
                series.yAxis.internalVisibility = series.yAxis.series.some(function (value) { return (value.visible); });
            }
            switch (series.type) {
                case 'Bar':
                case 'StackingBar':
                case 'StackingBar100':
                    if (seriesCollection[0].type.indexOf('Bar') === -1) {
                        continue;
                    }
                    break;
                case 'Polar':
                case 'Radar':
                    if (this.chartAreaType !== 'PolarRadar') {
                        continue;
                    }
                    if (this.chartAreaType === 'PolarRadar' && ((series.xAxisName !== null && (this.primaryXAxis.name !== series.xAxisName)) ||
                        (series.yAxisName !== null && (this.primaryYAxis.name !== series.yAxisName)))) {
                        continue;
                    }
                    break;
                case 'Pareto':
                    this.visibleSeries.push(series);
                    this.paretoSeriesModule.initSeries(series, this);
                    continue;
                default:
                    if (this.chartAreaType === 'PolarRadar' || seriesCollection[0].type.indexOf('Bar') > -1) {
                        continue;
                    }
                    break;
            }
            this.visibleSeries.push(series);
            seriesCollection[i] = series;
        }
    };
    Chart.prototype.isSecondaryAxis = function (axis) {
        return (this.axes.indexOf(axis) > -1);
    };
    Chart.prototype.renderTitle = function () {
        var rect;
        var margin = this.margin;
        var elementSpacing = 5;
        if (this.title) {
            var getAnchor = getTextAnchor(this.titleStyle.textAlignment, this.enableRtl);
            var elementSize = measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont);
            rect = new Rect(margin.left, 0, this.availableSize.width - margin.left - margin.right, 0);
            var borderWidth = this.titleStyle.border.width;
            var positionY = this.margin.top + ((elementSize.height) * 3 / 4);
            var positionX = titlePositionX(rect, this.titleStyle || this.themeStyle.chartTitleFont) + borderWidth;
            var rotation = void 0;
            var alignment = this.titleStyle.textAlignment;
            var subtitleSize = measureText(this.subTitle, this.subTitleStyle, this.themeStyle.chartSubTitleFont);
            switch (this.titleStyle.position) {
                case 'Top':
                    positionY += borderWidth * 0.5;
                    positionX += getAnchor === 'start' ? borderWidth * 0.5 + this.border.width :
                        getAnchor === 'end' ? ((-borderWidth * 2) - this.border.width) : 0;
                    break;
                case 'Bottom':
                    positionX += getAnchor === 'start' ? (borderWidth * 0.5) + this.border.width :
                        getAnchor === 'end' ? (-borderWidth * 2) - this.border.width : 0;
                    positionY = this.availableSize.height - this.margin.bottom - subtitleSize.height - (elementSize.height / 2) -
                        (borderWidth * 0.5) - (this.subTitleStyle.border.width * 0.5);
                    break;
                case 'Left':
                    positionX = this.margin.left + ((elementSize.height) * 3 / 4) + (borderWidth * 0.5);
                    positionY = alignment == 'Near' ? margin.bottom + (borderWidth * 0.5) + this.border.width :
                        alignment == 'Far' ? this.availableSize.height - margin.bottom - (borderWidth * 0.5) - this.border.width : this.availableSize.height / 2;
                    getAnchor = alignment == 'Near' ? 'end' : alignment == 'Far' ? 'start' : 'middle';
                    getAnchor = this.enableRtl ? (getAnchor === 'end' ? 'start' : getAnchor === 'start' ? 'end' : getAnchor) : getAnchor;
                    rotation = 'rotate(' + -90 + ',' + positionX + ',' + positionY + ')';
                    break;
                case 'Right':
                    positionX = this.availableSize.width - this.margin.right - ((elementSize.height) * 3 / 4) - (borderWidth * 0.5);
                    positionY = alignment == 'Near' ? margin.bottom + (borderWidth * 0.5) + this.border.width :
                        alignment == 'Far' ? this.availableSize.height - margin.bottom - (borderWidth * 0.5) - this.border.width : this.availableSize.height / 2;
                    getAnchor = alignment == 'Near' ? 'start' : alignment == 'Far' ? 'end' : 'middle';
                    getAnchor = this.enableRtl ? (getAnchor === 'end' ? 'start' : getAnchor === 'start' ? 'end' : getAnchor) : getAnchor;
                    rotation = 'rotate(' + 90 + ',' + positionX + ',' + positionY + ')';
                    break;
                case 'Custom':
                    positionX = this.titleStyle.x;
                    positionY = this.titleStyle.y;
                    getAnchor = 'middle';
                    break;
            }
            var borderOptions = {
                'id': this.element.id + '_ChartTitleBorder',
                'x': positionX - (getAnchor === 'middle' ? (elementSize.width / 2) + elementSpacing : getAnchor === 'end' ? elementSize.width + elementSpacing : elementSpacing),
                'y': positionY - elementSize.height + (elementSize.height / 4),
                'rx': this.titleStyle.border.cornerRadius,
                'ry': this.titleStyle.border.cornerRadius,
                'width': elementSize.width + (elementSpacing * 2),
                'height': elementSize.height * this.titleCollection.length,
                'fill': this.titleStyle.background,
                'stroke-width': borderWidth,
                'stroke': this.titleStyle.border.color,
                'transform': rotation ? rotation : '',
                'd': ''
            };
            var htmlObject = redrawElement(this.redraw, this.element.id + '_ChartTitleBorder', borderOptions, this.renderer)
                || this.renderer.drawRectangle(borderOptions);
            appendChildElement(this.enableCanvas, this.svgObject, htmlObject, this.redraw);
            var options = new TextOption(this.element.id + '_ChartTitle', positionX, positionY, getAnchor, this.titleCollection, rotation, 'auto');
            var element = redrawElement(this.redraw, this.element.id + '_ChartTitle', options, this.renderer) ||
                textElement$1(this.renderer, options, this.titleStyle, this.titleStyle.color || this.themeStyle.chartTitleFont.color, this.svgObject, null, null, null, null, null, null, null, null, this.enableCanvas, null, this.themeStyle.chartTitleFont);
            if (element) {
                element.setAttribute('tabindex', '0');
                element.setAttribute('class', 'e-chart-focused');
            }
            if (this.subTitle) {
                this.renderSubTitle(options);
            }
        }
    };
    Chart.prototype.renderSubTitle = function (options) {
        var maxWidth = 0;
        var titleWidth = 0;
        var padding = 10;
        var alignment = this.titleStyle.textAlignment;
        for (var _i = 0, _a = this.titleCollection; _i < _a.length; _i++) {
            var titleText = _a[_i];
            titleWidth = measureText(titleText, this.titleStyle, this.themeStyle.chartSubTitleFont).width;
            maxWidth = titleWidth > maxWidth ? titleWidth : maxWidth;
        }
        var subTitleElementSize = measureText(this.subTitleCollection.reduce(function (a, b) { return (a.length > b.length ? a : b); }), this.subTitleStyle, this.themeStyle.chartSubTitleFont);
        var getAnchor = getTextAnchor(this.subTitleStyle.textAlignment, this.enableRtl);
        var rect = new Rect(alignment === 'Center' ? (options.x - maxWidth * 0.5) : alignment === 'Far' ? options.x - maxWidth : options.x, 0, maxWidth, 0);
        if (this.titleStyle.position === 'Left') {
            rect.x = alignment === 'Center' ? (options.x - maxWidth * 0.5) : alignment == 'Far' ? this.margin.left + ((subTitleElementSize.height) * 3 / 4) : (options.x - maxWidth);
        }
        var elementSize = measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont);
        var positionY = options.y * options.text.length + subTitleElementSize.height + (padding / 2) + this.titleStyle.border.width + (this.subTitleStyle.border.width * 0.5);
        if (this.titleStyle.position === 'Bottom') {
            positionY = options.y * options.text.length + (padding / 2) + (elementSize.height / 2) + (subTitleElementSize.height / 2);
        }
        var borderOptions = {
            'id': this.element.id + '_ChartSubTitleBorder',
            'x': titlePositionX(rect, this.subTitleStyle) - (getAnchor === 'middle' ? (subTitleElementSize.width / 2) + padding / 2 : getAnchor === 'end' ? subTitleElementSize.width + padding / 2 : padding / 2),
            'y': positionY - subTitleElementSize.height + (subTitleElementSize.height / 4),
            'rx': this.subTitleStyle.border.cornerRadius,
            'ry': this.subTitleStyle.border.cornerRadius,
            'width': subTitleElementSize.width + padding,
            'height': subTitleElementSize.height * this.subTitleCollection.length,
            'fill': this.subTitleStyle.background,
            'stroke-width': this.subTitleStyle.border.width,
            'stroke': this.subTitleStyle.border.color,
            'transform': options.transform,
            'd': ''
        };
        var htmlObject = redrawElement(this.redraw, this.element.id + '_ChartSubTitleBorder', borderOptions, this.renderer)
            || this.renderer.drawRectangle(borderOptions);
        appendChildElement(this.enableCanvas, this.svgObject, htmlObject, this.redraw);
        var subTitleOptions = new TextOption(this.element.id + '_ChartSubTitle', titlePositionX(rect, this.subTitleStyle), positionY, getTextAnchor(this.subTitleStyle.textAlignment, this.enableRtl), this.subTitleCollection, options.transform, 'auto');
        var element = redrawElement(this.redraw, this.element.id + '_ChartSubTitle', subTitleOptions, this.renderer) ||
            textElement$1(this.renderer, subTitleOptions, this.subTitleStyle, this.subTitleStyle.color || this.themeStyle.chartSubTitleFont.color, this.svgObject, null, null, null, null, null, null, null, null, this.enableCanvas, null, this.themeStyle.chartSubTitleFont);
    };
    Chart.prototype.renderBorder = function () {
        var x = 0;
        var y = 0;
        var width = this.border.width;
        var backGroundImage = this.backgroundImage;
        var fillColor = backGroundImage ? 'transparent' : (this.background || this.themeStyle.background);
        if (this.stockChart && this.stockChart.legendSettings.visible && this.stockChart.stockLegendModule) {
            if (this.stockChart.legendSettings.position === 'Top') {
                y += this.stockChart.stockLegendModule.legendBounds.height;
            }
            else if (this.stockChart.legendSettings.position === 'Left') {
                x += this.stockChart.stockLegendModule.legendBounds.width;
            }
        }
        var rect = new RectOption(this.element.id + '_ChartBorder', fillColor, this.border, 1, new Rect(width * 0.5 + x, width * 0.5 + y, this.availableSize.width - width, this.availableSize.height - width));
        this.htmlObject = redrawElement(this.redraw, this.element.id + '_ChartBorder', rect, this.renderer)
            || this.renderer.drawRectangle(rect);
        this.htmlObject.setAttribute('aria-hidden', 'true');
        appendChildElement(this.enableCanvas, this.svgObject, this.htmlObject, this.redraw);
        // to draw back ground image for chart
        if (backGroundImage) {
            var image = new ImageOption(this.availableSize.height - width, this.availableSize.width - width, backGroundImage, 0, 0, this.element.id + '_ChartBackground', 'visible', 'none');
            this.htmlObject = redrawElement(this.redraw, this.element.id + '_ChartBackground', image, this.renderer)
                || this.renderer.drawImage(image);
            appendChildElement(this.enableCanvas, this.svgObject, this.htmlObject, this.redraw);
        }
    };
    /**
     * @private
     */
    Chart.prototype.renderAreaBorder = function () {
        if (this.chartAreaType === 'PolarRadar') {
            return null;
        }
        else {
            var element = getElement$1(this.element.id + '_ChartAreaBorder');
            var previousRect = element ?
                new Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')) : null;
            var rect = new RectOption(this.element.id + '_ChartAreaBorder', this.chartArea.background, { width: this.chartArea.border.width, color: this.chartArea.border.color || this.themeStyle.areaBorder }, this.chartArea.opacity, this.chartAxisLayoutPanel.seriesClipRect);
            this.htmlObject = this.renderer.drawRectangle(rect);
            this.htmlObject.setAttribute('aria-hidden', 'true');
            appendChildElement(this.enableCanvas, this.svgObject, this.htmlObject, this.redraw, true, 'x', 'y', null, null, true, true, previousRect);
            this.htmlObject = null;
        }
        // to draw back ground image for chart area
        var backGroundImage = this.chartArea.backgroundImage;
        if (backGroundImage) {
            var width = this.chartArea.border.width;
            var image = new ImageOption(this.initialClipRect.height - width, this.initialClipRect.width - width, backGroundImage, this.initialClipRect.x, this.initialClipRect.y, this.element.id + '_ChartAreaBackground', 'visible', 'none');
            this.htmlObject = this.renderer.drawImage(image);
            appendChildElement(this.enableCanvas, this.svgObject, this.htmlObject, this.redraw, true, 'x', 'y', null, null, true, true);
        }
    };
    /**
     * To add series for the chart
     *
     * @param {SeriesModel[]} seriesCollection - Defines the series collection to be added in chart.
     * @returns {void}.
     */
    Chart.prototype.addSeries = function (seriesCollection) {
        for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {
            var series = seriesCollection_1[_i];
            series = new Series(this, 'series', series);
            this.series.push(series);
        }
        this.refresh();
    };
    /**
     * To Remove series for the chart
     *
     * @param {number} index - Defines the series index to be remove in chart series
     * @returns {void}
     */
    Chart.prototype.removeSeries = function (index) {
        this.redraw = false; //fix for remove svg not working when use animatemethod.
        if (this.visibleSeries[index]) {
            this.visibleSeries[index].xAxis.orientation = null;
            this.visibleSeries[index].yAxis.orientation = null;
        }
        for (var i = 0; i < this.axes.length; i++) {
            if (this.axes[i].orientation === null) {
                this.axes.splice(i, 1);
            }
        }
        this.series.splice(index, 1);
        this.refresh();
    };
    /**
     * To Clear all series for the chart
     *
     * @returns {void}.
     */
    Chart.prototype.clearSeries = function () {
        this.series = [];
        this.refresh();
    };
    /**
     * To add secondary axis for the chart
     *
     * @param {AxisModel[]} axisCollection - Defines the axis collection to be added in chart.
     * @returns {void}.
     */
    Chart.prototype.addAxes = function (axisCollection) {
        for (var _i = 0, axisCollection_1 = axisCollection; _i < axisCollection_1.length; _i++) {
            var axis = axisCollection_1[_i];
            axis = new Axis(this, 'axes', axis);
            if (this.isBlazor) {
                axis.interval = isNaN(axis.interval) ? null : axis.interval;
                axis.desiredIntervals = isNaN(axis.desiredIntervals) ? null : axis.desiredIntervals;
            }
            this.axes.push(axis);
        }
        this.refresh();
    };
    /**
     * To remove secondary axis for the chart
     *
     * @param {number} index - Defines the axis collection to be removed in chart.
     * @returns {void}
     */
    Chart.prototype.removeAxis = function (index) {
        this.redraw = false;
        this.axes.splice(index, 1);
        this.refresh();
    };
    /**
     * To destroy the widget
     *
     * @function destroy
     * @returns {void}.
     * @member of Chart
     */
    Chart.prototype.destroy = function () {
        if (this.scrollBarModule) {
            this.scrollBarModule.destroy();
        }
        if (this.markerRender) {
            this.markerRender.removeEventListener();
            this.markerRender = null;
        }
        this.horizontalAxes = [];
        this.verticalAxes = [];
        this.visibleSeries = [];
        this.axisCollections = [];
        this.rotatedDataLabelCollections = [];
        this.seriesElements = null;
        this.chartAxisLayoutPanel = null;
        this.dataLabelCollections = null;
        this.dataLabelElements = null;
        this.yAxisElements = null;
        var element = document.getElementById(this.element.id + 'Keyboard_chart_focus');
        if (element) {
            element.remove();
        }
        var highlightElement = document.getElementById(this.element.id + '_ej2_chart_highlight');
        if (highlightElement) {
            highlightElement.remove();
        }
        removeElement$1('chartmeasuretext');
        /**
         * To fix react timeout destroy issue.
         */
        if (this.element) {
            this.unWireEvents();
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (this.isReact) {
                this.clearTemplate();
            }
            _super.prototype.destroy.call(this);
            if (!this.enableCanvas) {
                this.removeSvg();
                this.svgObject = null;
            }
        }
    };
    /**
     * Get component name
     */
    Chart.prototype.getModuleName = function () {
        return 'chart';
    };
    /**
     * Get the properties to be maintained in the persisted state.
     *
     * @private
     */
    Chart.prototype.getPersistData = function () {
        var keyEntity = ['loaded', 'animationComplete', 'primaryXAxis', 'primaryYAxis'];
        return this.addOnPersist(keyEntity);
    };
    /**
     * Method to create SVG element.
     */
    Chart.prototype.createChartSvg = function () {
        this.removeSvg();
        createSvg(this);
    };
    /**
     * Method to bind events for chart
     */
    Chart.prototype.unWireEvents = function () {
        var startEvent = Browser.touchStartEvent;
        var moveEvent = Browser.touchMoveEvent;
        var stopEvent = Browser.touchEndEvent;
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        /*! UnBind the Event handler */
        EventHandler.remove(this.element, startEvent, this.chartOnMouseDown);
        EventHandler.remove(this.element, moveEvent, this.mouseMove);
        EventHandler.remove(this.element, stopEvent, this.mouseEnd);
        EventHandler.remove(this.element, 'click', this.chartOnMouseClick);
        EventHandler.remove(this.element, 'dblclick', this.chartOnDoubleClick);
        EventHandler.remove(this.element, 'contextmenu', this.chartRightClick);
        EventHandler.remove(this.element, cancelEvent, this.mouseLeave);
        EventHandler.remove(this.element, 'keydown', this.chartKeyDown);
        EventHandler.remove(document.body, 'keydown', this.documentKeyHandler);
        EventHandler.remove(this.element, 'keyup', this.chartKeyUp);
        window.removeEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.resizeBound);
        /**
         * To fix memory issue
         */
        if (this.touchObject) {
            this.touchObject.destroy();
            this.touchObject = null;
        }
    };
    Chart.prototype.wireEvents = function () {
        /**
         * To fix react timeout destroy issue.
         */
        if (!this.element) {
            return;
        }
        /*! Find the Events type */
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        /*! Bind the Event handler */
        EventHandler.add(this.element, Browser.touchStartEvent, this.chartOnMouseDown, this);
        EventHandler.add(this.element, Browser.touchMoveEvent, this.mouseMove, this);
        EventHandler.add(this.element, Browser.touchEndEvent, this.mouseEnd, this);
        EventHandler.add(this.element, 'click', this.chartOnMouseClick, this);
        EventHandler.add(this.element, 'dblclick', this.chartOnDoubleClick, this);
        EventHandler.add(this.element, 'contextmenu', this.chartRightClick, this);
        EventHandler.add(this.element, cancelEvent, this.mouseLeave, this);
        EventHandler.add(this.element, 'keydown', this.chartKeyDown, this);
        EventHandler.add(document.body, 'keydown', this.documentKeyHandler, this);
        EventHandler.add(this.element, 'keyup', this.chartKeyUp, this);
        this.resizeBound = this.chartResize.bind(this);
        window.addEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.resizeBound);
        this.longPressBound = this.longPress.bind(this);
        this.touchObject = new Touch(this.element, { tapHold: this.longPressBound, tapHoldThreshold: 500 });
        /*! Apply the style for chart */
        this.setStyle(this.element);
    };
    Chart.prototype.chartRightClick = function (event) {
        if (this.crosshair.enable && this.crosshairModule &&
            (event.buttons === 2 || event.which === 0 || event.pointerType === 'touch')) {
            event.preventDefault();
            event.stopPropagation();
            return false;
        }
        return true;
    };
    Chart.prototype.setStyle = function (element) {
        var zooming = this.zoomSettings;
        var disableScroll = zooming.enableSelectionZooming || zooming.enablePinchZooming ||
            this.selectionMode !== 'None' || this.crosshair.enable || this.highlightMode !== 'None';
        element.style.touchAction = disableScroll ? 'none' : 'element';
        element.style.msTouchAction = disableScroll ? 'none' : 'element';
        element.style.msContentZooming = 'none';
        element.style.msUserSelect = 'none';
        element.style.webkitUserSelect = 'none';
        element.style.position = 'relative';
        element.style.display = 'block';
        // To fix angular and react tooltip div scrollbar issue
        element.style.overflow = 'hidden';
        element.style.height = (element.style.height || (this.height && this.height.indexOf('%') === -1)) ? element.style.height : 'inherit';
    };
    /**
     * Finds the orientation.
     *
     * @returns {boolean}
     * @private
     */
    Chart.prototype.isOrientation = function () {
        return ('orientation' in window && 'onorientationchange' in window);
    };
    /**
     * Handles the long press on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Chart.prototype.longPress = function (e) {
        this.mouseX = (e && e.originalEvent.changedTouches) ? (e.originalEvent.changedTouches[0].clientX) : 0;
        this.mouseY = (e && e.originalEvent.changedTouches) ? (e.originalEvent.changedTouches[0].clientY) : 0;
        this.startMove = true;
        this.allowPan = this.stockChart ? false : this.allowPan;
        this.setMouseXY(this.mouseX, this.mouseY);
        this.notify('tapHold', e);
        return false;
    };
    /**
     * To find mouse x, y for aligned chart element svg position
     */
    Chart.prototype.setMouseXY = function (pageX, pageY) {
        if (getElement$1(this.svgId)) {
            var svgRect = getElement$1(this.svgId).getBoundingClientRect();
            var rect = this.element.getBoundingClientRect();
            this.mouseY = ((pageY - rect.top) - Math.max(svgRect.top - rect.top, 0) / this.scaleX);
            this.mouseX = ((pageX - rect.left) - Math.max(svgRect.left - rect.left, 0) / this.scaleY);
            if (this.stockChart) {
                this.mouseX += this.stockChart.legendSettings.position === 'Left' ? this.stockChart.stockLegendModule.legendBounds.width : 0;
                this.mouseY += this.stockChart.legendSettings.position === 'Top' ? this.stockChart.stockLegendModule.legendBounds.height : 0;
            }
        }
    };
    /**
     * Export method for the chart.
     */
    Chart.prototype.export = function (type, fileName) {
        if (this.exportModule) {
            this.exportModule.export(type, fileName);
            if (this.afterExport) {
                this.exportModule.getDataUrl(this);
            }
        }
    };
    /**
     * Handles the chart resize.
     *
     * @returns {boolean} false
     * @private
     */
    Chart.prototype.chartResize = function () {
        var _this = this;
        this.animateSeries = false;
        var arg = {
            chart: this,
            name: resized,
            currentSize: new Size(0, 0),
            previousSize: new Size(this.availableSize.width, this.availableSize.height)
        };
        var beforeResizeArgs = { name: 'beforeResize', cancelResizedEvent: false };
        if (this.resizeTo) {
            clearTimeout(this.resizeTo);
        }
        this.trigger(beforeResize, beforeResizeArgs);
        if (!beforeResizeArgs.cancelResizedEvent) {
            this.resizeTo = +setTimeout(function () {
                if (_this.isDestroyed || _this.stockChart) {
                    clearTimeout(_this.resizeTo);
                    return;
                }
                _this.createChartSvg();
                arg.currentSize = _this.availableSize;
                _this.trigger(resized, arg);
                _this.refreshAxis();
                _this.refreshBound();
                _this.trigger('loaded', { chart: _this.isBlazor ? {} : _this });
            }, 500);
        }
        return false;
    };
    /**
     * Handles the mouse move.
     *
     * @returns {boolean} false
     * @private
     */
    Chart.prototype.mouseMove = function (e) {
        var pageX;
        var pageY;
        var touchArg;
        if (this.allowPan) {
            return false;
        }
        if (e.type === 'touchmove') {
            this.isTouch = true;
            touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            pageY = touchArg.changedTouches[0].clientY;
        }
        else {
            this.isTouch = e.pointerType === 'touch' || e.pointerType === '2' || this.isTouch;
            pageX = e.clientX;
            pageY = e.clientY;
        }
        this.previousPageX = pageX;
        this.previousPageY = pageY;
        if (getElement$1(this.svgId)) {
            this.setMouseXY(pageX, pageY);
            this.chartOnMouseMove(e);
        }
        return false;
    };
    /**
     * Handles the mouse leave.
     *
     * @returns {boolean} false
     * @private
     */
    Chart.prototype.mouseLeave = function (e) {
        var pageX;
        var pageY;
        var touchArg;
        if (this.stockChart && this.stockChart.onPanning) {
            return false;
        }
        if (e.type === 'touchleave') {
            this.isTouch = true;
            touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            pageY = touchArg.changedTouches[0].clientY;
        }
        else {
            this.isTouch = e.pointerType === 'touch' || e.pointerType === '2';
            pageX = e.clientX;
            pageY = e.clientY;
        }
        this.previousPageX = null;
        this.previousPageY = null;
        this.setMouseXY(pageX, pageY);
        this.chartOnMouseLeave(e);
        return false;
    };
    /**
     * Handles the mouse leave on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Chart.prototype.chartOnMouseLeave = function (e) {
        var element = e.target;
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        this.trigger(chartMouseLeave, { target: element.id, x: this.mouseX, y: this.mouseY });
        removeElement$1(this.element.id + '_EJ2_AxisLabel_Tooltip');
        this.isChartDrag = this.isPointMouseDown = false;
        this.notify(cancelEvent, e);
        return false;
    };
    /**
     * Handles the mouse double click on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Chart.prototype.chartOnDoubleClick = function (e) {
        var element = e.target;
        this.trigger(chartDoubleClick, { target: element.id, x: this.mouseX, y: this.mouseY });
        return false;
    };
    /**
     * Handles the keyboard onkeydown on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Chart.prototype.chartKeyDown = function (e) {
        var actionKey = '';
        if ((this.isZoomed && e.code === 'Tab') || e.code === 'Space') {
            e.preventDefault();
        }
        if (this.tooltip.enable && ((e.code === 'Tab' && this.previousTargetId.indexOf('Series') > -1) || e.code === 'Escape')) {
            actionKey = 'ESC';
        }
        if (this.highlightMode !== 'None' && e.code === 'Tab' && this.previousTargetId.indexOf('_chart_legend_') > -1) {
            if (this.highlightModule) {
                this.highlightModule.removeLegendHighlightStyles();
            }
        }
        if (e.ctrlKey && (e.key === '+' || e.code === 'Equal' || e.key === '-' || e.code === 'Minus')) {
            e.preventDefault();
            this.isZoomed = this.zoomModule && (this.zoomSettings.enableDeferredZooming || this.zoomSettings.enableSelectionZooming ||
                this.zoomSettings.enablePinchZooming || this.zoomSettings.enableMouseWheelZooming);
            //this.tooltipModule.fadeOut(this.element);
            actionKey = this.isZoomed ? e.code : '';
        }
        else if (e['keyCode'] === 82 && this.isZoomed) { // KeyCode 82 (R) for reseting
            e.preventDefault();
            this.isZoomed = false;
            actionKey = 'R';
        }
        else if (e.code.indexOf('Arrow') > -1) {
            e.preventDefault();
            actionKey = this.isZoomed ? e.code : '';
        }
        if (e.ctrlKey && (e.key === 'p')) {
            e.preventDefault();
            actionKey = 'CtrlP';
        }
        if (actionKey !== '')
            this.chartKeyboardNavigations(e, e.target.id, actionKey);
        return false;
    };
    /**
     * Handles the keyboard onkeydown on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Chart.prototype.chartKeyUp = function (e) {
        var actionKey = '';
        var targetId = e.target['id'];
        var groupElement;
        var markerGroup;
        var targetElement = e.target;
        var titleElement = getElement$1(this.element.id + '_ChartTitle');
        var seriesElement = getElement$1(this.element.id + 'SeriesCollection');
        var legendElement = getElement$1(this.element.id + '_chart_legend_translate_g');
        var pagingElement = getElement$1(this.element.id + '_chart_legend_pageup');
        if (titleElement) {
            titleElement.setAttribute('class', 'e-chart-focused');
        }
        if (seriesElement && seriesElement.firstElementChild && seriesElement.firstElementChild.children[1]) {
            var firstChild = seriesElement.firstElementChild.children[1];
            var className = firstChild.getAttribute('class');
            if (className && className.indexOf('e-chart-focused') === -1) {
                className = className + ' e-chart-focused';
            }
            else if (!className) {
                className = 'e-chart-focused';
            }
            firstChild.setAttribute('class', className);
        }
        if (legendElement) {
            var firstChild = legendElement.firstElementChild;
            var className = firstChild.getAttribute('class');
            if (className && className.indexOf('e-chart-focused') === -1) {
                className = className + ' e-chart-focused';
            }
            else if (!className) {
                className = 'e-chart-focused';
            }
            firstChild.setAttribute('class', className);
        }
        if (pagingElement) {
            pagingElement.setAttribute('class', 'e-chart-focused');
        }
        if (e.code === 'Tab') {
            if (this.previousTargetId !== '') {
                if ((this.previousTargetId.indexOf('_Series_') > -1 && targetId.indexOf('_Series_') === -1)) {
                    groupElement = getElement$1(this.element.id + 'SeriesCollection');
                    var previousElement = this.previousTargetId.indexOf('_Symbol') > -1 ?
                        getElement$1(this.element.id + 'SymbolGroup' + this.currentSeriesIndex).children[this.currentPointIndex + 1] :
                        (this.previousTargetId.indexOf('_Point_') > -1 ?
                            groupElement.children[this.currentSeriesIndex].children[this.currentPointIndex + 1] :
                            groupElement.children[this.currentSeriesIndex]);
                    this.setTabIndex(previousElement, groupElement.firstElementChild);
                    this.currentPointIndex = 0;
                    this.currentSeriesIndex = 0;
                }
                else if (this.previousTargetId.indexOf('_chart_legend_page') > -1 && targetId.indexOf('_chart_legend_page') === -1
                    && targetId.indexOf('_chart_legend_g_') === -1) {
                    this.setTabIndex(e.target, getElement$1(this.element.id + '_chart_legend_pageup'));
                }
                else if (this.previousTargetId.indexOf('_chart_legend_g_') > -1 && targetId.indexOf('_chart_legend_g_') === -1) {
                    groupElement = getElement$1(this.element.id + '_chart_legend_translate_g');
                    this.setTabIndex(groupElement.children[this.currentLegendIndex], groupElement.firstElementChild);
                }
            }
            this.previousTargetId = targetId;
            if (targetId.indexOf('SeriesGroup') > -1) {
                this.currentSeriesIndex = +targetId.split('SeriesGroup')[1];
                targetElement.removeAttribute('tabindex');
                targetElement.blur();
                if (targetElement.children[1].id.indexOf('_Point_') === -1) {
                    markerGroup = getElement$1(this.element.id + 'SymbolGroup' + targetId.split('SeriesGroup')[1]);
                }
                targetId = this.focusChild((markerGroup != null ? markerGroup.children[1] : targetElement.children[1]));
            }
            actionKey = this.highlightMode !== 'None' || this.tooltip.enable ? 'Tab' : '';
        }
        else if (e.code.indexOf('Arrow') > -1) {
            e.preventDefault();
            this.previousTargetId = targetId;
            if (targetId.indexOf('_chart_legend_page') > -1) {
                if (e.code === 'ArrowLeft') {
                    getElement$1(this.element.id + '_chart_legend_pagedown').removeAttribute('tabindex');
                    this.focusChild(getElement$1(this.element.id + '_chart_legend_pageup'));
                }
                else if (e.code === 'ArrowRight') {
                    getElement$1(this.element.id + '_chart_legend_pageup').removeAttribute('tabindex');
                    this.focusChild(getElement$1(this.element.id + '_chart_legend_pagedown'));
                }
            }
            else if ((targetId.indexOf('_chart_legend_') > -1)) {
                var legendElement_1 = targetElement.parentElement.children;
                legendElement_1[this.currentLegendIndex].removeAttribute('tabindex');
                this.currentLegendIndex += (e.code === 'ArrowUp' || e.code === 'ArrowRight') ? +1 : -1;
                this.currentLegendIndex = this.getActualIndex(this.currentLegendIndex, legendElement_1.length);
                var currentLegend = legendElement_1[this.currentLegendIndex];
                this.focusChild(currentLegend);
                targetId = currentLegend.children[1].id;
                actionKey = this.highlightMode !== 'None' ? 'ArrowMove' : '';
            }
            else if (targetId.indexOf('_Series_') > -1) {
                groupElement = targetElement.parentElement.parentElement;
                var currentPoint = e.target;
                targetElement.removeAttribute('tabindex');
                targetElement.blur();
                if (e.code === 'ArrowRight' || e.code === 'ArrowLeft') {
                    var seriesIndexes = [];
                    for (var i = 0; i < groupElement.children.length; i++) {
                        if (groupElement.children[i].id.indexOf('SeriesGroup') > -1) {
                            seriesIndexes.push(+groupElement.children[i].id.split('SeriesGroup')[1]);
                        }
                    }
                    this.currentSeriesIndex = seriesIndexes.indexOf(this.currentSeriesIndex) + (e.code === 'ArrowRight' ? 1 : -1);
                    this.currentSeriesIndex = seriesIndexes[this.getActualIndex(this.currentSeriesIndex, seriesIndexes.length)];
                }
                else {
                    this.currentPointIndex += e.code === 'ArrowUp' ? 1 : -1;
                }
                if (targetId.indexOf('_Symbol') > -1) {
                    this.currentPointIndex = this.getActualIndex(this.currentPointIndex, getElement$1(this.element.id + 'SymbolGroup' + this.currentSeriesIndex).childElementCount - 1);
                    currentPoint = getElement$1(this.element.id + '_Series_' + this.currentSeriesIndex + '_Point_' +
                        this.currentPointIndex + '_Symbol');
                }
                else if (targetId.indexOf('_Point_') > -1) {
                    this.currentPointIndex = this.getActualIndex(this.currentPointIndex, getElement$1(this.element.id + 'SeriesGroup' + this.currentSeriesIndex).childElementCount - 1);
                    currentPoint = getElement$1(this.element.id + '_Series_' + this.currentSeriesIndex + '_Point_' +
                        this.currentPointIndex);
                }
                targetId = this.focusChild(currentPoint);
                actionKey = this.tooltip.enable || this.highlightMode !== 'None' ? 'ArrowMove' : '';
            }
        }
        else if ((e.code === 'Enter' || e.code === 'Space') && ((targetId.indexOf('_chart_legend_') > -1) ||
            (targetId.indexOf('_Point_') > -1))) {
            targetId = (targetId.indexOf('_chart_legend_page') > -1) ? targetId : ((targetId.indexOf('_chart_legend_') > -1) ?
                targetElement.children[1].id : targetId);
            actionKey = 'Enter';
        }
        if (actionKey !== '') {
            this.chartKeyboardNavigations(e, targetId, actionKey);
        }
        return false;
    };
    Chart.prototype.setTabIndex = function (previousElement, currentElement) {
        if (previousElement) {
            previousElement.removeAttribute('tabindex');
        }
        if (currentElement) {
            currentElement.setAttribute('tabindex', '0');
        }
    };
    Chart.prototype.getActualIndex = function (index, totalLength) {
        return index > totalLength - 1 ? 0 : (index < 0 ? totalLength - 1 : index);
    };
    Chart.prototype.focusChild = function (element) {
        element.setAttribute('tabindex', '0');
        var className = element.getAttribute('class');
        element.setAttribute('tabindex', '0');
        if (className && className.indexOf('e-chart-focused') === -1) {
            className = 'e-chart-focused ' + className;
        }
        else if (!className) {
            className = 'e-chart-focused';
        }
        element.setAttribute('class', className);
        element.focus();
        return element.id;
    };
    /**
     * Handles the document onkey.
     *
     * @private
     */
    Chart.prototype.documentKeyHandler = function (e) {
        // 74 - J
        if (e.altKey && e.keyCode === 74 && !isNullOrUndefined(this.element)) {
            this.element.focus();
        }
    };
    Chart.prototype.chartKeyboardNavigations = function (e, targetId, actionKey) {
        this.isLegendClicked = false;
        switch (actionKey) {
            case 'Tab':
            case 'ArrowMove':
                if (this.highlightModule) {
                    this.highlightModule.removeLegendHighlightStyles();
                }
                if (targetId.indexOf('_Point_') > -1) {
                    var seriesIndex = +(targetId.split('_Series_')[1].split('_Point_')[0]);
                    var pointIndex = +(targetId.split('_Series_')[1].replace('_Symbol', '').split('_Point_')[1]);
                    var pointRegion = this.visibleSeries[seriesIndex].points[pointIndex].symbolLocations[0];
                    this.mouseX = pointRegion.x + this.initialClipRect.x;
                    this.mouseY = pointRegion.y + this.initialClipRect.y;
                    if (this.highlightModule) {
                        this.highlightModule.highlightChart(document.getElementById(targetId), 'mousemove');
                        this.highlightModule.completeSelection(document.getElementById(targetId), 'mousemove');
                    }
                    if (this.tooltipModule) {
                        this.tooltipModule.tooltip();
                    }
                }
                if (this.highlightModule && this.highlightMode !== 'None') {
                    targetId = targetId.indexOf('_chart_legend_g_') > -1 ? document.getElementById(targetId).firstChild['id'] : targetId;
                    var legendID = this.element.id + '_chart_legend';
                    var legendItemsId = [legendID + '_text_', legendID + '_shape_marker_',
                        legendID + '_shape_'];
                    for (var i = 0; i < legendItemsId.length; i++) {
                        var id = legendItemsId[i];
                        if (targetId.indexOf(id) > -1) {
                            document.getElementById(targetId).setAttribute('class', '');
                            this.highlightModule.legendSelection(this, parseInt(targetId.split(id)[1], 10), document.getElementById(targetId), 'mousemove');
                            break;
                        }
                    }
                }
                break;
            case 'Enter':
            case 'Space':
                if (targetId.indexOf('_chart_legend_') > -1) {
                    this.isLegendClicked = true;
                    this.legendModule.click(e);
                    this.focusChild(document.getElementById(targetId).parentElement);
                }
                else {
                    this.selectionModule.calculateSelectedElements(document.getElementById(targetId), 'click');
                }
                break;
            case 'CtrlP':
                this.print();
                break;
            case 'ESC':
                this.tooltipModule.removeTooltip(1);
                break;
            case 'Equal':
            case 'Minus':
                this.zoomModule.isZoomed = this.zoomModule.performedUI = true;
                this.zoomModule.isPanning = this.isChartDrag = false;
                if (actionKey === 'Equal') {
                    this.zoomModule.toolkit.zoomInOutCalculation(1, this, this.axisCollections, this.zoomSettings.mode);
                }
                else {
                    this.zoomModule.toolkit.zoomInOutCalculation(-1, this, this.axisCollections, this.zoomSettings.mode);
                }
                this.zoomModule.performZoomRedraw(this);
                this.element.focus();
                break;
            case 'ArrowUp':
            case 'ArrowDown':
            case 'ArrowLeft':
            case 'ArrowRight':
                var yArrowPadding = actionKey === 'ArrowUp' ? 10 : (actionKey === 'ArrowDown' ? -10 : 0);
                var xArrowPadding = actionKey === 'ArrowLeft' ? -10 : (actionKey === 'ArrowRight' ? 10 : 0);
                this.zoomModule.isPanning = this.isChartDrag = true;
                this.zoomModule.doPan(this, this.axisCollections, xArrowPadding, yArrowPadding);
                this.zoomModule.performZoomRedraw(this);
                this.element.focus();
                break;
            case 'R':
                this.zoomModule.toolkit.reset(e);
                break;
        }
    };
    /**
     * Handles the mouse click on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Chart.prototype.chartOnMouseClick = function (e) {
        var _this = this;
        var element = e.target;
        var chart = this;
        this.clickCount++;
        var timeInterval = 400;
        if (this.clickCount === 1) {
            this.singleClickTimer = +setTimeout(function () {
                chart.clickCount = 0;
                chart.trigger(chartMouseClick, { target: element.id, x: chart.mouseX, y: chart.mouseY });
            }, timeInterval);
        }
        else if (this.clickCount === 2 && !this.pointDoubleClick) {
            clearTimeout(this.singleClickTimer);
            this.clickCount = 0;
        }
        var isAngular = 'isAngular';
        if (this[isAngular]) {
            var observers = 'observers';
            timeInterval = this.pointDoubleClick[observers].length > 0 ? 400 : 0;
        }
        else {
            timeInterval = this.pointDoubleClick ? 400 : 0;
        }
        if (this.clickCount === 1 && this.pointClick) {
            this.singleClickTimer = +setTimeout(function () {
                _this.clickCount = 0;
                _this.triggerPointEvent(pointClick, e);
            }, timeInterval);
        }
        else if (this.clickCount === 2 && this.pointDoubleClick) {
            clearTimeout(this.singleClickTimer);
            this.clickCount = 0;
            this.triggerPointEvent(pointDoubleClick, e);
        }
        if (this.axisLabelClick) {
            this.triggerAxisLabelClickEvent(axisLabelClick, e);
        }
        this.notify('click', e);
        return false;
    };
    Chart.prototype.triggerPointEvent = function (event, e) {
        var evt = e;
        var data = new ChartData(this);
        var pointData = data.getData();
        if (pointData.series && pointData.point) {
            this.trigger(event, {
                series: this.isBlazor ? {} : pointData.series,
                point: pointData.point,
                seriesIndex: pointData.series.index, pointIndex: pointData.point.index,
                x: this.mouseX, y: this.mouseY, pageX: evt.pageX, pageY: evt.pageY
            });
        }
    };
    Chart.prototype.triggerAxisLabelClickEvent = function (event, e) {
        var targetElement = e.target;
        var clickEvt = e;
        if (targetElement.id.indexOf('_AxisLabel_') !== -1) {
            var index = targetElement.id.split('_AxisLabel_');
            var axisIndex = +index[0].slice(-1);
            var labelIndex = +index[1];
            var currentAxis = this.axisCollections[axisIndex];
            if (currentAxis.visible && (axisIndex === 0 || axisIndex === 1)) {
                this.trigger(event, {
                    chart: this,
                    axis: currentAxis,
                    text: currentAxis.visibleLabels[labelIndex].text,
                    labelID: targetElement.id,
                    index: labelIndex,
                    location: new ChartLocation(clickEvt.pageX, clickEvt.pageY),
                    value: currentAxis.visibleLabels[labelIndex].value
                });
            }
        }
    };
    /**
     * Handles the mouse move on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Chart.prototype.chartOnMouseMove = function (e) {
        var element = e.target;
        this.trigger(chartMouseMove, { target: element.id, x: this.mouseX, y: this.mouseY });
        if (this.pointMove) {
            this.triggerPointEvent(pointMove, e);
        }
        // Tooltip for chart series.
        if (!this.isTouch) {
            this.titleTooltip(e, this.mouseX, this.mouseY);
            this.axisTooltip(e, this.mouseX, this.mouseY);
        }
        if (this.dataEditingModule) {
            this.dataEditingModule.pointMouseMove(e);
        }
        this.notify(Browser.touchMoveEvent, e);
        this.isTouch = false;
        return false;
    };
    Chart.prototype.titleTooltip = function (event, x, y, isTouch) {
        var targetId = event.target.id;
        var id = (targetId === (this.element.id + '_ChartTitle') || targetId === (this.element.id + '_ChartSubTitle') ||
            targetId.indexOf('_AxisTitle') > -1 || targetId.indexOf('_legend_title') > -1);
        var index = 0;
        if (targetId.indexOf('_AxisTitle') > -1) {
            index = parseInt(((targetId.replace(this.element.id, '')).replace('AxisLabel_', '')).split('_')[2], 10);
        }
        if (id && (event.target.textContent.indexOf('...') > -1)) {
            var title = (targetId === (this.element.id + '_ChartTitle')) ? this.title :
                targetId.indexOf('_AxisTitle') > -1 ? this.axisCollections[index].title :
                    targetId.indexOf('_ChartSubTitle') > -1 ? this.subTitle : this.legendSettings.title;
            showTooltip(title, x, y, this.element.offsetWidth, this.element.id + '_EJ2_Title_Tooltip', getElement$1(this.element.id + '_Secondary_Element'), isTouch);
        }
        else {
            removeElement$1(this.element.id + '_EJ2_Title_Tooltip');
        }
    };
    Chart.prototype.axisTooltip = function (event, x, y, isTouch) {
        var targetId = event.target.id;
        if (((targetId.indexOf('AxisLabel') > -1) || targetId.indexOf('Axis_MultiLevelLabel') > -1) &&
            (event.target.textContent.indexOf('...') > -1)) {
            var isTitleOrLegendEnabled = (this.legendSettings.visible || this.primaryXAxis.title === '');
            showTooltip(this.findAxisLabel(targetId), x, y, this.element.offsetWidth, this.element.id + '_EJ2_AxisLabel_Tooltip', getElement$1(this.element.id + '_Secondary_Element'), isTouch, isTitleOrLegendEnabled);
        }
        else {
            removeElement$1(this.element.id + '_EJ2_AxisLabel_Tooltip');
        }
    };
    Chart.prototype.findAxisLabel = function (text) {
        var texts;
        if (text.indexOf('AxisLabel') > -1) {
            texts = ((text.replace(this.element.id, '')).replace('AxisLabel_', '')).split('_');
            return this.axisCollections[parseInt(texts[0], 10)].visibleLabels[parseInt(texts[1], 10)].originalText;
        }
        else {
            texts = ((text.replace(this.element.id, '')).replace('Axis_MultiLevelLabel_Level_', '').replace('Text_', '')).split('_');
            return (this.axisCollections[parseInt(texts[0], 10)].multiLevelLabels[parseInt(texts[1], 10)]
                .categories[parseInt(texts[2], 10)].text);
        }
    };
    /**
     * Handles the mouse down on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Chart.prototype.chartOnMouseDown = function (e) {
        var pageX;
        var pageY;
        var target;
        var touchArg;
        var offset = Browser.isDevice ? 20 : 30;
        var rect = this.element.getBoundingClientRect();
        var element = e.target;
        if (this.stockChart && this.stockChart.zoomSettings.enablePan) {
            this.allowPan = true;
        }
        this.trigger(chartMouseDown, { target: element.id, x: this.mouseX, y: this.mouseY });
        if (e.type === 'touchstart') {
            this.isTouch = true;
            touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            pageY = touchArg.changedTouches[0].clientY;
            target = touchArg.target;
        }
        else {
            this.isTouch = e.pointerType === 'touch';
            pageX = e.clientX;
            pageY = e.clientY;
            target = e.target;
        }
        var svgRect = getElement$1(this.svgId).getBoundingClientRect();
        this.mouseDownX = this.previousMouseMoveX = (pageX - rect.left) - Math.max(svgRect.left - rect.left, 0);
        this.mouseDownY = this.previousMouseMoveY = (pageY - rect.top) - Math.max(svgRect.top - rect.top, 0);
        if (this.isTouch) {
            this.isDoubleTap = (new Date().getTime() < this.threshold && target.id.indexOf(this.element.id + '_Zooming_') === -1 &&
                (this.mouseDownX - offset >= this.mouseX || this.mouseDownX + offset >= this.mouseX) &&
                (this.mouseDownY - offset >= this.mouseY || this.mouseDownY + offset >= this.mouseY) &&
                (this.mouseX - offset >= this.mouseDownX || this.mouseX + offset >= this.mouseDownX) &&
                (this.mouseY - offset >= this.mouseDownY || this.mouseY + offset >= this.mouseDownY));
        }
        if (this.dataEditingModule) {
            this.dataEditingModule.pointMouseDown();
        }
        this.notify(Browser.touchStartEvent, e);
        return false;
    };
    /**
     * Handles the mouse up.
     *
     * @returns {boolean} false
     * @private
     */
    Chart.prototype.mouseEnd = function (e) {
        var pageY;
        var pageX;
        var touchArg;
        if (e.type === 'touchend') {
            touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            this.isTouch = true;
            pageY = touchArg.changedTouches[0].clientY;
        }
        else {
            pageY = e.clientY;
            pageX = e.clientX;
            this.isTouch = e.pointerType === 'touch' || e.pointerType === '2';
        }
        this.setMouseXY(pageX, pageY);
        this.chartOnMouseUp(e);
        return false;
    };
    /**
     * Handles the mouse up.
     *
     * @returns {boolean}
     * @private
     */
    Chart.prototype.chartOnMouseUp = function (e) {
        var element = e.target;
        this.trigger(chartMouseUp, { target: element.id, x: this.mouseX, y: this.mouseY });
        this.isChartDrag = false;
        this.allowPan = false;
        if (this.isTouch) {
            this.titleTooltip(e, this.mouseX, this.mouseY, this.isTouch);
            this.axisTooltip(e, this.mouseX, this.mouseY, this.isTouch);
            this.threshold = new Date().getTime() + 300;
        }
        if (this.dataEditingModule) {
            this.dataEditingModule.pointMouseUp();
        }
        if (!this.enableCanvas && this.seriesElements) {
            this.seriesElements.removeAttribute('clip-path');
        }
        this.notify(Browser.touchEndEvent, e);
        return false;
    };
    /**
     * Method to set culture for chart
     */
    Chart.prototype.setCulture = function () {
        this.intl = new Internationalization();
        this.setLocaleConstants();
        this.localeObject = new L10n(this.getModuleName(), this.defaultLocalConstants, this.locale);
    };
    /**
     * Method to set the annotation content dynamically for chart.
     */
    Chart.prototype.setAnnotationValue = function (annotationIndex, content) {
        var parentNode = getElement$1(this.element.id + '_Annotation_Collections');
        var annotation = this.annotations[annotationIndex];
        var element;
        if (content !== null) {
            annotation.content = content;
            if (parentNode) {
                removeElement$1(this.element.id + '_Annotation_' + annotationIndex);
                element = this.createElement('div');
                this.annotationModule.processAnnotation(annotation, annotationIndex, element);
                parentNode.appendChild(element.children[0]);
            }
            else {
                this.annotationModule.renderAnnotations(getElement$1(this.element.id + '_Secondary_Element'));
            }
        }
    };
    /**
     * Method to set locale constants
     */
    Chart.prototype.setLocaleConstants = function () {
        this.defaultLocalConstants = {
            ZoomIn: 'Zoom in',
            Zoom: 'Zoom',
            ZoomOut: 'Zoom out',
            Pan: 'Pan',
            Reset: 'Reset',
            ResetZoom: 'Reset Zoom'
        };
    };
    /**
     * Theming for chart
     */
    Chart.prototype.setTheme = function () {
        /*! Set theme */
        this.themeStyle = getThemeColor(this.theme, this.enableCanvas);
        if (!(document.getElementById(this.element.id + 'Keyboard_chart_focus'))) {
            var style = document.createElement('style');
            style.setAttribute('id', this.element.id + 'Keyboard_chart_focus');
            style.innerText = '.e-chart-focused:focus, path[class*=_ej2_chart_selection_series]:focus,' +
                'path[id*=_Point_]:focus, text[id*=_ChartTitle]:focus {outline: none } .e-chart-focused:focus-visible, path[class*=_ej2_chart_selection_series]:focus-visible,' +
                'path[id*=_Point_]:focus-visible, text[id*=_ChartTitle]:focus-visible {outline: 1.5px ' + this.themeStyle.tabColor + ' solid}';
            document.body.appendChild(style);
        }
    };
    /**
     * To provide the array of modules needed for control rendering
     *
     * @returns {ModuleDeclaration[]}
     * @private
     */
    /* eslint-disable  */
    Chart.prototype.requiredModules = function () {
        var _this = this;
        var modules = [];
        var series = this.series;
        var enableAnnotation = false;
        var moduleName;
        var errorBarVisible = false;
        var isPointDrag = false;
        var dataLabelEnable = false;
        var zooming = this.zoomSettings;
        this.chartAreaType = (series.length > 0 && (series[0].type === 'Polar' || series[0].type === 'Radar')) ? 'PolarRadar' : 'Cartesian';
        if (this.tooltip.enable) {
            modules.push({
                member: 'Tooltip',
                args: [this]
            });
        }
        series.map(function (value) {
            _this.isLegend = (_this.legendSettings.visible && ((value.name !== '') || !!_this.isLegend));
            moduleName = value.type.indexOf('100') !== -1 ? value.type.replace('100', '') + 'Series' : value.type + 'Series';
            errorBarVisible = value.errorBar.visible || errorBarVisible;
            dataLabelEnable = value.marker.dataLabel.visible || dataLabelEnable || (value.type == 'Pareto' && value.paretoOptions.marker.dataLabel.visible);
            isPointDrag = value.dragSettings.enable || isPointDrag;
            if (!modules.some(function (currentModule) {
                return currentModule.member === moduleName;
            })) {
                modules.push({
                    member: moduleName,
                    args: [_this, series]
                });
            }
            if (_this.chartAreaType === 'PolarRadar') {
                modules.push({
                    member: value.drawType + 'Series',
                    args: [_this, series]
                });
            }
            if (value.type === 'Pareto') {
                modules.push({
                    member: 'ColumnSeries',
                    args: [_this, series]
                });
                modules.push({
                    member: 'LineSeries',
                    args: [_this, series]
                });
            }
        });
        this.findIndicatorModules(modules);
        this.findTrendLineModules(modules);
        modules = this.findAxisModule(modules);
        enableAnnotation = this.annotations.some(function (value) {
            return (value.content !== null);
        });
        if (errorBarVisible) {
            modules.push({
                member: 'ErrorBar',
                args: [this, series]
            });
        }
        if (this.isLegend) {
            modules.push({
                member: 'Legend',
                args: [this]
            });
        }
        if (this.enableExport || this.allowExport) {
            modules.push({
                member: 'Export',
                args: [this]
            });
        }
        if (this.chartAreaType !== 'PolarRadar' && this.crosshair.enable) {
            modules.push({
                member: 'Crosshair',
                args: [this]
            });
        }
        if (this.chartAreaType !== 'PolarRadar' && !this.scrollSettingEnabled && (zooming.enableSelectionZooming
            || zooming.enableMouseWheelZooming || zooming.enablePinchZooming || zooming.enablePan || zooming.enableScrollbar || zooming.showToolbar)) {
            modules.push({
                member: 'Zoom',
                args: [this, this.zoomSettings]
            });
            if (zooming.enableScrollbar) {
                modules.push({
                    member: 'ScrollBar',
                    args: [this]
                });
            }
        }
        if (this.selectionMode !== 'None' && !(this.chartAreaType === 'PolarRadar' &&
            this.selectionMode.indexOf('Drag') > -1)) {
            modules.push({
                member: 'Selection',
                args: [this]
            });
        }
        if (this.highlightMode !== 'None' || this.legendSettings.enableHighlight) {
            modules.push({
                member: 'Highlight',
                args: [this]
            });
        }
        if (dataLabelEnable) {
            modules.push({
                member: 'DataLabel',
                args: [this, series]
            });
        }
        if (isPointDrag) {
            modules.push({
                member: 'DataEditing',
                args: [this]
            });
        }
        if (enableAnnotation) {
            modules.push({
                member: 'Annotation',
                args: [this]
            });
        }
        return modules;
    };
    Chart.prototype.findAxisModule = function (modules) {
        var axisCollections = [];
        axisCollections.push(this.primaryXAxis);
        axisCollections.push(this.primaryYAxis);
        axisCollections = axisCollections.concat(this.axes);
        var datetimeEnabled = false;
        var categoryEnabled = false;
        var logarithmicEnabled = false;
        var striplineEnabled = false;
        var dateTimeCategoryEnabled = false;
        var multiLevelEnabled = false;
        for (var _i = 0, axisCollections_1 = axisCollections; _i < axisCollections_1.length; _i++) {
            var axis = axisCollections_1[_i];
            datetimeEnabled = axis.valueType === 'DateTime' || datetimeEnabled;
            categoryEnabled = axis.valueType === 'Category' || categoryEnabled;
            logarithmicEnabled = axis.valueType === 'Logarithmic' || logarithmicEnabled;
            dateTimeCategoryEnabled = axis.valueType === 'DateTimeCategory' || dateTimeCategoryEnabled;
            striplineEnabled = this.findStriplineVisibility(axis.stripLines) || striplineEnabled;
            multiLevelEnabled = axis.multiLevelLabels.length > 0 || multiLevelEnabled;
            this.scrollSettingEnabled = axis.scrollbarSettings.enable ? true : this.scrollSettingEnabled;
        }
        if (datetimeEnabled) {
            modules.push({
                member: 'DateTime',
                args: [this]
            });
        }
        if (categoryEnabled) {
            modules.push({
                member: 'Category',
                args: [this]
            });
        }
        if (logarithmicEnabled) {
            modules.push({
                member: 'Logarithmic',
                args: [this]
            });
        }
        if (striplineEnabled) {
            modules.push({
                member: 'StripLine',
                args: [this]
            });
        }
        if (multiLevelEnabled) {
            modules.push({
                member: 'MultiLevelLabel',
                args: [this]
            });
        }
        if (dateTimeCategoryEnabled) {
            modules.push({
                member: 'DateTimeCategory',
                args: [this]
            });
        }
        if (this.scrollSettingEnabled) {
            modules.push({
                member: 'ScrollBar',
                args: [this]
            });
        }
        return modules;
    };
    Chart.prototype.findIndicatorModules = function (modules) {
        var macdEnable;
        var bandEnable;
        var indicators = this.indicators;
        if (this.indicators.length) {
            modules.push({
                member: 'LineSeries',
                args: [this]
            });
            indicators.map(function (indicator) {
                macdEnable = macdEnable || indicator.type === 'Macd';
                bandEnable = bandEnable || indicator.type === 'BollingerBands';
            });
            if (macdEnable) {
                modules.push({
                    member: 'ColumnSeries',
                    args: [this]
                });
            }
            if (bandEnable) {
                modules.push({
                    member: 'RangeAreaSeries',
                    args: [this]
                });
            }
            if (bandEnable) {
                modules.push({
                    member: 'SplineRangeAreaSeries',
                    args: [this]
                });
            }
            for (var _i = 0, _a = this.indicators; _i < _a.length; _i++) {
                var indicator = _a[_i];
                modules.push({
                    member: indicator.type + 'Indicator',
                    args: [this]
                });
            }
        }
    };
    Chart.prototype.findTrendLineModules = function (modules) {
        var isLine;
        var isSpline;
        var _loop_1 = function (series) {
            var markerEnable;
            series.trendlines.map(function (trendline) {
                markerEnable = markerEnable || trendline.marker.visible;
                isLine = isLine || (trendline.type === 'Linear' || trendline.type === 'MovingAverage') ? true : false;
                isSpline = isSpline || (!isLine || (trendline.type === 'Exponential' || trendline.type === 'Logarithmic' || trendline.type === 'Power' || trendline.type === 'Polynomial')) ? true : false;
            });
            if (markerEnable) {
                modules.push({
                    member: 'Marker',
                    args: [this_1, series]
                });
            }
        };
        var this_1 = this;
        for (var _i = 0, _a = this.series; _i < _a.length; _i++) {
            var series = _a[_i];
            _loop_1(series);
        }
        if (isLine || isSpline) {
            modules.push({
                member: 'TrendLine',
                args: [this]
            });
        }
        if (isLine) {
            modules.push({
                member: 'LineSeries',
                args: [this]
            });
        }
        if (isSpline) {
            modules.push({
                member: 'SplineSeries',
                args: [this]
            });
        }
    };
    Chart.prototype.findStriplineVisibility = function (striplines) {
        var visible = false;
        for (var _i = 0, striplines_1 = striplines; _i < striplines_1.length; _i++) {
            var stripline = striplines_1[_i];
            if (stripline.visible) {
                visible = true;
                break;
            }
        }
        return visible;
    };
    /**
     * To Remove the SVG.
     * @return {boolean}
     * @private
     */
    Chart.prototype.removeSvg = function () {
        if (this.redraw) {
            return null;
        }
        blazorTemplatesReset(this);
        if (this.enableCanvas && this.svgObject && this.svgObject.tagName === 'CANVAS') {
            this.renderer.clearRect(new Rect(0, 0, this.availableSize.width, this.availableSize.height));
            if (this.svgObject.parentNode) {
                remove(this.svgObject);
            }
            return null;
        }
        removeElement$1(this.element.id + '_Secondary_Element');
        if (this.isReact) {
            this.clearTemplate();
        }
        var removeLength = 0;
        if (this.zoomModule && this.zoomModule.pinchTarget) {
            this.zoomModule.pinchTarget.id = '';
            this.zoomModule.pinchTarget.setAttribute('opacity', '0');
            this.svgObject.appendChild(this.zoomModule.pinchTarget);
            removeLength = 1;
        }
        // Fix for blazor resize issue
        if (!isNullOrUndefined(this.resizeTo)) {
            if (this.resizeTo !== this.checkResize && this.isBlazor && this.element.childElementCount) {
                var containerCollection = document.querySelectorAll('.e-chart');
                for (var index = 0; index < containerCollection.length; index++) {
                    var container = containerCollection[index];
                    while (container.firstChild) {
                        remove(container.firstChild);
                    }
                }
            }
            this.checkResize = this.resizeTo;
        }
        if (this.svgObject) {
            while (this.svgObject.childNodes.length > removeLength) {
                this.svgObject.removeChild(this.svgObject.firstChild);
            }
            if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode && !(this.stockChart)) {
                remove(this.svgObject);
            }
        }
    };
    Chart.prototype.refreshDefinition = function (definitions) {
        for (var _i = 0, definitions_1 = definitions; _i < definitions_1.length; _i++) {
            var item = definitions_1[_i];
            item.axes = [];
        }
    };
    /**
     * Refresh the axis default value.
     *
     * @returns {boolean}
     * @private
     */
    Chart.prototype.refreshAxis = function () {
        var axis = this.primaryXAxis;
        axis.rect = new Rect(undefined, undefined, 0, 0);
        axis = this.primaryYAxis;
        axis.isStack100 = false;
        axis.rect = new Rect(undefined, undefined, 0, 0);
        for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {
            var item = _a[_i];
            axis = item;
            axis.rect = new Rect(undefined, undefined, 0, 0);
            axis.isStack100 = false;
        }
        if (this.paretoSeriesModule && this.series[0].type === 'Pareto') {
            for (var _b = 0, _c = this.paretoSeriesModule.paretoAxes; _b < _c.length; _b++) {
                var item = _c[_b];
                axis = item;
                axis.rect = new Rect(undefined, undefined, 0, 0);
                axis.isStack100 = false;
            }
        }
    };
    Chart.prototype.axisChange = function (axis) {
        if (!axis.name && !axis.valueType) {
            return false;
        }
        this.refreshDefinition(this.columns);
        this.refreshDefinition(this.rows);
        this.calculateVisibleAxis();
        this.processData();
        return true;
    };
    /**
     * Get visible series by index
     */
    Chart.prototype.getVisibleSeries = function (visibleSeries, index) {
        for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
            var series = visibleSeries_1[_i];
            if (index === series.index) {
                return series;
            }
        }
        return null;
    };
    /**
     * Fix for live data update flicker issue
     */
    Chart.prototype.refreshLiveData = function () {
        this.calculateVisibleSeries();
        this.initTechnicalIndicators();
        this.initTrendLines();
        this.refreshDefinition(this.columns);
        this.refreshDefinition(this.rows);
        this.calculateVisibleAxis();
        this.processData(false);
        if (!this.isBlazor) {
            this.enableCanvas ? this.createChartSvg() : this.removeSvg();
            this.refreshAxis();
            this.refreshBound();
            this.trigger('loaded', { chart: this.isBlazor ? {} : this });
        }
    };
    /**
     * To remove style element
     */
    Chart.prototype.removeStyles = function () {
        removeElement$1(this.element.id + '_ej2_chart_selection');
        removeElement$1(this.element.id + '_ej2_chart_highlight');
    };
    /**
     * To trigger the manual mouse move event for live chart tooltip
     */
    Chart.prototype.mouseMoveEvent = function () {
        if (this.tooltip.enable && this.previousPageX !== null && this.previousPageY !== null) {
            var mousemove = document.createEvent('MouseEvent');
            mousemove.initMouseEvent('mousemove', true, false, window, 1, 100, 100, this.previousPageX, this.previousPageY, false, false, false, false, 0, null);
            this.element.dispatchEvent(mousemove);
        }
    };
    /**
     * Displays a tooltip for the data points.
     *
     * @param {object} x - Specifies the x value of the point or x coordinate.
     * @param {number} y - Specifies the x value of the point or y coordinate.
     * @param {boolean} isPoint - Specifies whether x and y are data point or chart coordinates.
     * @returns {void}
     */
    Chart.prototype.showTooltip = function (x, y, isPoint) {
        if (isPoint === void 0) { isPoint = false; }
        if (isPoint) {
            for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
                var series = _a[_i];
                for (var _b = 0, _c = series.points; _b < _c.length; _b++) {
                    var point = _c[_b];
                    var pointX = series.xAxis.valueType == 'DateTime' ? point.xValue : point.x;
                    var xValue = x;
                    if (series.xAxis.valueType == 'DateTime') {
                        xValue = new Date(xValue).getTime();
                    }
                    if (x == pointX && y === point.yValue) {
                        this.mouseX = point.regions[0].x + this.chartAxisLayoutPanel.seriesClipRect.x;
                        this.mouseY = point.regions[0].y + this.chartAxisLayoutPanel.seriesClipRect.y;
                        this.tooltipModule.tooltip();
                        this.markerRender.mouseMoveHandler();
                        break;
                    }
                }
            }
        }
        else {
            if (this.isTouch) {
                this.startMove = true;
            }
            this.mouseX = x;
            this.mouseY = y;
            this.tooltipModule.mouseMoveHandler();
            this.markerRender.mouseMoveHandler();
        }
    };
    /**
     * Hides a tooltip in the chart.
     *
     * @returns {void}
     */
    Chart.prototype.hideTooltip = function () {
        this.tooltipModule.removeTooltip(Browser.isDevice ? 2000 : 1000);
    };
    /**
     * Displays a crosshair for the chart.
     *
     * @param {object} x - Specifies the x value of the point or x coordinate.
     * @param {number} y - Specifies the x value of the point or y coordinate.
     * @returns {void}
     */
    Chart.prototype.showCrosshair = function (x, y) {
        this.mouseX = x;
        this.mouseY = y;
        this.isCrosshair = false;
        if (withInBounds(this.mouseX, this.mouseY, this.chartAxisLayoutPanel.seriesClipRect)) {
            this.crosshairModule.crosshair();
        }
        else {
            this.hideCrosshair();
        }
        this.isCrosshair = true;
    };
    /**
     * Hides a tooltip in the chart.
     *
     * @returns {void}
     */
    Chart.prototype.hideCrosshair = function () {
        this.crosshairModule.removeCrosshair(Browser.isDevice ? 2000 : 1000);
    };
    /**
     * Called internally if any of the property value changed.
     * @private
     */
    // tslint:disable-next-line:max-func-body-length
    Chart.prototype.onPropertyChanged = function (newProp, oldProp) {
        var renderer = false;
        var refreshBounds = false;
        this.animateSeries = false;
        var axis;
        if (!this.delayRedraw) {
            for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
                var prop = _a[_i];
                switch (prop) {
                    case 'primaryXAxis':
                        axis = newProp.primaryXAxis;
                        refreshBounds = this.axisChange(axis);
                        if (newProp.primaryXAxis.edgeLabelPlacement) {
                            renderer = true;
                        }
                        if (!newProp.primaryXAxis.crosshairTooltip) {
                            refreshBounds = true;
                        }
                        if (!isNullOrUndefined(axis.isInversed) || !isNullOrUndefined(axis.opposedPosition)) {
                            this.primaryXAxis.setIsInversedAndOpposedPosition();
                        }
                        break;
                    case 'primaryYAxis':
                        axis = newProp.primaryYAxis;
                        refreshBounds = this.axisChange(axis);
                        if (newProp.primaryYAxis.edgeLabelPlacement) {
                            renderer = true;
                        }
                        if (!newProp.primaryYAxis.crosshairTooltip) {
                            refreshBounds = true;
                        }
                        if (!isNullOrUndefined(axis.isInversed) || !isNullOrUndefined(axis.opposedPosition)) {
                            this.primaryYAxis.setIsInversedAndOpposedPosition();
                        }
                        break;
                    case 'axes':
                        for (var _b = 0, _c = Object.keys(newProp.axes); _b < _c.length; _b++) {
                            var index = _c[_b];
                            axis = newProp.axes[index];
                            refreshBounds = refreshBounds || this.axisChange(axis);
                            if (!axis.crosshairTooltip) {
                                refreshBounds = true;
                            }
                            if (!isNullOrUndefined(axis.isInversed) || !isNullOrUndefined(axis.opposedPosition)) {
                                this.axes[index].setIsInversedAndOpposedPosition();
                            }
                        }
                        break;
                    case 'height':
                    case 'width':
                        this.createChartSvg();
                        refreshBounds = true;
                        break;
                    case 'subTitle':
                    case 'title':
                        refreshBounds = true;
                        break;
                    case 'titleStyle':
                        if (newProp.titleStyle && (newProp.titleStyle.size || newProp.titleStyle.textOverflow)) {
                            refreshBounds = true;
                        }
                        else {
                            renderer = true;
                        }
                        break;
                    case 'subTitleStyle':
                        if (newProp.subTitleStyle && (newProp.subTitleStyle.size || newProp.subTitleStyle.textOverflow)) {
                            refreshBounds = true;
                        }
                        else {
                            renderer = true;
                        }
                        break;
                    case 'border':
                        renderer = true;
                        break;
                    case 'dataSource':
                        this.processData(false);
                        refreshBounds = true;
                        break;
                    case 'enableCanvas':
                        this.refresh();
                        break;
                    case 'series':
                        var len = this.series.length;
                        var seriesRefresh = false;
                        var series = void 0;
                        var blazorProp = void 0;
                        for (var i = 0; i < len; i++) {
                            series = newProp.series[i];
                            // I264774 blazor series visible property binding not working issue fixed.
                            if (this.isBlazor && series && ((series.visible !== oldProp.series[i].visible) || series.isClosed ||
                                series.marker || series.emptyPointSettings || series.type || series.boxPlotMode || series.showMean)) {
                                blazorProp = true;
                            }
                            if (!isNullOrUndefined(series) && (series.dataSource || series.query || series.errorBar || series.xName ||
                                series.yName || series.size || series.high || series.low || series.open || series.close || series.trendlines ||
                                series.fill || series.name || series.marker || series.width || series.binInterval || series.type || (series.visible !== oldProp.series[i].visible) || blazorProp)) {
                                extend(this.getVisibleSeries(this.visibleSeries, i), series, null, true);
                                seriesRefresh = true;
                            }
                        }
                        if (seriesRefresh) {
                            this.calculateVisibleSeries();
                            this.initTechnicalIndicators();
                            this.initTrendLines();
                            this.refreshDefinition(this.columns);
                            this.refreshDefinition(this.rows);
                            this.calculateVisibleAxis();
                            this.processData(false);
                            refreshBounds = true;
                        }
                        break;
                    case 'indicators':
                        refreshBounds = true;
                        break;
                    case 'zoomSettings':
                        if (newProp.zoomSettings.enableScrollbar || oldProp.zoomSettings.enableScrollbar) {
                            refreshBounds = true;
                        }
                        renderer = true;
                        break;
                    case 'background':
                        renderer = true;
                        break;
                    case 'chartArea':
                        if (newProp.chartArea.border && newProp.chartArea.border.width) {
                            refreshBounds = true;
                        }
                        renderer = true;
                        break;
                    case 'legendSettings':
                        if (!newProp.legendSettings.background || !newProp.legendSettings.opacity) {
                            refreshBounds = true;
                        }
                        renderer = true;
                        break;
                    case 'palettes':
                        this.calculateVisibleSeries();
                        renderer = true;
                        break;
                    case 'selectedDataIndexes':
                        if (this.selectionModule) {
                            this.selectionModule.currentMode = this.selectionMode;
                            this.selectionModule.selectedDataIndexes = this.selectedDataIndexes;
                            this.selectionModule.styleId = this.element.id + '_ej2_chart_selection';
                            this.selectionModule.redrawSelection(this, oldProp.selectionMode, true);
                        }
                        else if (this.highlightModule) {
                            this.highlightModule.currentMode = this.highlightMode;
                            this.highlightModule.highlightDataIndexes = this.selectedDataIndexes;
                            this.highlightModule.styleId = this.element.id + '_ej2_chart_highlight';
                            this.highlightModule.redrawSelection(this, oldProp.selectionMode, true);
                        }
                        break;
                    case 'selectionMode':
                        if (this.selectionModule && newProp.selectionMode && newProp.selectionMode.indexOf('Drag') === -1) {
                            this.selectionModule.currentMode = this.selectionMode;
                            this.selectionModule.styleId = this.element.id + '_ej2_chart_selection';
                            this.selectionModule.redrawSelection(this, oldProp.selectionMode, true);
                        }
                        break;
                    case 'isMultiSelect':
                        if (this.selectionModule && !newProp.isMultiSelect && this.selectionModule.selectedDataIndexes.length > 1) {
                            this.selectionModule.currentMode = this.selectionMode;
                            this.selectionModule.styleId = this.element.id + '_ej2_chart_selection';
                            this.selectionModule.redrawSelection(this, oldProp.selectionMode);
                        }
                        break;
                    case 'highlightMode':
                    case 'selectionPattern':
                    case 'highlightPattern':
                        this.removeStyles();
                        renderer = true;
                        break;
                    case 'theme':
                        this.animateSeries = true;
                        break;
                    case 'enableRtl':
                    case 'locale':
                    case 'currencyCode':
                        if (this.isBlazor) {
                            this.setCulture();
                            renderer = true;
                        }
                        else {
                            this.refresh();
                        }
                        break;
                    case 'tooltip':
                        if (this.tooltipModule) { // To check the tooltip enable is true.
                            this.tooltipModule.previousPoints = [];
                            if (this.tooltip.template) {
                                this.tooltipModule.template = this.tooltip.template;
                            }
                        }
                        break;
                }
            }
            if (!refreshBounds && renderer) {
                this.rotatedDataLabelCollections = [];
                this.removeSvg();
                this.renderElements();
                this.trigger('loaded', { chart: this.isBlazor ? {} : this });
            }
            if (refreshBounds) {
                this.enableCanvas ? this.createChartSvg() : this.removeSvg();
                if (this.isReact) {
                    this.clearTemplate();
                }
                this.dragY = null;
                this.refreshAxis();
                this.refreshBound();
                this.trigger('loaded', { chart: this.isBlazor ? {} : this });
                this.redraw = false;
                this.animated = false;
            }
        }
    };
    __decorate([
        Property(null)
    ], Chart.prototype, "width", void 0);
    __decorate([
        Property(null)
    ], Chart.prototype, "height", void 0);
    __decorate([
        Property('')
    ], Chart.prototype, "title", void 0);
    __decorate([
        Property('')
    ], Chart.prototype, "dataSource", void 0);
    __decorate([
        Complex({ fontFamily: null, size: "16px", fontStyle: 'Normal', fontWeight: '600', color: null }, titleSettings)
    ], Chart.prototype, "titleStyle", void 0);
    __decorate([
        Property('')
    ], Chart.prototype, "subTitle", void 0);
    __decorate([
        Complex({ fontFamily: null, size: "14px", fontStyle: 'Normal', fontWeight: '400', color: null }, titleSettings)
    ], Chart.prototype, "subTitleStyle", void 0);
    __decorate([
        Complex({}, Margin)
    ], Chart.prototype, "margin", void 0);
    __decorate([
        Complex({ color: '#DDDDDD', width: 0 }, Border)
    ], Chart.prototype, "border", void 0);
    __decorate([
        Property(null)
    ], Chart.prototype, "background", void 0);
    __decorate([
        Complex({ border: { color: null, width: 0.5 }, background: 'transparent' }, ChartArea)
    ], Chart.prototype, "chartArea", void 0);
    __decorate([
        Complex({ name: 'primaryXAxis' }, Axis)
    ], Chart.prototype, "primaryXAxis", void 0);
    __decorate([
        Complex({ name: 'primaryYAxis' }, Axis)
    ], Chart.prototype, "primaryYAxis", void 0);
    __decorate([
        Collection([{}], Row)
    ], Chart.prototype, "rows", void 0);
    __decorate([
        Collection([{}], Column)
    ], Chart.prototype, "columns", void 0);
    __decorate([
        Collection([{}], Axis)
    ], Chart.prototype, "axes", void 0);
    __decorate([
        Collection([{}], Series)
    ], Chart.prototype, "series", void 0);
    __decorate([
        Collection([{}], ChartAnnotationSettings)
    ], Chart.prototype, "annotations", void 0);
    __decorate([
        Property([])
    ], Chart.prototype, "palettes", void 0);
    __decorate([
        Property('Material')
    ], Chart.prototype, "theme", void 0);
    __decorate([
        Complex({}, TooltipSettings)
    ], Chart.prototype, "tooltip", void 0);
    __decorate([
        Complex({}, CrosshairSettings)
    ], Chart.prototype, "crosshair", void 0);
    __decorate([
        Complex({}, LegendSettings)
    ], Chart.prototype, "legendSettings", void 0);
    __decorate([
        Collection([{}], RangeColorSetting)
    ], Chart.prototype, "rangeColorSettings", void 0);
    __decorate([
        Complex({}, ZoomSettings)
    ], Chart.prototype, "zoomSettings", void 0);
    __decorate([
        Property('')
    ], Chart.prototype, "highlightColor", void 0);
    __decorate([
        Property('None')
    ], Chart.prototype, "selectionMode", void 0);
    __decorate([
        Property('None')
    ], Chart.prototype, "highlightMode", void 0);
    __decorate([
        Property('None')
    ], Chart.prototype, "selectionPattern", void 0);
    __decorate([
        Property('None')
    ], Chart.prototype, "highlightPattern", void 0);
    __decorate([
        Property(false)
    ], Chart.prototype, "isMultiSelect", void 0);
    __decorate([
        Property(false)
    ], Chart.prototype, "allowMultiSelection", void 0);
    __decorate([
        Property(true)
    ], Chart.prototype, "enableExport", void 0);
    __decorate([
        Property(false)
    ], Chart.prototype, "allowExport", void 0);
    __decorate([
        Collection([], Indexes)
    ], Chart.prototype, "selectedDataIndexes", void 0);
    __decorate([
        Property(false)
    ], Chart.prototype, "useGroupingSeparator", void 0);
    __decorate([
        Property(false)
    ], Chart.prototype, "enableAutoIntervalOnBothAxis", void 0);
    __decorate([
        Property(false)
    ], Chart.prototype, "isTransposed", void 0);
    __decorate([
        Property(false)
    ], Chart.prototype, "enableCanvas", void 0);
    __decorate([
        Property(null)
    ], Chart.prototype, "backgroundImage", void 0);
    __decorate([
        Collection([], TechnicalIndicator)
    ], Chart.prototype, "indicators", void 0);
    __decorate([
        Property(true)
    ], Chart.prototype, "enableAnimation", void 0);
    __decorate([
        Property(null)
    ], Chart.prototype, "description", void 0);
    __decorate([
        Property(1)
    ], Chart.prototype, "tabIndex", void 0);
    __decorate([
        Property(true)
    ], Chart.prototype, "enableSideBySidePlacement", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "resized", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "beforeResize", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "annotationRender", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "beforePrint", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "loaded", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "beforeExport", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "afterExport", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "load", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "animationComplete", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "legendRender", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "textRender", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "pointRender", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "seriesRender", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "axisLabelRender", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "axisLabelClick", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "axisRangeCalculated", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "axisMultiLabelRender", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "legendClick", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "multiLevelLabelClick", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "tooltipRender", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "sharedTooltipRender", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "chartMouseMove", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "chartMouseClick", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "chartDoubleClick", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "pointClick", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "pointDoubleClick", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "pointMove", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "chartMouseLeave", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "chartMouseDown", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "chartMouseUp", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "dragComplete", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "selectionComplete", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "zoomComplete", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "onZooming", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "scrollStart", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "scrollEnd", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "scrollChanged", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "dragStart", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "drag", void 0);
    __decorate([
        Event()
    ], Chart.prototype, "dragEnd", void 0);
    __decorate([
        Property('USD')
    ], Chart.prototype, "currencyCode", void 0);
    Chart = __decorate([
        NotifyPropertyChanges
    ], Chart);
    return Chart;
}(Component));

var __extends$11 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/**
 * Common axis classes
 *
 * @private
 */
var NiceInterval = /** @__PURE__ @class */ (function (_super) {
    __extends$11(NiceInterval, _super);
    function NiceInterval() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Method to calculate numeric datetime interval.
     */
    NiceInterval.prototype.calculateDateTimeNiceInterval = function (axis, size, start, end, isChart) {
        if (isChart === void 0) { isChart = true; }
        var oneDay = 24 * 60 * 60 * 1000;
        var startDate = new Date(start);
        var endDate = new Date(end);
        //var axisInterval ;
        var totalDays = (Math.abs((startDate.getTime() - endDate.getTime()) / (oneDay)));
        var interval;
        axis.actualIntervalType = axis.intervalType;
        var type = axis.intervalType;
        switch (type) {
            case 'Years':
                interval = this.calculateNumericNiceInterval(axis, totalDays / 365, size);
                break;
            case 'Quarter':
                interval = this.calculateNumericNiceInterval(axis, (totalDays / 365) * 4, size);
                break;
            case 'Months':
                interval = this.calculateNumericNiceInterval(axis, totalDays / 30, size);
                break;
            case 'Weeks':
                interval = this.calculateNumericNiceInterval(axis, totalDays / 7, size);
                break;
            case 'Days':
                interval = this.calculateNumericNiceInterval(axis, totalDays, size);
                break;
            case 'Hours':
                interval = this.calculateNumericNiceInterval(axis, totalDays * 24, size);
                break;
            case 'Minutes':
                interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60, size);
                break;
            case 'Seconds':
                interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60 * 60, size);
                break;
            case 'Auto':
                interval = this.calculateNumericNiceInterval(axis, totalDays / 365, size);
                if (interval >= 1) {
                    axis.actualIntervalType = 'Years';
                    return interval;
                }
                interval = this.calculateNumericNiceInterval(axis, totalDays / 30, size);
                if (interval >= 1) {
                    axis.actualIntervalType = 'Months';
                    return interval;
                }
                interval = this.calculateNumericNiceInterval(axis, totalDays / 7, size);
                if (interval >= 1 && !isChart) {
                    axis.actualIntervalType = 'Weeks';
                    return interval;
                }
                interval = this.calculateNumericNiceInterval(axis, totalDays, size);
                if (interval >= 1) {
                    axis.actualIntervalType = 'Days';
                    return interval;
                }
                interval = this.calculateNumericNiceInterval(axis, totalDays * 24, size);
                if (interval >= 1) {
                    axis.actualIntervalType = 'Hours';
                    return interval;
                }
                interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60, size);
                if (interval >= 1) {
                    axis.actualIntervalType = 'Minutes';
                    return interval;
                }
                interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60 * 60, size);
                axis.actualIntervalType = 'Seconds';
                return interval;
        }
        return interval;
    };
    /**
     * To get the skeleton for the DateTime axis.
     *
     * @returns {string} skeleton format
     * @private
     */
    NiceInterval.prototype.getSkeleton = function (axis, currentValue, previousValue, isBlazor) {
        var skeleton;
        var intervalType = axis.actualIntervalType;
        if (axis.skeleton) {
            return axis.skeleton;
        }
        if (intervalType === 'Years') {
            if (isBlazor) {
                skeleton = axis.isChart ? (axis.valueType === 'DateTime' ? 'y' : 'y') : 'y';
            }
            else {
                skeleton = axis.isChart ? ((axis.valueType === 'DateTime' && axis.isIntervalInDecimal) ? 'y' : 'yMMM') : 'y';
            }
        }
        else if (intervalType === 'Quarter') {
            skeleton = isBlazor ? 'y' : 'yMMM';
        }
        else if (intervalType === 'Months') {
            if (isBlazor) {
                skeleton = axis.isChart ? 'm' : 'm';
            }
            else {
                skeleton = axis.isChart ? 'MMMd' : 'MMM';
            }
        }
        else if (intervalType === 'Weeks') {
            skeleton = isBlazor ? 'm' : 'MEd';
        }
        else if (intervalType === 'Days') {
            if (isBlazor) {
                skeleton = 'd';
            }
            else {
                skeleton = axis.isChart ? (axis.valueType === 'DateTime' ? 'MMMd' : 'yMd') : 'MMMd';
            }
        }
        else if (intervalType === 'Hours') {
            if (isBlazor) {
                skeleton = 't';
            }
            else {
                skeleton = axis.isChart ? (axis.valueType === 'DateTime' ? 'Hm' : 'EHm') : 'h';
            }
        }
        else if (intervalType === 'Minutes') {
            if (isBlazor) {
                skeleton = 'T';
            }
            else {
                skeleton = axis.isChart ? 'Hms' : 'hm';
            }
        }
        else {
            if (isBlazor) {
                skeleton = 'T';
            }
            else {
                skeleton = axis.isChart ? 'Hms' : 'hms';
            }
        }
        return skeleton;
    };
    /**
     * Find label format for axis
     *
     * @param {Axis} axis axis
     * @param {number} currentValue currentValue
     * @param {number} previousValue previousValue
     * @private
     */
    NiceInterval.prototype.findCustomFormats = function (axis, currentValue, previousValue) {
        var labelFormat = axis.labelFormat ? axis.labelFormat : '';
        if (axis.isChart && !axis.skeleton && axis.actualIntervalType === 'Months' && !labelFormat) {
            labelFormat = axis.valueType === 'DateTime' ? 'MMM yyyy' : 'yMMM';
        }
        return labelFormat;
    };
    return NiceInterval;
}(Double));

var __extends$10 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * `DateTime` module is used to render datetime axis.
 */
var DateTime = /** @__PURE__ @class */ (function (_super) {
    __extends$10(DateTime, _super);
    /**
     * Constructor for the dateTime module.
     *
     * @private
     */
    function DateTime(chart) {
        return _super.call(this, chart) || this;
    }
    /**
     * The function to calculate the range and labels for the axis.
     *
     * @returns {void}
     */
    DateTime.prototype.calculateRangeAndInterval = function (size, axis) {
        this.calculateRange(axis);
        this.getActualRange(axis, size);
        this.applyRangePadding(axis, size);
        this.calculateVisibleLabels(axis, this.chart);
    };
    /**
     * Actual Range for the axis.
     *
     * @private
     */
    DateTime.prototype.getActualRange = function (axis, size) {
        var option = {
            skeleton: 'full',
            type: 'dateTime'
        };
        var dateParser = this.chart.intl.getDateParser(option);
        var dateFormatter = this.chart.intl.getDateFormat(option);
        // Axis min
        if ((axis.minimum) !== null) {
            this.min = this.chart.isBlazor ? Date.parse(axis.minimum.toString()) : Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({ val: axis.minimum }).val))));
        }
        else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {
            this.min = Date.parse(dateParser(dateFormatter(new Date(1970, 1, 1))));
        }
        // Axis Max
        if ((axis.maximum) !== null) {
            this.max = this.chart.isBlazor ? Date.parse(axis.maximum.toString()) : Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({ val: axis.maximum }).val))));
        }
        else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {
            this.max = Date.parse(dateParser(dateFormatter(new Date(1970, 5, 1))));
        }
        if (this.min === this.max) {
            this.max = this.max + 2592000000;
            this.min = this.min - 2592000000;
        }
        axis.actualRange = {};
        axis.doubleRange = new DoubleRange(this.min, this.max);
        var datetimeInterval = this.calculateDateTimeNiceInterval(axis, size, axis.doubleRange.start, axis.doubleRange.end);
        if (!axis.interval) {
            axis.actualRange.interval = datetimeInterval;
        }
        else {
            axis.actualRange.interval = axis.interval;
        }
        axis.actualRange.min = axis.doubleRange.start;
        axis.actualRange.max = axis.doubleRange.end;
    };
    /**
     * Apply padding for the range.
     *
     * @private
     */
    DateTime.prototype.applyRangePadding = function (axis, size) {
        this.min = (axis.actualRange.min);
        this.max = (axis.actualRange.max);
        var minimum;
        var maximum;
        var interval = axis.actualRange.interval;
        if (!setRange(axis)) {
            var rangePadding = axis.getRangePadding(this.chart);
            minimum = new Date(this.min);
            maximum = new Date(this.max);
            var intervalType = axis.actualIntervalType;
            if (rangePadding === 'None') {
                this.min = minimum.getTime();
                this.max = maximum.getTime();
            }
            else if (rangePadding === 'Additional' || rangePadding === 'Round') {
                switch (intervalType) {
                    case 'Years':
                        this.getYear(minimum, maximum, rangePadding, interval);
                        break;
                    case 'Months':
                        this.getMonth(minimum, maximum, rangePadding, interval);
                        break;
                    case 'Days':
                        this.getDay(minimum, maximum, rangePadding, interval);
                        break;
                    case 'Hours':
                        this.getHour(minimum, maximum, rangePadding, interval);
                        break;
                    case 'Minutes':
                        var minute = (minimum.getMinutes() / interval) * interval;
                        var endMinute = maximum.getMinutes() + (minimum.getMinutes() - minute);
                        if (rangePadding === 'Round') {
                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minute, 0)).getTime();
                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), endMinute, 59)).getTime();
                        }
                        else {
                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minute + (-interval), 0)).getTime();
                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), endMinute + (interval), 0)).getTime();
                        }
                        break;
                    case 'Seconds':
                        var second = (minimum.getSeconds() / interval) * interval;
                        var endSecond = maximum.getSeconds() + (minimum.getSeconds() - second);
                        if (rangePadding === 'Round') {
                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minimum.getMinutes(), second, 0)).getTime();
                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), maximum.getMinutes(), endSecond, 0)).getTime();
                        }
                        else {
                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minimum.getMinutes(), second + (-interval), 0)).getTime();
                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), maximum.getMinutes(), endSecond + (interval), 0)).getTime();
                        }
                        break;
                }
            }
        }
        axis.actualRange.min = (axis.minimum != null) ? this.min : this.min;
        axis.actualRange.max = (axis.maximum != null) ? this.max : this.max;
        axis.actualRange.delta = (axis.actualRange.max - axis.actualRange.min);
        axis.doubleRange = new DoubleRange(axis.actualRange.min, axis.actualRange.max);
        this.calculateVisibleRange(size, axis);
    };
    DateTime.prototype.getYear = function (minimum, maximum, rangePadding, interval) {
        var startYear = minimum.getFullYear();
        var endYear = maximum.getFullYear();
        if (rangePadding === 'Additional') {
            this.min = (new Date(startYear - interval, 1, 1, 0, 0, 0)).getTime();
            this.max = (new Date(endYear + interval, 1, 1, 0, 0, 0)).getTime();
        }
        else {
            this.min = new Date(startYear, 0, 0, 0, 0, 0).getTime();
            this.max = new Date(endYear, 11, 30, 23, 59, 59).getTime();
        }
    };
    DateTime.prototype.getMonth = function (minimum, maximum, rangePadding, interval) {
        var month = minimum.getMonth();
        var endMonth = maximum.getMonth();
        if (rangePadding === 'Round') {
            this.min = (new Date(minimum.getFullYear(), month, 0, 0, 0, 0)).getTime();
            this.max = (new Date(maximum.getFullYear(), endMonth, new Date(maximum.getFullYear(), maximum.getMonth(), 0).getDate(), 23, 59, 59)).getTime();
        }
        else {
            this.min = (new Date(minimum.getFullYear(), month + (-interval), 1, 0, 0, 0)).getTime();
            this.max = (new Date(maximum.getFullYear(), endMonth + (interval), endMonth === 2 ? 28 : 30, 0, 0, 0)).getTime();
        }
    };
    DateTime.prototype.getDay = function (minimum, maximum, rangePadding, interval) {
        var day = minimum.getDate();
        var endDay = maximum.getDate();
        if (rangePadding === 'Round') {
            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), day, 0, 0, 0)).getTime();
            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), endDay, 23, 59, 59)).getTime();
        }
        else {
            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), day + (-interval), 0, 0, 0)).getTime();
            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), endDay + (interval), 0, 0, 0)).getTime();
        }
    };
    DateTime.prototype.getHour = function (minimum, maximum, rangePadding, interval) {
        var hour = (minimum.getHours() / interval) * interval;
        var endHour = maximum.getHours() + (minimum.getHours() - hour);
        if (rangePadding === 'Round') {
            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), hour, 0, 0)).getTime();
            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), endHour, 59, 59)).getTime();
        }
        else {
            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), hour + (-interval), 0, 0)).getTime();
            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), endHour + (interval), 0, 0)).getTime();
        }
    };
    /**
     * Calculate visible range for axis.
     *
     * @private
     */
    DateTime.prototype.calculateVisibleRange = function (size, axis) {
        axis.visibleRange = {
            min: axis.actualRange.min,
            max: axis.actualRange.max,
            interval: axis.actualRange.interval,
            delta: axis.actualRange.delta
        };
        var isLazyLoad = isNullOrUndefined(axis.zoomingScrollBar) ? false : axis.zoomingScrollBar.isLazyLoad;
        if ((isZoomSet(axis)) && !isLazyLoad) {
            axis.calculateVisibleRangeOnZooming(size);
            axis.visibleRange.interval = (axis.enableAutoIntervalOnZooming) ?
                this.calculateDateTimeNiceInterval(axis, size, axis.visibleRange.min, axis.visibleRange.max)
                : axis.visibleRange.interval;
        }
        axis.dateTimeInterval = this.increaseDateTimeInterval(axis, axis.visibleRange.min, axis.visibleRange.interval).getTime()
            - axis.visibleRange.min;
        axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);
    };
    /**
     * Calculate visible labels for the axis.
     *
     * @param {Axis} axis axis
     * @param {Chart | RangeNavigator} chart chart
     * @returns {void}
     * @private
     */
    DateTime.prototype.calculateVisibleLabels = function (axis, chart) {
        axis.visibleLabels = [];
        var tempInterval = axis.visibleRange.min;
        var labelStyle;
        var previousValue;
        var isBlazor = chart.getModuleName() === 'chart' ? chart.isBlazor : false;
        var axisLabels = axis.visibleLabels;
        if (!setRange(axis)) {
            tempInterval = this.alignRangeStart(axis, tempInterval, axis.visibleRange.interval).getTime();
        }
        while (tempInterval <= axis.visibleRange.max) {
            labelStyle = (extend({}, getValue('properties', axis.labelStyle), null, true));
            previousValue = axisLabels.length ? axis.visibleLabels[axisLabels.length - 1].value : tempInterval;
            axis.format = chart.intl.getDateFormat({
                format: this.findCustomFormats(axis, tempInterval, previousValue) || this.blazorCustomFormat(axis),
                type: firstToLowerCase(axis.skeletonType),
                skeleton: this.getSkeleton(axis, tempInterval, previousValue, isBlazor)
            });
            axis.startLabel = axis.format(new Date(axis.visibleRange.min));
            axis.endLabel = axis.format(new Date(axis.visibleRange.max));
            if (withIn(tempInterval, axis.visibleRange)) {
                var interval = this.increaseDateTimeInterval(axis, tempInterval, axis.visibleRange.interval).getTime();
                if (interval > axis.visibleRange.max) {
                    axis.endLabel = axis.format(new Date(tempInterval));
                }
                triggerLabelRender(chart, tempInterval, axis.format(new Date(tempInterval)), labelStyle, axis);
            }
            var actualInterval = tempInterval;
            tempInterval = this.increaseDateTimeInterval(axis, tempInterval, axis.visibleRange.interval).getTime();
            if (actualInterval === tempInterval) {
                break;
            }
        }
        //tooltip and crosshair formats for 'Months' and 'Days' interval types
        if ((axis.actualIntervalType === 'Months' || axis.actualIntervalType === 'Days') && axis.isChart) {
            axis.format = chart.intl.getDateFormat({
                format: axis.labelFormat || (axis.actualIntervalType === 'Months' && !axis.skeleton ? 'y MMM' : ''),
                type: firstToLowerCase(axis.skeletonType), skeleton: axis.skeleton || (axis.actualIntervalType === 'Days' ? 'MMMd' : '')
            });
        }
        if (axis.getMaxLabelWidth) {
            axis.getMaxLabelWidth(this.chart);
        }
    };
    /** @private */
    DateTime.prototype.blazorCustomFormat = function (axis) {
        if (this.chart.isBlazor) {
            return axis.actualIntervalType === 'Years' ? (axis.isIntervalInDecimal ? 'yyyy' : 'MMM y') :
                (axis.actualIntervalType === 'Days' && !axis.isIntervalInDecimal) ? 'ddd HH tt' : '';
        }
        else {
            return '';
        }
    };
    /** @private */
    DateTime.prototype.increaseDateTimeInterval = function (axis, value, interval) {
        var result = new Date(value);
        if (axis.interval) {
            axis.isIntervalInDecimal = (interval % 1) === 0;
            axis.visibleRange.interval = interval;
        }
        else {
            interval = Math.ceil(interval);
            axis.visibleRange.interval = interval;
        }
        var intervalType = axis.actualIntervalType;
        if (axis.isIntervalInDecimal) {
            switch (intervalType) {
                case 'Years':
                    result.setFullYear(result.getFullYear() + interval);
                    return result;
                case 'Quarter':
                    result.setMonth(result.getMonth() + (3 * interval));
                    return result;
                case 'Months':
                    result.setMonth(result.getMonth() + interval);
                    return result;
                case 'Weeks':
                    result.setDate(result.getDate() + (interval * 7));
                    return result;
                case 'Days':
                    result.setDate(result.getDate() + interval);
                    return result;
                case 'Hours':
                    result.setHours(result.getHours() + interval);
                    return result;
                case 'Minutes':
                    result.setMinutes(result.getMinutes() + interval);
                    return result;
                case 'Seconds':
                    result.setSeconds(result.getSeconds() + interval);
                    return result;
            }
        }
        else {
            result = this.getDecimalInterval(result, interval, intervalType);
        }
        return result;
    };
    DateTime.prototype.alignRangeStart = function (axis, sDate, intervalSize) {
        var sResult = new Date(sDate);
        switch (axis.actualIntervalType) {
            case 'Years':
                var year = Math.floor(Math.floor(sResult.getFullYear() / intervalSize) * intervalSize);
                sResult = new Date(year, sResult.getMonth(), sResult.getDate(), 0, 0, 0);
                return sResult;
            case 'Months':
                var month = Math.floor(Math.floor((sResult.getMonth()) / intervalSize) * intervalSize);
                sResult = new Date(sResult.getFullYear(), month, sResult.getDate(), 0, 0, 0);
                return sResult;
            case 'Days':
                var day = Math.floor(Math.floor((sResult.getDate()) / intervalSize) * intervalSize);
                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), day, 0, 0, 0);
                return sResult;
            case 'Hours':
                var hour = Math.floor(Math.floor((sResult.getHours()) / intervalSize) * intervalSize);
                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), hour, 0, 0);
                return sResult;
            case 'Minutes':
                var minutes = Math.floor(Math.floor((sResult.getMinutes()) / intervalSize) * intervalSize);
                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), sResult.getHours(), minutes, 0, 0);
                return sResult;
            case 'Seconds':
                var seconds = Math.floor(Math.floor((sResult.getSeconds()) / intervalSize) * intervalSize);
                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), sResult.getHours(), sResult.getMinutes(), seconds, 0);
                return sResult;
        }
        return sResult;
    };
    DateTime.prototype.getDecimalInterval = function (result, interval, intervalType) {
        var roundValue = Math.floor(interval);
        var decimalValue = interval - roundValue;
        switch (intervalType) {
            case 'Years':
                var month = Math.round(12 * decimalValue);
                result.setFullYear(result.getFullYear() + roundValue);
                result.setMonth(result.getMonth() + month);
                return result;
            case 'Quarter':
                result.setMonth(result.getMonth() + (3 * interval));
                return result;
            case 'Months':
                var days = Math.round(30 * decimalValue);
                result.setMonth(result.getMonth() + roundValue);
                result.setDate(result.getDate() + days);
                return result;
            case 'Weeks':
                result.setDate(result.getDate() + (interval * 7));
                return result;
            case 'Days':
                var hour = Math.round(24 * decimalValue);
                result.setDate(result.getDate() + roundValue);
                result.setHours(result.getHours() + hour);
                return result;
            case 'Hours':
                var min = Math.round(60 * decimalValue);
                result.setHours(result.getHours() + roundValue);
                result.setMinutes(result.getMinutes() + min);
                return result;
            case 'Minutes':
                var sec = Math.round(60 * decimalValue);
                result.setMinutes(result.getMinutes() + roundValue);
                result.setSeconds(result.getSeconds() + sec);
                return result;
            case 'Seconds':
                var milliSec = Math.round(1000 * decimalValue);
                result.setSeconds(result.getSeconds() + roundValue);
                result.setMilliseconds(result.getMilliseconds() + milliSec);
                return result;
        }
        return result;
    };
    /**
     * Get module name
     */
    DateTime.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'DateTime';
    };
    /**
     * To destroy the category axis.
     *
     * @returns {void}
     * @private
     */
    DateTime.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return DateTime;
}(NiceInterval));

var __extends$12 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * `Category` module is used to render category axis.
 */
var Category = /** @__PURE__ @class */ (function (_super) {
    __extends$12(Category, _super);
    /**
     * Constructor for the category module.
     *
     * @private
     */
    function Category(chart) {
        return _super.call(this, chart) || this;
    }
    /**
     * The function to calculate the range and labels for the axis.
     *
     * @returns {void}
     */
    Category.prototype.calculateRangeAndInterval = function (size, axis) {
        this.calculateRange(axis);
        this.getActualRange(axis, size);
        this.applyRangePadding(axis, size);
        this.calculateVisibleLabels(axis);
    };
    /**
     * Actual Range for the axis.
     *
     * @private
     */
    Category.prototype.getActualRange = function (axis, size) {
        this.initializeDoubleRange(axis);
        // axis.doubleRange = new DoubleRange(<number>this.min, <number>this.max);
        axis.actualRange = {};
        if (!axis.interval) {
            axis.actualRange.interval = Math.max(1, Math.floor(axis.doubleRange.delta / getActualDesiredIntervalsCount(size, axis)));
        }
        else {
            axis.actualRange.interval = Math.ceil(axis.interval);
        }
        axis.actualRange.min = axis.doubleRange.start;
        axis.actualRange.max = axis.doubleRange.end;
        axis.actualRange.delta = axis.doubleRange.delta;
    };
    /**
     * Padding for the axis.
     *
     * @private
     */
    Category.prototype.applyRangePadding = function (axis, size) {
        var isColumn;
        axis.series.forEach(function (element) {
            if (!isColumn) {
                isColumn = element.type.indexOf('Column') > -1 && !(axis.zoomFactor < 1 || axis.zoomPosition > 0) && isNullOrUndefined(axis.minimum) && isNullOrUndefined(axis.maximum);
            }
        });
        var ticks = ((axis.labelPlacement === 'BetweenTicks' || isColumn) && !this.chart.stockChart && this.chart.chartAreaType !== 'PolarRadar') ? 0.5 : 0;
        if (ticks > 0) {
            axis.actualRange.min -= ticks;
            axis.actualRange.max += ticks;
        }
        else {
            axis.actualRange.max += axis.actualRange.max ? 0 : 0.5;
        }
        axis.doubleRange = new DoubleRange(axis.actualRange.min, axis.actualRange.max);
        axis.actualRange.delta = axis.doubleRange.delta;
        this.calculateVisibleRange(size, axis);
    };
    /**
     * Calculate label for the axis.
     *
     * @private
     */
    Category.prototype.calculateVisibleLabels = function (axis) {
        /*! Generate axis labels */
        axis.visibleLabels = [];
        axis.visibleRange.interval = axis.visibleRange.interval < 1 ? 1 : axis.visibleRange.interval;
        var tempInterval = Math.ceil(axis.visibleRange.min);
        var labelStyle;
        if (axis.zoomFactor < 1 || axis.zoomPosition > 0) {
            tempInterval = axis.visibleRange.min - (axis.visibleRange.min % axis.visibleRange.interval);
        }
        var position;
        axis.startLabel = axis.labels[Math.round(axis.visibleRange.min)];
        axis.endLabel = axis.labels[Math.floor(axis.visibleRange.max)];
        for (; tempInterval <= axis.visibleRange.max; tempInterval += axis.visibleRange.interval) {
            labelStyle = (extend({}, getValue('properties', axis.labelStyle), null, true));
            if (withIn(tempInterval, axis.visibleRange) && axis.labels.length > 0) {
                position = Math.round(tempInterval);
                triggerLabelRender(this.chart, position, axis.labels[position] ? axis.labels[position].toString() : '', labelStyle, axis);
            }
        }
        if (axis.getMaxLabelWidth) {
            axis.getMaxLabelWidth(this.chart);
        }
    };
    /**
     * Get module name
     */
    Category.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'Category';
    };
    /**
     * To destroy the category axis.
     *
     * @returns {void}
     * @private
     */
    Category.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return Category;
}(NiceInterval));

var __extends$13 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * `Logarithmic` module is used to render log axis.
 */
var Logarithmic = /** @__PURE__ @class */ (function (_super) {
    __extends$13(Logarithmic, _super);
    /**
     * Constructor for the logerithmic module.
     *
     * @private
     */
    function Logarithmic(chart) {
        return _super.call(this, chart) || this;
    }
    /**
     * The method to calculate the range and labels for the axis.
     *
     * @returns {void}
     */
    Logarithmic.prototype.calculateRangeAndInterval = function (size, axis) {
        this.calculateRange(axis);
        this.getActualRange(axis, size);
        this.calculateVisibleRange(size, axis);
        this.calculateVisibleLabels(axis, this.chart);
    };
    /**
     * Calculates actual range for the axis.
     *
     * @private
     */
    Logarithmic.prototype.getActualRange = function (axis, size) {
        this.initializeDoubleRange(axis);
        this.min = this.min < 0 ? 0 : this.min;
        var logStart = logBase(this.min, axis.logBase);
        logStart = isFinite(logStart) ? logStart : this.min;
        var logEnd = this.max === 1 ? 1 : logBase(this.max, axis.logBase);
        logEnd = isFinite(logStart) ? logEnd : this.max;
        this.min = Math.floor(logStart / 1);
        var isRectSeries = axis.series && axis.series.some(function (item) {
            return (item.type.indexOf('Column') !== -1 || item.type.indexOf('Bar') !== -1) && item.type.indexOf('Range') === -1;
        });
        if (isRectSeries) {
            this.min = (this.min <= 0) ? (+this.min - 1) : this.min;
        }
        this.max = Math.ceil(logEnd / 1);
        this.max = this.max === this.min ? this.max + 1 : this.max;
        axis.actualRange.interval = axis.interval || this.calculateLogNiceInterval(this.max - this.min, size, axis);
        axis.actualRange.min = this.min;
        axis.actualRange.max = this.max;
        axis.actualRange.delta = this.max - this.min;
    };
    /**
     * Calculates visible range for the axis.
     *
     * @private
     */
    Logarithmic.prototype.calculateVisibleRange = function (size, axis) {
        axis.visibleRange = {
            interval: axis.actualRange.interval, max: axis.actualRange.max,
            min: axis.actualRange.min, delta: axis.actualRange.delta
        };
        var isLazyLoad = isNullOrUndefined(axis.zoomingScrollBar) ? false : axis.zoomingScrollBar.isLazyLoad;
        if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && !isLazyLoad) {
            axis.calculateVisibleRangeOnZooming(size);
            axis.visibleRange.interval = (axis.enableAutoIntervalOnZooming) ?
                this.calculateLogNiceInterval(axis.doubleRange.delta, size, axis)
                : axis.visibleRange.interval;
            axis.visibleRange.interval = Math.floor(axis.visibleRange.interval) === 0 ? 1 : Math.floor(axis.visibleRange.interval);
            axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);
        }
    };
    /**
     * Calculates log iInteval for the axis.
     *
     * @private
     */
    Logarithmic.prototype.calculateLogNiceInterval = function (delta, size, axis) {
        var actualDesiredIntervalsCount = getActualDesiredIntervalsCount(size, axis);
        var niceInterval = delta;
        var minInterval = Math.pow(axis.logBase, Math.floor(logBase(niceInterval, 10)));
        for (var j = 0, len = axis.intervalDivs.length; j < len; j++) {
            var currentInterval = minInterval * axis.intervalDivs[j];
            if (actualDesiredIntervalsCount < (delta / currentInterval)) {
                break;
            }
            niceInterval = currentInterval;
        }
        return niceInterval;
    };
    /**
     * Calculates labels for the axis.
     *
     * @private
     */
    Logarithmic.prototype.calculateVisibleLabels = function (axis, chart) {
        /*! Generate axis labels */
        var tempInterval = axis.visibleRange.min;
        axis.visibleLabels = [];
        var labelStyle;
        var value;
        if (axis.zoomFactor < 1 || axis.zoomPosition > 0) {
            tempInterval = axis.visibleRange.min - (axis.visibleRange.min % axis.visibleRange.interval);
        }
        var axisFormat = this.getFormat(axis);
        var isCustomFormat = axisFormat.match('{value}') !== null;
        var startValue = Math.pow(axis.logBase, axis.visibleRange.min);
        axis.format = chart.intl.getNumberFormat({
            format: isCustomFormat ? '' : axisFormat,
            useGrouping: chart.useGroupingSeparator,
            maximumFractionDigits: startValue < 1 ? 20 : 3
        });
        axis.startLabel = axis.format(startValue < 1 ? +startValue.toPrecision(1) : startValue);
        axis.endLabel = axis.format(Math.pow(axis.logBase, axis.visibleRange.max));
        for (; tempInterval <= axis.visibleRange.max; tempInterval += axis.visibleRange.interval) {
            labelStyle = (extend({}, getValue('properties', axis.labelStyle), null, true));
            if (withIn(tempInterval, axis.visibleRange)) {
                value = Math.pow(axis.logBase, tempInterval);
                triggerLabelRender(this.chart, tempInterval, this.formatValue(axis, isCustomFormat, axisFormat, value < 1 ? +value.toPrecision(1) : value), labelStyle, axis);
            }
        }
        if (axis.getMaxLabelWidth) {
            axis.getMaxLabelWidth(this.chart);
        }
    };
    /**
     * Get module name
     */
    Logarithmic.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'Logarithmic';
    };
    /**
     * To destroy the category axis.
     *
     * @returns {void}
     * @private
     */
    Logarithmic.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return Logarithmic;
}(Double));

var __extends$14 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Category module is used to render category axis.
 */
var DateTimeCategory = /** @__PURE__ @class */ (function (_super) {
    __extends$14(DateTimeCategory, _super);
    /**
     * Constructor for the category module.
     *
     * @private
     */
    function DateTimeCategory(chart) {
        return _super.call(this, chart) || this;
    }
    /**
     * The function to calculate the range and labels for the axis.
     *
     * @returns {void}
     * @private
     */
    DateTimeCategory.prototype.calculateRangeAndInterval = function (size, axis) {
        this.axisSize = size;
        this.calculateRange(axis);
        this.getActualRange(axis, size);
        this.applyRangePadding(axis, size);
        this.calculateVisibleLabels(axis);
    };
    /**
     * Calculate label for the axis.
     *
     * @private
     */
    DateTimeCategory.prototype.calculateVisibleLabels = function (axis) {
        /*! Generate axis labels */
        axis.visibleLabels = [];
        var labelStyle;
        var padding = axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;
        var previousIndex = 0;
        var isRangeNavigator = this.chart.getModuleName() === 'rangeNavigator';
        this.axisSize = isRangeNavigator ? this.chart.availableSize : this.axisSize;
        if (isRangeNavigator || this.chart.stockChart) {
            axis.labels.sort(function (a, b) { return Number(a) - Number(b); });
        }
        if (axis.intervalType === 'Auto') {
            this.calculateDateTimeNiceInterval(axis, this.axisSize, parseInt(axis.labels[0], 10), parseInt(axis.labels[axis.labels.length - 1], 10));
        }
        else {
            axis.actualIntervalType = axis.intervalType;
        }
        axis.format = this.chart.intl.getDateFormat({
            format: axis.labelFormat || this.blazorCustomFormat(axis), type: firstToLowerCase(axis.skeletonType),
            skeleton: this.getSkeleton(axis, null, null, this.chart.isBlazor)
        });
        var i = (!isRangeNavigator && this.chart.stockChart) ? 1 : 0;
        var interval = axis.interval ? axis.interval : 1;
        for (; i < axis.labels.length; i += interval) {
            labelStyle = (extend({}, getValue('properties', axis.labelStyle), null, true));
            if (this.chart.stockChart || isRangeNavigator) {
                if (axis.intervalType === 'Auto') {
                    if ((((!isRangeNavigator && i === 1) || this.StartOfWeek(axis.labels.map(Number)[i], axis.labels.map(Number)[i - 1], axis, i, previousIndex))
                        || axis.isIndexed) && withIn(i, axis.visibleRange)) {
                        triggerLabelRender(this.chart, i, (axis.isIndexed ? this.getIndexedAxisLabel(axis.labels[i], axis.format) :
                            axis.format(new Date(axis.labels.map(Number)[i]))), labelStyle, axis);
                        previousIndex = i;
                    }
                }
                else if ((((!isRangeNavigator && i === 1) || !this.sameInterval(axis.labels.map(Number)[i], axis.labels.map(Number)[i - 1], axis.actualIntervalType, i))
                    || axis.isIndexed) && withIn(i, axis.visibleRange)) {
                    if ((!isRangeNavigator && i === 1) || this.isMaximum(i, previousIndex, axis)) {
                        triggerLabelRender(this.chart, i, (axis.isIndexed ? this.getIndexedAxisLabel(axis.labels[i], axis.format) :
                            axis.format(new Date(axis.labels.map(Number)[i]))), labelStyle, axis);
                        previousIndex = i;
                    }
                }
            }
            else {
                if (!this.sameInterval(axis.labels.map(Number)[i], axis.labels.map(Number)[i - 1], axis.actualIntervalType, i)
                    || axis.isIndexed) {
                    if (withIn(i - padding, axis.visibleRange)) {
                        triggerLabelRender(this.chart, i, (axis.isIndexed ? this.getIndexedAxisLabel(axis.labels[i], axis.format) :
                            axis.format(new Date(axis.labels.map(Number)[i]))), labelStyle, axis);
                    }
                }
            }
        }
        if (axis.getMaxLabelWidth) {
            axis.getMaxLabelWidth(this.chart);
        }
    };
    /** @private */
    DateTimeCategory.prototype.blazorCustomFormat = function (axis) {
        if (this.chart.isBlazor && axis.actualIntervalType === 'Years') {
            return 'yyyy';
        }
        else {
            return '';
        }
    };
    /**
     * To get the Indexed axis label text with axis format for DateTimeCategory axis.
     *
     * @param {string} value value
     * @param {Function} format format
     * @returns {string} Indexed axis label text
     */
    DateTimeCategory.prototype.getIndexedAxisLabel = function (value, format) {
        var texts = value.split(',');
        for (var i = 0; i < texts.length; i++) {
            texts[i] = format(new Date(parseInt(texts[i], 10)));
        }
        return texts.join(', ');
    };
    /**
     * get same interval
     */
    DateTimeCategory.prototype.sameInterval = function (currentDate, previousDate, type, index) {
        var sameValue;
        if (index === 0) {
            sameValue = false;
        }
        else {
            switch (type) {
                case 'Years':
                    sameValue = new Date(currentDate).getFullYear() === new Date(previousDate).getFullYear();
                    break;
                case 'Quarter':
                    sameValue = new Date(currentDate).getFullYear() === new Date(previousDate).getFullYear() &&
                        Math.floor(new Date(currentDate).getMonth() / 3) === Math.floor(new Date(previousDate).getMonth() / 3);
                    break;
                case 'Months':
                    sameValue = new Date(currentDate).getFullYear() === new Date(previousDate).getFullYear() &&
                        new Date(currentDate).getMonth() === new Date(previousDate).getMonth();
                    break;
                case 'Weeks':
                    sameValue = new Date(currentDate).getFullYear() === new Date(previousDate).getFullYear() &&
                        new Date(currentDate).getMonth() === new Date(previousDate).getMonth() &&
                        Math.floor((new Date(currentDate).getDate() - 1) / 7) ===
                            Math.floor((new Date(previousDate).getDate() - 1) / 7);
                    break;
                case 'Days':
                    sameValue = (Math.abs(currentDate - previousDate) < 24 * 60 * 60 * 1000 &&
                        new Date(currentDate).getDay() === new Date(previousDate).getDay());
                    break;
                case 'Hours':
                    sameValue = (Math.abs(currentDate - previousDate) < 60 * 60 * 1000 &&
                        new Date(currentDate).getDay() === new Date(previousDate).getDay());
                    break;
                case 'Minutes':
                    sameValue = (Math.abs(currentDate - previousDate) < 60 * 1000 &&
                        new Date(currentDate).getMinutes() === new Date(previousDate).getMinutes());
                    break;
                case 'Seconds':
                    sameValue = (Math.abs(currentDate - previousDate) < 1000 &&
                        new Date(currentDate).getDay() === new Date(previousDate).getDay());
                    break;
            }
        }
        return sameValue;
    };
    /**
     * To check whether the current label comes in the same week as the previous label week.
     */
    DateTimeCategory.prototype.StartOfWeek = function (currentDate, previousDate, axis, index, previousIndex) {
        if (index === 0) {
            return true;
        }
        var isMonday = false;
        var labelsCount = 30;
        if (axis.labels.length >= labelsCount) {
            var previousDay = new Date(previousDate);
            var currentday = new Date(currentDate);
            previousDay.setDate(previousDay.getDate() - previousDay.getDay());
            currentday.setDate(currentday.getDate() - currentday.getDay());
            isMonday = !(previousDay.getTime() === currentday.getTime()) && this.isMaximum(index, previousIndex, axis);
        }
        else {
            isMonday = this.isMaximum(index, previousIndex, axis);
        }
        return isMonday;
    };
    /**
     * To check whether the distance between labels is above the axisLabel maximum length.
     */
    DateTimeCategory.prototype.isMaximum = function (index, previousIndex, axis) {
        if (index === 0) {
            return true;
        }
        var axisLabelMaximumLength = 100;
        var pointX = valueToCoefficient(index, axis) * axis.rect.width;
        var previousPointX = valueToCoefficient(previousIndex, axis) * axis.rect.width;
        return (pointX - previousPointX >= (axis.labels.length >= 15 ? axisLabelMaximumLength : axisLabelMaximumLength / 2));
    };
    /**
     * Get module name
     */
    DateTimeCategory.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'DateTimeCategory';
    };
    /**
     * To destroy the category axis.
     *
     * @returns {void}
     * @private
     */
    DateTimeCategory.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return DateTimeCategory;
}(Category));

/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable max-len */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/**
 * StripLine src
 */
/**
 * `StripLine` module is used to render the stripLine in chart.
 */
var StripLine = /** @__PURE__ @class */ (function () {
    function StripLine() {
    }
    /**
     * Finding x, y, width and height of the strip line
     *
     * @param {Axis} axis axis
     * @param {StripLineSettingsModel} stripline stripline
     * @param {Rect} seriesClipRect seriesClipRect
     * @param {number} startValue startValue
     * @param {Axis} segmentAxis segmentAxis
     * @param {Chart} chart chart instance
     */
    StripLine.prototype.measureStripLine = function (axis, stripline, seriesClipRect, startValue, segmentAxis, chart) {
        var actualStart;
        var actualEnd;
        var orientation = axis.orientation;
        var isDateTimeAxis = axis.valueType === 'DateTime';
        if (stripline.isRepeat && stripline.size !== null) {
            actualStart = startValue;
            actualEnd = null;
        }
        else {
            if (axis.valueType === 'DateTimeCategory') {
                var start = stripline.start;
                var end = stripline.end;
                actualStart = (start != null && typeof start !== 'number') ?
                    axis.labels.indexOf(this.dateToMilliSeconds(start, chart).toString()) : start;
                actualEnd = (end != null && typeof end !== 'number') ?
                    axis.labels.indexOf(this.dateToMilliSeconds(end, chart).toString()) : end;
            }
            else {
                actualStart = stripline.start === null ? null : isDateTimeAxis && this.isCoreDate(stripline.start) ?
                    this.dateToMilliSeconds(stripline.start, chart) : +stripline.start;
                actualEnd = stripline.end === null ? null : isDateTimeAxis && this.isCoreDate(stripline.start) ?
                    this.dateToMilliSeconds(stripline.end, chart) : +stripline.end;
            }
        }
        var rect = this.getFromTovalue(actualStart, actualEnd, stripline.size, stripline.startFromAxis, axis, stripline);
        var height = (orientation === 'Vertical') ? (rect.to - rect.from) * axis.rect.height : seriesClipRect.height;
        var width = (orientation === 'Horizontal') ? (rect.to - rect.from) * axis.rect.width : seriesClipRect.width;
        var x = (orientation === 'Vertical') ? seriesClipRect.x : ((rect.from * axis.rect.width) + axis.rect.x);
        var y = (orientation === 'Horizontal') ? seriesClipRect.y : (axis.rect.y + axis.rect.height -
            ((stripline.sizeType === 'Pixel' ? rect.from : rect.to) * axis.rect.height));
        if (stripline.isSegmented && stripline.segmentStart != null && stripline.segmentEnd != null && stripline.sizeType !== 'Pixel') {
            var start = isDateTimeAxis && this.isCoreDate(stripline.segmentStart) ?
                this.dateToMilliSeconds(stripline.segmentStart, chart) : +stripline.segmentStart;
            var end = isDateTimeAxis && this.isCoreDate(stripline.segmentEnd) ?
                this.dateToMilliSeconds(stripline.segmentEnd, chart) : +stripline.segmentEnd;
            var segRect = this.getFromTovalue(start, end, null, null, segmentAxis, stripline);
            if (segmentAxis.orientation === 'Vertical') {
                y = (segmentAxis.rect.y + segmentAxis.rect.height -
                    (segRect.to * segmentAxis.rect.height));
                height = (segRect.to - segRect.from) * segmentAxis.rect.height;
            }
            else {
                x = ((segRect.from * segmentAxis.rect.width) + segmentAxis.rect.x);
                width = (segRect.to - segRect.from) * segmentAxis.rect.width;
            }
        }
        if ((height !== 0 && width !== 0) || (stripline.sizeType === 'Pixel' && (stripline.start !== null || stripline.startFromAxis))) {
            return new Rect(x, y, width, height);
        }
        return new Rect(0, 0, 0, 0);
    };
    /**
     * To get from to value from start, end, size, start from axis
     *
     * @param {number} start start
     * @param {number} end end
     * @param {number} size size
     * @param {boolean} startFromAxis startFromAxis
     * @param {Axis} axis axis
     * @param {StripLineSettingsModel} stripline stripline
     */
    StripLine.prototype.getFromTovalue = function (start, end, size, startFromAxis, axis, stripline) {
        var from = (!stripline.isRepeat && startFromAxis) ? axis.visibleRange.min : start;
        if (axis.valueType === 'Double' && size !== null && !startFromAxis && stripline.start == null) {
            from += size;
        }
        var to = this.getToValue(Math.max(start, isNullOrUndefined(end) ? start : end), from, size, axis, end, stripline);
        from = this.findValue(from, axis);
        to = this.findValue(to, axis);
        return { from: valueToCoefficient(axis.isAxisInverse ? to : from, axis), to: valueToCoefficient(axis.isAxisInverse ? from : to, axis) };
    };
    /**
     * Finding end value of the strip line
     *
     * @param {number} to to
     * @param {number} from from
     * @param {number} size size
     * @param {Axis} axis axis
     * @param {number} end end
     * @param {StripLineSettingsModel} stripline stripline
     */
    StripLine.prototype.getToValue = function (to, from, size, axis, end, stripline) {
        var sizeType = stripline.sizeType;
        var isEnd = (end === null);
        if (axis.valueType === 'DateTime') {
            var fromValue = new Date(from);
            if (sizeType === 'Auto') {
                sizeType = axis.actualIntervalType;
                size *= axis.visibleRange.interval;
            }
            switch (sizeType) {
                case 'Years':
                    return (isEnd ? new Date(fromValue.setFullYear(fromValue.getFullYear() + size)) : to);
                case 'Months':
                    return (isEnd ? new Date(fromValue.setMonth(fromValue.getMonth() + size)) : to);
                case 'Days':
                    return (isEnd ? new Date(fromValue.setDate(fromValue.getDate() + size)) : to);
                case 'Hours':
                    return (isEnd ? new Date(fromValue.setHours(fromValue.getHours() + size)) : to);
                case 'Minutes':
                    return (isEnd ? new Date(fromValue.setMinutes(fromValue.getMinutes() + size)) : to);
                case 'Seconds':
                    return (isEnd ? new Date(fromValue.setSeconds(fromValue.getSeconds() + size)) : to);
                default:
                    return from;
            }
        }
        else {
            return stripline.sizeType === 'Pixel' ? from : (isEnd ? (from + size) : to);
        }
    };
    /**
     * To check the strip line values within range
     *
     * @param {number} value value
     * @param {Axis} axis axis
     */
    StripLine.prototype.findValue = function (value, axis) {
        if (value < axis.visibleRange.min) {
            value = axis.visibleRange.min;
        }
        else if (value > axis.visibleRange.max) {
            value = axis.visibleRange.max;
        }
        return value;
    };
    /**
     * Date parse
     *
     * @param {Date} value date
     * @param {Chart} chart chart instance
     * @returns {Date} parsed date
     */
    StripLine.prototype.dateParse = function (value, chart) {
        var dateParser = chart.intl.getDateParser({ skeleton: 'full', type: 'dateTime' });
        var dateFormatter = chart.intl.getDateFormat({ skeleton: 'full', type: 'dateTime' });
        return new Date((Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({ val: value }).val))))));
    };
    /**
     * To render strip lines based start and end.
     *
     * @param {Chart} chart chart
     * @param {ZIndex} position position
     * @param {Axis[]} axes axes
     * @private
     */
    StripLine.prototype.renderStripLine = function (chart, position, axes) {
        var id = chart.element.id + '_stripline_' + position + '_';
        var seriesClipRect = chart.chartAxisLayoutPanel.seriesClipRect;
        var end = 0;
        var limit = 0;
        var startValue = 0;
        var segmentAxis = null;
        var range;
        var options = new RectOption(id + 'ClipRect', 'transparent', { width: 1, color: 'Gray' }, 1, {
            x: seriesClipRect.x, y: seriesClipRect.y,
            width: seriesClipRect.width,
            height: seriesClipRect.height
        });
        var striplineGroup = chart.renderer.createGroup({
            id: id + 'collections',
            'clip-path': 'url(#' + id + 'ClipRect' + ')'
        });
        if (!chart.enableCanvas) {
            striplineGroup.appendChild(appendClipElement(chart.redraw, options, chart.renderer));
        }
        for (var _i = 0, axes_1 = axes; _i < axes_1.length; _i++) {
            var axis = axes_1[_i];
            var count = 0;
            for (var _a = 0, _b = axis.stripLines; _a < _b.length; _a++) {
                var stripline = _b[_a];
                if (stripline.visible && stripline.zIndex === position) {
                    if (stripline.isSegmented && stripline.segmentStart != null && stripline.segmentEnd != null &&
                        stripline.sizeType !== 'Pixel') {
                        segmentAxis = this.getSegmentAxis(axes, axis, stripline);
                    }
                    if (stripline.isRepeat && stripline.repeatEvery != null && stripline.size !== null && stripline.sizeType !== 'Pixel') {
                        limit = (stripline.repeatUntil != null) ? ((axis.valueType === 'DateTime') ?
                            this.dateToMilliSeconds(stripline.repeatUntil, chart) : +stripline.repeatUntil) : axis.actualRange.max;
                        startValue = axis.valueType === 'DateTime' && this.isCoreDate(stripline.start) ?
                            this.dateToMilliSeconds(stripline.start, chart) : stripline.start;
                        if ((stripline.startFromAxis && axis.valueType === 'DateTime' && stripline.sizeType === 'Auto') ||
                            (stripline.start < axis.visibleRange.min)) {
                            startValue = axis.visibleLabels[0].value === axis.visibleRange.min ? axis.visibleRange.min :
                                axis.visibleLabels[0].value - (axis.valueType === 'DateTime' ? axis.dateTimeInterval :
                                    axis.visibleRange.interval);
                        }
                        startValue = stripline.startFromAxis && axis.valueType !== 'DateTime' ? axis.visibleRange.min : startValue;
                        while (startValue < limit) {
                            end = (startValue + (axis.valueType === 'DateTime' ? axis.dateTimeInterval * +stripline.size : stripline.size));
                            range = withIn(end, axis.visibleRange);
                            if ((startValue >= axis.visibleRange.min && startValue < axis.visibleRange.max) || range) {
                                this.renderStripLineElement(axis, stripline, seriesClipRect, id, striplineGroup, chart, startValue, segmentAxis, count);
                            }
                            count++;
                            startValue = this.getStartValue(axis, stripline, startValue, chart);
                        }
                    }
                    else {
                        this.renderStripLineElement(axis, stripline, seriesClipRect, id, striplineGroup, chart, null, segmentAxis, count);
                        count++;
                    }
                }
            }
        }
        appendChildElement(chart.enableCanvas, chart.svgObject, striplineGroup, chart.redraw);
    };
    /**
     * To convert the C# date to js date
     *
     * @param {string | number | Object} value date value
     * @returns {boolean} returns true if datetime value type is string(for asp platform)
     */
    StripLine.prototype.isCoreDate = function (value) {
        return typeof value === 'string' ? true : false;
    };
    /**
     * To get the total milli seconds
     *
     * @param {Date | number | Object} value date value
     * @param {Chart} chart chart instance
     * @returns {number} returns milliseconds
     */
    StripLine.prototype.dateToMilliSeconds = function (value, chart) {
        return this.dateParse(value, chart).getTime();
    };
    /**
     * To draw the single line strip line
     *
     * @param {StripLineSettingsModel} stripline stripline
     * @param {Rect} rect rect
     * @param {string} id id
     * @param {Element} parent parent
     * @param {Chart} chart chart
     * @param {Axis} axis axis
     */
    StripLine.prototype.renderPath = function (stripline, rect, id, parent, chart, axis) {
        var element = getElement$1(id);
        var direction = element ? element.getAttribute('d') : '';
        var strokeWidth = stripline.size;
        var d = (axis.orientation === 'Vertical') ? ('M ' + rect.x + ' ' + rect.y + ' ' + 'L ' + (rect.x + rect.width)
            + ' ' + rect.y) :
            ('M ' + rect.x + ' ' + rect.y + ' ' + 'L ' + rect.x + ' ' + (rect.y + rect.height));
        if (stripline.sizeType !== 'Pixel') {
            d = (axis.orientation === 'Vertical') ? ('M ' + rect.x + ' ' + (rect.y + (rect.height / 2)) + ' ' + 'L ' + (rect.x + rect.width)
                + ' ' + (rect.y + (rect.height / 2))) :
                ('M ' + (rect.x + (rect.width / 2)) + ' ' + rect.y + ' ' + 'L ' + (rect.x + (rect.width / 2)) + ' ' + (rect.y + rect.height));
            strokeWidth = axis.orientation === 'Vertical' ? rect.height : rect.width;
        }
        appendChildElement(chart.enableCanvas, parent, chart.renderer.drawPath(new PathOption(id, 'none', strokeWidth, stripline.color, stripline.opacity, stripline.dashArray, d)), chart.redraw, true, 'x', 'y', null, direction, true);
    };
    /**
     * To draw the rectangle
     *
     * @param {StripLineSettingsModel} stripline stripline
     * @param {Rect} rect rect
     * @param {string} id id
     * @param {Element} parent parent
     * @param {Chart} chart chart
     */
    StripLine.prototype.renderRectangle = function (stripline, rect, id, parent, chart) {
        var element = getElement$1(id);
        var previousRect = element ? new Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')) : null;
        appendChildElement(chart.enableCanvas, parent, chart.renderer.drawRectangle(new RectOption(id, 'none', stripline.border, stripline.opacity, rect, 0, 0, '', null)), chart.redraw, true, 'x', 'y', null, null, true, true, previousRect);
    };
    /**
     * To draw the Image
     *
     * @param {StripLineSettingsModel} stripline stripline
     * @param {Rect} rect rect
     * @param {string} id id
     * @param {Element} parent parent
     * @param {Chart} chart chart
     */
    StripLine.prototype.drawImage = function (stripline, rect, id, parent, chart) {
        if (stripline.sizeType === 'Pixel') {
            rect.width = rect.width ? rect.width : stripline.size;
            rect.height = rect.height ? rect.height : stripline.size;
        }
        var image = new ImageOption(rect.height, rect.width, stripline.imageUrl, rect.x, rect.y, id, 'visible', 'none');
        var htmlObject = chart.renderer.drawImage(image);
        appendChildElement(chart.enableCanvas, parent, htmlObject, chart.redraw, true, 'x', 'y', null, null, true, true);
    };
    /**
     * To create the text on strip line
     *
     * @param {StripLineSettingsModel} stripline stripline
     * @param {Rect} rect rect
     * @param {string} id id
     * @param {Element} parent parent
     * @param {Chart} chart chart
     * @param {Axis} axis axis
     */
    StripLine.prototype.renderText = function (stripline, rect, id, parent, chart, axis) {
        var textSize = measureText(stripline.text, stripline.textStyle, chart.themeStyle.stripLineLabelFont);
        var isRotationNull = (stripline.rotation === null);
        var textMid = isRotationNull ? 3 * (textSize.height / 8) : 0;
        var ty = rect.y + (rect.height / 2) + textMid;
        var rotation = isRotationNull ? ((axis.orientation === 'Vertical') ? 0 : -90) : stripline.rotation;
        var tx = rect.x + (rect.width / 2);
        var anchor;
        var padding = 5;
        if (axis.orientation === 'Horizontal') {
            tx = this.getTextStart(tx + (textMid * this.factor(stripline.horizontalAlignment)), rect.width, stripline.horizontalAlignment);
            ty = this.getTextStart(ty - textMid, rect.height, stripline.verticalAlignment) +
                (stripline.verticalAlignment === 'Start' && !isRotationNull ? (textSize.height / 4) : 0);
            anchor = isRotationNull ? this.invertAlignment(stripline.verticalAlignment) : stripline.horizontalAlignment;
            anchor = tx - textSize.width / 2 < axis.rect.x ? 'Start' : tx + textSize.width / 2 > axis.rect.width ? 'End' : anchor;
        }
        else {
            tx = this.getTextStart(tx, rect.width, stripline.horizontalAlignment);
            ty = this.getTextStart(ty + (textMid * this.factor(stripline.verticalAlignment)) - padding, rect.height, stripline.verticalAlignment);
            anchor = stripline.horizontalAlignment;
            anchor = chart.enableRtl ? (anchor === 'End' ? 'Start' : anchor === 'Start' ? 'End' : anchor) : anchor;
        }
        textElement$1(chart.renderer, new TextOption(id, tx, ty, anchor, stripline.text, 'rotate(' + rotation + ' ' + tx + ',' + ty + ')', 'middle'), stripline.textStyle, stripline.textStyle.color || chart.themeStyle.stripLineLabelFont.color, parent, null, null, null, null, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.stripLineLabelFont);
    };
    StripLine.prototype.invertAlignment = function (anchor) {
        switch (anchor) {
            case 'Start':
                anchor = 'End';
                break;
            case 'End':
                anchor = 'Start';
                break;
        }
        return anchor;
    };
    /**
     * To find the next value of the recurrence strip line
     *
     * @param {Axis} axis axis
     * @param {StripLineSettingsModel} stripline stripline
     * @param {number} startValue startValue
     * @param {Chart} chart chart instance
     * @returns {number} next start value of the recurrence strip line
     */
    StripLine.prototype.getStartValue = function (axis, stripline, startValue, chart) {
        if (axis.valueType === 'DateTime') {
            return (this.getToValue(null, startValue, +stripline.repeatEvery, axis, null, stripline));
        }
        else {
            return startValue + (+stripline.repeatEvery);
        }
    };
    /**
     * Finding segment axis for segmented strip line
     *
     * @param {Axis[]} axes axes collection
     * @param {Axis} axis axis
     * @param {StripLineSettingsModel} stripline stripline
     */
    StripLine.prototype.getSegmentAxis = function (axes, axis, stripline) {
        var segment;
        if (stripline.segmentAxisName == null) {
            return (axis.orientation === 'Horizontal') ? axes[1] : axes[0];
        }
        else {
            for (var i = 0; i < axes.length; i++) {
                if (stripline.segmentAxisName === axes[i].name) {
                    segment = axes[i];
                }
            }
            return segment;
        }
    };
    /**
     * To render strip line on chart
     *
     * @param {Axis} axis axis
     * @param {StripLineSettingsModel} stripline stripline
     * @param {Rect} seriesClipRect seriesClipRect
     * @param {string} id id
     * @param {Element} striplineGroup striplineGroup
     * @param {Chart} chart chart
     * @param {number} startValue startValue
     * @param {Axis} segmentAxis segmentAxis
     * @param {number} count count
     */
    StripLine.prototype.renderStripLineElement = function (axis, stripline, seriesClipRect, id, striplineGroup, chart, startValue, segmentAxis, count) {
        var rect = this.measureStripLine(axis, stripline, seriesClipRect, startValue, segmentAxis, chart);
        if (stripline.imageUrl) {
            this.drawImage(stripline, rect, id + 'rect_' + axis.name + '_' + count, striplineGroup, chart);
        }
        else {
            this.renderPath(stripline, rect, id + (stripline.sizeType === 'Pixel' ? 'path_' : 'rect_') + axis.name + '_' + count, striplineGroup, chart, axis);
            var pixelRect = new Rect(axis.orientation === 'Horizontal' ? (rect.x - stripline.size / 2) : rect.x, axis.orientation === 'Vertical' ? (rect.y - stripline.size / 2) : rect.y, rect.width ? rect.width : stripline.size, rect.height ? rect.height : stripline.size);
            this.renderRectangle(stripline, stripline.sizeType === 'Pixel' ? pixelRect : rect, id + 'border_' + axis.name + '_' + count, striplineGroup, chart);
        }
        if (stripline.text !== '') {
            this.renderText(stripline, rect, id + 'text_' + axis.name + '_' + count, striplineGroup, chart, axis);
        }
    };
    /**
     * To find the factor of the text
     *
     * @param {Anchor} anchor text anchor
     */
    StripLine.prototype.factor = function (anchor) {
        var factor = 0;
        switch (anchor) {
            case 'Start':
                factor = 1;
                break;
            case 'End':
                factor = -1;
                break;
        }
        return factor;
    };
    /**
     * To find the start value of the text
     *
     * @param {number} xy xy values
     * @param {number} size text size
     * @param {Anchor} textAlignment text alignment
     */
    StripLine.prototype.getTextStart = function (xy, size, textAlignment) {
        var padding = 5;
        switch (textAlignment) {
            case 'Start':
                xy = xy - (size / 2) + padding;
                break;
            case 'End':
                xy = xy + (size / 2) - padding;
                break;
        }
        return xy;
    };
    /**
     * To get the module name for `StripLine`.
     *
     * @private
     */
    StripLine.prototype.getModuleName = function () {
        return 'StripLine';
    };
    /**
     * To destroy the `StripLine` module.
     *
     * @private
     */
    StripLine.prototype.destroy = function () {
        // destroy peform here
    };
    return StripLine;
}());

/* eslint-disable no-trailing-spaces */
/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * Base for line type series.
 */
var LineBase = /** @__PURE__ @class */ (function () {
    /** @private */
    function LineBase(chartModule) {
        this.chart = chartModule;
    }
    /**
     * To improve the chart performance.
     *
     * @returns {void}
     * @private
     */
    LineBase.prototype.enableComplexProperty = function (series) {
        var tempPoints = [];
        var tempPoints2 = [];
        var xVisibleRange = series.xAxis.visibleRange;
        var yVisibleRange = series.yAxis.visibleRange;
        var seriesPoints = series.points;
        var areaBounds = series.clipRect;
        var xTolerance = Math.abs(xVisibleRange.delta / areaBounds.width);
        var yTolerance = Math.abs(yVisibleRange.delta / areaBounds.height);
        var prevXValue = (seriesPoints[0] && seriesPoints[0].xValue > xTolerance) ? 0 : xTolerance;
        var prevYValue = (seriesPoints[0] && seriesPoints[0].y > yTolerance) ? 0 : yTolerance;
        var xVal = 0;
        var yVal = 0;
        for (var _i = 0, seriesPoints_1 = seriesPoints; _i < seriesPoints_1.length; _i++) {
            var currentPoint = seriesPoints_1[_i];
            currentPoint.symbolLocations = [];
            xVal = currentPoint.xValue ? currentPoint.xValue : xVisibleRange.min;
            yVal = currentPoint.yValue ? currentPoint.yValue : yVisibleRange.min;
            if (Math.abs(prevXValue - xVal) >= xTolerance || Math.abs(prevYValue - yVal) >= yTolerance) {
                tempPoints.push(currentPoint);
                prevXValue = xVal;
                prevYValue = yVal;
            }
        }
        var tempPoint;
        for (var i = 0; i < tempPoints.length; i++) {
            tempPoint = tempPoints[i];
            if (isNullOrUndefined(tempPoint.x) || (series.category === 'Indicator' && (isNaN(tempPoint.xValue) || isNaN(tempPoint.yValue)))) {
                continue;
            }
            else {
                tempPoints2.push(tempPoint);
            }
        }
        return tempPoints2;
    };
    /**
     * To generate the line path direction.
     *
     * @param {Points} firstPoint firstPoint
     * @param {Points} secondPoint secondPoint
     * @param {Series} series series
     * @param {boolean} isInverted isInverted
     * @param {Function} getPointLocation getPointLocation
     * @param {string} startPoint startPoint
     */
    LineBase.prototype.getLineDirection = function (firstPoint, secondPoint, series, isInverted, getPointLocation, startPoint) {
        var direction = '';
        if (firstPoint != null) {
            var point1 = getPointLocation(firstPoint.xValue, firstPoint.yValue, series.xAxis, series.yAxis, isInverted, series);
            var point2 = getPointLocation(secondPoint.xValue, secondPoint.yValue, series.xAxis, series.yAxis, isInverted, series);
            direction = startPoint + ' ' + (point1.x) + ' ' + (point1.y) + ' ' +
                'L' + ' ' + (point2.x) + ' ' + (point2.y) + ' ';
        }
        return direction;
    };
    /**
     * To append the line path.
     *
     * @returns {void}
     * @private
     */
    LineBase.prototype.appendLinePath = function (options, series, clipRect) {
        var element = getElement$1(options.id);
        var chart = series.chart;
        var previousDirection = element ? element.getAttribute('d') : null;
        var htmlObject = series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));
        if (htmlObject) {
            htmlObject.setAttribute('clip-path', clipRect);
        }
        series.pathElement = htmlObject;
        if (!series.chart.enableCanvas) {
            series.seriesElement.appendChild(htmlObject);
        }
        series.isRectSeries = false;
        pathAnimation(element, options.d, series.chart.redraw, previousDirection, chart.duration);
    };
    /**
     * To render the marker for the series.
     *
     * @returns {void}
     * @private
     */
    LineBase.prototype.renderMarker = function (series) {
        if (series.marker && series.marker.visible) {
            series.chart.markerRender.render(series);
        }
    };
    /**
     * To do the progressive animation.
     *
     * @returns {void}
     * @private
     */
    LineBase.prototype.doProgressiveAnimation = function (series, option) {
        var animation = new Animation({});
        var path = series.pathElement;
        var strokeDashArray = path.getAttribute('stroke-dasharray');
        var pathLength = series.pathElement.getTotalLength();
        var currentTime;
        path.style.visibility = 'hidden';
        animation.animate(path, {
            duration: (option.duration === 0 && animationMode === 'Enable') ? 1000 : option.duration,
            delay: option.delay,
            progress: function (args) {
                if (args.timeStamp >= args.delay) {
                    path.style.visibility = 'visible';
                    currentTime = Math.abs(Math.round(((args.timeStamp - args.delay) * pathLength) / args.duration));
                    path.setAttribute('stroke-dasharray', currentTime + ',' + pathLength);
                }
            },
            end: function () {
                path.setAttribute('stroke-dasharray', strokeDashArray);
                series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });
            }
        });
    };
    /**
     * To store the symbol location and region.
     *
     * @param {Points} point point
     * @param {Series} series series
     * @param {boolean} isInverted isInverted
     * @param {Function} getLocation getLocation
     */
    LineBase.prototype.storePointLocation = function (point, series, isInverted, getLocation) {
        var markerWidth = (series.marker && series.marker.width) ? series.marker.width : 0;
        var markerHeight = (series.marker && series.marker.height) ? series.marker.height : 0;
        point.symbolLocations.push(getLocation(point.xValue, point.yValue, series.xAxis, series.yAxis, isInverted, series));
        point.regions.push(new Rect(point.symbolLocations[0].x - markerWidth, point.symbolLocations[0].y - markerHeight, 2 * markerWidth, 2 * markerHeight));
    };
    /**
     * To find point with in the visible range
     *
     * @param {Points} point point
     * @param {Axis} yAxis yAxis
     * @private
     */
    LineBase.prototype.withinYRange = function (point, yAxis) {
        return point.yValue >= yAxis.visibleRange.min && point.yValue <= yAxis.visibleRange.max;
    };
    LineBase.prototype.GetStepLineDirection = function (currentPoint, previousPoint, stepLineType, command) {
        if (command === void 0) { command = 'L'; }
        if (stepLineType === 'Right') {
            return (command + ' ' +
                (previousPoint.x) + ' ' + (currentPoint.y) + ' L ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');
        }
        else if (stepLineType === 'Center') {
            var centerX = previousPoint.x + (currentPoint.x - previousPoint.x) / 2;
            return (command + ' ' +
                (centerX) + ' ' + (previousPoint.y) + ' L ' + (centerX) + ' ' + (currentPoint.y) + ' L ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');
        }
        else {
            return (command + ' ' +
                (currentPoint.x) + ' ' + (previousPoint.y) + ' L ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');
        }
    };
    /**
     * To get first and last visible points
     *
     * @private
     */
    LineBase.prototype.getFirstLastVisiblePoint = function (points) {
        var first = null;
        var last = null;
        for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
            var point = points_1[_i];
            if (first === null && point.visible) {
                first = last = point;
            }
            last = point.visible ? point : last;
        }
        return { first: first ? first : points[0], last: last ? last : points[points.length - 1] };
    };
    /**
     * To Generate the area series border path direction from area series main direction path.
     *
     *  @param {string} direction direction
     *
     * */
    LineBase.prototype.getBorderDirection = function (direction) {
        var coordinates = direction.split(' ');
        if (coordinates.length > 3 && !(this.chart.stackingAreaSeriesModule) && !(this.chart.stackingStepAreaSeriesModule)) {
            coordinates.splice(coordinates.length - 4, 3);
        }
        else if (this.chart.stackingAreaSeriesModule || this.chart.stackingStepAreaSeriesModule) {
            coordinates.splice(coordinates.length / 2 + 1, coordinates.length / 2 + 1);
            if (coordinates[coordinates.length - 1] === 'L') {
                coordinates.splice(coordinates.length - 1, 1);
            }
        }
        return coordinates.join(' ');
    };
    /**
     * To remove empty point directions from series direction of area types.
     *
     *  @param {string} borderDirection direction
     *
     * */
    LineBase.prototype.removeEmptyPointsBorder = function (borderDirection) {
        var startIndex = 0;
        var coordinates = borderDirection.split(' ');
        // eslint-disable-next-line @typescript-eslint/tslint/config
        var point;
        do {
            point = coordinates.indexOf('M', startIndex);
            if (point > -1) {
                coordinates.splice(point + 1, 3);
                startIndex = point + 1;
                if (point - 6 > 0) {
                    coordinates.splice(point - 6, 6);
                    startIndex -= 6;
                }
            }
        } while (point !== -1);
        return coordinates.join(' ');
    };
    /**
     * To do the linear animation.
     *
     * @returns {void}
     * @private
     */
    LineBase.prototype.doLinearAnimation = function (series, animation) {
        var clipRect = series.clipRectElement.childNodes[0].childNodes[0];
        var duration = series.chart.animated ? series.chart.duration : animation.duration;
        var effect = getAnimationFunction('Linear');
        var elementHeight = +clipRect.getAttribute('height');
        var elementWidth = +clipRect.getAttribute('width');
        var xCenter = +clipRect.getAttribute('x');
        var yCenter = series.chart.requireInvertedAxis ? +clipRect.getAttribute('height') + +clipRect.getAttribute('y') :
            +clipRect.getAttribute('y');
        var value;
        clipRect.style.visibility = 'hidden';
        new Animation({}).animate(clipRect, {
            duration: (duration === 0 && animationMode === 'Enable') ? 1000 : duration,
            delay: animation.delay,
            progress: function (args) {
                if (args.timeStamp >= args.delay) {
                    clipRect.style.visibility = 'visible';
                    if (series.chart.requireInvertedAxis) {
                        value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);
                        clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter +
                            ') scale(1,' + (value / elementHeight) + ') translate(' + (-xCenter) + ' ' + (-yCenter) + ')');
                    }
                    else {
                        value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);
                        clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter +
                            ') scale(' + (value / elementWidth) + ', 1) translate(' + (-xCenter) + ' ' + (-yCenter) + ')');
                    }
                }
            },
            end: function () {
                clipRect.setAttribute('transform', 'translate(0,0)');
                series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });
            }
        });
    };
    return LineBase;
}());

var __extends$15 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `LineSeries` module used to render the line series.
 */
var LineSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$15(LineSeries, _super);
    function LineSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render Line Series.
     *
     * @returns {void}
     * @private
     */
    LineSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {
        var point1;
        var point2;
        var direction = '';
        var prevPoint = null;
        var startPoint = 'M';
        var isPolar = (series.chart && series.chart.chartAreaType === 'PolarRadar');
        var isDrop = (series.emptyPointSettings && series.emptyPointSettings.mode === 'Drop');
        var getCoordinate = isPolar ? TransformToVisible : getPoint;
        var visiblePoints = series.category === 'TrendLine' ? series.points : this.enableComplexProperty(series);
        for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {
            var point = visiblePoints_1[_i];
            point.regions = [];
            point.symbolLocations = [];
            if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {
                direction += this.getLineDirection(prevPoint, point, series, isInverted, getCoordinate, startPoint);
                startPoint = prevPoint ? 'L' : startPoint;
                prevPoint = point;
                this.storePointLocation(point, series, isInverted, getCoordinate);
            }
            else {
                prevPoint = isDrop ? prevPoint : null;
                startPoint = isDrop ? startPoint : 'M';
            }
        }
        if (isPolar) {
            if (series.isClosed) {
                var points = this.getFirstLastVisiblePoint(visiblePoints);
                point2 = getCoordinate(points.last.xValue, points.last.yValue, xAxis, yAxis, isInverted, series);
                point1 = getCoordinate(points.first.xValue, points.first.yValue, xAxis, yAxis, isInverted, series);
                direction = direction.concat(startPoint + ' ' + point2.x + ' ' + point2.y + ' ' + 'L' + ' ' + point1.x + ' ' + point1.y);
            }
        }
        var name = series.category === 'Indicator' ? series.chart.element.id + '_Indicator_' + series.index + '_' + series.name :
            series.category === 'TrendLine' ? series.chart.element.id + '_Series_' + series.sourceIndex + '_TrendLine_' + series.index :
                series.chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index);
        var options = new PathOption(name, 'none', series.width, series.interior, series.opacity, series.dashArray, direction);
        this.appendLinePath(options, series, '');
        this.renderMarker(series);
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    LineSeries.prototype.doAnimation = function (series) {
        var option = series.animation;
        this.doProgressiveAnimation(series, option);
    };
    /**
     * Get module name.
     */
    LineSeries.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'LineSeries';
    };
    /**
     * To destroy the line series.
     *
     * @returns {void}
     * @private
     */
    LineSeries.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return LineSeries;
}(LineBase));

/* eslint-disable @typescript-eslint/tslint/config */
/* eslint-disable max-len */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/**
 * Column Series Base
 */
var ColumnBase = /** @__PURE__ @class */ (function () {
    function ColumnBase() {
    }
    ColumnBase.prototype.getSideBySideInfo = function (series) {
        if (series.chart.enableSideBySidePlacement && !series.position) {
            this.getSideBySidePositions(series);
        }
        if (series.columnWidthInPixel) {
            return new DoubleRange(0, 0);
        }
        var position = series.type === 'Histogram' || !series.chart.enableSideBySidePlacement ? 0 : series.position;
        var rectCount = series.type === 'Histogram' || !series.chart.enableSideBySidePlacement ? 1 : series.rectCount;
        series.isRectSeries = true;
        var visibleSeries = series.chart.visibleSeries;
        var seriesSpacing = series.chart.enableSideBySidePlacement ? series.columnSpacing : 0; // Column Spacing
        var pointSpacing = (series.columnWidth === null || isNaN(+series.columnWidth)) ? ((series.type === 'Histogram') ? 1 : 0.7) :
            Math.min(series.columnWidth, 1); // Column width
        var minimumPointDelta = getMinPointsDelta(series.xAxis, visibleSeries);
        var width = minimumPointDelta * pointSpacing;
        var radius;
        var location = (position) / rectCount - 0.5;
        var doubleRange = new DoubleRange(location, location + (1 / rectCount));
        if (!(isNaN(doubleRange.start) || isNaN(doubleRange.end))) {
            if (series.groupName && series.type.indexOf('Stacking') === -1) {
                var mainColumnWidth_1 = 0.7;
                series.chart.series.filter(function (series) { if (series.columnWidth > mainColumnWidth_1) {
                    mainColumnWidth_1 = series.columnWidth;
                } });
                var mainWidth = minimumPointDelta * mainColumnWidth_1;
                var mainDoubleRange = new DoubleRange(doubleRange.start * mainWidth, doubleRange.end * mainWidth);
                var difference = ((mainDoubleRange.delta) - (doubleRange.end * width - doubleRange.start * width)) / 2;
                doubleRange = new DoubleRange(mainDoubleRange.start + difference, mainDoubleRange.end - difference);
            }
            else {
                doubleRange = new DoubleRange(doubleRange.start * width, doubleRange.end * width);
            }
            radius = seriesSpacing * doubleRange.delta;
            doubleRange = new DoubleRange(doubleRange.start + radius / 2, doubleRange.end - radius / 2);
        }
        return doubleRange;
    };
    /**
     * To get the rect values.
     *
     * @returns {Rect} rect region values
     * @private
     */
    ColumnBase.prototype.getRectangle = function (x1, y1, x2, y2, series) {
        var point1 = getPoint(x1, y1, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);
        var point2 = getPoint(x2, y2, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);
        return new Rect(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y), Math.abs(point2.x - point1.x), Math.abs(point2.y - point1.y));
    };
    /**
     * To draw the cylindrical shape for points.
     *
     * @returns {void}
     * @private
     */
    ColumnBase.prototype.drawCylinder = function (options, element, cylinderSeriesOption, rect, series) {
        var width = rect.width;
        var height = rect.height;
        if (series.chart.enableCanvas) {
            var ctx = series.chart.canvasRender.ctx;
            var canvasCtx = ctx;
            ctx.save();
            var gradientColor = colorNameToHex(options.fill);
            var x = rect.x + series.clipRect.x;
            var y = rect.y + series.clipRect.y;
            var arc = 2 * Math.PI + 0.1;
            var rx = void 0, ry = void 0, cx1 = void 0, cx2 = void 0, cy1 = void 0, cy2 = void 0, x1 = void 0, x2 = void 0, y1 = void 0, y2 = void 0, cx = void 0, cy = void 0, xl = void 0, yl = void 0, xPos = void 0, yPos = void 0, step = void 0, rxt = void 0, ryt = void 0;
            var gx1 = 0;
            var gx2 = 0;
            var gy1 = 0;
            var gy2 = 0;
            var ini = 0;
            ctx.fillStyle = applyZLight(gradientColor, 0.9);
            ctx.lineWidth = 0;
            ctx.strokeStyle = applyZLight(gradientColor, 0.9);
            ctx.globalAlpha = options.opacity;
            if (cylinderSeriesOption.isColumn) {
                gx1 = x;
                gx2 = width + x;
                rx = width / 2;
                ry = rx / 4;
                cx2 = cx1 = x + rx;
                y2 = cy1 = y - ry;
                x2 = x;
                x1 = x + width;
                cy2 = y1 = y + height - ry;
                step = Math.PI;
                rxt = -rx;
                ryt = ry;
                if (cylinderSeriesOption.stacking) {
                    if (!cylinderSeriesOption.isLastSeries) {
                        y2 = cy1 = y + ry;
                    }
                }
            }
            else {
                gy2 = height + y;
                gy1 = y;
                ry = height / 2;
                rx = ry / 4;
                x2 = cx1 = x + rx;
                x1 = cx2 = x + width + rx;
                y1 = y + height;
                y2 = y;
                cy2 = cy1 = y + ry;
                ini = Math.PI / 2;
                step = Math.PI * 1.5;
                if (cylinderSeriesOption.stacking) {
                    if (!cylinderSeriesOption.isLastSeries) {
                        x1 = cx2 = x + width - rx;
                    }
                }
                ry = -ry;
                rx = -rx;
                rxt = rx;
                ryt = -ry;
            }
            var color = applyZLight(gradientColor, 0.7);
            var gradient = ctx.createLinearGradient(gx1, gy1, gx2, gy2);
            gradient.addColorStop(0, gradientColor);
            gradient.addColorStop(0.3, color);
            gradient.addColorStop(0.7, color);
            gradient.addColorStop(1, gradientColor);
            for (var j = 1; j <= 4; j++) {
                var i = 0;
                if (j < 4) {
                    ctx.beginPath();
                }
                if (j % 2 === 0) {
                    cx = cx2;
                    cy = cy2;
                    xl = x2;
                    yl = y2;
                }
                else {
                    cx = cx1;
                    cy = cy1;
                    xl = x1;
                    yl = y1;
                }
                if (j === 4) {
                    rx = rxt;
                    ry = ryt;
                    ctx.fillStyle = gradient;
                }
                if (j > 2) {
                    i = ini;
                    arc = step;
                }
                for (; i <= arc; i += 0.1) {
                    xPos = cx - (rx * Math.cos(i));
                    yPos = cy + (ry * Math.sin(i));
                    if (i === 0) {
                        ctx.moveTo(xPos, yPos);
                    }
                    else {
                        ctx.lineTo(xPos, yPos);
                    }
                }
                if (j > 2) {
                    ctx.lineTo(xl, yl);
                }
                if (j !== 3) {
                    ctx.stroke();
                    ctx.fill();
                }
            }
            if (options.id.indexOf('Series') >= 0) {
                ctx.clip();
                ctx.restore();
                ctx = canvasCtx;
            }
        }
        else {
            var chart = series.chart;
            var x = rect.x;
            var y = rect.y;
            var id = options.id;
            var gradientColor = options.fill;
            var fillColor = gradientColor;
            var format = checkColorFormat(gradientColor);
            if (!format) {
                gradientColor = colorNameToHex(gradientColor);
            }
            var AEx = 0;
            var AEy = 0;
            var LX = 0;
            var LY = 0;
            var GX = 0;
            var GY = 0;
            var X = void 0, Y = void 0, X1 = void 0, Y1 = void 0, X2 = void 0, Y2 = void 0, rx = void 0, ry = void 0;
            var i = 2;
            if (cylinderSeriesOption.isColumn) {
                rx = width / 2;
                ry = rx / 4;
                X = X1 = x;
                Y = ry < y ? y - ry : cylinderSeriesOption.stacking ? y + ry : (y - ry);
                Y1 = Y;
                AEx = 2 * rx;
                LY = ry < y ? height : (height < 2 * ry ? height : cylinderSeriesOption.stacking ? height - (2 * ry) : height);
                X2 = X;
                Y2 = ry < y ? Y + height : (height < Y ? height + Y : cylinderSeriesOption.stacking ? height + (y - ry) : height + Y);
                GX = 100;
                if (cylinderSeriesOption.stacking) {
                    if (!cylinderSeriesOption.isLastSeries) {
                        Y = Y1 = y + ry;
                        LY = height < rx / 2 ? height : height - rx / 2;
                    }
                }
            }
            else {
                ry = height / 2;
                rx = ry / 4;
                Y = Y1 = y;
                X = X1 = Math.abs(x - rx);
                AEy = 2 * ry;
                LX = width;
                X2 = X + width;
                Y2 = Y;
                GY = 100;
                if (cylinderSeriesOption.stacking) {
                    if (!cylinderSeriesOption.isLastSeries) {
                        X2 = (X + width - rx * 2);
                        LX = width - rx * 2;
                    }
                }
            }
            remove(this.element);
            while (i--) {
                options.d = 'M' + X.toString() + ',' + Y.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,0 ' + AEx.toString() + ',' + AEy.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,0 ' + (-1 * AEx).toString() + ',' + (-1 * AEy).toString();
                options.id = id + '_' + 'Region_' + i;
                options.fill = applyZLight(gradientColor, 0.9);
                if (i % 2 === 0 && series.type !== 'StackingBar100' && series.type !== 'StackingBar' && series.type !== 'Bar') {
                    options.fill = options.fill + '10';
                }
                this.element = chart.renderer.drawPath(this.options, new Int32Array([series.clipRect.x, series.clipRect.y]));
                appendChildElement(series.chart.enableCanvas, series.seriesElement, this.element, chart.redraw);
                X = X2;
                Y = Y2;
            }
            options.d = 'M' + X1.toString() + ',' + Y1.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,0 ' + AEx.toString() + ',' + AEy.toString() + 'l' + LX.toString() + ' ' + LY.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,1 ' + (-1 * AEx).toString() + ',' + (-1 * AEy).toString() + ' z';
            options.id = id + '_' + 'Region_2';
            options.fill = applyZLight(gradientColor, 0.7);
            var optiong = void 0;
            if (fillColor.indexOf('url') === -1) {
                if (!document.getElementById(id)) {
                    optiong = { 'id': id, x1: '0%', y1: '0%', x2: GX.toString() + '%', y2: GY.toString() + '%' };
                    var gradientElement = [{ colorStop: '0%', color: gradientColor }, { colorStop: '30%', color: applyZLight(gradientColor, 0.7) }, { colorStop: '70%', color: applyZLight(gradientColor, 0.7) }, { colorStop: '100%', color: gradientColor }];
                    this.drawGradient(optiong, gradientElement, series);
                }
                options.fill = 'url(#' + optiong.id + ')';
            }
            this.element = chart.renderer.drawPath(this.options, new Int32Array([series.clipRect.x, series.clipRect.y]));
            appendChildElement(series.chart.enableCanvas, series.seriesElement, this.element, chart.redraw);
        }
    };
    /**
     * To get the gradient of each points.
     *
     * @returns {void}
     * @private
     */
    ColumnBase.prototype.drawGradient = function (optiong, gradientElement, series) {
        var chart = series.chart;
        var defElement = chart.renderer.createDefs();
        var xmlns = 'http://www.w3.org/2000/svg';
        var linearGradientElement = document.createElementNS(xmlns, 'linearGradient');
        linearGradientElement.setAttribute('id', optiong.id);
        linearGradientElement.setAttribute('x1', optiong.x1);
        linearGradientElement.setAttribute('y1', optiong.y1);
        linearGradientElement.setAttribute('x2', optiong.x2);
        linearGradientElement.setAttribute('y2', optiong.y2);
        for (var i = 0; i < gradientElement.length; i++) {
            var stopElement = document.createElementNS(xmlns, 'stop');
            stopElement.setAttribute('offset', gradientElement[i].colorStop);
            stopElement.setAttribute('stop-color', gradientElement[i].color);
            stopElement.setAttribute('stop-opacity', '1');
            linearGradientElement.appendChild(stopElement);
        }
        series.seriesElement.appendChild(defElement);
        defElement.appendChild(linearGradientElement);
    };
    /**
     * To get the position of each series.
     *
     * @returns {void}
     * @private
     */
    ColumnBase.prototype.getSideBySidePositions = function (series) {
        var chart = series.chart;
        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {
            var columnItem = _a[_i];
            for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {
                var item = _c[_b];
                this.findRectPosition(series.findSeriesCollection(columnItem, item, false));
            }
        }
    };
    ColumnBase.prototype.findRectPosition = function (seriesCollection) {
        var groupingValues = [];
        var vSeries = { rectCount: 0, position: null };
        for (var i = 0; i < seriesCollection.length; i++) {
            var value = seriesCollection[i];
            if (value.type.indexOf('Stacking') !== -1 || value.groupName !== '') {
                var groupName = value.type.indexOf('Stacking') !== -1 ? value.stackingGroup : value.type + value.groupName;
                if (groupName) {
                    if (groupingValues[groupName] === undefined) {
                        value.position = vSeries.rectCount;
                        groupingValues[groupName] = vSeries.rectCount++;
                    }
                    else {
                        value.position = groupingValues[groupName];
                    }
                }
                else {
                    if (vSeries.position === null) {
                        value.position = vSeries.rectCount;
                        vSeries.position = vSeries.rectCount++;
                    }
                    else {
                        value.position = vSeries.position;
                    }
                }
            }
            else {
                value.position = vSeries.rectCount++;
            }
        }
        for (var i = 0; i < seriesCollection.length; i++) {
            var value = seriesCollection[i];
            value.rectCount = vSeries.rectCount;
        }
    };
    /**
     * Updates the symbollocation for points
     *
     * @returns {void}
     * @private
     */
    ColumnBase.prototype.updateSymbolLocation = function (point, rect, series) {
        if (!series.chart.requireInvertedAxis) {
            this.updateXRegion(point, rect, series);
        }
        else {
            this.updateYRegion(point, rect, series);
        }
        if (series.type === 'Histogram') {
            point.minimum = +point.x - series.histogramValues.binWidth / 2;
            point.maximum = +point.x + series.histogramValues.binWidth / 2;
        }
    };
    /**
     * Update the region for the point.
     *
     * @returns {void}
     * @private
     */
    ColumnBase.prototype.updateXRegion = function (point, rect, series) {
        point.symbolLocations.push({
            x: rect.x + (rect.width) / 2,
            y: (series.seriesType === 'BoxPlot' || series.seriesType.indexOf('HighLow') !== -1 ||
                (point.yValue >= 0 === !series.yAxis.isAxisInverse)) ? rect.y : (rect.y + rect.height)
        });
        this.getRegion(point, rect, series);
        if (series.type === 'RangeColumn') {
            point.symbolLocations.push({
                x: rect.x + (rect.width) / 2,
                y: rect.y + rect.height
            });
        }
    };
    /**
     * Update the region for the point in bar series.
     *
     * @returns {void}
     * @private
     */
    ColumnBase.prototype.updateYRegion = function (point, rect, series) {
        point.symbolLocations.push({
            x: (series.seriesType === 'BoxPlot' || series.seriesType.indexOf('HighLow') !== -1 ||
                (point.yValue >= 0 === !series.yAxis.isAxisInverse)) ? rect.x + rect.width : rect.x,
            y: rect.y + rect.height / 2
        });
        this.getRegion(point, rect, series);
        if (series.type === 'RangeColumn') {
            point.symbolLocations.push({
                x: rect.x,
                y: rect.y + rect.height / 2
            });
        }
    };
    /**
     * To render the marker for the series.
     *
     * @returns {void}
     * @private
     */
    ColumnBase.prototype.renderMarker = function (series) {
        if (series.marker && series.marker.visible) {
            series.chart.markerRender.render(series);
        }
    };
    /**
     * To get the marker region when Y value is 0
     *
     * @param {Points} point point
     * @param {rect} rect rect
     * @param {Series} series series
     */
    ColumnBase.prototype.getRegion = function (point, rect, series) {
        if (point.y === 0) {
            var markerWidth = (series.marker && series.marker.width) ? series.marker.width : 0;
            var markerHeight = (series.marker && series.marker.height) ? series.marker.height : 0;
            point.regions.push(new Rect(point.symbolLocations[0].x - markerWidth, point.symbolLocations[0].y - markerHeight, 2 * markerWidth, 2 * markerHeight));
        }
        else {
            point.regions.push(rect);
        }
    };
    /**
     * To trigger the point rendering event.
     *
     * @returns {void}
     * @private
     */
    ColumnBase.prototype.triggerEvent = function (series, point, fill, border) {
        var argsData = {
            cancel: false, name: pointRender, series: series, point: point,
            fill: series.setPointColor(point, fill),
            border: series.setBorderColor(point, border)
        };
        series.chart.trigger(pointRender, argsData);
        point.color = argsData.fill;
        return argsData;
    };
    /**
     * To draw the rectangle for points.
     *
     * @returns {void}
     * @private
     */
    ColumnBase.prototype.drawRectangle = function (series, point, rect, argsData) {
        var chart = series.chart;
        var check = chart.requireInvertedAxis ? rect.height : rect.width;
        if (check <= 0) {
            return null;
        }
        var direction;
        if (point.y === 0) {
            // For 0 values corner radius will not calculate
            direction = this.calculateRoundedRectPath(rect, 0, 0, 0, 0);
        }
        else {
            direction = this.calculateRoundedRectPath(rect, series.cornerRadius.topLeft, series.cornerRadius.topRight, series.cornerRadius.bottomLeft, series.cornerRadius.bottomRight, chart.requireInvertedAxis);
        }
        var name = series.category === 'Indicator' ? chart.element.id + '_Indicator_' + series.index + '_' + series.name +
            '_Point_' + point.index : chart.element.id + '_Series_' + series.index + '_Point_' + point.index;
        var previousElement = redrawElement(chart.redraw, name);
        var previousDirection = previousElement ? previousElement.getAttribute('d') : '';
        this.options = new PathOption(name, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.dashArray, (series.columnFacet === 'Cylinder') ? '' : direction);
        this.element = chart.renderer.drawPath(this.options, new Int32Array([series.clipRect.x, series.clipRect.y]));
        switch (series.seriesType) {
            case 'XY':
                this.element.setAttribute('role', 'img');
                this.element.setAttribute('aria-label', point.x + ':' + point.yValue + ', ' + series.name);
                break;
            case 'HighLow':
                this.element.setAttribute('role', 'img');
                this.element.setAttribute('aria-label', point.x + ':' + point.high + ', ' + point.low + ', ' + series.name);
                break;
        }
        appendChildElement(series.chart.enableCanvas, series.seriesElement, this.element, chart.redraw);
        if (!series.chart.enableCanvas) {
            pathAnimation(this.element, (series.columnFacet === 'Cylinder') ? '' : direction, chart.redraw, previousDirection, chart.duration);
        }
    };
    /**
     * To animate the series.
     *
     * @returns {void}
     * @private
     */
    ColumnBase.prototype.animate = function (series) {
        var rectElements = series.seriesElement.childNodes;
        var count = series.category === 'Indicator' ? 0 : 1;
        var visiblePoints = getVisiblePoints(series);
        for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {
            var point = visiblePoints_1[_i];
            if (!point.symbolLocations.length && !(series.type === 'BoxAndWhisker' && point.regions.length)) {
                continue;
            }
            if ((series.type === 'Column' || series.type === 'Bar' || series.type === 'StackingColumn' || series.type === 'StackingColumn100' || series.type === 'StackingBar' || series.type === 'StackingBar100') && series.columnFacet === 'Cylinder') {
                for (var j = 0; j < rectElements.length; j++) {
                    this.animateRect(rectElements[j], series, point);
                }
            }
            else {
                this.animateRect(rectElements[count], series, point);
                count++;
            }
        }
    };
    /**
     * To animate the series.
     *
     * @returns {void}
     * @private
     */
    ColumnBase.prototype.animateRect = function (element, series, point) {
        var option = series.animation;
        var duration = series.chart.animated ? series.chart.duration : option.duration;
        var effect = getAnimationFunction('Linear');
        var isPlot = point.yValue < 0;
        var x;
        var y;
        var elementHeight = +point.regions[0].height;
        var elementWidth = +point.regions[0].width;
        var centerX;
        var centerY;
        if (!series.chart.requireInvertedAxis) {
            x = +point.regions[0].x;
            if (series.type.indexOf('Stacking') > -1) {
                y = (1 - valueToCoefficient(0, series.yAxis)) * (series.yAxis.rect.height);
                centerX = x;
                centerY = y;
            }
            else {
                y = +point.regions[0].y;
                centerY = (series.seriesType.indexOf('HighLow') !== -1 || series.type.indexOf('Waterfall') !== -1) ? y + elementHeight / 2 :
                    (isPlot !== series.yAxis.isAxisInverse) ? y : y + elementHeight;
                centerX = isPlot ? x : x + elementWidth;
            }
        }
        else {
            y = +point.regions[0].y;
            if (series.type.indexOf('Stacking') > -1) {
                x = (valueToCoefficient(0, series.yAxis)) * series.yAxis.rect.width;
                centerX = x;
                centerY = y;
            }
            else {
                x = +point.regions[0].x;
                centerY = isPlot ? y : y + elementHeight;
                centerX = (series.seriesType.indexOf('HighLow') !== -1 || series.type.indexOf('Waterfall') !== -1) ? x + elementWidth / 2 :
                    (isPlot !== series.yAxis.isAxisInverse) ? x + elementWidth : x;
            }
        }
        var value;
        if (!isNullOrUndefined(element)) {
            element.style.visibility = 'hidden';
            new Animation({}).animate(element, {
                duration: (duration === 0 && animationMode === 'Enable') ? 1000 : duration,
                delay: option.delay,
                progress: function (args) {
                    if (args.timeStamp >= args.delay) {
                        element.style.visibility = 'visible';
                        if (!series.chart.requireInvertedAxis) {
                            elementHeight = elementHeight ? elementHeight : 1;
                            value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);
                            element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY +
                                ') scale(1,' + (value / elementHeight) + ') translate(' + (-centerX) + ' ' + (-centerY) + ')');
                        }
                        else {
                            elementWidth = elementWidth ? elementWidth : 1;
                            value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);
                            element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY +
                                ') scale(' + (value / elementWidth) + ', 1) translate(' + (-centerX) + ' ' + (-centerY) + ')');
                        }
                    }
                },
                end: function () {
                    element.setAttribute('transform', 'translate(0,0)');
                    var seriesElement = series.seriesElement;
                    if (element === seriesElement.lastElementChild || point.index === series.points.length - 1 ||
                        (series.type === 'Waterfall' && element === seriesElement.children[seriesElement.childElementCount - 2])) {
                        series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });
                        if (series.type === 'Waterfall') {
                            var rectElements = seriesElement.childNodes;
                            for (var i = 0; i < rectElements.length; i++) {
                                if (rectElements[i].id.indexOf('Connector') !== -1) {
                                    rectElements[i].style.visibility = 'visible';
                                    rectElements[i].setAttribute('transform', 'translate(0,0)');
                                }
                            }
                        }
                    }
                }
            });
        }
    };
    /**
     * To get rounded rect path direction.
     */
    ColumnBase.prototype.calculateRoundedRectPath = function (rect, topLeft, topRight, bottomLeft, bottomRight, inverted) {
        if (inverted === void 0) { inverted = false; }
        var halfValue = inverted ? rect.width / 2 : rect.height / 2;
        topLeft = Math.min(topLeft, halfValue);
        topRight = Math.min(topRight, halfValue);
        bottomLeft = Math.min(bottomLeft, halfValue);
        bottomRight = Math.min(bottomRight, halfValue);
        return 'M' + ' ' + rect.x + ' ' + (topLeft + rect.y) +
            ' Q ' + rect.x + ' ' + rect.y + ' ' + (rect.x + topLeft) + ' ' +
            rect.y + ' ' + 'L' + ' ' + (rect.x + rect.width - topRight) + ' ' + rect.y +
            ' Q ' + (rect.x + rect.width) + ' ' + rect.y + ' ' +
            (rect.x + rect.width) + ' ' + (rect.y + topRight) + ' ' + 'L ' +
            (rect.x + rect.width) + ' ' + (rect.y + rect.height - bottomRight)
            + ' Q ' + (rect.x + rect.width) + ' ' + (rect.y + rect.height) + ' ' + (rect.x + rect.width - bottomRight) + ' ' +
            (rect.y + rect.height) + ' ' + 'L ' + (rect.x + bottomLeft) + ' ' + (rect.y + rect.height) + ' Q ' + rect.x + ' ' +
            (rect.y + rect.height) + ' ' + rect.x + ' ' + (rect.y + rect.height - bottomLeft) + ' ' + 'L' + ' ' + rect.x + ' ' +
            (topLeft + rect.y) + ' ' + 'Z';
    };
    return ColumnBase;
}());

var __extends$16 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-returns */
/**
 * `ColumnSeries` Module used to render the column series.
 */
var ColumnSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$16(ColumnSeries, _super);
    function ColumnSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ColumnSeries.prototype.render = function (series) {
        var sideBySideInfo = this.getSideBySideInfo(series);
        var origin = Math.max(series.yAxis.visibleRange.min, 0);
        var argsData;
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var pointColumn = _a[_i];
            pointColumn.symbolLocations = [];
            pointColumn.regions = [];
            if (pointColumn.visible && withInRange(series.points[pointColumn.index - 1], pointColumn, series.points[pointColumn.index + 1], series)) {
                this.rect = this.getRectangle(pointColumn.xValue + sideBySideInfo.start, pointColumn.yValue, pointColumn.xValue + sideBySideInfo.end, origin, series);
                this.rect.width = series.columnWidthInPixel ? (series.columnWidthInPixel - (series.chart.enableSideBySidePlacement ? series.columnWidthInPixel * series.columnSpacing : 0)) : this.rect.width;
                this.rect.x = series.columnWidthInPixel ? this.rect.x - (((series.columnWidthInPixel / 2) * series.rectCount) -
                    (series.columnWidthInPixel * series.index)) : this.rect.x;
                var color = series.category === 'Indicator' ? pointColumn.color : series.interior;
                argsData = this.triggerEvent(series, pointColumn, color, { width: series.border.width, color: series.border.color });
                if (!argsData.cancel) {
                    this.updateSymbolLocation(pointColumn, this.rect, series);
                    this.drawRectangle(series, pointColumn, this.rect, argsData);
                    if (series.columnFacet === 'Cylinder') {
                        var cylinderSeriesOption = {
                            'isColumn': true,
                            'stacking': false,
                            'isLastSeries': true
                        };
                        this.drawCylinder(this.options, this.element, cylinderSeriesOption, this.rect, series);
                    }
                }
            }
        }
        this.renderMarker(series);
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    ColumnSeries.prototype.doAnimation = function (series) {
        this.animate(series);
    };
    /**
     * Get module name.
     */
    ColumnSeries.prototype.getModuleName = function () {
        return 'ColumnSeries';
        /**
         * return the module name
         */
    };
    /**
     * To destroy the column series.
     *
     * @returns {void}
     * @private
     */
    ColumnSeries.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return ColumnSeries;
}(ColumnBase));

var __extends$18 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-returns */
/**
 * Base class for multi colored series
 */
var MultiColoredSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$18(MultiColoredSeries, _super);
    function MultiColoredSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * To Generate the area path direction.
     *
     * @param {number} xValue xValue
     * @param {number} yValue yValue
     * @param {Series} series series
     * @param {boolean} isInverted isInverted
     * @param {Function} getPointLocation getPointLocation
     * @param {ChartLocation} startPoint startPoint
     * @param {string} startPath startPath
     */
    MultiColoredSeries.prototype.getAreaPathDirection = function (xValue, yValue, series, isInverted, getPointLocation, startPoint, startPath) {
        var direction = '';
        var firstPoint;
        if (startPoint === null) {
            firstPoint = getPointLocation(xValue, yValue, series.xAxis, series.yAxis, isInverted, series);
            direction += (startPath + ' ' + (firstPoint.x) + ' ' + (firstPoint.y) + ' ');
        }
        return direction;
    };
    /**
     * To Generate the empty point direction.
     *
     * @param {ChartLocation} firstPoint firstPoint
     * @param {ChartLocation} secondPoint secondPoint
     * @param {Series} series series
     * @param {boolean} isInverted isInverted
     * @param {Function} getPointLocation getPointLocation
     */
    MultiColoredSeries.prototype.getAreaEmptyDirection = function (firstPoint, secondPoint, series, isInverted, getPointLocation) {
        var direction = '';
        direction += this.getAreaPathDirection(firstPoint.x, firstPoint.y, series, isInverted, getPointLocation, null, 'L');
        direction += this.getAreaPathDirection(secondPoint.x, secondPoint.y, series, isInverted, getPointLocation, null, 'L');
        return direction;
    };
    /**
     * To set point color.
     */
    MultiColoredSeries.prototype.setPointColor = function (currentPoint, previous, series, isXSegment, segments) {
        if (series.pointColorMapping === '') {
            var segment = void 0;
            var value = void 0;
            for (var i = 0; i < segments.length; i++) {
                segment = segments[i];
                value = isXSegment ? currentPoint.xValue : currentPoint.yValue;
                if (value <= this.getAxisValue(segment.value, isXSegment ? series.xAxis : series.yAxis, series.chart) ||
                    (!segment.value && segment.value !== 0)) {
                    currentPoint.interior = segment.color;
                    break;
                }
            }
            if (currentPoint.interior == null) {
                currentPoint.interior = series.interior;
            }
            return false;
        }
        else {
            if (previous) {
                return series.setPointColor(currentPoint, series.interior) !== series.setPointColor(previous, series.interior);
            }
            else {
                return false;
            }
        }
    };
    MultiColoredSeries.prototype.sortSegments = function (series, chartSegments) {
        var _this = this;
        var axis = series.segmentAxis === 'X' ? series.xAxis : series.yAxis;
        var segments = [].concat(chartSegments);
        return segments.sort(function (a, b) {
            return _this.getAxisValue(a.value, axis, series.chart) - _this.getAxisValue(b.value, axis, series.chart);
        });
    };
    /**
     * Segment calculation performed here.
     *
     * @param {Series} series series
     * @param {PathOption[]} options options
     * @param {ChartSegmentModel[]} segments chartSegments
     */
    MultiColoredSeries.prototype.applySegmentAxis = function (series, options, segments) {
        var _this = this;
        if (series.pointColorMapping !== '') {
            options.map(function (option) {
                _this.appendLinePath(option, series, '');
            });
            return null;
        }
        var isXSegment = series.segmentAxis === 'X';
        var axis = isXSegment ? series.xAxis : series.yAxis;
        var chart = series.chart;
        var segment;
        this.includeSegment(segments, axis, series, segments.length);
        var length = segments.length;
        var value;
        var clipPath;
        var attributeOptions;
        var areaBorderCount = 0;
        var _loop_1 = function (index) {
            segment = segments[index];
            value = this_1.getAxisValue(segment.value, axis, series.chart);
            clipPath = this_1.createClipRect(index ? this_1.getAxisValue(segments[index - 1].value, axis, series.chart)
                : axis.visibleRange.min, value, series, index, isXSegment);
            if (clipPath) {
                options.map(function (option) {
                    areaBorderCount += 1;
                    attributeOptions = {
                        'clip-path': clipPath,
                        'stroke-dasharray': segment.dashArray,
                        'opacity': option.opacity,
                        'stroke': series.type.indexOf('Line') > -1 ? segment.color || series.interior : option['stroke'],
                        'stroke-width': option['stroke-width'],
                        'fill': series.type.indexOf('Line') > -1 ? 'none' : segment.color || series.interior,
                        'id': option.id + '_Segment_' + index,
                        'd': option.d
                    };
                    if (areaBorderCount % 2 === 0 && _this.chart.multiColoredAreaSeriesModule && series.border.color !== 'transparent' && attributeOptions['stroke-width'] !== 0) {
                        attributeOptions.fill = 'transparent';
                    }
                    pathAnimation(getElement$1(attributeOptions.id), attributeOptions.d, chart.redraw);
                    series.pathElement = chart.renderer.drawPath(attributeOptions);
                    if (!series.chart.enableCanvas) {
                        series.seriesElement.appendChild(chart.renderer.drawPath(attributeOptions));
                    }
                });
            }
        };
        var this_1 = this;
        for (var index = 0; index < length; index++) {
            _loop_1(index);
        }
    };
    MultiColoredSeries.prototype.includeSegment = function (segments, axis, series, length) {
        if (length <= 0) {
            segments.push({ value: axis.visibleRange.max, color: series.interior });
            return null;
        }
        if (this.getAxisValue(segments[length - 1].value, axis, series.chart) < axis.visibleRange.max) {
            segments.push({ value: axis.visibleRange.max, color: series.interior });
        }
    };
    /**
     * To create clip rect for segment axis.
     *
     * @param {number} startValue startValue
     * @param {number} endValue endValue
     * @param {Series} series series
     * @param {number} index index
     * @param {boolean} isX isX
     */
    MultiColoredSeries.prototype.createClipRect = function (startValue, endValue, series, index, isX) {
        var isRequired = series.chart.requireInvertedAxis;
        var startPointLocation = getPoint(isX ? startValue : series.xAxis.visibleRange.min, isX ? series.yAxis.visibleRange.max : endValue, series.xAxis, series.yAxis, isRequired);
        var endPointLocation = getPoint(isX ? endValue : series.xAxis.visibleRange.max, isX ? series.yAxis.visibleRange.min : startValue, series.xAxis, series.yAxis, isRequired);
        endPointLocation = isRequired ?
            [startPointLocation, startPointLocation = endPointLocation][0] : endPointLocation;
        var options;
        if (((series.xAxis.isInversed || series.xAxis.isAxisInverse) ? startPointLocation.x - endPointLocation.x > 0 : endPointLocation.x - startPointLocation.x > 0) &&
            (series.yAxis.isInversed ? startPointLocation.y - endPointLocation.y > 0 : endPointLocation.y - startPointLocation.y > 0)) {
            options = new RectOption(series.chart.element.id + '_ChartSegment' + series.index + 'ClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, {
                x: (series.xAxis.isInversed || series.xAxis.isAxisInverse) ? endPointLocation.x : startPointLocation.x,
                y: series.yAxis.isInversed ? endPointLocation.y : startPointLocation.y,
                width: (series.xAxis.isInversed || series.xAxis.isAxisInverse) ? startPointLocation.x - endPointLocation.x : endPointLocation.x - startPointLocation.x,
                height: series.yAxis.isInversed ? startPointLocation.y - endPointLocation.y : endPointLocation.y - startPointLocation.y
            });
            if (!series.chart.enableCanvas) {
                series.seriesElement.appendChild(appendClipElement(series.chart.redraw, options, series.chart.renderer));
            }
            return 'url(#' + series.chart.element.id + '_ChartSegment' + series.index + 'ClipRect_' + index + ')';
        }
        return null;
    };
    /**
     * To get exact value from segment value.
     *
     * @param {Object} segmentValue segmentValue
     * @param {Axis} axis axis
     * @param {Chart} chart chart
     */
    MultiColoredSeries.prototype.getAxisValue = function (segmentValue, axis, chart) {
        if (segmentValue === null) {
            segmentValue = axis.visibleRange.max;
        }
        if (axis.valueType === 'DateTime') {
            var option = { skeleton: 'full', type: 'dateTime' };
            return Date.parse(chart.intl.getDateParser(option)(chart.intl.getDateFormat(option)(new Date(DataUtil.parse.parseJson({ val: segmentValue }).val))));
        }
        else if (axis.valueType.indexOf('Category') > -1) {
            var xValue = axis.valueType === 'DateTimeCategory' ?
                (segmentValue.getTime()).toString() :
                segmentValue;
            return (axis.labels.indexOf(xValue) < 0) ? +segmentValue : axis.labels.indexOf(xValue);
        }
        else {
            return +segmentValue;
        }
    };
    return MultiColoredSeries;
}(LineBase));

var __extends$17 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `AreaSeries` module is used to render the area series.
 */
var AreaSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$17(AreaSeries, _super);
    function AreaSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render Area series.
     *
     * @returns {void}
     * @private
     */
    AreaSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {
        var startPoint = null;
        var direction = '';
        var isPolar = (series.chart && series.chart.chartAreaType === 'PolarRadar');
        var origin = Math.max(series.yAxis.visibleRange.min, 0);
        if (isPolar) {
            var connectPoints = this.getFirstLastVisiblePoint(series.points);
            origin = connectPoints.first.yValue;
        }
        var currentXValue;
        var isDropMode = (series.emptyPointSettings && series.emptyPointSettings.mode === 'Drop');
        var borderWidth = series.border.width ? series.border.width : 0;
        var borderColor = series.border.color ? series.border.color : series.interior;
        var getCoordinate = series.chart.chartAreaType === 'PolarRadar' ? TransformToVisible : getPoint;
        var visiblePoints = this.enableComplexProperty(series);
        var point;
        var emptyPointDirection = '';
        for (var i = 0; i < visiblePoints.length; i++) {
            point = visiblePoints[i];
            currentXValue = point.xValue;
            point.symbolLocations = [];
            point.regions = [];
            if (point.visible && withInRange(visiblePoints[i - 1], point, visiblePoints[i + 1], series)) {
                direction += this.getAreaPathDirection(currentXValue, origin, series, isInverted, getCoordinate, startPoint, 'M');
                startPoint = startPoint || new ChartLocation(currentXValue, origin);
                // First Point to draw the area path
                direction += this.getAreaPathDirection(currentXValue, point.yValue, series, isInverted, getCoordinate, null, 'L');
                if (visiblePoints[i + 1] && (!visiblePoints[i + 1].visible &&
                    (!isPolar || (isPolar && this.withinYRange(visiblePoints[i + 1], yAxis)))) && !isDropMode) {
                    direction += this.getAreaEmptyDirection({ 'x': currentXValue, 'y': origin }, startPoint, series, isInverted, getCoordinate);
                    startPoint = null;
                }
                this.storePointLocation(point, series, isInverted, getCoordinate);
            }
        }
        if (isPolar && direction !== '') {
            var endPoint = '';
            var chart = this.chart;
            endPoint += this.getAreaPathDirection(0, origin, series, isInverted, getCoordinate, null, 'L');
            if (xAxis.isAxisInverse || yAxis.isAxisInverse) {
                direction += (series.type === 'Polar' ? chart.polarSeriesModule.getPolarIsInversedPath(xAxis, endPoint) :
                    chart.radarSeriesModule.getRadarIsInversedPath(xAxis, endPoint));
            }
            direction = direction.concat(direction + ' ' + 'Z');
        }
        this.appendLinePath(new PathOption(series.chart.element.id + '_Series_' + series.index, series.interior, 0, 'transparent', series.opacity, series.dashArray, ((series.points.length > 1 && direction !== '') ? (direction + this.getAreaPathDirection(series.points[series.points.length - 1].xValue, series.chart.chartAreaType === 'PolarRadar' ?
            series.points[series.points.length - 1].yValue : origin, series, isInverted, getCoordinate, null, 'L')) : '')), series, '');
        /**
         * To draw border for the path directions of area
         */
        if (series.border.width !== 0) {
            emptyPointDirection = this.removeEmptyPointsBorder(direction);
            this.appendLinePath(new PathOption(series.chart.element.id + '_Series_border_' + series.index, 'transparent', borderWidth, borderColor, 1, series.dashArray, emptyPointDirection), series, '');
        }
        this.renderMarker(series);
    };
    /**
     * To destroy the area series.
     *
     * @returns {void}
     * @private
     */
    AreaSeries.prototype.destroy = function () {
        /**
         * Destroy method calling here
         */
    };
    /**
     * Get module name
     */
    AreaSeries.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'AreaSeries';
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    AreaSeries.prototype.doAnimation = function (series) {
        var option = series.animation;
        this.doLinearAnimation(series, option);
    };
    return AreaSeries;
}(MultiColoredSeries));

var __extends$19 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `BarSeries` module is used to render the bar series.
 */
var BarSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$19(BarSeries, _super);
    function BarSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BarSeries.prototype.render = function (series) {
        var origin = Math.max(series.yAxis.visibleRange.min, 0);
        var sideBySideInfo = this.getSideBySideInfo(series);
        var argsData;
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var pointBar = _a[_i];
            pointBar.symbolLocations = [];
            pointBar.regions = [];
            if (pointBar.visible && withInRange(series.points[pointBar.index - 1], pointBar, series.points[pointBar.index + 1], series)) {
                this.rect = this.getRectangle(pointBar.xValue + sideBySideInfo.start, pointBar.yValue, pointBar.xValue + sideBySideInfo.end, origin, series);
                this.rect.height = series.columnWidthInPixel ? series.columnWidthInPixel : this.rect.height;
                this.rect.y = series.columnWidthInPixel ? this.rect.y - (((series.columnWidthInPixel / 2) * series.rectCount) -
                    (series.columnWidthInPixel * series.index)) : this.rect.y;
                argsData = this.triggerEvent(series, pointBar, series.interior, { width: series.border.width, color: series.border.color });
                if (!argsData.cancel) {
                    this.updateSymbolLocation(pointBar, this.rect, series);
                    this.drawRectangle(series, pointBar, this.rect, argsData);
                    if (series.columnFacet === 'Cylinder') {
                        var cylinderSeriesOption = {
                            'isColumn': false,
                            'stacking': false,
                            'isLastSeries': true
                        };
                        this.drawCylinder(this.options, this.element, cylinderSeriesOption, this.rect, series);
                    }
                }
            }
        }
        this.renderMarker(series);
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    BarSeries.prototype.doAnimation = function (series) {
        this.animate(series);
    };
    /**
     * To destroy the bar series.
     *
     * @returns {void}
     * @private
     */
    BarSeries.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    /**
     * Get module name
     */
    BarSeries.prototype.getModuleName = function () {
        return 'BarSeries';
    };
    return BarSeries;
}(ColumnBase));

var __extends$21 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Specifies the Polar Axis Layout.
 */
var PolarRadarPanel = /** @__PURE__ @class */ (function (_super) {
    __extends$21(PolarRadarPanel, _super);
    function PolarRadarPanel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** @private */
        _this.visibleAxisLabelRect = [];
        return _this;
    }
    /**
     * Measure the polar radar axis size.
     *
     * @returns {void}
     * @private
     */
    PolarRadarPanel.prototype.measureAxis = function (rect) {
        var chart = this.chart;
        this.initialClipRect = rect;
        this.seriesClipRect = new Rect(rect.x, rect.y, rect.width, rect.height);
        //Measure axis size calculation
        this.measureRowAxis(chart, this.initialClipRect);
        this.measureColumnAxis(chart, this.initialClipRect);
        this.calculateAxisSize();
    };
    PolarRadarPanel.prototype.measureRowAxis = function (chart, rect) {
        this.calculateRowSize(rect);
        var row = chart.rows[0];
        this.measureDefinition(row, chart, new Size(chart.availableSize.width, row.computedHeight));
    };
    PolarRadarPanel.prototype.measureColumnAxis = function (chart, rect) {
        this.calculateColumnSize(rect);
        var column = chart.columns[0];
        this.measureDefinition(column, chart, new Size(column.computedWidth, chart.availableSize.height));
    };
    /**
     * Measure the column and row in chart.
     *
     * @returns {void}
     * @private
     */
    PolarRadarPanel.prototype.measureDefinition = function (definition, chart, size) {
        for (var _i = 0, _a = definition.axes; _i < _a.length; _i++) {
            var axis = _a[_i];
            axis.getModule(chart);
            axis.baseModule.calculateRangeAndInterval(size, axis);
        }
    };
    /**
     * Measure the axis.
     *
     * @returns {void}
     * @private
     */
    PolarRadarPanel.prototype.calculateAxisSize = function () {
        var chart = this.chart;
        var axis;
        var padding = 5;
        this.centerX = this.initialClipRect.width * 0.5 + this.initialClipRect.x;
        this.centerY = this.initialClipRect.height * 0.5 + this.initialClipRect.y;
        chart.radius = Math.min(this.initialClipRect.width, this.initialClipRect.height) / 2 - padding -
            chart.primaryXAxis.majorTickLines.height - chart.primaryXAxis.maxLabelSize.height;
        chart.radius = (chart.primaryXAxis.coefficient * chart.radius) / 100;
        this.seriesClipRect.y = this.centerY - chart.radius;
        this.seriesClipRect.x = this.centerX - chart.radius;
        this.seriesClipRect.height = 2 * chart.radius;
        this.seriesClipRect.width = 2 * chart.radius;
        this.calculateRowSize(this.seriesClipRect);
        axis = chart.primaryYAxis;
        axis.rect = this.seriesClipRect;
        this.calculateColumnSize(this.seriesClipRect);
        axis = chart.primaryXAxis;
        axis.rect = this.seriesClipRect;
    };
    /**
     * Measure the axis.
     *
     * @returns {void}
     * @private
     */
    PolarRadarPanel.prototype.measure = function () {
        var chart = this.chart;
        var yAxis = chart.primaryYAxis;
        yAxis.isRTLEnabled = chart.enableRtl;
        yAxis.setIsInversedAndOpposedPosition(true);
        chart.verticalAxes.push(yAxis);
        var row = chart.rows[0];
        row.axes[0] = yAxis;
        chart.rows[0] = row;
        var xAxis = chart.primaryXAxis;
        xAxis.isRTLEnabled = chart.enableRtl;
        xAxis.setIsInversedAndOpposedPosition(true);
        chart.horizontalAxes.push(xAxis);
        var column = chart.columns[0];
        column.axes[0] = xAxis;
        chart.columns[0] = column;
    };
    /**
     * Measure the row size.
     *
     * @returns {void}
     */
    PolarRadarPanel.prototype.calculateRowSize = function (rect) {
        /*! Calculate row size */
        var chart = this.chart;
        var row = chart.rows[0];
        row.computedHeight = rect.height / 2;
        row.computedTop = rect.y;
        chart.rows[0] = row;
    };
    /**
     * Measure the row size.
     *
     * @returns {void}
     */
    PolarRadarPanel.prototype.calculateColumnSize = function (rect) {
        /*! Calculate column size */
        var chart = this.chart;
        var column = chart.columns[0];
        column.computedLeft = rect.x;
        column.computedWidth = rect.width;
        chart.columns[0] = column;
    };
    /**
     * To render the axis element.
     *
     * @returns {void}
     * @private
     */
    PolarRadarPanel.prototype.renderAxes = function () {
        var axis;
        var chart = this.chart;
        this.startAngle = chart.primaryXAxis.startAngle;
        var axisElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisCollection' });
        var axisLineElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisOutsideCollection' });
        for (var i = 0, len = chart.axisCollections.length; i < len; i++) {
            this.element = chart.renderer.createGroup({ id: chart.element.id + 'AxisGroup' + i });
            axis = chart.axisCollections[i];
            if (axis.orientation === 'Horizontal') {
                if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0) {
                    this.drawXAxisGridLine(axis, i);
                }
                if (axis.visible && axis.internalVisibility) {
                    this.drawXAxisLabels(axis, i);
                }
            }
            else {
                this.drawYAxisGridLine(axis, i);
                if (axis.lineStyle.width > 0) {
                    this.drawYAxisLine(axis, i);
                }
                if (axis.visible && axis.internalVisibility) {
                    this.drawYAxisLabels(axis, i);
                }
            }
            if (!this.chart.enableCanvas) {
                axisElement.appendChild(this.element);
            }
        }
        if (!this.chart.enableCanvas) {
            axisElement.appendChild(this.element);
        }
        appendChildElement(chart.enableCanvas, chart.svgObject, axisElement, chart.redraw);
        return axisLineElement;
    };
    PolarRadarPanel.prototype.drawYAxisLine = function (axis, index) {
        var chart = this.chart;
        var optionsLine = {};
        var vector = CoefficientToVector(valueToPolarCoefficient(axis.visibleLabels[0].value, axis), this.startAngle);
        var axisLine = 'M ' + this.centerX + ' ' + this.centerY + 'L ' +
            (this.centerX + chart.radius * vector.x) + ' ' + (this.centerY + chart.radius * vector.y);
        optionsLine = {
            'id': chart.element.id + 'AxisLine_' + index,
            'd': axisLine,
            'stroke-dasharray': axis.lineStyle.dashArray,
            'stroke-width': axis.lineStyle.width,
            'stroke': axis.lineStyle.color || chart.themeStyle.axisLine
        };
        /**
         * I252450
         * When we click the center of the marker which is plotted in the axis line, selection did not work is fixed
         * Cause: Instead of marker id, axis  line id is obtained while clicking
         * Fix: Pointer events set to none for axis lines
         */
        var element = chart.renderer.drawPath(optionsLine);
        this.setPointerEventNone(element);
        if (!this.chart.enableCanvas) {
            chart.yAxisElements.appendChild(element);
        }
    };
    PolarRadarPanel.prototype.drawYAxisLabels = function (axis, index) {
        var chart = this.chart;
        var elementSize;
        var options;
        var pointX = 0;
        var pointY = 0;
        var angle = this.startAngle < 0 ? this.startAngle + 360 : this.startAngle;
        var anchor = 'middle';
        var radius;
        var padding = 5;
        var isIntersect;
        var labelRegions = [];
        var isLabelVisible = [];
        isLabelVisible[0] = true;
        var intersectType = axis.labelIntersectAction;
        var labelElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisLabels' + index });
        var vector = CoefficientToVector(valueToPolarCoefficient(axis.visibleLabels[0].value, axis), this.startAngle);
        for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {
            isIntersect = false;
            radius = chart.radius * valueToCoefficient(axis.visibleLabels[i].value, axis);
            elementSize = axis.visibleLabels[i].size;
            radius = chart.radius * valueToCoefficient(axis.visibleLabels[i].value, axis);
            pointX = (this.centerX + radius * vector.x) + ((axis.majorTickLines.height + elementSize.width / 2 + padding / 2)
                * (Math.cos(angle * Math.PI / 180)) * (axis.labelPosition === 'Inside' && chart.enableRtl ? -1 : axis.labelPosition === 'Inside' ? 1 : axis.labelPosition === 'Outside' && chart.enableRtl ? 1 : -1));
            pointY = (this.centerY + radius * vector.y) + ((axis.majorTickLines.height + elementSize.height / 2)
                * (Math.sin(angle * Math.PI / 180)) * (axis.labelPosition === 'Inside' && chart.enableRtl ? -1 : axis.labelPosition === 'Inside' ? 1 : axis.labelPosition === 'Outside' && chart.enableRtl ? 1 : -1));
            pointY += (elementSize.height / 4);
            labelRegions[i] = this.getLabelRegion(pointX, pointY, axis.visibleLabels[i], anchor);
            if (i !== 0 && intersectType === 'Hide') {
                for (var j = i; j >= 0; j--) {
                    j = (j === 0) ? 0 : (j === i) ? (j - 1) : j;
                    if (isLabelVisible[j] && isOverlap(labelRegions[i], labelRegions[j])) {
                        isIntersect = true;
                        isLabelVisible[i] = false;
                        break;
                    }
                    else {
                        isLabelVisible[i] = true;
                    }
                }
                if (isIntersect) {
                    continue; // If the label is intersect, the label render is ignored.
                }
                // To check Y axis label with visible X axis label
                for (var _i = 0, _a = this.visibleAxisLabelRect; _i < _a.length; _i++) {
                    var rect = _a[_i];
                    if (isOverlap(labelRegions[i], rect)) {
                        isIntersect = true;
                        break;
                    }
                }
            }
            if (isIntersect) {
                continue;
            }
            this.visibleAxisLabelRect.push(labelRegions[i]);
            options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, anchor, axis.visibleLabels[i].text);
            textElement$1(chart.renderer, options, axis.labelStyle, axis.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, false, chart.redraw, true, true, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisLabelFont);
        }
        if (!this.chart.enableCanvas) {
            chart.yAxisElements.appendChild(labelElement);
        }
    };
    PolarRadarPanel.prototype.drawYAxisGridLine = function (axis, index) {
        var chart = this.chart;
        var options;
        var radius;
        var majorTick = '';
        var majorGrid = '';
        var vector;
        var angle = this.startAngle < 0 ? this.startAngle + 360 : this.startAngle;
        var x1;
        var y1;
        var x2;
        var y2;
        var border = {
            color: axis.majorGridLines.color || chart.themeStyle.majorGridLine,
            width: axis.majorGridLines.width
        };
        var previousValue;
        var element;
        if (axis.majorGridLines.width > 0) {
            if (chart.visibleSeries[0].type === 'Polar') {
                for (var j = 0; j < axis.visibleLabels.length; j++) {
                    element = getElement$1(chart.element.id + '_MajorGridLine_' + index + '_' + j);
                    previousValue = element ? element.getAttribute('r') : null;
                    radius = chart.radius * valueToCoefficient(axis.visibleLabels[j].value, axis);
                    options = new CircleOption(chart.element.id + '_MajorGridLine_' + index + '_' + j, 'transparent', border, axis.majorGridLines.width, this.centerX, this.centerY, radius);
                    appendChildElement(chart.enableCanvas, this.element, chart.renderer.drawCircle(options), chart.redraw, true, 'r', 'r', new ChartLocation(+previousValue, +previousValue), null, true);
                }
                if (radius !== chart.radius) {
                    options = new CircleOption(chart.element.id + '_MajorGridLine_' + index + '_' + axis.visibleLabels.length + 1, 'transparent', border, axis.majorGridLines.width, this.centerX, this.centerY, chart.radius);
                    appendChildElement(chart.enableCanvas, this.element, chart.renderer.drawCircle(options), chart.redraw, true, 'r', 'r', new ChartLocation(+previousValue, +previousValue), null, true);
                }
            }
            else {
                for (var j = 0; j < axis.visibleLabels.length; j++) {
                    radius = chart.radius * valueToCoefficient(axis.visibleLabels[j].value, axis);
                    majorGrid = this.renderRadarGrid(radius, '', chart);
                    element = getElement$1(chart.element.id + '_MajorGridLine_' + index + '_' + j);
                    previousValue = element ? element.getAttribute('d') : null;
                    options = new PathOption(chart.element.id + '_MajorGridLine_' + index + '_' + j, 'transparent', axis.majorGridLines.width, axis.majorGridLines.color || chart.themeStyle.majorGridLine, null, null, majorGrid);
                    appendChildElement(chart.enableCanvas, this.element, chart.renderer.drawPath(options), chart.redraw, true, 'x', 'y', null, previousValue, true);
                }
                if (radius !== chart.radius) {
                    majorGrid = this.renderRadarGrid(chart.radius, '', chart);
                    element = getElement$1(chart.element.id + '_MajorGridLine_' + index + '_' + axis.visibleLabels.length);
                    previousValue = element ? element.getAttribute('d') : null;
                    options = new PathOption(chart.element.id + '_MajorGridLine_' + index + '_' + axis.visibleLabels.length, 'transparent', axis.majorGridLines.width, axis.majorGridLines.color || chart.themeStyle.majorGridLine, null, null, majorGrid);
                    appendChildElement(chart.enableCanvas, this.element, chart.renderer.drawPath(options), chart.redraw, true, 'x', 'y', null, previousValue, true);
                }
            }
        }
        if (axis.majorTickLines.width > 0) {
            vector = CoefficientToVector(valueToPolarCoefficient(axis.visibleLabels[0].value, axis), this.startAngle);
            for (var i = 0; i < axis.visibleLabels.length; i++) {
                radius = chart.radius * valueToCoefficient(axis.visibleLabels[i].value, axis);
                x1 = this.centerX + radius * vector.x;
                y1 = this.centerY + radius * vector.y;
                x2 = x1 + (axis.majorTickLines.height * (Math.cos(angle * Math.PI / 180)) * (axis.tickPosition === 'Inside' && chart.enableRtl ? -1 : axis.tickPosition === 'Inside' ? 1 : axis.tickPosition === 'Outside' && chart.enableRtl ? 1 : -1));
                y2 = y1 + (axis.majorTickLines.height * (Math.sin(angle * Math.PI / 180)) * (axis.tickPosition === 'Inside' && chart.enableRtl ? -1 : axis.tickPosition === 'Inside' ? 1 : axis.tickPosition === 'Outside' && chart.enableRtl ? 1 : -1));
                majorTick = 'M ' + x1 + ' ' + y1 + ' L ' + x2 + ' ' + y2;
                this.renderTickLine(axis, index, majorTick, '', i);
            }
        }
    };
    PolarRadarPanel.prototype.renderRadarGrid = function (radius, majorGrid, chart) {
        var vector;
        var vector2;
        var x1;
        var y1;
        var x2;
        var y2;
        for (var i = 0, len = chart.primaryXAxis.visibleLabels.length; i < len; i++) {
            vector = CoefficientToVector(valueToPolarCoefficient(chart.primaryXAxis.visibleLabels[i].value, chart.primaryXAxis), this.startAngle);
            if (i + 1 < len) {
                vector2 = CoefficientToVector(valueToPolarCoefficient(chart.primaryXAxis.visibleLabels[i + 1].value, chart.primaryXAxis), this.startAngle);
            }
            else {
                vector2 = CoefficientToVector(valueToPolarCoefficient(chart.primaryXAxis.visibleLabels[0].value, chart.primaryXAxis), this.startAngle);
            }
            x1 = this.centerX + radius * vector.x;
            y1 = this.centerY + radius * vector.y;
            x2 = this.centerX + radius * vector2.x;
            y2 = this.centerY + radius * vector2.y;
            majorGrid = majorGrid.concat((i ? 'L ' : 'M ') + x1 + ' ' + y1 + ' ' + 'L ' + x2 + ' ' + y2 + ' ');
        }
        return majorGrid;
    };
    PolarRadarPanel.prototype.drawXAxisGridLine = function (axis, index) {
        var chart = this.chart;
        var tempInterval;
        var vector;
        var majorGrid = '';
        var majorTick = '';
        var minorGirdLine = '';
        var minorTickLine = '';
        var x1 = this.centerX;
        var x2;
        var y1 = this.centerY;
        var y2;
        var minorDirection;
        var length = axis.visibleLabels.length;
        //Gridlines
        for (var i = 0; i < length; i++) {
            tempInterval = axis.visibleLabels[i].value;
            vector = CoefficientToVector(valueToPolarCoefficient(axis.visibleLabels[i].value, axis), this.startAngle);
            x2 = this.centerX + chart.radius * vector.x;
            y2 = this.centerY + chart.radius * vector.y;
            var xLoc = x2 + (axis.majorTickLines.height * vector.x * (axis.tickPosition === 'Inside' ? -1 : 1));
            var yLoc = y2 + (axis.majorTickLines.height * vector.y * (axis.tickPosition === 'Inside' ? -1 : 1));
            majorGrid = 'M ' + x1 + ' ' + y1 + ' ' + 'L ' + x2 + ' ' + y2;
            majorTick = 'M ' + x2 + ' ' + y2 + ' L ' + xLoc + ' ' + yLoc;
            if (axis.minorTicksPerInterval > 0 && (axis.minorGridLines.width > 0 || axis.minorTickLines.width > 0)
                && axis.valueType !== 'Category' && chart.visibleSeries[0].type !== 'Radar') {
                minorDirection = this.drawAxisMinorLine(axis, tempInterval, minorGirdLine, minorTickLine);
                minorGirdLine = minorDirection[0];
                minorTickLine = minorDirection[1];
            }
            this.renderTickLine(axis, index, majorTick, minorTickLine, i);
            this.renderGridLine(axis, index, majorGrid, minorGirdLine, i);
        }
    };
    PolarRadarPanel.prototype.drawAxisMinorLine = function (axis, tempInterval, minorGird, minorTick) {
        var value = tempInterval;
        var x;
        var y;
        var vector;
        var range = axis.visibleRange;
        var direction = [];
        for (var j = 0; j < axis.minorTicksPerInterval; j++) {
            value += (axis.valueType === 'DateTime' ? axis.dateTimeInterval : axis.visibleRange.interval) /
                (axis.minorTicksPerInterval + 1);
            if (inside(value, range)) {
                vector = CoefficientToVector(valueToPolarCoefficient(value, axis), this.startAngle);
                x = this.centerX + this.chart.radius * vector.x;
                y = this.centerY + this.chart.radius * vector.y;
                var tickXSize = x + (axis.minorTickLines.height * vector.x * (axis.tickPosition === 'Inside' ? -1 : 1));
                var tickYSize = y + (axis.minorTickLines.height * vector.y * (axis.tickPosition === 'Inside' ? -1 : 1));
                minorGird = minorGird.concat('M' + ' ' + this.centerX + ' ' + this.centerY
                    + 'L ' + x + ' ' + y);
                minorTick = minorTick.concat('M' + ' ' + x + ' ' + y + 'L' + ' ' + (tickXSize) + ' ' +
                    (tickYSize));
            }
        }
        direction.push(minorGird);
        direction.push(minorTick);
        return direction;
    };
    /**
     * To render the axis label.
     *
     * @param {Axis} axis axis
     * @param {number} index index
     * @returns {void}
     * @private
     */
    PolarRadarPanel.prototype.drawXAxisLabels = function (axis, index) {
        this.visibleAxisLabelRect = [];
        var legendRect;
        if (this.chart.legendModule) {
            legendRect = this.chart.legendModule.legendBounds;
        }
        var chart = this.chart;
        var pointX = 0;
        var pointY = 0;
        var labelElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisLabels' + index });
        var options;
        var vector;
        var labelText;
        var firstLabelX;
        var islabelInside = axis.labelPosition === 'Inside';
        var padding = 5;
        var lastLabelX;
        var label;
        var textAnchor = '';
        var isIntersect;
        var labelRegions = [];
        var isLabelVisible = [];
        isLabelVisible[0] = true;
        var intersectType = axis.labelIntersectAction;
        var ticksbwtLabel = axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;
        var radius = chart.radius + axis.majorTickLines.height;
        radius = (islabelInside) ? -radius : radius;
        for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {
            isIntersect = false;
            vector = CoefficientToVector(valueToPolarCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis), this.startAngle);
            if (!isNaN(vector.x) && !isNaN(vector.y)) {
                pointX = this.centerX + (radius + axis.majorTickLines.height + padding) * vector.x;
                pointY = this.centerY + (radius + axis.majorTickLines.height + padding) * vector.y;
                textAnchor = parseFloat(pointX.toFixed(1)) === parseFloat(this.centerX.toFixed(1)) ? 'middle' :
                    ((pointX < this.centerX && !islabelInside) || (pointX > this.centerX && islabelInside)) ? 'end' : 'start';
            }
            label = axis.visibleLabels[i];
            labelText = label.text;
            // to trim axis labels based on available size
            if (axis.enableTrim || intersectType === 'Trim') {
                var originalText = axis.visibleLabels[i].originalText;
                var trimText = void 0;
                var size = void 0;
                var labelPosition = axis.labelPosition;
                var chartWidth = chart.availableSize.width;
                var textLength = originalText.length;
                for (var i_1 = textLength - 1; i_1 >= 0; --i_1) {
                    trimText = originalText.substring(0, i_1) + '...';
                    size = measureText(trimText, axis.labelStyle, this.chart.themeStyle.axisLabelFont).width;
                    if (pointX === chartWidth / 2 ? (pointX - size / 2 >= 0 && pointX + size / 2 <= chartWidth) :
                        ((labelPosition === 'Outside' && ((pointX >= chartWidth / 2 && pointX + size <= chartWidth) ||
                            (pointX <= chartWidth / 2 && pointX - size >= 0))) || (labelPosition === 'Inside' &&
                            (pointX + size <= chartWidth / 2 || pointX - size >= chartWidth / 2)))) {
                        labelText = i_1 === textLength - 1 ? originalText : trimText;
                        label.size.width = measureText(labelText, axis.labelStyle, this.chart.themeStyle.axisLabelFont).width;
                        label.text = labelText;
                        break;
                    }
                }
            }
            // fix for label style not working in axisLabelRender event issue
            labelRegions[i] = this.getLabelRegion(pointX, pointY, label, textAnchor);
            if (i === 0) {
                firstLabelX = pointX;
            }
            else if (i === axis.visibleLabels.length - 1 && axis.valueType !== 'Category') {
                lastLabelX = measureText(labelText, axis.labelStyle, this.chart.themeStyle.axisLabelFont).height;
                lastLabelX += pointX;
                labelText = (lastLabelX > firstLabelX) ? '' : labelText;
            }
            // Label intersect action (Hide) perform here
            if (i !== 0 && intersectType === 'Hide') {
                for (var j = i; j >= 0; j--) {
                    j = (j === 0) ? 0 : ((j === i) ? (j - 1) : j);
                    if (isLabelVisible[j] && isOverlap(labelRegions[i], labelRegions[j])) {
                        isIntersect = true;
                        isLabelVisible[i] = false;
                        break;
                    }
                    else {
                        isLabelVisible[i] = true;
                    }
                }
            }
            if (!isIntersect && legendRect) {
                isIntersect = isOverlap(labelRegions[i], legendRect);
                if (isIntersect) {
                    var width = this.getAvailableSpaceToTrim(legendRect, labelRegions[i]);
                    if (width > 0) {
                        labelText = textTrim(width, axis.visibleLabels[i].originalText, axis.labelStyle, this.chart.enableRtl, this.chart.themeStyle.axisLabelFont);
                        isIntersect = false;
                    }
                }
            }
            options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, !chart.enableRtl ? textAnchor : textAnchor === 'end' ? 'start' : textAnchor === 'start' ? 'end' : textAnchor, labelText, '', 'central');
            if (isIntersect) {
                continue; // If the label is intersect, the label render is ignored.
            }
            this.visibleAxisLabelRect.push(labelRegions[i]);
            textElement$1(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, false, chart.redraw, true, true, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisLabelFont);
        }
        if (!this.chart.enableCanvas) {
            this.element.appendChild(labelElement);
        }
    };
    /**
     * To get available space to trim.
     *
     * @param {Rect} legendRect legendRect
     * @param {Rect} labelRect labelRect
     * @returns {number} available space value
     */
    PolarRadarPanel.prototype.getAvailableSpaceToTrim = function (legendRect, labelRect) {
        var legendX1 = legendRect.x;
        var legendX2 = legendX1 + legendRect.width;
        var labelX1 = labelRect.x;
        var labelX2 = labelX1 + labelRect.width;
        var width = 0;
        if (labelX1 > legendX1 && labelX1 < legendX2 && labelX2 > legendX2) {
            width = labelX2 - legendX2;
        }
        else if (labelX1 > legendX1 && labelX1 < legendX2 && labelX2 < legendX2) {
            width = 0;
        }
        else if (labelX2 > legendX1 && labelX2 < legendX2 && labelX1 < legendX1) {
            width = legendX1 - labelX1;
        }
        else if (labelX2 > legendX1 && labelX2 > legendX2 && labelX1 < legendX1) {
            width = legendX1 - labelX1;
        }
        return width;
    };
    /**
     * Getting axis label bounds
     *
     * @param {number} pointX pointX
     * @param {number} pointY pointY
     * @param {VisibleLabels} label label
     * @param {string} anchor anchor
     * @returns {Rect} label region
     */
    PolarRadarPanel.prototype.getLabelRegion = function (pointX, pointY, label, anchor) {
        if (anchor === 'middle') {
            pointX -= (label.size.width / 2);
        }
        else if (anchor === 'end') {
            pointX -= label.size.width;
        }
        else {
            // eslint-disable-next-line no-self-assign
            pointX = pointX;
        }
        pointY -= (label.size.height / 2);
        return new Rect(pointX, pointY, label.size.width, label.size.height);
    };
    PolarRadarPanel.prototype.renderTickLine = function (axis, index, majorTickLine, minorTickLine, gridIndex) {
        var tickOptions;
        var chart = this.chart;
        var direction;
        var element;
        if (axis.majorTickLines.width > 0) {
            element = getElement$1(chart.element.id + '_MajorTickLine_' + index + '_' + gridIndex);
            direction = element ? element.getAttribute('d') : null;
            tickOptions = new PathOption(chart.element.id + '_MajorTickLine_' + index + '_' + gridIndex, 'transparent', axis.majorTickLines.width, axis.majorTickLines.color || chart.themeStyle.majorTickLine, null, null, majorTickLine);
            /**
             * I252450
             * When we click the center of the marker which is plotted in the axis, selection did not work is fixed
             * Cause: Instead of marker id, axis Tick line id is obtained while clicking
             * Fix: Pointer events set to none for tick lines
             */
            element = chart.renderer.drawPath(tickOptions);
            this.setPointerEventNone(element);
            appendChildElement(chart.enableCanvas, chart.yAxisElements, element, chart.redraw, true, 'x', 'y', null, direction);
        }
        if (axis.minorTickLines.width > 0) {
            element = getElement$1(chart.element.id + '_MinorTickLine_' + index + '_' + gridIndex);
            direction = element ? element.getAttribute('d') : null;
            tickOptions = new PathOption(chart.element.id + '_MinorTickLine_' + index + '_' + gridIndex, 'transparent', axis.minorTickLines.width, axis.minorTickLines.color || chart.themeStyle.minorTickLine, null, null, minorTickLine);
            /**
             * I252450
             * When we click the center of the marker which is plotted in the axis, selection did not work is fixed
             * Cause: Instead of marker id, axis Tick line id is obtained while clicking
             * Fix: Pointer events set to none for tick lines
             */
            element = chart.renderer.drawPath(tickOptions);
            this.setPointerEventNone(element);
            appendChildElement(chart.enableCanvas, chart.yAxisElements, element, chart.redraw, true, 'x', 'y', null, direction);
        }
    };
    PolarRadarPanel.prototype.renderGridLine = function (axis, index, majorGrid, minorGird, gridIndex) {
        var chart = this.chart;
        var gridOptions;
        var direction;
        var element;
        if (axis.majorGridLines.width > 0) {
            element = getElement$1(chart.element.id + '_MajorGridLine_' + index + '_' + gridIndex);
            direction = element ? element.getAttribute('d') : null;
            gridOptions = new PathOption(chart.element.id + '_MajorGridLine_' + index + '_' + gridIndex, 'transparent', axis.majorGridLines.width, axis.majorGridLines.color || chart.themeStyle.majorGridLine, null, axis.majorGridLines.dashArray, majorGrid);
            appendChildElement(chart.enableCanvas, this.element, chart.renderer.drawPath(gridOptions), chart.redraw, true, 'x', 'y', null, direction);
        }
        if (axis.minorGridLines.width > 0) {
            element = getElement$1(chart.element.id + '_MinorGridLine_' + index + '_' + gridIndex);
            direction = element ? element.getAttribute('d') : null;
            gridOptions = new PathOption(chart.element.id + '_MinorGridLine_' + index + '_' + gridIndex, 'transparent', axis.minorGridLines.width, axis.minorGridLines.color || chart.themeStyle.minorGridLine, null, axis.minorGridLines.dashArray, minorGird);
            appendChildElement(chart.enableCanvas, this.element, chart.renderer.drawPath(gridOptions), chart.redraw, true, 'x', 'y', null, direction);
        }
    };
    PolarRadarPanel.prototype.setPointerEventNone = function (element) {
        if (element) {
            element.style.pointerEvents = 'none';
        }
    };
    return PolarRadarPanel;
}(LineBase));

var __extends$20 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable prefer-const */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `PolarSeries` module is used to render the polar series.
 */
var PolarSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$20(PolarSeries, _super);
    function PolarSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render Polar Series.
     *
     * @returns {void}
     * @private
     */
    PolarSeries.prototype.render = function (series, xAxis, yAxis, inverted) {
        var seriesType = firstToLowerCase(series.drawType);
        var yAxisMin = yAxis.minimum;
        var yAxisMax = yAxis.maximum;
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var visiblePoint = _a[_i];
            visiblePoint.visible = visiblePoint.visible && !((!isNullOrUndefined(yAxisMin) && visiblePoint.yValue < yAxisMin) ||
                (!isNullOrUndefined(yAxisMax) && visiblePoint.yValue > yAxisMax));
        }
        if (series.points.length) {
            if ((series.drawType.indexOf('Column') > -1)) {
                this.columnDrawTypeRender(series, xAxis, yAxis);
            }
            else {
                series.chart[seriesType + 'SeriesModule'].render(series, xAxis, yAxis, inverted);
            }
        }
    };
    /**
     * Render Column DrawType.
     *
     * @returns {void}
     * @private
     */
    PolarSeries.prototype.columnDrawTypeRender = function (series, xAxis, yAxis) {
        var options;
        var argsData;
        var startAngle;
        var endAngle;
        var itemCurrentXPos;
        var radius;
        var inversedValue;
        var pointStartAngle;
        var pointEndAngle;
        var x1;
        var x2;
        var y1;
        var y2;
        var startValue;
        var endValue;
        var innerRadius;
        var min = xAxis.actualRange.min;
        var centerX = (series.clipRect.width / 2) + series.clipRect.x;
        var dStartX;
        var dStartY;
        var centerY = (series.clipRect.height / 2) + series.clipRect.y;
        var dEndX;
        var dEndY;
        var isRangeColumn = series.drawType === 'RangeColumn';
        var isPolar = series.type === 'Polar';
        var isLogAxis = yAxis.valueType === 'Logarithmic';
        var isStacking = series.drawType === 'StackingColumn';
        var direction = '';
        var sumofYValues = 0;
        var arcValue;
        var interval = (series.points[1] ? series.points[1].xValue : 2 * series.points[0].xValue) - series.points[0].xValue;
        var isInverse = xAxis.isAxisInverse;
        //customer issue ID-I249730, Polar columnSeries in OnTicks with inversed axis
        var ticks = (xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks') ? 0 :
            isInverse ? -interval / 2 : interval / 2;
        var rangeInterval = xAxis.valueType === 'DateTime' ? xAxis.dateTimeInterval : 1;
        this.getSeriesPosition(series);
        var position = isInverse ? (series.rectCount - 1 - series.position) : series.position;
        do {
            sumofYValues += rangeInterval;
            min += rangeInterval;
        } while (min <= xAxis.actualRange.max - (xAxis.valueType === 'Category' ? 0 : 1));
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var point = _a[_i];
            point.symbolLocations = [];
            point.regions = [];
            if (point.visible && withInRange(series.points[point.index - 1], point, series.points[point.index + 1], series)) {
                inversedValue = isInverse ? (xAxis.visibleRange.max - point.xValue) : point.xValue - xAxis.visibleRange.min;
                itemCurrentXPos = (inversedValue) +
                    ((interval / series.rectCount) * position - ticks) + (sumofYValues / 360 * xAxis.startAngle);
                itemCurrentXPos = (((itemCurrentXPos) / (sumofYValues)));
                startAngle = 2 * Math.PI * (itemCurrentXPos + xAxis.startAngle);
                endAngle = 2 * Math.PI * ((itemCurrentXPos + xAxis.startAngle) + (interval / series.rectCount) / (sumofYValues));
                if (startAngle === 0 && endAngle === 0) {
                    endAngle = 2 * Math.PI;
                    arcValue = '1';
                }
                else {
                    arcValue = '0';
                }
                pointStartAngle = startAngle;
                pointEndAngle = endAngle;
                startAngle = (startAngle - 0.5 * Math.PI) + (series.columnSpacing / 2);
                endAngle = ((endAngle - 0.5 * Math.PI) - 0.000001) - (series.columnSpacing / 2);
                if (isStacking || isRangeColumn) {
                    startValue = isRangeColumn ? point.low : series.stackedValues.startValues[point.index];
                    endValue = isRangeColumn ? point.high : series.stackedValues.endValues[point.index];
                    endValue = (isLogAxis ? logBase(endValue === 0 ? 1 : endValue, yAxis.logBase) : endValue);
                    endValue = endValue > yAxis.actualRange.max ? yAxis.actualRange.max : endValue;
                }
                else {
                    startValue = yAxis.visibleRange.min;
                    endValue = point.yValue > yAxis.actualRange.max ? yAxis.actualRange.max : point.yValue;
                }
                radius = startValue === endValue ? 0 : series.chart.radius * valueToCoefficient(endValue, yAxis);
                x1 = centerX + radius * Math.cos(startAngle);
                x2 = centerX + radius * Math.cos(endAngle);
                y1 = centerY + radius * Math.sin(startAngle);
                y2 = centerY + radius * Math.sin(endAngle);
                innerRadius = series.chart.radius * valueToCoefficient((startValue === 0 && yAxis.visibleRange.min !== 0) ? yAxis.visibleRange.min : startValue, yAxis);
                dStartX = centerX + innerRadius * Math.cos(startAngle);
                dStartY = centerY + innerRadius * Math.sin(startAngle);
                dEndX = centerX + innerRadius * Math.cos(endAngle);
                dEndY = centerY + innerRadius * Math.sin(endAngle);
                if (isPolar) {
                    direction = ('M' + ' ' + x1 + ' ' + y1 + ' ' + 'A' + ' ' + radius + ' ' + radius + ' ' + '0' + ' '
                        + arcValue + ' ' + 1 + ' ' + x2 + ' ' + y2 + ' ' + 'L' + ' ' + dEndX + ' ' + dEndY + ' ' +
                        'A' + ' ' + innerRadius + ' ' + innerRadius + ' ' + '1' + ' ' + '0' + ' ' + '0' + ' '
                        + dStartX + ' ' + dStartY + ' ' + 'Z');
                }
                else {
                    direction = ('M' + ' ' + x1 + ' ' + y1 + ' ' + 'L' + ' ' + x2 + ' ' + y2 + ' ' + 'L '
                        + dEndX + ' ' + dEndY + ' ' + 'L' + ' ' + dStartX + ' ' + dStartY + ' ' + 'Z');
                }
                point.regionData = new PolarArc(pointStartAngle, pointEndAngle, innerRadius, radius, itemCurrentXPos);
                argsData = this.triggerEvent(series.chart, series, point);
                options = new PathOption(series.chart.element.id + '_Series_' + series.index + '_Point_' + point.index, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.dashArray, direction);
                if (!argsData.cancel) {
                    this.appendLinePath(options, series, '');
                    if (isPolar) {
                        point.symbolLocations.push({
                            x: centerX + radius * Math.cos((startAngle + (endAngle - startAngle) / 2)),
                            y: centerY + radius * Math.sin((startAngle + (endAngle - startAngle) / 2))
                        });
                        if (isRangeColumn) {
                            point.symbolLocations.push({
                                x: centerX + innerRadius * Math.cos((startAngle + (endAngle - startAngle) / 2)),
                                y: centerY + innerRadius * Math.sin((startAngle + (endAngle - startAngle) / 2))
                            });
                        }
                    }
                    else {
                        point.symbolLocations.push({ x: (x1 + x2) / 2, y: (y1 + y2) / 2 });
                        if (isRangeColumn) {
                            point.symbolLocations.push({ x: (dEndX + dStartX) / 2, y: (dEndY + dStartY) / 2 });
                        }
                    }
                }
            }
        }
        this.renderMarker(series);
        series.isRectSeries = true;
    };
    /**
     * To trigger the point rendering event.
     *
     * @returns {void}
     * @private
     */
    PolarSeries.prototype.triggerEvent = function (chart, series, point) {
        var argsData = {
            cancel: false, name: pointRender, series: series, point: point,
            fill: series.setPointColor(point, series.interior),
            border: series.setBorderColor(point, { width: series.border.width, color: series.border.color })
        };
        chart.trigger(pointRender, argsData);
        point.color = argsData.fill;
        return argsData;
    };
    /** get position for column drawtypes
     *
     * @returns {void}
     * @private
     */
    PolarSeries.prototype.getSeriesPosition = function (series) {
        var chart = series.chart;
        var seriesCollection = [];
        var stackingGroup = [];
        var vSeries = { rectCount: 0, position: null };
        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
            var series_1 = _a[_i];
            if (series_1.visible && (series_1.type === 'Polar' || series_1.type === 'Radar') && series_1.drawType.indexOf('Column') !== -1) {
                seriesCollection.push(series_1);
            }
        }
        for (var i = 0; i < seriesCollection.length; i++) {
            var series_2 = seriesCollection[i];
            if (series_2.drawType.indexOf('Stacking') !== -1) {
                if (series_2.stackingGroup) {
                    if (stackingGroup[series_2.stackingGroup] === undefined) {
                        series_2.position = vSeries.rectCount;
                        stackingGroup[series_2.stackingGroup] = vSeries.rectCount++;
                    }
                    else {
                        series_2.position = stackingGroup[series_2.stackingGroup];
                    }
                }
                else {
                    if (vSeries.position === null) {
                        series_2.position = vSeries.rectCount;
                        vSeries.position = vSeries.rectCount++;
                    }
                    else {
                        series_2.position = vSeries.position;
                    }
                }
            }
            else {
                series_2.position = vSeries.rectCount++;
            }
        }
        for (var i = 0; i < seriesCollection.length; i++) {
            var value = seriesCollection[i];
            value.rectCount = vSeries.rectCount;
        }
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    PolarSeries.prototype.doAnimation = function (series) {
        var duration = series.animation.duration;
        var delay = series.animation.delay;
        var rectElements = series.seriesElement.childNodes;
        var count = 1;
        if (series.drawType === 'Scatter') {
            for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
                var point = _a[_i];
                if (!point.symbolLocations.length || !rectElements[count]) {
                    continue;
                }
                markerAnimate(rectElements[count], delay, duration, series, point.index, point.symbolLocations[0], false);
                count++;
            }
        }
        else {
            for (count = 1; count < rectElements.length; count++) {
                this.doPolarRadarAnimation(rectElements[count], delay, duration, series);
            }
        }
    };
    /**
     * To do the Polar Radar draw type column animation.
     *
     * @returns {void}
     * @private
     */
    PolarSeries.prototype.doPolarRadarAnimation = function (animateElement, delay, duration, series) {
        var chartcenterX = series.clipRect.width / 2 + series.clipRect.x;
        var chartcenterY = series.clipRect.height / 2 + series.clipRect.y;
        var elementHeight = 0;
        animateElement.style.visibility = 'hidden';
        new Animation({}).animate(animateElement, {
            duration: duration,
            delay: delay,
            progress: function (args) {
                if (args.timeStamp > args.delay) {
                    args.element.style.visibility = 'visible';
                    elementHeight = ((args.timeStamp - args.delay) / args.duration);
                    animateElement.setAttribute('transform', 'translate(' + chartcenterX
                        + ' ' + chartcenterY + ') scale(' + elementHeight + ') translate(' + (-chartcenterX) + ' ' + (-chartcenterY) + ')');
                }
            },
            end: function () {
                animateElement.style.visibility = 'visible';
                animateElement.removeAttribute('transform');
                series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });
            }
        });
    };
    // path calculation for isInversed polar area series
    PolarSeries.prototype.getPolarIsInversedPath = function (xAxis, endPoint) {
        var vector;
        var x1;
        var y1;
        var chart = this.chart;
        var radius = chart.radius;
        var direction = endPoint;
        var circleRotate = xAxis.isAxisInverse ? '1 1 ' : '1 0 ';
        vector = CoefficientToVector(valueToPolarCoefficient(xAxis.visibleLabels[0].value, xAxis), this.startAngle);
        x1 = this.centerX + radius * vector.x;
        y1 = this.centerY + radius * vector.y;
        return direction += 'L ' + x1 + ' ' + y1 + ' A ' + radius + ' ' + radius + ' 0 ' + circleRotate +
            x1 + ' ' + (this.centerY + radius) + ' A ' + radius + ' ' + radius + ' 0 ' + circleRotate + x1 + ' ' + y1 + ' ';
    };
    /**
     * Get module name.
     */
    PolarSeries.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'PolarSeries';
    };
    /**
     * To destroy the polar series.
     *
     * @returns {void}
     * @private
     */
    PolarSeries.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return PolarSeries;
}(PolarRadarPanel));

var __extends$22 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * `RadarSeries` module is used to render the radar series.
 */
var RadarSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$22(RadarSeries, _super);
    function RadarSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render radar Series.
     *
     * @returns {void}
     * @private
     */
    RadarSeries.prototype.render = function (series, xAxis, yAxis, inverted) {
        var seriesType = firstToLowerCase(series.drawType);
        var yAxisMin = yAxis.minimum;
        var yAxisMax = yAxis.maximum;
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var point = _a[_i];
            point.visible = point.visible && !((!isNullOrUndefined(yAxisMin) && point.yValue < yAxisMin) ||
                (!isNullOrUndefined(yAxisMax) && point.yValue > yAxisMax));
        }
        if (series.points.length) {
            if (series.drawType.indexOf('Column') === -1) {
                series.chart[seriesType + 'SeriesModule'].render(series, xAxis, yAxis, inverted);
            }
            else {
                this.columnDrawTypeRender(series, xAxis, yAxis);
            }
        }
    };
    // path calculation for isInversed polar area series
    RadarSeries.prototype.getRadarIsInversedPath = function (xAxis, endPoint) {
        var chart = this.chart;
        var x1;
        var y1;
        var vector;
        var radius = chart.radius;
        var length = xAxis.visibleLabels.length;
        var direction = endPoint;
        vector = CoefficientToVector(valueToPolarCoefficient(xAxis.visibleLabels[0].value, xAxis), this.startAngle);
        y1 = this.centerY + radius * vector.y;
        x1 = this.centerX + radius * vector.x;
        direction += ' L ' + x1 + ' ' + y1 + ' ';
        for (var i = length - 1; i >= 0; i--) {
            vector = CoefficientToVector(valueToPolarCoefficient(xAxis.visibleLabels[i].value, xAxis), this.startAngle);
            y1 = this.centerY + radius * vector.y;
            x1 = this.centerX + radius * vector.x;
            direction += 'L ' + x1 + ' ' + y1 + ' ';
        }
        return direction;
    };
    /**
     * Get module name.
     */
    RadarSeries.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'RadarSeries';
    };
    /**
     * To destroy the radar series.
     *
     * @returns {void}
     * @private
     */
    RadarSeries.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return RadarSeries;
}(PolarSeries));

var __extends$23 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable prefer-const */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `StackingBarSeries` module is used to render the stacking bar series.
 */
var StackingBarSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$23(StackingBarSeries, _super);
    function StackingBarSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StackingBarSeries.prototype.render = function (series) {
        var sideBySideInfo = this.getSideBySideInfo(series);
        var stackedValue = series.stackedValues;
        var argsData;
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var pointStack = _a[_i];
            pointStack.symbolLocations = [];
            pointStack.regions = [];
            if (pointStack.visible &&
                withInRange(series.points[pointStack.index - 1], pointStack, series.points[pointStack.index + 1], series)) {
                this.rect = this.getRectangle(pointStack.xValue + sideBySideInfo.start, stackedValue.endValues[pointStack.index], pointStack.xValue + sideBySideInfo.end, stackedValue.startValues[pointStack.index], series);
                this.rect.height = series.columnWidthInPixel ? series.columnWidthInPixel : this.rect.height;
                this.rect.y = series.columnWidthInPixel ? this.rect.y - (series.columnWidthInPixel / 2) : this.rect.y;
                argsData = this.triggerEvent(series, pointStack, series.interior, { width: series.border.width, color: series.border.color });
                if (!argsData.cancel) {
                    this.drawRectangle(series, pointStack, this.rect, argsData);
                    this.updateSymbolLocation(pointStack, this.rect, series);
                    if (series.columnFacet === 'Cylinder') {
                        var cylinderSeriesOption = {
                            'isColumn': false,
                            'stacking': series.type === 'StackingBar100',
                            'isLastSeries': true
                        };
                        this.drawCylinder(this.options, this.element, cylinderSeriesOption, this.rect, series);
                    }
                }
            }
        }
        this.renderMarker(series);
    };
    /**
     * To destroy the stacking bar.
     *
     * @returns {void}
     * @private
     */
    StackingBarSeries.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    /**
     * Get module name.
     */
    StackingBarSeries.prototype.getModuleName = function () {
        return 'StackingBarSeries';
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    StackingBarSeries.prototype.doAnimation = function (series) {
        this.animate(series);
    };
    return StackingBarSeries;
}(ColumnBase));

var __extends$24 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `CandleSeries` module is used to render the candle series.
 */
var CandleSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$24(CandleSeries, _super);
    function CandleSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render Candle series.
     *
     * @returns {void}
     * @private
     */
    CandleSeries.prototype.render = function (series) {
        var sideBySideInfo = this.getSideBySideInfo(series);
        var argsData;
        var borderWidth = Math.max(series.border.width, 1);
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var point = _a[_i];
            var direction = '';
            var centerRegion = void 0;
            var tickRegion = void 0;
            //initializing after zooming and also normal initialization
            point.regions = [];
            point.symbolLocations = [];
            if (point.visible && withInRange(series.points[point.index - 1], point, series.points[point.index + 1], series)) {
                //region to cover the top and bottom ticks
                tickRegion = this.getRectangle((point.xValue + sideBySideInfo.median), Math.max(point.high, point.low), (point.xValue + sideBySideInfo.median), Math.min(point.high, point.low), series);
                if (!series.chart.requireInvertedAxis) {
                    tickRegion.x -= borderWidth / 2;
                    tickRegion.width = borderWidth;
                }
                else {
                    tickRegion.y -= borderWidth / 2;
                    tickRegion.height = borderWidth;
                }
                //get middleRect
                centerRegion = this.getRectangle((point.xValue + sideBySideInfo.start), Math.max(point.open, point.close), (point.xValue + sideBySideInfo.end), Math.min(point.open, point.close), series);
                direction = this.getPathString(tickRegion, centerRegion, series);
                argsData = this.triggerPointRenderEvent(series, point);
                if (!argsData.cancel) {
                    this.drawCandle(series, point, centerRegion, argsData, direction);
                    this.updateSymbolLocation(point, tickRegion, series);
                    this.updateSymbolLocation(point, centerRegion, series);
                }
            }
        }
    };
    /**
     * Trigger point rendering event
     */
    CandleSeries.prototype.triggerPointRenderEvent = function (series, point) {
        var fill = this.getCandleColor(point, series);
        var border = { color: series.border.color, width: Math.max(series.border.width, 1) };
        return this.triggerEvent(series, point, fill, border);
    };
    /**
     * Find the color of the candle
     *
     * @param {Points} point point
     * @param {Series} series series
     * @returns {string} color of the candle
     * @private
     */
    CandleSeries.prototype.getCandleColor = function (point, series) {
        var previousPoint = series.points[point.index - 1];
        if (series.enableSolidCandles === false) {
            if (!previousPoint) {
                return series.bearFillColor || series.chart.themeStyle.bearFillColor;
            }
            else {
                return previousPoint.close > point.close ? series.bullFillColor || series.chart.themeStyle.bullFillColor
                    : series.bearFillColor || series.chart.themeStyle.bearFillColor;
            }
        }
        else {
            return point.open > point.close ? series.bullFillColor || series.chart.themeStyle.bullFillColor :
                series.bearFillColor || series.chart.themeStyle.bearFillColor;
        }
    };
    /**
     * Finds the path of the candle shape
     *
     * @private
     */
    CandleSeries.prototype.getPathString = function (topRect, midRect, series) {
        var direction = '';
        var center = series.chart.requireInvertedAxis ? topRect.y + topRect.height / 2 :
            topRect.x + topRect.width / 2;
        //tick 1 segment
        direction += !series.chart.requireInvertedAxis ?
            'M' + ' ' + (center) + ' ' + (topRect.y) + ' ' + 'L' + ' ' + (center) + ' ' + midRect.y :
            'M' + ' ' + (topRect.x) + ' ' + (center) + ' ' + 'L' + ' ' + (midRect.x) + ' ' + center;
        direction = direction.concat(' M' + ' ' + (midRect.x) + ' ' + (midRect.y) + ' ' +
            'L' + ' ' + (midRect.x + midRect.width) + ' ' + (midRect.y) + ' ' +
            'L' + ' ' + (midRect.x + midRect.width) + ' ' +
            (midRect.y + midRect.height) + ' ' +
            'L' + ' ' + (midRect.x) + ' ' + (midRect.y + midRect.height) +
            ' ' + 'Z');
        direction += !series.chart.requireInvertedAxis ?
            ' M' + ' ' + (center) + ' ' + (midRect.y + midRect.height) + ' ' + 'L' + ' ' + (center) + ' ' + (topRect.y +
                topRect.height) :
            ' M' + ' ' + (midRect.x + midRect.width) + ' ' + (center) + ' ' + 'L' + ' ' +
                (topRect.x + topRect.width) + ' ' + center;
        return direction;
    };
    /**
     * Draws the candle shape
     *
     * @param {Series} series series
     * @param {Points} point point
     * @param {Rect} rect point region
     * @param {IPointRenderEventArgs} argsData argsData
     * @param {string} direction path direction
     * @returns {void}
     * @private
     */
    CandleSeries.prototype.drawCandle = function (series, point, rect, argsData, direction) {
        var check = series.chart.requireInvertedAxis ? rect.height : rect.width;
        if (check <= 0) {
            return null;
        }
        var fill = !series.enableSolidCandles ?
            (point.open > point.close ? argsData.fill : 'transparent') : argsData.fill;
        argsData.border.color = argsData.fill;
        var options = new PathOption(series.chart.element.id + '_Series_' + series.index + '_Point_' + point.index, fill, argsData.border.width, argsData.border.color, series.opacity, series.dashArray, direction);
        var element = getElement$1(options.id);
        var previousDirection = element ? element.getAttribute('d') : null;
        var candleElement = series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));
        candleElement.setAttribute('role', 'img');
        candleElement.setAttribute('aria-label', point.x.toString() + ':' + point.high.toString()
            + ':' + point.low.toString() + ':' + point.close.toString() + ':' + point.open.toString());
        if (!series.chart.enableCanvas) {
            series.seriesElement.appendChild(candleElement);
        }
        pathAnimation(element, direction, series.chart.redraw, previousDirection);
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    CandleSeries.prototype.doAnimation = function (series) {
        this.animate(series);
    };
    /**
     * Get module name.
     */
    CandleSeries.prototype.getModuleName = function () {
        return 'CandleSeries';
        /**
         * return the module name
         */
    };
    /**
     * To destroy the candle series.
     *
     * @returns {void}
     * @private
     */
    CandleSeries.prototype.destroy = function () {
        /**
         * Destroys the candle series.
         */
    };
    return CandleSeries;
}(ColumnBase));

var __extends$25 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `StackingColumnSeries` module used to render the stacking column series.
 */
var StackingColumnSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$25(StackingColumnSeries, _super);
    function StackingColumnSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StackingColumnSeries.prototype.render = function (series) {
        series.isRectSeries = true;
        var sideBySideInfo = this.getSideBySideInfo(series);
        var argsData;
        var stackedValue = series.stackedValues;
        var visiblePoints = getVisiblePoints(series);
        for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {
            var point = visiblePoints_1[_i];
            point.symbolLocations = [];
            point.regions = [];
            if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {
                this.rect = this.getRectangle(point.xValue + sideBySideInfo.start, stackedValue.endValues[point.index], point.xValue + sideBySideInfo.end, stackedValue.startValues[point.index], series);
                this.rect.width = series.columnWidthInPixel ? series.columnWidthInPixel : this.rect.width;
                this.rect.x = series.columnWidthInPixel ? this.rect.x - (((series.columnWidthInPixel / 2) * series.rectCount) -
                    (series.columnWidthInPixel * series.position)) : this.rect.x;
                argsData = this.triggerEvent(series, point, series.interior, { width: series.border.width, color: series.border.color });
                if (!argsData.cancel) {
                    this.drawRectangle(series, point, this.rect, argsData);
                    this.updateSymbolLocation(point, this.rect, series);
                    if (series.columnFacet === 'Cylinder') {
                        var cylinderSeriesOption = {
                            'isColumn': true,
                            'stacking': series.type === 'StackingColumn100',
                            'isLastSeries': true
                        };
                        this.drawCylinder(this.options, this.element, cylinderSeriesOption, this.rect, series);
                    }
                }
            }
        }
        this.renderMarker(series);
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    StackingColumnSeries.prototype.doAnimation = function (series) {
        this.animate(series);
    };
    /**
     * To destroy the stacking column.
     *
     * @returns {void}
     * @private
     */
    StackingColumnSeries.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    /**
     * Get module name.
     */
    StackingColumnSeries.prototype.getModuleName = function () {
        return 'StackingColumnSeries';
    };
    return StackingColumnSeries;
}(ColumnBase));

var __extends$26 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `StepLineSeries` module is used to render the step line series.
 */
var StepLineSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$26(StepLineSeries, _super);
    function StepLineSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render the Step line series.
     *
     * @returns {void}
     * @private
     */
    StepLineSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {
        var direction = '';
        var startPoint = 'M';
        var prevPoint = null;
        var lineLength;
        var point1;
        var point2;
        var visiblePoints = this.enableComplexProperty(series);
        if (xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks') {
            lineLength = 0.5;
        }
        else {
            lineLength = 0;
        }
        for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {
            var point = visiblePoints_1[_i];
            point.symbolLocations = [];
            point.regions = [];
            if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {
                if (prevPoint != null) {
                    point2 = getPoint(point.xValue, point.yValue, xAxis, yAxis, isInverted);
                    point1 = getPoint(prevPoint.xValue, prevPoint.yValue, xAxis, yAxis, isInverted);
                    direction = direction.concat(startPoint + ' ' + (point1.x) + ' ' + (point1.y) + this.GetStepLineDirection(point2, point1, series.step));
                    startPoint = 'L';
                }
                else {
                    point1 = getPoint(point.xValue - lineLength, point.yValue, xAxis, yAxis, isInverted);
                    direction = direction.concat(startPoint + ' ' + (point1.x) + ' ' + (point1.y) + ' ');
                    startPoint = 'L';
                }
                this.storePointLocation(point, series, isInverted, getPoint);
                prevPoint = point;
            }
            else {
                prevPoint = series.emptyPointSettings.mode === 'Drop' ? prevPoint : null;
                startPoint = series.emptyPointSettings.mode === 'Drop' ? startPoint : 'M';
            }
        }
        if (visiblePoints.length > 0) {
            point1 = getPoint(visiblePoints[visiblePoints.length - 1].xValue + lineLength, visiblePoints[visiblePoints.length - 1].yValue, xAxis, yAxis, isInverted);
            direction = direction.concat(startPoint + ' ' + (point1.x) + ' ' + (point1.y) + ' ');
        }
        var pathOptions = new PathOption(series.chart.element.id + '_Series_' + series.index, 'transparent', series.width, series.interior, series.opacity, series.dashArray, direction);
        this.appendLinePath(pathOptions, series, '');
        this.renderMarker(series);
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    StepLineSeries.prototype.doAnimation = function (series) {
        var option = series.animation;
        this.doLinearAnimation(series, option);
    };
    /**
     * To destroy the step line series.
     *
     * @returns {void}
     * @private
     */
    StepLineSeries.prototype.destroy = function () {
        /**
         * Destroy method calling here
         */
    };
    /**
     * Get module name.
     */
    StepLineSeries.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'StepLineSeries';
    };
    return StepLineSeries;
}(LineBase));

var __extends$27 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `StepAreaSeries` Module used to render the step area series.
 */
var StepAreaSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$27(StepAreaSeries, _super);
    function StepAreaSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render StepArea series.
     *
     * @returns {void}
     * @private
     */
    StepAreaSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {
        var currentPoint;
        var secondPoint;
        var start = null;
        var direction = '';
        var visiblePoints = this.enableComplexProperty(series);
        var pointsLength = visiblePoints.length;
        var origin = Math.max(series.yAxis.visibleRange.min, 0);
        var point;
        var xValue;
        var lineLength;
        var prevPoint = null;
        var emptyPointDirection = '';
        if (xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks') {
            lineLength = 0.5;
        }
        else {
            lineLength = 0;
        }
        for (var i = 0; i < pointsLength; i++) {
            point = visiblePoints[i];
            xValue = point.xValue;
            point.symbolLocations = [];
            point.regions = [];
            if (point.visible && withInRange(visiblePoints[i - 1], point, visiblePoints[i + 1], series)) {
                if (start === null) {
                    start = new ChartLocation(xValue, 0);
                    // Start point for the current path
                    currentPoint = getPoint(xValue - lineLength, origin, xAxis, yAxis, isInverted);
                    direction += ('M' + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');
                    currentPoint = getPoint(xValue - lineLength, point.yValue, xAxis, yAxis, isInverted);
                    direction += ('L' + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');
                }
                // First Point to draw the Steparea path
                if (prevPoint != null) {
                    currentPoint = getPoint(point.xValue, point.yValue, xAxis, yAxis, isInverted);
                    secondPoint = getPoint(prevPoint.xValue, prevPoint.yValue, xAxis, yAxis, isInverted);
                    direction = direction.concat(this.GetStepLineDirection(currentPoint, secondPoint, series.step));
                }
                else if (series.emptyPointSettings.mode === 'Gap') {
                    currentPoint = getPoint(point.xValue, point.yValue, xAxis, yAxis, isInverted);
                    direction += 'L' + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ';
                }
                this.storePointLocation(point, series, isInverted, getPoint);
                prevPoint = point;
            }
            if (visiblePoints[i + 1] && !visiblePoints[i + 1].visible && series.emptyPointSettings.mode !== 'Drop') {
                // current start point
                currentPoint = getPoint(xValue + lineLength, origin, xAxis, yAxis, isInverted);
                direction += ('L' + ' ' + (currentPoint.x) + ' ' + (currentPoint.y));
                start = null;
                prevPoint = null;
            }
        }
        if ((pointsLength > 1) && direction !== '') {
            start = { 'x': visiblePoints[pointsLength - 1].xValue + lineLength, 'y': visiblePoints[pointsLength - 1].yValue };
            secondPoint = getPoint(start.x, start.y, xAxis, yAxis, isInverted);
            direction += ('L' + ' ' + (secondPoint.x) + ' ' + (secondPoint.y) + ' ');
            start = { 'x': visiblePoints[pointsLength - 1].xValue + lineLength, 'y': origin };
            secondPoint = getPoint(start.x, start.y, xAxis, yAxis, isInverted);
            direction += ('L' + ' ' + (secondPoint.x) + ' ' + (secondPoint.y) + ' ');
        }
        else {
            direction = '';
        }
        var options = new PathOption(series.chart.element.id + '_Series_' + series.index, series.interior, 0, 'transparent', series.opacity, series.dashArray, direction);
        this.appendLinePath(options, series, '');
        /**
         * To draw border for the path directions of area
         */
        if (series.border.width !== 0) {
            emptyPointDirection = this.removeEmptyPointsBorder(this.getBorderDirection(direction));
            var options_1 = new PathOption(series.chart.element.id + '_Series_border_' + series.index, 'transparent', series.border.width, series.border.color ? series.border.color : series.interior, 1, series.dashArray, emptyPointDirection);
            this.appendLinePath(options_1, series, '');
        }
        this.renderMarker(series);
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    StepAreaSeries.prototype.doAnimation = function (series) {
        var option = series.animation;
        this.doLinearAnimation(series, option);
    };
    /**
     * To destroy the step Area series.
     *
     * @returns {void}
     * @private
     */
    StepAreaSeries.prototype.destroy = function () {
        /**
         * Destroy method calling here
         */
    };
    /**
     * Get module name.
     */
    StepAreaSeries.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'StepAreaSeries';
    };
    return StepAreaSeries;
}(LineBase));

var __extends$28 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable max-len */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `StackingAreaSeries` module used to render the Stacking Area series.
 */
var StackingAreaSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$28(StackingAreaSeries, _super);
    function StackingAreaSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render the Stacking area series.
     *
     * @returns {void}
     * @private
     */
    StackingAreaSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {
        var polarAreaType = series.chart.chartAreaType === 'PolarRadar';
        var getCoordinate = polarAreaType ? TransformToVisible : getPoint;
        var lineDirection = '';
        var visiblePoints = this.enableComplexProperty(series);
        var pointsLength = visiblePoints.length;
        var stackedvalue = series.stackedValues;
        var pointIndex;
        var nextPointIndex;
        var origin = polarAreaType ?
            Math.max(series.yAxis.visibleRange.min, stackedvalue.endValues[0]) :
            Math.max(series.yAxis.visibleRange.min, stackedvalue.startValues[0]);
        var startPoint = 0;
        var point1;
        var point2;
        var emptyPointDirection = '';
        if (pointsLength > 0) {
            point1 = getCoordinate(visiblePoints[0].xValue, origin, xAxis, yAxis, isInverted, series);
            lineDirection = lineDirection.concat('M' + ' ' + (point1.x) + ' ' + (point1.y) + ' ');
        }
        var isPolar = (series.chart && series.chart.chartAreaType === 'PolarRadar');
        for (var i = 0; i < pointsLength; i++) {
            pointIndex = visiblePoints[i].index;
            visiblePoints[i].symbolLocations = [];
            visiblePoints[i].regions = [];
            if (visiblePoints[i].visible && withInRange(visiblePoints[i - 1], visiblePoints[i], visiblePoints[i + 1], series)) {
                point1 = getCoordinate(visiblePoints[i].xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted, series);
                lineDirection = lineDirection.concat('L' + ' ' + (point1.x) + ' ' + (point1.y) + ' ');
                visiblePoints[i].symbolLocations.push(getCoordinate(visiblePoints[i].xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted, series));
                visiblePoints[i].regions.push(new Rect(visiblePoints[i].symbolLocations[0].x - series.marker.width, visiblePoints[i].symbolLocations[0].y - series.marker.height, 2 * series.marker.width, 2 * series.marker.height));
            }
            else {
                if (!isPolar && series.emptyPointSettings.mode !== 'Drop') {
                    for (var j = i - 1; j >= startPoint; j--) {
                        pointIndex = visiblePoints[j].index;
                        point2 = getCoordinate(visiblePoints[j].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted, series);
                        lineDirection = lineDirection.concat('L' + ' ' + (point2.x) + ' ' + (point2.y) + ' ');
                    }
                    if (visiblePoints[i + 1] && (visiblePoints[i + 1].visible &&
                        (!isPolar || (isPolar && this.withinYRange(visiblePoints[i + 1], yAxis))))) {
                        nextPointIndex = visiblePoints[i + 1].index;
                        point1 = getCoordinate(visiblePoints[i + 1].xValue, stackedvalue.startValues[nextPointIndex], xAxis, yAxis, isInverted, series);
                        lineDirection = lineDirection.concat('M' + ' ' + (point1.x) + ' ' + (point1.y) + ' ');
                    }
                    startPoint = i + 1;
                }
            }
        }
        if (series.chart.chartAreaType === 'PolarRadar' && visiblePoints.length > 1) {
            var connectPoints = this.getFirstLastVisiblePoint(series.points);
            var chart = this.chart;
            point1 = { 'x': connectPoints.first.xValue, 'y': stackedvalue.endValues[connectPoints.first.index] };
            point2 = getCoordinate(point1.x, point1.y, xAxis, yAxis, isInverted, series);
            lineDirection += ('L' + ' ' + (point2.x) + ' ' + (point2.y) + ' ');
            if (this.chart.visible === 1 && (xAxis.isAxisInverse || yAxis.isAxisInverse)) {
                this.chart.enableAnimation = false;
                lineDirection = (series.type === 'Polar' ? chart.polarSeriesModule.getPolarIsInversedPath(xAxis, lineDirection) :
                    chart.radarSeriesModule.getRadarIsInversedPath(xAxis, lineDirection));
            }
        }
        if (!isPolar || (isPolar && series.index !== this.getFirstSeriesIndex(series.chart.visibleSeries))) {
            for (var j = pointsLength - 1; j >= startPoint; j--) {
                pointIndex = visiblePoints[j].index;
                if (isPolar && !visiblePoints[j].visible) {
                    continue;
                }
                var previousSeries = this.getPreviousSeries(series);
                if (previousSeries.emptyPointSettings.mode !== 'Drop' || !previousSeries.points[j].isEmpty) {
                    point2 = getCoordinate(visiblePoints[j].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted, series);
                    if (stackedvalue.startValues[pointIndex] === stackedvalue.endValues[pointIndex]) {
                        point2.y = Math.floor(point2.y);
                    }
                    lineDirection = lineDirection.concat(((j === (pointsLength - 1) && polarAreaType) ? 'M' : 'L')
                        + ' ' + (point2.x) + ' ' + (point2.y) + ' ');
                }
            }
        }
        var options = new PathOption(series.chart.element.id + '_Series_' + series.index, series.interior, 0, 'transparent', series.opacity, series.dashArray, lineDirection);
        this.appendLinePath(options, series, '');
        /**
         * To draw border for the path directions of area
         */
        if (series.border.width !== 0) {
            emptyPointDirection = this.removeEmptyPointsBorder(this.getBorderDirection(lineDirection));
            var options_1 = new PathOption(series.chart.element.id + '_Series_border_' + series.index, 'transparent', series.border.width, series.border.color ? series.border.color : series.interior, 1, series.dashArray, emptyPointDirection);
            this.appendLinePath(options_1, series, '');
        }
        this.renderMarker(series);
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    StackingAreaSeries.prototype.doAnimation = function (series) {
        var option = series.animation;
        this.doLinearAnimation(series, option);
    };
    /**
     * To destroy the stacking area.
     *
     * @returns {void}
     * @private
     */
    StackingAreaSeries.prototype.destroy = function () {
        /**
         * Destroy method calling here
         */
    };
    /**
     * Get module name.
     */
    StackingAreaSeries.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'StackingAreaSeries';
    };
    /**
     * To find previous visible series
     */
    StackingAreaSeries.prototype.getPreviousSeries = function (series) {
        var seriesCollection = series.chart.visibleSeries;
        for (var i = 0, length_1 = seriesCollection.length; i < length_1; i++) {
            if (series.index === seriesCollection[i].index && i !== 0) {
                return seriesCollection[i - 1];
            }
        }
        return seriesCollection[0];
    };
    /**
     * To find the first visible series index
     *
     * @param {Series[]} seriesCollection first visible series index
     */
    StackingAreaSeries.prototype.getFirstSeriesIndex = function (seriesCollection) {
        for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {
            var series = seriesCollection_1[_i];
            if (series.visible) {
                return series.index;
            }
        }
        return 0;
    };
    return StackingAreaSeries;
}(LineBase));

var __extends$29 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable max-len */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `StackingStepAreaSeries` module used to render the Stacking Step Area series.
 */
var StackingStepAreaSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$29(StackingStepAreaSeries, _super);
    function StackingStepAreaSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render the Stacking step area series.
     *
     * @returns {void}
     * @private
     */
    StackingStepAreaSeries.prototype.render = function (stackSeries, xAxis, yAxis, isInverted) {
        var currentPointLocation;
        var secondPoint;
        var start = null;
        var direction = '';
        var borderDirection = '';
        var stackedvalue = stackSeries.stackedValues;
        var visiblePoint = this.enableComplexProperty(stackSeries);
        var origin = Math.max(stackSeries.yAxis.visibleRange.min, stackedvalue.startValues[0]);
        var pointsLength = visiblePoint.length;
        var options;
        var point;
        var point2;
        var point3;
        var xValue;
        var lineLength;
        var prevPoint = null;
        var validIndex;
        var startPoint = 0;
        var pointIndex;
        if (xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks') {
            lineLength = 0.5;
        }
        else {
            lineLength = 0;
        }
        for (var i = 0; i < pointsLength; i++) {
            point = visiblePoint[i];
            xValue = point.xValue;
            point.symbolLocations = [];
            point.regions = [];
            pointIndex = point.index;
            if (point.visible && withInRange(visiblePoint[i - 1], point, visiblePoint[i + 1], stackSeries)) {
                if (start === null) {
                    start = new ChartLocation(xValue, 0);
                    currentPointLocation = getPoint(xValue - lineLength, origin, xAxis, yAxis, isInverted);
                    direction += ('M' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ');
                    currentPointLocation = getPoint(xValue - lineLength, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);
                    direction += ('L' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ');
                    borderDirection += ('M' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ');
                }
                if (prevPoint != null) {
                    currentPointLocation = getPoint(point.xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);
                    secondPoint = getPoint(prevPoint.xValue, stackedvalue.endValues[prevPoint.index], xAxis, yAxis, isInverted);
                    direction += (this.GetStepLineDirection(currentPointLocation, secondPoint, stackSeries.step));
                    borderDirection += (this.GetStepLineDirection(currentPointLocation, secondPoint, stackSeries.step));
                }
                else if (stackSeries.emptyPointSettings.mode === 'Gap') {
                    currentPointLocation = getPoint(point.xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);
                    direction += 'L' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ';
                    borderDirection += 'L' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ';
                }
                visiblePoint[i].symbolLocations.push(getPoint(visiblePoint[i].xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted));
                visiblePoint[i].regions.push(new Rect(visiblePoint[i].symbolLocations[0].x - stackSeries.marker.width, visiblePoint[i].symbolLocations[0].y - stackSeries.marker.height, 2 * stackSeries.marker.width, 2 * stackSeries.marker.height));
                prevPoint = point;
            }
            // If we set the empty point mode is Gap or next point of the current point is false, we will close the series path.
            if (visiblePoint[i + 1] && (!visiblePoint[i + 1].visible && start !== null) && stackSeries.emptyPointSettings.mode !== 'Drop') {
                var previousPointIndex = void 0;
                for (var j = i; j >= startPoint; j--) {
                    pointIndex = visiblePoint[j].index;
                    previousPointIndex = j === 0 ? 0 : visiblePoint[j - 1].index;
                    currentPointLocation = getPoint(visiblePoint[pointIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);
                    if (j !== 0 && (stackedvalue.startValues[pointIndex] < stackedvalue.startValues[previousPointIndex] ||
                        stackedvalue.startValues[pointIndex] > stackedvalue.startValues[previousPointIndex])) {
                        direction = direction.concat('L' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ');
                        secondPoint = getPoint(visiblePoint[previousPointIndex].xValue, stackedvalue.startValues[previousPointIndex], xAxis, yAxis, isInverted);
                    }
                    else {
                        secondPoint = getPoint(visiblePoint[pointIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);
                    }
                    if (visiblePoint[previousPointIndex].visible) {
                        direction = direction.concat(this.GetStepLineDirection(secondPoint, currentPointLocation, this.prevStep));
                    }
                }
                startPoint = i + 2;
                start = null;
                prevPoint = null;
            }
        }
        if (direction !== '') {
            // For category axis
            if (pointsLength > 1) {
                pointIndex = visiblePoint[pointsLength - 1].index;
                start = { 'x': visiblePoint[pointsLength - 1].xValue + lineLength, 'y': stackedvalue.endValues[pointIndex] };
                secondPoint = getPoint(start.x, start.y, xAxis, yAxis, isInverted);
                direction += ('L' + ' ' + (secondPoint.x) + ' ' + (secondPoint.y) + ' ');
                borderDirection += ('L' + ' ' + (secondPoint.x) + ' ' + (secondPoint.y) + ' ');
                start = { 'x': visiblePoint[pointsLength - 1].xValue + lineLength, 'y': stackedvalue.startValues[pointIndex] };
                secondPoint = getPoint(start.x, start.y, xAxis, yAxis, isInverted);
                direction += ('L' + ' ' + (secondPoint.x) + ' ' + (secondPoint.y) + ' ');
            }
            // To close the stacked step area series path in reverse order
            for (var j = pointsLength - 1; j >= startPoint; j--) {
                var index = void 0;
                if (visiblePoint[j].visible) {
                    pointIndex = visiblePoint[j].index;
                    point2 = getPoint(visiblePoint[j].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);
                    direction = direction.concat('L' + ' ' + (point2.x) + ' ' + (point2.y) + ' ');
                }
                if (j !== 0 && !visiblePoint[j - 1].visible) {
                    index = this.getNextVisiblePointIndex(visiblePoint, j);
                }
                if (j !== 0) {
                    validIndex = index ? index : j - 1;
                    pointIndex = index ? visiblePoint[index].index : visiblePoint[j - 1].index;
                    point3 = getPoint(visiblePoint[validIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);
                    if (!(j !== 0 && !visiblePoint[j - 1].visible)) {
                        direction = direction.concat(this.GetStepLineDirection(point3, point2, this.prevStep));
                    }
                }
            }
            this.prevStep = stackSeries.step === 'Right' ? 'Left' : stackSeries.step === 'Left' ? 'Right' : stackSeries.step;
            options = new PathOption(stackSeries.chart.element.id + '_Series_' + stackSeries.index, stackSeries.interior, 0, 'transparent', stackSeries.opacity, stackSeries.dashArray, direction);
            this.appendLinePath(options, stackSeries, '');
            /**
             * To draw border for the path directions of area
             */
            if (stackSeries.border.width !== 0) {
                options = new PathOption(stackSeries.chart.element.id + '_Series_border_' + stackSeries.index, 'transparent', stackSeries.border.width, stackSeries.border.color ? stackSeries.border.color : stackSeries.interior, 1, stackSeries.dashArray, borderDirection);
                this.appendLinePath(options, stackSeries, '');
            }
            this.renderMarker(stackSeries);
        }
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    StackingStepAreaSeries.prototype.doAnimation = function (series) {
        var option = series.animation;
        this.doLinearAnimation(series, option);
    };
    /**
     * To destroy the stacking step area.
     *
     * @returns {void}
     * @private
     */
    StackingStepAreaSeries.prototype.destroy = function () {
        /**
         * Destroy method calling here
         */
    };
    /**
     * Get module name.
     */
    StackingStepAreaSeries.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'StackingStepAreaSeries';
    };
    /**
     * To get the nearest visible point
     *
     * @param {Points[]} points points
     * @param {number} j index
     */
    StackingStepAreaSeries.prototype.getNextVisiblePointIndex = function (points, j) {
        var index;
        for (index = j - 1; index >= 0; index--) {
            if (!points[index].visible) {
                continue;
            }
            else {
                return index;
            }
        }
        return 0;
    };
    return StackingStepAreaSeries;
}(LineBase));

var __extends$30 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `StackingLineSeries` module used to render the Stacking Line series.
 */
var StackingLineSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$30(StackingLineSeries, _super);
    function StackingLineSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render the Stacking line series.
     *
     * @returns {void}
     * @private
     */
    StackingLineSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {
        var polarType = series.chart.chartAreaType === 'PolarRadar';
        var getCoordinate = polarType ? TransformToVisible : getPoint;
        var direction = '';
        var visiblePts = this.enableComplexProperty(series);
        var pointsLength = visiblePts.length;
        var stackedvalue = series.stackedValues;
        var pointIndex;
        var nextPointIndex;
        var point1;
        var point2;
        for (var i = 0; i < pointsLength; i++) {
            visiblePts[i].regions = [];
            visiblePts[i].symbolLocations = [];
            pointIndex = visiblePts[i].index;
            if (visiblePts[i].visible && withInRange(visiblePts[i - 1], visiblePts[i], visiblePts[i + 1], series)) {
                point1 = getCoordinate(visiblePts[i].xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted, series);
                direction = direction.concat((i ? 'L' : 'M') + ' ' + (point1.x) + ' ' + (point1.y) + ' ');
                visiblePts[i].symbolLocations.push(getCoordinate(visiblePts[i].xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted, series));
                visiblePts[i].regions.push(new Rect(visiblePts[i].symbolLocations[0].x - series.marker.width, visiblePts[i].symbolLocations[0].y - series.marker.height, 2 * series.marker.width, 2 * series.marker.height));
            }
            else {
                if (series.emptyPointSettings.mode !== 'Drop') {
                    if (visiblePts[i + 1] && visiblePts[i + 1].visible) {
                        nextPointIndex = visiblePts[i + 1].index;
                        point1 = getCoordinate(visiblePts[i + 1].xValue, stackedvalue.endValues[nextPointIndex], xAxis, yAxis, isInverted, series);
                        direction = direction.concat('M' + ' ' + (point1.x) + ' ' + (point1.y) + ' ');
                    }
                }
            }
        }
        if (series.chart.chartAreaType === 'PolarRadar' && visiblePts.length > 1) {
            point1 = { 'y': stackedvalue.endValues[0], 'x': series.points[0].xValue };
            point2 = getCoordinate(point1.x, point1.y, xAxis, yAxis, isInverted, series);
            direction += ('L' + ' ' + (point2.x) + ' ' + (point2.y) + ' ');
        }
        var options = new PathOption(series.chart.element.id + '_Series_' + series.index, 'none', series.width, series.interior, series.opacity, series.dashArray, direction);
        this.appendLinePath(options, series, '');
        this.renderMarker(series);
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    StackingLineSeries.prototype.doAnimation = function (series) {
        var option = series.animation;
        this.doLinearAnimation(series, option);
    };
    /**
     * To destroy the stacking line.
     *
     * @returns {void}
     * @private
     */
    StackingLineSeries.prototype.destroy = function () {
        /**
         * Destroy method calling here
         */
    };
    /**
     * Get module name.
     */
    StackingLineSeries.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'StackingLineSeries';
    };
    return StackingLineSeries;
}(LineBase));

/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable @typescript-eslint/ban-types */
/**
 * `ScatterSeries` module is used to render the scatter series.
 */
var ScatterSeries = /** @__PURE__ @class */ (function () {
    function ScatterSeries() {
    }
    /**
     * Render the scatter series.
     *
     * @returns {void}
     * @private
     */
    ScatterSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {
        // Scatter series DataLabel is not rendered after selecting StackingColumn
        series.isRectSeries = false;
        var marker = series.marker;
        var visiblePoints = this.enableComplexProperty(series);
        var argsData;
        var getCoordinate = series.chart.chartAreaType === 'PolarRadar' ? TransformToVisible : getPoint;
        var startLocation;
        var redraw = series.chart.redraw;
        var scatterBorder = {
            width: this.isLineShapeMarker(marker.shape) ? series.width : series.border.width,
            color: this.isLineShapeMarker(marker.shape) ? series.interior : series.border.color
        };
        for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {
            var point = visiblePoints_1[_i];
            startLocation = (redraw && point.symbolLocations) ? point.symbolLocations[0] : null;
            point.symbolLocations = [];
            point.regions = [];
            if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {
                argsData = {
                    cancel: false, name: pointRender, series: series, point: point,
                    fill: series.setPointColor(point, series.interior),
                    border: series.setBorderColor(point, scatterBorder),
                    height: marker.height, width: marker.width, shape: marker.shape
                };
                series.chart.trigger(pointRender, argsData);
                if (!argsData.cancel) {
                    point.symbolLocations.push(getCoordinate(point.xValue, point.yValue, xAxis, yAxis, isInverted, series));
                    point.color = argsData.fill;
                    this.refresh(series, point, argsData, startLocation);
                }
                else {
                    point.marker = { visible: true };
                }
            }
        }
    };
    ScatterSeries.prototype.isLineShapeMarker = function (shape) {
        return shape === 'HorizontalLine' || shape === 'VerticalLine' || shape === 'Cross';
    };
    /**
     * To improve the chart performance.
     *
     * @returns {void}
     * @private
     */
    ScatterSeries.prototype.enableComplexProperty = function (series) {
        var tempPoints2 = [];
        var tempPoints = [];
        var yVisibleRange = series.yAxis.visibleRange;
        var xVisibleRange = series.xAxis.visibleRange;
        var areaBounds = series.clipRect;
        var seriesPoints = series.points;
        var yTolerance = Math.abs(yVisibleRange.delta / areaBounds.height);
        var xTolerance = Math.abs(xVisibleRange.delta / areaBounds.width);
        var prevYValue = (seriesPoints[0] && seriesPoints[0].y > yTolerance) ? 0 : yTolerance;
        var prevXValue = (seriesPoints[0] && seriesPoints[0].x > xTolerance) ? 0 : xTolerance;
        var yVal = 0;
        var xVal = 0;
        for (var _i = 0, seriesPoints_1 = seriesPoints; _i < seriesPoints_1.length; _i++) {
            var currentPoint = seriesPoints_1[_i];
            currentPoint.symbolLocations = [];
            yVal = currentPoint.yValue ? currentPoint.yValue : yVisibleRange.min;
            xVal = currentPoint.xValue ? currentPoint.xValue : xVisibleRange.min;
            if (Math.abs(prevYValue - yVal) >= yTolerance || Math.abs(prevXValue - xVal) >= xTolerance) {
                tempPoints.push(currentPoint);
                prevYValue = yVal;
                prevXValue = xVal;
            }
        }
        var currentTempPoint;
        for (var i = 0; i < tempPoints.length; i++) {
            currentTempPoint = tempPoints[i];
            if (isNullOrUndefined(currentTempPoint.x) || currentTempPoint.x === '') {
                continue;
            }
            else {
                tempPoints2.push(currentTempPoint);
            }
        }
        return tempPoints2;
    };
    /**
     * To append scatter element
     *
     * @param {Series} series series
     * @param {Points} point point
     * @param {IPointRenderEventArgs} argsData argsData
     * @param {ChartLocation} startLocation startLocation
     * @returns {void}
     */
    ScatterSeries.prototype.refresh = function (series, point, argsData, startLocation) {
        var chart = series.chart;
        var circlePath;
        var previousPath;
        var marker = series.marker;
        var imageURL = argsData.point.marker.imageUrl || marker.imageUrl;
        var shapeOption = new PathOption(chart.element.id + '_Series_' + series.index + '_Point_' + point.index, argsData.fill, argsData.border.width, (series.chart.enableCanvas && !argsData.border.color) ? argsData.fill : argsData.border.color, series.opacity, null);
        if (chart.redraw && getElement$1(shapeOption.id)) {
            circlePath = argsData.shape === 'Circle' ? 'c' : '';
            previousPath = getElement$1(shapeOption.id).getAttribute('d');
        }
        var element = drawSymbol(point.symbolLocations[0], argsData.shape, new Size(argsData.width, argsData.height), imageURL, shapeOption, point.x.toString() + ':' + point.yValue.toString(), series.chart.renderer, series.clipRect);
        appendChildElement(series.chart.enableCanvas, series.seriesElement, element, chart.redraw, true, circlePath + 'x', circlePath + 'y', startLocation, previousPath, false, false, null, null, true);
        point.regions.push(new Rect(point.symbolLocations[0].x - marker.width, point.symbolLocations[0].y - marker.height, 2 * marker.width, 2 * marker.height));
        point.marker = {
            border: argsData.border, fill: argsData.fill,
            height: argsData.height, visible: true,
            width: argsData.width, shape: argsData.shape, imageUrl: imageURL
        };
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    ScatterSeries.prototype.doAnimation = function (series) {
        var duration = series.animation.duration;
        var delay = series.animation.delay;
        var rectElements = series.seriesElement.childNodes;
        var count = 1;
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var point = _a[_i];
            if (!point.symbolLocations.length || !rectElements[count]) {
                continue;
            }
            markerAnimate(rectElements[count], delay, duration, series, point.index, point.symbolLocations[0], false);
            count++;
        }
    };
    /**
     * Get module name.
     */
    ScatterSeries.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'ScatterSeries';
    };
    /**
     * To destroy the scatter.
     *
     * @returns {void}
     */
    ScatterSeries.prototype.destroy = function () {
        /**
         * Destroy method calling here
         */
    };
    return ScatterSeries;
}());

var __extends$31 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-returns */
/**
 * `RangeColumnSeries` module is used to render the range column series.
 */
var RangeColumnSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$31(RangeColumnSeries, _super);
    function RangeColumnSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render Range Column series.
     *
     * @returns {void}
     * @private
     */
    RangeColumnSeries.prototype.render = function (series) {
        var rect;
        var sideBySideInfo = this.getSideBySideInfo(series);
        //let origin: number = Math.max(<number>series.yAxis.visibleRange.min, 0);
        var argsData;
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var rangePoint = _a[_i];
            rangePoint.symbolLocations = [];
            rangePoint.regions = [];
            if (rangePoint.visible && withInRange(series.points[rangePoint.index - 1], rangePoint, series.points[rangePoint.index + 1], series)) {
                rect = this.getRectangle(rangePoint.xValue + sideBySideInfo.start, rangePoint.high, rangePoint.xValue + sideBySideInfo.end, rangePoint.low, series);
                rect.width = series.columnWidthInPixel ? series.columnWidthInPixel : rect.width;
                rect.x = series.columnWidthInPixel ? rect.x - (((series.columnWidthInPixel / 2) * series.rectCount) -
                    (series.columnWidthInPixel * series.index)) : rect.x;
                argsData = this.triggerEvent(series, rangePoint, series.interior, { width: series.border.width, color: series.border.color });
                if (!argsData.cancel) {
                    this.updateSymbolLocation(rangePoint, rect, series);
                    this.drawRectangle(series, rangePoint, rect, argsData);
                }
            }
        }
        this.renderMarker(series);
    };
    /**
     * Get module name.
     */
    RangeColumnSeries.prototype.getModuleName = function () {
        return 'RangeColumnSeries';
        /**
         * return the module name
         */
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    RangeColumnSeries.prototype.doAnimation = function (series) {
        this.animate(series);
    };
    /**
     * To destroy the range column series.
     *
     * @returns {void}
     * @private
     */
    RangeColumnSeries.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return RangeColumnSeries;
}(ColumnBase));

var __extends$32 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * `RangeStepAreaSeries` Module used to render the range step area series.
 */
var RangeStepAreaSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$32(RangeStepAreaSeries, _super);
    function RangeStepAreaSeries() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.borderDirection = '';
        _this.prevPoint = null;
        return _this;
    }
    /**
     * Render RangeStepArea series.
     *
     * @returns {void}
     * @private
     */
    RangeStepAreaSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {
        this.prevPoint = null;
        var point;
        var currentPoint;
        var secondPoint;
        var start = null;
        var direction = '';
        var lineLength = 0;
        var command = 'M';
        var closed = undefined;
        var low;
        var high;
        var borderWidth = series.border.width ? series.border.width : 0;
        var borderColor = series.border.color ? series.border.color : series.interior;
        var origin = Math.max(series.yAxis.visibleRange.min, 0);
        var visiblePoints = this.enableComplexProperty(series);
        if (xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks') {
            lineLength = 0.5;
        }
        for (var i = 0, length_1 = visiblePoints.length; i < length_1; i++) {
            point = visiblePoints[i];
            point.symbolLocations = [];
            point.regions = [];
            low = Math.min(point.low, point.high);
            high = Math.max(point.low, point.high);
            if (yAxis.isAxisInverse) {
                var temp = low;
                low = high;
                high = temp;
            }
            var lowPoint = getPoint(point.xValue, low, xAxis, yAxis, isInverted);
            var highPoint = getPoint(point.xValue, high, xAxis, yAxis, isInverted);
            point.symbolLocations.push(highPoint);
            point.symbolLocations.push(lowPoint);
            var rect = new Rect(Math.min(lowPoint.x, highPoint.x), Math.min(lowPoint.y, highPoint.y), Math.max(Math.abs(highPoint.x - lowPoint.x), series.marker.width), Math.max(Math.abs(highPoint.y - lowPoint.y), series.marker.width));
            point.regions.push(rect);
            //Path to connect the high points.
            if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {
                if (start === null) {
                    start = new ChartLocation(point.xValue, 0);
                    // Start point for the current path.
                    currentPoint = getPoint(point.xValue - lineLength, origin, xAxis, yAxis, isInverted);
                    direction += (command + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');
                    currentPoint = getPoint(point.xValue - lineLength, point.high > point.low ? point.high
                        : point.low, xAxis, yAxis, isInverted);
                    direction += ('L' + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');
                    this.borderDirection += (command + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');
                }
                // First Point to draw the RangeStepArea path.
                if (this.prevPoint != null) {
                    currentPoint = getPoint(point.xValue, point.high > point.low ? point.high
                        : point.low, xAxis, yAxis, isInverted);
                    secondPoint = getPoint(this.prevPoint.xValue, this.prevPoint.high > this.prevPoint.low ? this.prevPoint.high
                        : this.prevPoint.low, xAxis, yAxis, isInverted);
                    direction += (this.GetStepLineDirection(currentPoint, secondPoint, series.step, command));
                    this.borderDirection += (this.GetStepLineDirection(currentPoint, secondPoint, series.step, command));
                }
                else if (series.emptyPointSettings.mode === 'Gap') {
                    currentPoint = getPoint(point.xValue, point.high > point.low ? point.high
                        : point.low, xAxis, yAxis, isInverted);
                    direction += command + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ';
                    this.borderDirection += command + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ';
                }
                closed = false;
                command = ' L';
                this.prevPoint = point;
                if ((i + 1 < visiblePoints.length && !visiblePoints[i + 1].visible)
                    || i === visiblePoints.length - 1) {
                    // Path to connect the low points.
                    direction = this.closeRangeStepAreaPath(visiblePoints, point, series, direction, i, xAxis, yAxis, isInverted);
                    command = 'M';
                    direction = direction.concat(' ' + 'Z ');
                    closed = true;
                    this.prevPoint = null;
                    start = null;
                }
            }
            else {
                if (closed === false && i !== 0) {
                    direction = this.closeRangeStepAreaPath(visiblePoints, point, series, direction, i, xAxis, yAxis, isInverted);
                    closed = true;
                }
                command = 'M';
                point.symbolLocations = [];
            }
        }
        var options = new PathOption(series.chart.element.id + '_Series_' + series.index, series.interior, 0, 'transparent', series.opacity, series.dashArray, direction);
        this.appendLinePath(options, series, '');
        /**
         * To draw border for the range step area chart.
         */
        if (series.border.width !== 0) {
            this.appendLinePath(new PathOption(series.chart.element.id + '_Series_border_' + series.index, 'transparent', borderWidth, borderColor, 1, series.dashArray, this.borderDirection), series, '');
            this.borderDirection = '';
        }
        this.renderMarker(series);
    };
    /**
     * Calculating path direction for rendering the low points.
     *
     * @returns {void}.
     * @private
     */
    RangeStepAreaSeries.prototype.closeRangeStepAreaPath = function (visiblePoints, point, series, direction, i, xAxis, yAxis, isInverted) {
        var currentPoint;
        var secondPoint;
        var low;
        var high;
        for (var j = i; j >= 0; j--) {
            if (visiblePoints[j].visible) {
                point = visiblePoints[j];
                low = Math.min(point.low, point.high);
                high = Math.max(point.low, point.high);
                if (yAxis.isAxisInverse) {
                    var temp = low;
                    low = high;
                    high = temp;
                }
                // Lowpoint for RangeStepArea path.
                if (this.prevPoint != null) {
                    currentPoint = getPoint(point.xValue, point.low < point.high ? point.low
                        : point.high, xAxis, yAxis, isInverted);
                    secondPoint = getPoint(this.prevPoint.xValue, this.prevPoint.low < this.prevPoint.high ? this.prevPoint.low
                        : this.prevPoint.high, xAxis, yAxis, isInverted);
                    direction += (this.GetStepLineDirection(currentPoint, secondPoint, series.step));
                    if (j === i) {
                        this.borderDirection += (this.GetStepLineDirection(currentPoint, secondPoint, series.step, 'M'));
                    }
                    else {
                        this.borderDirection += (this.GetStepLineDirection(currentPoint, secondPoint, series.step, 'L'));
                    }
                }
            }
            else {
                break;
            }
            this.prevPoint = point;
        }
        return direction;
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    RangeStepAreaSeries.prototype.doAnimation = function (series) {
        var option = series.animation;
        this.doLinearAnimation(series, option);
    };
    /**
     * Get module name.
     */
    RangeStepAreaSeries.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series.
         */
        return 'RangeStepAreaSeries';
    };
    /**
     * To destroy the range step area series.
     *
     * @returns {void}
     * @private
     */
    RangeStepAreaSeries.prototype.destroy = function () {
        /**
         * Destroys range step area series.
         */
    };
    return RangeStepAreaSeries;
}(LineBase));

var __extends$33 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `WaterfallSeries` module is used to render the waterfall series.
 */
var WaterfallSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$33(WaterfallSeries, _super);
    function WaterfallSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render waterfall series.
     *
     * @returns {void}
     * @private
     */
    WaterfallSeries.prototype.render = function (series) {
        var rect;
        var sideBySideInfo = this.getSideBySideInfo(series);
        var origin = Math.max(series.yAxis.visibleRange.min, 0);
        var argsData;
        var prevEndValue = 0;
        var direction = '';
        var currentEndValue = 0;
        var originValue;
        var prevRegion = null;
        var y;
        var isInversed = series.chart.requireInvertedAxis;
        var intermediateOrigin = 0;
        var redraw = series.chart.redraw;
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var point = _a[_i];
            point.symbolLocations = [];
            point.regions = [];
            if (point.visible && withInRange(series.points[point.index - 1], point, series.points[point.index + 1], series)) {
                //Calcute the current point value to render waterfall series.
                var isSum = this.isIntermediateSum(series, point.index);
                var totalSum = this.isSumIndex(series, point.index);
                currentEndValue += isSum || totalSum === true ? 0 : point.yValue;
                //Calcute the origin value for points
                originValue = (isSum === true ? intermediateOrigin : ((prevEndValue !== null && !totalSum) ? prevEndValue : origin));
                rect = this.getRectangle(point.xValue + sideBySideInfo.start, currentEndValue, point.xValue + sideBySideInfo.end, originValue, series);
                argsData = this.triggerPointRenderEvent(series, point);
                //intermediateOrigin is used only for imtermediate data
                if (isSum) {
                    intermediateOrigin = currentEndValue;
                }
                prevEndValue = currentEndValue;
                if (!argsData.cancel) {
                    this.updateSymbolLocation(point, rect, series);
                    this.drawRectangle(series, point, rect, argsData);
                }
                var currentRegion = point.regions[0];
                if (prevRegion !== null) {
                    var prevLeft = isInversed ? prevRegion.x : prevRegion.y;
                    var currentLeft = isInversed ? currentRegion.x : currentRegion.y;
                    var prevBottom = void 0;
                    var currentBottom = void 0;
                    var currentYValue = currentRegion.y;
                    var currentXValue = currentRegion.x;
                    var beforePoint = series.points[point.index - 1];
                    if (point.yValue === 0) {
                        prevBottom = isInversed ? prevRegion.x + prevRegion.width : prevRegion.y + prevRegion.height;
                        currentBottom = isInversed ?
                            point.symbolLocations[0].x : point.symbolLocations[0].y;
                    }
                    else {
                        prevBottom = isInversed ? (beforePoint.yValue === 0) ?
                            beforePoint.symbolLocations[0].x : prevRegion.x + prevRegion.width : (beforePoint.yValue === 0) ?
                            beforePoint.symbolLocations[0].y : prevRegion.y + prevRegion.height;
                        currentBottom = isInversed ?
                            currentRegion.x + currentRegion.width : currentRegion.y + currentRegion.height;
                    }
                    if (Math.round(prevLeft) === Math.round(currentLeft) ||
                        Math.round(prevBottom) === Math.round(currentLeft)) {
                        y = isInversed ? (currentRegion.x === 0 && prevRegion.x === 0) ? currentBottom : currentRegion.x : currentRegion.y;
                        y = (point.yValue === 0) ?
                            (isInversed ? point.symbolLocations[0].x : point.symbolLocations[0].y) : y;
                    }
                    else {
                        y = currentBottom;
                    }
                    if (isInversed) {
                        if (beforePoint.yValue === 0) {
                            prevRegion.y = ((prevRegion.y + prevRegion.height / 2) + (rect.height / 2)) - prevRegion.height;
                        }
                        if (point.yValue === 0) {
                            currentYValue = ((currentRegion.y + currentRegion.height / 2) - (rect.height / 2));
                        }
                        direction = direction.concat('M' + ' ' + y + ' ' + (prevRegion.y + prevRegion.height) + ' ' +
                            'L' + ' ' + y + ' ' + currentYValue + ' ');
                    }
                    else {
                        if (beforePoint.yValue === 0) {
                            prevRegion.x = ((prevRegion.x + prevRegion.width / 2) - (rect.width / 2));
                            currentXValue = ((currentRegion.x + currentRegion.width / 2) + (rect.width / 2)) - currentRegion.width;
                        }
                        direction = direction.concat('M' + ' ' + prevRegion.x + ' ' + y + ' ' +
                            'L' + ' ' + (currentXValue + currentRegion.width) + ' ' + y + ' ');
                    }
                }
                prevRegion = point.regions[0];
            }
        }
        var options = new PathOption(series.chart.element.id + '_Series_' + series.index + '_Connector_', 'none', series.connector.width, series.connector.color, series.opacity, series.connector.dashArray, direction);
        if (redraw && getElement$1(options.id)) {
            direction = getElement$1(options.id).getAttribute('d');
        }
        var element = (redrawElement(redraw, options.id, options, series.chart.renderer) ||
            series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y])));
        element.style.visibility = (!series.chart.enableCanvas) ? ((((series.animation.enable && animationMode != 'Disable') || animationMode === 'Enable') && series.chart.animateSeries) ?
            'hidden' : 'visible') : null;
        appendChildElement(series.chart.enableCanvas, series.seriesElement, element, redraw, true, null, null, null, direction);
        this.renderMarker(series);
    };
    /**
     * To check intermediateSumIndex in waterfall series.
     *
     * @returns {boolean} check intermediateSumIndex
     * @private
     */
    WaterfallSeries.prototype.isIntermediateSum = function (series, index) {
        if (series.intermediateSumIndexes !== undefined && series.intermediateSumIndexes.indexOf(index) !== -1) {
            return true;
        }
        return false;
    };
    /**
     * To check sumIndex in waterfall series.
     *
     * @returns {boolean} check sumIndex
     * @private
     */
    WaterfallSeries.prototype.isSumIndex = function (series, index) {
        if (series.sumIndexes !== undefined && series.sumIndexes.indexOf(index) !== -1) {
            return true;
        }
        return false;
    };
    /**
     * To trigger the point rendering event for waterfall series.
     *
     * @returns {IPointRenderEventArgs} point rendering event values
     * @private
     */
    WaterfallSeries.prototype.triggerPointRenderEvent = function (series, point) {
        var color;
        var isSum = this.isIntermediateSum(series, point.index);
        var totalSum = this.isSumIndex(series, point.index);
        if (isSum || totalSum) {
            color = series.summaryFillColor;
        }
        else if (point.y < 0) {
            color = series.negativeFillColor;
        }
        else {
            color = series.interior;
        }
        return this.triggerEvent(series, point, color, { color: series.border.color, width: series.border.width });
    };
    /**
     * Add sumIndex and intermediateSumIndex data.
     *
     * @returns {object[]} data
     * @private
     */
    WaterfallSeries.prototype.processInternalData = function (json, series) {
        var data = json;
        var index;
        var sumValue = 0;
        var intermediateSum = series.intermediateSumIndexes;
        var sumIndex = series.sumIndexes;
        if (intermediateSum !== undefined && intermediateSum.length > 0) {
            for (var i = 0; i < intermediateSum.length; i++) {
                for (var j = 0; j < data.length; j++) {
                    if (j === intermediateSum[i]) {
                        if (i === 0) {
                            index = subArraySum(data, -1, intermediateSum[i], null, series);
                        }
                        else {
                            index = subArraySum(data, intermediateSum[i - 1], intermediateSum[i], null, series);
                        }
                        data[j][series.yName] = index;
                    }
                }
            }
        }
        if (sumIndex !== undefined && sumIndex.length > 0) {
            for (var k = 0; k < sumIndex.length; k++) {
                for (var j = 0; j < data.length; j++) {
                    if (j === sumIndex[k]) {
                        if (intermediateSum !== undefined) {
                            index = subArraySum(data, intermediateSum[k] - 1, sumIndex[k], sumIndex, series);
                        }
                        else {
                            if (k === 0) {
                                index = subArraySum(data, -1, sumIndex[k], null, series);
                            }
                            else {
                                index = subArraySum(data, sumIndex[k - 1], sumIndex[k], null, series);
                            }
                        }
                        sumValue += index;
                        data[j][series.yName] = sumValue;
                    }
                }
            }
        }
        return data;
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    WaterfallSeries.prototype.doAnimation = function (series) {
        this.animate(series);
    };
    /**
     * Get module name.
     */
    WaterfallSeries.prototype.getModuleName = function () {
        return 'WaterfallSeries';
        /**
         * return the module name
         */
    };
    /**
     * To destroy the waterfall series.
     *
     * @returns {void}
     * @private
     */
    WaterfallSeries.prototype.destroy = function () {
        /**
         * Destroys the waterfall series.
         */
    };
    return WaterfallSeries;
}(ColumnBase));

var __extends$34 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `HiloSeries` module is used to render the hilo series.
 */
var HiloSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$34(HiloSeries, _super);
    function HiloSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render Hiloseries.
     *
     * @returns {void}
     * @private
     */
    HiloSeries.prototype.render = function (series) {
        var region;
        var sideBySideInfo = this.getSideBySideInfo(series);
        var argsData;
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var point = _a[_i];
            point.symbolLocations = [];
            point.regions = [];
            if (point.visible &&
                withInRange(series.points[point.index - 1], point, series.points[point.index + 1], series)) {
                region = this.getRectangle(point.xValue + sideBySideInfo.median, point.high, point.xValue + sideBySideInfo.median, point.low, series);
                argsData = this.triggerPointRenderEvent(series, point);
                if (!argsData.cancel) {
                    if (!series.chart.requireInvertedAxis) {
                        region.width = argsData.border.width;
                        region.x = region.x - (region.width / 2);
                    }
                    else {
                        region.height = argsData.border.width;
                        region.y = region.y - (region.height / 2);
                    }
                    argsData.border.width = 0;
                    this.updateSymbolLocation(point, region, series);
                    this.drawRectangle(series, point, region, argsData);
                }
            }
        }
    };
    /**
     * To trigger the point rendering event.
     *
     * @returns {void}
     * @private
     */
    HiloSeries.prototype.triggerPointRenderEvent = function (series, point) {
        var border = { color: series.fill, width: Math.max(series.border.width, 2) };
        return _super.prototype.triggerEvent.call(this, series, point, series.interior, border);
    };
    /**
     * Get module name.
     */
    HiloSeries.prototype.getModuleName = function () {
        return 'HiloSeries';
        /**
         * return the module name
         */
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    HiloSeries.prototype.doAnimation = function (series) {
        this.animate(series);
    };
    /**
     * To destroy the Hilo series.
     *
     * @returns {void}
     * @private
     */
    HiloSeries.prototype.destroy = function () {
        /**
         * Destroys the Hilo Series
         */
    };
    return HiloSeries;
}(ColumnBase));

var __extends$35 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `HiloOpenCloseSeries` module is used to render the hiloOpenClose series.
 */
var HiloOpenCloseSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$35(HiloOpenCloseSeries, _super);
    function HiloOpenCloseSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render HiloOpenCloseSeries series.
     *
     * @returns {void}
     * @private
     */
    HiloOpenCloseSeries.prototype.render = function (series) {
        var highLowRect;
        var index1;
        var index2;
        var sideBySideInfo = this.getSideBySideInfo(series);
        var argsData;
        var borderWidth = Math.max(series.border.width, 2);
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var point = _a[_i];
            point.symbolLocations = [];
            point.regions = [];
            if (point.visible &&
                withInRange(series.points[point.index - 1], point, series.points[point.index + 1], series)) {
                //highlow
                highLowRect = this.getRectangle(point.xValue + sideBySideInfo.start, Math.max(point.high, point.low), point.xValue + sideBySideInfo.end, Math.min(point.high, point.low), series);
                point.regions.push(this.getRectangle(point.xValue + sideBySideInfo.median, Math.max(point.high, point.low), point.xValue + sideBySideInfo.median, Math.min(point.high, point.low), series));
                this.updateTickRegion(!series.chart.requireInvertedAxis, point.regions[0], borderWidth);
                //open
                point.regions.push(this.getRectangle(point.xValue + sideBySideInfo.start, Math.max(point.open, point.close), point.xValue + sideBySideInfo.median, Math.max(point.open, point.close), series));
                //close
                point.regions.push(this.getRectangle(point.xValue + sideBySideInfo.median, Math.min(point.open, point.close), point.xValue + sideBySideInfo.end, Math.min(point.open, point.close), series));
                argsData = this.triggerPointRenderEvent(series, point);
                if (!argsData.cancel) {
                    this.updateSymbolLocation(point, point.regions[0], series);
                    index1 = point.open > point.close ? 1 : 2;
                    index2 = point.open > point.close ? 2 : 1;
                    var open_1 = { x: point.regions[index1].x, y: point.regions[index1].y };
                    var close_1 = { x: point.regions[index2].x, y: point.regions[index2].y };
                    this.drawHiloOpenClosePath(series, point, open_1, close_1, highLowRect, argsData);
                }
                this.updateTickRegion(series.chart.requireInvertedAxis, point.regions[1], borderWidth);
                this.updateTickRegion(series.chart.requireInvertedAxis, point.regions[2], borderWidth);
            }
        }
    };
    /**
     * Updates the tick region
     */
    HiloOpenCloseSeries.prototype.updateTickRegion = function (horizontal, region, borderWidth) {
        if (horizontal) {
            region.x -= borderWidth / 2;
            region.width = borderWidth;
        }
        else {
            region.y -= borderWidth / 2;
            region.height = borderWidth;
        }
    };
    /**
     * Trigger point rendering event
     */
    HiloOpenCloseSeries.prototype.triggerPointRenderEvent = function (series, point) {
        var fill = (point.open <= point.close) ? series.bearFillColor || series.chart.themeStyle.bearFillColor :
            series.bullFillColor || series.chart.themeStyle.bullFillColor;
        var border = { color: series.border.color, width: Math.max(series.border.width, 1) };
        return this.triggerEvent(series, point, fill, border);
    };
    /**
     * To draw the rectangle for points.
     *
     * @returns {void}
     * @private
     */
    HiloOpenCloseSeries.prototype.drawHiloOpenClosePath = function (series, point, open, close, rect, argsData) {
        // region highlow
        var direction;
        if (series.chart.requireInvertedAxis) {
            direction = ('M' + ' ' + (rect.x) + ' ' + (rect.y + rect.height / 2) + ' ' +
                'L' + ' ' + (rect.x + rect.width) + ' ' + (rect.y + rect.height / 2) + ' ');
            direction += ('M' + ' ' + (open.x) + ' ' + (rect.y + rect.height / 2) + ' ' +
                'L' + ' ' + (open.x) + ' ' + (rect.y + rect.height) + ' ');
            direction += ('M' + ' ' + (close.x) + ' ' + (rect.y + rect.height / 2) + ' ' +
                'L' + ' ' + (close.x) + ' ' + (rect.y) + ' ');
        }
        else {
            direction = ('M' + ' ' + (rect.x + rect.width / 2) + ' ' + (rect.y + rect.height) + ' ' +
                'L' + ' ' + (rect.x + rect.width / 2) + ' ' + (rect.y) + ' ');
            //region opentick
            direction += ('M' + ' ' + (rect.x) + ' ' + (open.y) + ' ' +
                'L' + ' ' + (rect.x + rect.width / 2 + argsData.border.width / 2) + ' ' + (open.y) + ' ');
            //region closetick
            direction += ('M' + ' ' + (rect.x + rect.width / 2 - argsData.border.width / 2) + ' ' + (close.y) + ' ' +
                'L' + ' ' + (rect.x + rect.width) + ' ' + (close.y) + ' ');
        }
        var options = new PathOption(series.chart.element.id + '_Series_' + series.index + '_Point_' + point.index, argsData.fill, argsData.border.width, argsData.fill, series.opacity, series.dashArray, direction);
        pathAnimation(getElement$1(options.id), direction, series.chart.redraw);
        var element = series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));
        element.setAttribute('role', 'img');
        element.setAttribute('aria-label', point.x.toString() + ':' + point.high.toString()
            + ':' + point.low.toString() + ':' + point.close.toString() + ':' + point.open.toString());
        if (!series.chart.enableCanvas) {
            series.seriesElement.appendChild(element);
        }
    };
    /**
     * Get module name.
     */
    HiloOpenCloseSeries.prototype.getModuleName = function () {
        return 'HiloOpenCloseSeries';
        /**
         * return the module name
         */
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    HiloOpenCloseSeries.prototype.doAnimation = function (series) {
        this.animate(series);
    };
    /**
     * To destroy the column series.
     *
     * @returns {void}
     * @private
     */
    HiloOpenCloseSeries.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return HiloOpenCloseSeries;
}(ColumnBase));

var __extends$36 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `RangeAreaSeries` module is used to render the range area series.
 */
var RangeAreaSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$36(RangeAreaSeries, _super);
    function RangeAreaSeries() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.borderDirection = '';
        return _this;
    }
    /**
     * Render RangeArea Series.
     *
     * @returns {void}
     * @private
     */
    RangeAreaSeries.prototype.render = function (series, xAxis, yAxis, inverted) {
        var point;
        var direction = '';
        var command = 'M';
        var closed = undefined;
        var borderWidth = series.border.width ? series.border.width : 0;
        var borderColor = series.border.color ? series.border.color : series.interior;
        var visiblePoints = this.enableComplexProperty(series);
        for (var i = 0, length_1 = visiblePoints.length; i < length_1; i++) {
            point = visiblePoints[i];
            point.symbolLocations = [];
            point.regions = [];
            var low = Math.min(point.low, point.high);
            var high = Math.max(point.low, point.high);
            if (yAxis.isAxisInverse) {
                var temp = low;
                low = high;
                high = temp;
            }
            var lowPoint = getPoint(point.xValue, low, xAxis, yAxis, inverted);
            var highPoint = getPoint(point.xValue, high, xAxis, yAxis, inverted);
            point.symbolLocations.push(highPoint);
            point.symbolLocations.push(lowPoint);
            var rect = new Rect(Math.min(lowPoint.x, highPoint.x), Math.min(lowPoint.y, highPoint.y), Math.max(Math.abs(highPoint.x - lowPoint.x), series.marker.width), Math.max(Math.abs(highPoint.y - lowPoint.y), series.marker.width));
            if (!inverted) {
                rect.x -= series.marker.width / 2;
            }
            else {
                rect.y -= series.marker.width / 2;
            }
            point.regions.push(rect);
            //Path to connect the high points
            if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {
                direction = direction.concat(command + ' ' + (lowPoint.x) + ' ' + (lowPoint.y) + ' ');
                this.borderDirection += (command + ' ' + (lowPoint.x) + ' ' + (lowPoint.y) + ' ');
                closed = false;
                if ((i + 1 < visiblePoints.length && !visiblePoints[i + 1].visible)
                    || i === visiblePoints.length - 1) {
                    // Path to connect the low points
                    direction = this.closeRangeAreaPath(visiblePoints, point, series, direction, i);
                    command = 'M';
                    direction = direction.concat(' ' + 'Z');
                    closed = true;
                }
                command = 'L';
            }
            else {
                if (closed === false && i !== 0) {
                    direction = this.closeRangeAreaPath(visiblePoints, point, series, direction, i);
                    closed = true;
                }
                command = 'M';
                point.symbolLocations = [];
            }
        }
        var name = series.category === 'Indicator' ? series.chart.element.id + '_Indicator_' + series.index + '_' + series.name :
            series.chart.element.id + '_Series_' + series.index;
        var options = new PathOption(name, series.interior, 0, 'transparent', series.opacity, series.dashArray, direction);
        this.appendLinePath(options, series, '');
        /**
         * To draw border for the path directions of area
         */
        if (series.border.width !== 0) {
            this.appendLinePath(new PathOption(series.chart.element.id + '_Series_border_' + series.index, 'transparent', borderWidth, borderColor, 1, series.dashArray, this.borderDirection), series, '');
            this.borderDirection = '';
        }
        this.renderMarker(series);
    };
    /**
     * path for rendering the low points
     *
     * @returns {void}.
     * @private
     */
    RangeAreaSeries.prototype.closeRangeAreaPath = function (visiblePoints, point, series, direction, i) {
        for (var j = i; j >= 0; j--) {
            if (visiblePoints[j].visible && visiblePoints[j].symbolLocations[0]) {
                point = visiblePoints[j];
                direction += 'L' + ' ' + (point.symbolLocations[0].x) + ' ' + ((point.symbolLocations[0].y)) + ' ';
                this.borderDirection += (j === i ? 'M' : 'L') + ' ' + (point.symbolLocations[0].x) + ' ' + ((point.symbolLocations[0].y)) + ' ';
            }
            else {
                break;
            }
        }
        return direction;
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    RangeAreaSeries.prototype.doAnimation = function (series) {
        var option = series.animation;
        this.doLinearAnimation(series, option);
    };
    /**
     * Get module name.
     */
    RangeAreaSeries.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'RangeAreaSeries';
    };
    /**
     * To destroy the line series.
     *
     * @returns {void}
     * @private
     */
    RangeAreaSeries.prototype.destroy = function () {
        /**
         * Destroys range area series
         */
    };
    return RangeAreaSeries;
}(LineBase));

var __extends$38 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable max-len */
/* eslint-disable no-case-declarations */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * render Line series
 */
var SplineBase = /** @__PURE__ @class */ (function (_super) {
    __extends$38(SplineBase, _super);
    /** @private */
    function SplineBase(chartModule) {
        var _this = _super.call(this, chartModule) || this;
        _this.splinePoints = [];
        _this.lowSplinePoints = [];
        return _this;
    }
    /**
     * To find the control points for spline.
     *
     * @returns {void}
     * @private
     */
    SplineBase.prototype.findSplinePoint = function (series) {
        var value;
        var lowPoints;
        var realPoints = [];
        var points = [];
        var point;
        var pointIndex = 0;
        var negativePoint = false;
        realPoints = this.filterEmptyPoints(series);
        for (var i = 0; i < realPoints.length; i++) {
            point = realPoints[i];
            if (point.x === null || point.x === '') {
                continue;
            }
            else {
                point.index = pointIndex;
                pointIndex++;
                points.push(point);
            }
        }
        var isLow = false;
        this.splinePoints = this.findSplineCoefficients(points, series, isLow);
        if (series.type === 'SplineRangeArea') {
            isLow = !isLow;
            this.lowSplinePoints = this.findSplineCoefficients(points, series, isLow);
        }
        if (points.length > 1) {
            series.drawPoints = [];
            series.lowDrawPoints = [];
            for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
                var point_1 = points_1[_i];
                negativePoint = negativePoint ? negativePoint : point_1.yValue < 0;
                if (point_1.index !== 0) {
                    var previous = this.getPreviousIndex(points, point_1.index - 1, series);
                    if (series.type === 'SplineRangeArea') {
                        points[previous].yValue = points[previous].high > points[previous].low ? points[previous].high : points[previous].low;
                        point_1.yValue = point_1.high > point_1.low ? point_1.high : point_1.low;
                    }
                    value = this.getControlPoints(points[previous], point_1, this.splinePoints[previous], this.splinePoints[point_1.index], series);
                    series.drawPoints.push(value);
                    if (series.type === 'SplineRangeArea') {
                        points[previous].yValue = points[previous].low < points[previous].high ? points[previous].low : points[previous].high;
                        point_1.yValue = point_1.low < point_1.high ? point_1.low : point_1.high;
                        lowPoints = this.getControlPoints(points[previous], point_1, this.lowSplinePoints[previous], this.lowSplinePoints[point_1.index], series);
                        series.lowDrawPoints.push(lowPoints);
                    }
                    // fix for Y-Axis of Spline chart not adjusting scale to suit dataSource issue
                    var delta = series.yMax - series.yMin;
                    if (point_1.yValue && value.controlPoint1.y && value.controlPoint2.y && delta > 1) {
                        series.yMin = Math.min(series.yMin, point_1.yValue, value.controlPoint1.y, value.controlPoint2.y);
                        series.yMax = Math.ceil(Math.max(series.yMax, point_1.yValue, value.controlPoint1.y, value.controlPoint2.y));
                        series.yMin = series.yAxis.valueType !== 'Logarithmic' ? Math.floor(series.yMin) : series.yMin;
                    }
                }
            }
            if (!negativePoint && series.yMin < 0) {
                series.yMin = 0;
            }
            if (series.chart.chartAreaType === 'PolarRadar' && series.isClosed) {
                value = this.getControlPoints({ xValue: points[points.length - 1].xValue, yValue: points[points.length - 1].yValue }, { xValue: points[points.length - 1].xValue + 1, yValue: points[0].yValue }, this.splinePoints[0], this.splinePoints[points[points.length - 1].index], series);
                series.drawPoints.push(value);
            }
        }
    };
    SplineBase.prototype.getPreviousIndex = function (points, i, series) {
        if (series.emptyPointSettings.mode !== 'Drop') {
            return i;
        }
        while (isNullOrUndefined(points[i]) && i > -1) {
            i = i - 1;
        }
        return i;
    };
    SplineBase.prototype.getNextIndex = function (points, i, series) {
        if (series.emptyPointSettings.mode !== 'Drop') {
            return i;
        }
        while (isNullOrUndefined(points[i]) && i < points.length) {
            i = i + 1;
        }
        return i;
    };
    SplineBase.prototype.filterEmptyPoints = function (series, seriesPoints) {
        if (series.emptyPointSettings.mode !== 'Drop' && this.isPointInRange(series.points)) {
            return seriesPoints ? seriesPoints : series.points;
        }
        var points = seriesPoints ? seriesPoints : extend([], series.points, null, true);
        for (var i = 0; i < points.length; i++) {
            points[i].index = i;
            if (points[i].isEmpty) {
                points[i].symbolLocations = [];
                points[i].regions = [];
                points.splice(i, 1);
                i--;
            }
        }
        return points;
    };
    /**
     * To find points in the range
     *
     * @private
     */
    SplineBase.prototype.isPointInRange = function (points) {
        for (var _i = 0, points_2 = points; _i < points_2.length; _i++) {
            var point = points_2[_i];
            if (!point.isPointInRange) {
                return false;
            }
        }
        return true;
    };
    /**
     * To find the natural spline.
     *
     * @returns {void}
     * @private
     */
    SplineBase.prototype.findSplineCoefficients = function (points, series, isLow) {
        var ySpline = [];
        var ySplineDuplicate = [];
        var cardinalSplineTension = series.cardinalSplineTension ? series.cardinalSplineTension : 0.5;
        cardinalSplineTension = cardinalSplineTension < 0 ? 0 : cardinalSplineTension > 1 ? 1 : cardinalSplineTension;
        switch (series.splineType) {
            case 'Monotonic':
                ySpline = this.monotonicSplineCoefficients(points, series, isLow);
                break;
            case 'Cardinal':
                ySpline = this.cardinalSplineCofficients(points, series, isLow);
                break;
            default:
                if (series.splineType === 'Clamped') {
                    ySpline = this.clampedSplineCofficients(points, series, isLow);
                }
                else {
                    // assigning the first and last value as zero
                    ySpline[0] = ySplineDuplicate[0] = 0;
                    ySpline[points.length - 1] = 0;
                }
                ySpline = this.naturalSplineCoefficients(points, series, isLow);
                break;
        }
        return ySpline;
    };
    /**
     *  To find Monotonic Spline Coefficients
     */
    SplineBase.prototype.monotonicSplineCoefficients = function (points, series, isLow) {
        var count = points.length;
        var ySpline = [];
        var dx = [];
        var dy = [];
        var slope = [];
        var interPoint;
        for (var i = 0; i < count - 1; i++) {
            if (series.type === 'SplineRangeArea') {
                if (!isLow) {
                    points[i + 1].yValue = points[i + 1].high > points[i + 1].low ? points[i + 1].high : points[i + 1].low;
                    points[i].yValue = points[i].high > points[i].low ? points[i].high : points[i].low;
                }
                if (isLow) {
                    points[i + 1].yValue = points[i + 1].low < points[i + 1].high ? points[i + 1].low : points[i + 1].high;
                    points[i].yValue = points[i].low < points[i].high ? points[i].low : points[i].high;
                }
            }
            dx[i] = points[i + 1].xValue - points[i].xValue;
            dy[i] = points[i + 1].yValue - points[i].yValue;
            slope[i] = dy[i] / dx[i];
        }
        //interpolant points
        var slopeLength = slope.length;
        // to find the first and last co-efficient value
        ySpline[0] = slope[0];
        ySpline[count - 1] = slope[slopeLength - 1];
        //to find the other co-efficient values
        for (var j = 0; j < dx.length; j++) {
            if (slopeLength > j + 1) {
                if (slope[j] * slope[j + 1] <= 0) {
                    ySpline[j + 1] = 0;
                }
                else {
                    interPoint = dx[j] + dx[j + 1];
                    ySpline[j + 1] = 3 * interPoint / ((interPoint + dx[j + 1]) / slope[j] + (interPoint + dx[j]) / slope[j + 1]);
                }
            }
        }
        return ySpline;
    };
    /**
     * To find Cardinal Spline Coefficients
     */
    SplineBase.prototype.cardinalSplineCofficients = function (points, series, isLow) {
        var count = points.length;
        var ySpline = [];
        var cardinalSplineTension = series.cardinalSplineTension ? series.cardinalSplineTension : 0.5;
        cardinalSplineTension = cardinalSplineTension < 0 ? 0 : cardinalSplineTension > 1 ? 1 : cardinalSplineTension;
        for (var i = 0; i < count; i++) {
            if (i === 0) {
                ySpline[i] = (count > 2) ? (cardinalSplineTension * (points[i + 2].xValue - points[i].xValue)) : 0;
            }
            else if (i === (count - 1)) {
                ySpline[i] = (count > 2) ? (cardinalSplineTension * (points[count - 1].xValue - points[count - 3].xValue)) : 0;
            }
            else {
                ySpline[i] = (cardinalSplineTension * (points[i + 1].xValue - points[i - 1].xValue));
            }
        }
        return ySpline;
    };
    /**
     * To find Clamped Spline Coefficients
     */
    SplineBase.prototype.clampedSplineCofficients = function (points, series, isLow) {
        var count = points.length;
        var ySpline = [];
        var ySplineDuplicate = [];
        for (var i = 0; i < count - 1; i++) {
            if (series.type === 'SplineRangeArea') {
                if (!isLow) {
                    points[1].yValue = points[1].high > points[1].low ? points[1].high : points[1].low;
                    points[0].yValue = points[0].high > points[0].low ? points[0].high : points[0].low;
                    points[points.length - 1].yValue = points[points.length - 1].high > points[points.length - 1].low ?
                        points[points.length - 1].high : points[points.length - 1].low;
                    points[points.length - 2].yValue = points[points.length - 2].high > points[points.length - 2].low ?
                        points[points.length - 2].high : points[points.length - 2].low;
                }
                if (isLow) {
                    points[1].yValue = points[1].low < points[1].high ? points[1].low : points[1].high;
                    points[0].yValue = points[0].low < points[0].high ? points[0].low : points[0].high;
                    points[points.length - 1].yValue = points[points.length - 1].low < points[points.length - 1].high ?
                        points[points.length - 1].low : points[points.length - 1].high;
                    points[points.length - 2].yValue = points[points.length - 2].low < points[points.length - 2].high ?
                        points[points.length - 2].low : points[points.length - 2].high;
                }
            }
            ySpline[0] = (3 * (points[1].yValue - points[0].yValue)) / (points[1].xValue - points[0].xValue) - 3;
            ySplineDuplicate[0] = 0.5;
            ySpline[points.length - 1] = (3 * (points[points.length - 1].yValue - points[points.length - 2].yValue)) /
                (points[points.length - 1].xValue - points[points.length - 2].xValue);
            ySpline[0] = ySplineDuplicate[0] = Math.abs(ySpline[0]) === Infinity ? 0 : ySpline[0];
            ySpline[points.length - 1] = ySplineDuplicate[points.length - 1] = Math.abs(ySpline[points.length - 1]) === Infinity ?
                0 : ySpline[points.length - 1];
        }
        return ySpline;
    };
    /**
     * To find Natural Spline Coefficients
     */
    SplineBase.prototype.naturalSplineCoefficients = function (points, series, isLow) {
        var count = points.length;
        var ySpline = [];
        var ySplineDuplicate = [];
        var dy1;
        var dy2;
        var coefficient1;
        var coefficient2;
        var coefficient3;
        ySpline[0] = ySplineDuplicate[0] = 0;
        ySpline[points.length - 1] = 0;
        for (var i = 1; i < count - 1; i++) {
            if (series.type === 'SplineRangeArea') {
                if (!isLow) {
                    points[i + 1].yValue = points[i + 1].low > points[i + 1].high ? points[i + 1].low : points[i + 1].high;
                    points[i].yValue = points[i].low > points[i].high ? points[i].low : points[i].high;
                    points[i - 1].yValue = points[i - 1].low > points[i - 1].high ? points[i - 1].low : points[i - 1].high;
                }
                if (isLow) {
                    points[i + 1].yValue = points[i + 1].high < points[i + 1].low ? points[i + 1].high : points[i + 1].low;
                    points[i].yValue = points[i].high < points[i].low ? points[i].high : points[i].low;
                    points[i - 1].yValue = points[i - 1].high < points[i - 1].low ? points[i - 1].high : points[i - 1].low;
                }
            }
            coefficient1 = points[i].xValue - points[i - 1].xValue;
            coefficient2 = points[i + 1].xValue - points[i - 1].xValue;
            coefficient3 = points[i + 1].xValue - points[i].xValue;
            dy1 = points[i + 1].yValue - points[i].yValue || null;
            dy2 = points[i].yValue - points[i - 1].yValue || null;
            if (coefficient1 === 0 || coefficient2 === 0 || coefficient3 === 0) {
                ySpline[i] = 0;
                ySplineDuplicate[i] = 0;
            }
            else {
                var p = 1 / (coefficient1 * ySpline[i - 1] + 2 * coefficient2);
                ySpline[i] = -p * coefficient3;
                ySplineDuplicate[i] = p * (6 * (dy1 / coefficient3 - dy2 / coefficient1) - coefficient1 * ySplineDuplicate[i - 1]);
            }
        }
        for (var k = count - 2; k >= 0; k--) {
            ySpline[k] = ySpline[k] * ySpline[k + 1] + ySplineDuplicate[k];
        }
        return ySpline;
    };
    /**
     * To find the control points for spline.
     *
     * @returns {void}
     * @private
     */
    SplineBase.prototype.getControlPoints = function (point1, point2, ySpline1, ySpline2, series) {
        var controlPoint1;
        var controlPoint2;
        var point;
        var ySplineDuplicate1 = ySpline1;
        var ySplineDuplicate2 = ySpline2;
        var xValue1 = point1.xValue;
        var yValue1 = point1.yValue;
        var xValue2 = point2.xValue;
        var yValue2 = point2.yValue;
        switch (series.splineType) {
            case 'Cardinal':
                if (series.xAxis.valueType === 'DateTime') {
                    ySplineDuplicate1 = ySpline1 / this.dateTimeInterval(series);
                    ySplineDuplicate2 = ySpline2 / this.dateTimeInterval(series);
                }
                controlPoint1 = new ChartLocation(xValue1 + ySpline1 / 3, yValue1 + ySplineDuplicate1 / 3);
                controlPoint2 = new ChartLocation(xValue2 - ySpline2 / 3, yValue2 - ySplineDuplicate2 / 3);
                point = new ControlPoints(controlPoint1, controlPoint2);
                break;
            case 'Monotonic':
                var value = (xValue2 - xValue1) / 3;
                controlPoint1 = new ChartLocation(xValue1 + value, yValue1 + ySpline1 * value);
                controlPoint2 = new ChartLocation(xValue2 - value, yValue2 - ySpline2 * value);
                point = new ControlPoints(controlPoint1, controlPoint2);
                break;
            default:
                var one3 = 1 / 3.0;
                var deltaX2 = (xValue2 - xValue1);
                deltaX2 = deltaX2 * deltaX2;
                var y1 = one3 * (((2 * yValue1) + yValue2) - one3 * deltaX2 * (ySpline1 + 0.5 * ySpline2));
                var y2 = one3 * ((yValue1 + (2 * yValue2)) - one3 * deltaX2 * (0.5 * ySpline1 + ySpline2));
                controlPoint1 = new ChartLocation((2 * (xValue1) + (xValue2)) * one3, y1);
                controlPoint2 = new ChartLocation(((xValue1) + 2 * (xValue2)) * one3, y2);
                point = new ControlPoints(controlPoint1, controlPoint2);
                break;
        }
        return point;
    };
    /**
     * calculate datetime interval in hours
     */
    SplineBase.prototype.dateTimeInterval = function (series) {
        var interval = series.xAxis.actualIntervalType;
        var intervalInMilliseconds;
        if (interval === 'Years') {
            intervalInMilliseconds = 365 * 24 * 60 * 60 * 1000;
        }
        else if (interval === 'Months') {
            intervalInMilliseconds = 30 * 24 * 60 * 60 * 1000;
        }
        else if (interval === 'Days') {
            intervalInMilliseconds = 24 * 60 * 60 * 1000;
        }
        else if (interval === 'Hours') {
            intervalInMilliseconds = 60 * 60 * 1000;
        }
        else if (interval === 'Minutes') {
            intervalInMilliseconds = 60 * 1000;
        }
        else if (interval === 'Seconds') {
            intervalInMilliseconds = 1000;
        }
        else {
            intervalInMilliseconds = 30 * 24 * 60 * 60 * 1000;
        }
        return intervalInMilliseconds;
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    SplineBase.prototype.doAnimation = function (series) {
        var option = series.animation;
        this.doLinearAnimation(series, option);
    };
    return SplineBase;
}(LineBase));

var __extends$37 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `SplineRangeAreaSeries` module is used to render the range area series.
 */
var SplineRangeAreaSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$37(SplineRangeAreaSeries, _super);
    function SplineRangeAreaSeries() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.borderDirection = '';
        return _this;
    }
    /**
     * Render SplineRangeArea Series.
     *
     * @returns {void}
     * @private
     */
    SplineRangeAreaSeries.prototype.render = function (series, xAxis, yAxis, inverted) {
        var point;
        var direction = '';
        var closed = undefined;
        var firstPoint = null;
        var pt;
        var betweenPt1;
        var betweenPt2;
        var highControlPt1;
        var highControlPt2;
        var realPoint = [];
        var points = [];
        var Index = 0;
        var borderWidth = series.border.width ? series.border.width : 0;
        var borderColor = series.border.color ? series.border.color : series.interior;
        var lastPoint = '';
        realPoint = this.filterEmptyPoints(series);
        for (var i = 0; i < realPoint.length; i++) {
            point = realPoint[i];
            if (point.x === null || point.x === '') {
                continue;
            }
            else {
                point.index = Index;
                Index++;
                points.push(point);
            }
        }
        var previous;
        var next;
        var visiblePoint = this.enableComplexProperty(series);
        var length = visiblePoint.length;
        for (var i = 0; i < length; i++) {
            point = visiblePoint[i];
            point.regions = [];
            point.symbolLocations = [];
            next = this.getNextIndex(points, point.index - 1, series);
            previous = this.getPreviousIndex(points, point.index - 1, series);
            var lowPoint = Math.min(point.low, point.high);
            var highPoint = Math.max(point.low, point.high);
            if (yAxis.isAxisInverse) {
                var temp = lowPoint;
                lowPoint = highPoint;
                highPoint = temp;
            }
            var lowPtCoordinate = getPoint(point.xValue, lowPoint, xAxis, yAxis, inverted);
            var highPtCoordinate = getPoint(point.xValue, highPoint, xAxis, yAxis, inverted);
            point.symbolLocations.push(highPtCoordinate);
            point.symbolLocations.push(lowPtCoordinate);
            var rect1 = new Rect(Math.min(lowPtCoordinate.x, highPtCoordinate.x), Math.min(lowPtCoordinate.y, highPtCoordinate.y), Math.max(Math.abs(highPtCoordinate.x - lowPtCoordinate.x), series.marker.width), Math.max(Math.abs(highPtCoordinate.y - lowPtCoordinate.y), series.marker.width));
            if (!inverted) {
                rect1.x -= series.marker.width / 2;
            }
            else {
                rect1.y -= series.marker.width / 2;
            }
            point.regions.push(rect1);
            //Path to connect the high points
            if (point.visible &&
                withInRange(visiblePoint[previous], point, visiblePoint[next], series)) {
                if (firstPoint) {
                    highControlPt1 = series.drawPoints[previous].controlPoint1;
                    highControlPt2 = series.drawPoints[previous].controlPoint2;
                    pt = getPoint(point.xValue, point.high > point.low ? point.high : point.low, xAxis, yAxis, inverted);
                    betweenPt1 = getPoint(highControlPt1.x, highControlPt1.y, xAxis, yAxis, inverted);
                    betweenPt2 = getPoint(highControlPt2.x, highControlPt2.y, xAxis, yAxis, inverted);
                    direction = direction.concat('C ' + betweenPt1.x + ' '
                        + betweenPt1.y + ' ' + betweenPt2.x + ' ' + betweenPt2.y + ' ' + pt.x + ' ' + pt.y + ' ');
                    this.borderDirection += 'C ' + betweenPt1.x + ' '
                        + betweenPt1.y + ' ' + betweenPt2.x + ' ' + betweenPt2.y + ' ' + pt.x + ' ' + pt.y + ' ';
                }
                else {
                    if (yAxis.isAxisInverse) {
                        direction = direction.concat('M ' + (highPtCoordinate.x) + ' ' + (highPtCoordinate.y) + ' ' + 'L ' + (lowPtCoordinate.x) + ' ' + (lowPtCoordinate.y) + ' ');
                        this.borderDirection += 'M ' + (highPtCoordinate.x) + ' ' + (highPtCoordinate.y) + ' ';
                        lastPoint = 'L ' + (lowPtCoordinate.x) + ' ' + (lowPtCoordinate.y);
                    }
                    else {
                        direction = direction.concat('M ' + (lowPtCoordinate.x) + ' ' + (lowPtCoordinate.y) + ' ' + 'L ' + (highPtCoordinate.x) + ' ' + (highPtCoordinate.y) + ' ');
                        this.borderDirection += 'M ' + (highPtCoordinate.x) + ' ' + (highPtCoordinate.y) + ' ';
                        lastPoint = 'L ' + (lowPtCoordinate.x) + ' ' + (lowPtCoordinate.y);
                    }
                    closed = false;
                }
                if ((i + 1 < visiblePoint.length && !visiblePoint[i + 1].visible)
                    || i === visiblePoint.length - 1) {
                    // Path to connect the low points
                    direction = this.closeSplineRangeAreaPath(visiblePoint, point, series, direction, i, xAxis, yAxis, inverted);
                    this.borderDirection += lastPoint;
                    lastPoint = '';
                    direction = direction.concat(' ' + 'Z');
                    closed = true;
                }
                firstPoint = point;
            }
            else {
                if (closed === false && i !== 0) {
                    direction = this.closeSplineRangeAreaPath(visiblePoint, point, series, direction, i, xAxis, yAxis, inverted);
                    closed = true;
                }
                firstPoint = null;
                point.symbolLocations = [];
            }
        }
        var name1 = series.category === 'Indicator' ? series.chart.element.id + '_Indicator_' + series.index + '_' + series.name :
            series.chart.element.id + '_Series_' + series.index;
        var options = new PathOption(name1, series.interior, 0, 'transparent', series.opacity, series.dashArray, direction);
        this.appendLinePath(options, series, '');
        /**
         * To draw border for the path directions of area
         */
        if (series.border.width !== 0) {
            this.appendLinePath(new PathOption(series.chart.element.id + '_Series_border_' + series.index, 'transparent', borderWidth, borderColor, 1, series.dashArray, this.borderDirection), series, '');
            this.borderDirection = '';
        }
        this.renderMarker(series);
    };
    /**
     * path for rendering the low points in SplineRangeArea
     *
     * @returns {void}.
     * @private
     */
    SplineRangeAreaSeries.prototype.closeSplineRangeAreaPath = function (visiblePoint, point, series, direction, i, xAxis, yAxis, inverted) {
        var firstPoint = null;
        var pt;
        var betweenPt1;
        var betweenPt2;
        var lowControlPt1;
        var lowControlPt2;
        for (var j = i; j > 0; j--) {
            if (visiblePoint[j].visible) {
                point = visiblePoint[j];
                var low = Math.min(point.low, point.high);
                var high = Math.max(point.low, point.high);
                if (yAxis.isAxisInverse) {
                    var temp = low;
                    low = high;
                    high = temp;
                }
                var lowPtCoordinate = getPoint(point.xValue, low, xAxis, yAxis, inverted);
                var highPtCoordinate = getPoint(point.xValue, high, xAxis, yAxis, inverted);
                if (firstPoint) {
                    lowControlPt1 = series.lowDrawPoints[j].controlPoint1;
                    lowControlPt2 = series.lowDrawPoints[j].controlPoint2;
                    pt = getPoint(point.xValue, point.low < point.high ? point.low : point.high, xAxis, yAxis, inverted);
                    betweenPt1 = getPoint(lowControlPt1.x, lowControlPt1.y, xAxis, yAxis, inverted);
                    betweenPt2 = getPoint(lowControlPt2.x, lowControlPt2.y, xAxis, yAxis, inverted);
                    direction = direction.concat('C ' + betweenPt2.x + ' '
                        + betweenPt2.y + ' ' + betweenPt1.x + ' ' + betweenPt1.y + ' ' + pt.x + ' ' + pt.y + ' ');
                    this.borderDirection += 'C ' + betweenPt2.x + ' '
                        + betweenPt2.y + ' ' + betweenPt1.x + ' ' + betweenPt1.y + ' ' + pt.x + ' ' + pt.y + ' ';
                }
                else {
                    if (yAxis.isAxisInverse) {
                        direction = direction.concat('L ' + (highPtCoordinate.x) + ' ' + (highPtCoordinate.y) + ' ');
                        this.borderDirection += 'M ' + (highPtCoordinate.x) + ' ' + (highPtCoordinate.y) + ' ';
                    }
                    else {
                        direction = direction.concat('L ' + (lowPtCoordinate.x) + ' ' + (lowPtCoordinate.y) + ' ');
                        this.borderDirection += 'M ' + (lowPtCoordinate.x) + ' ' + (lowPtCoordinate.y) + ' ';
                    }
                }
            }
            else {
                break;
            }
            firstPoint = point;
        }
        return direction;
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    SplineRangeAreaSeries.prototype.doAnimation = function (series) {
        var option = series.animation;
        this.doLinearAnimation(series, option);
    };
    /**
     * Get module name.
     */
    SplineRangeAreaSeries.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'SplineRangeAreaSeries';
    };
    /**
     * To destroy the line series.
     *
     * @returns {void}
     * @private
     */
    SplineRangeAreaSeries.prototype.destroy = function () {
        /**
         * Destroys range area series
         */
    };
    return SplineRangeAreaSeries;
}(SplineBase));

/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-returns */
/**
 * `BubbleSeries` module is used to render the bubble series.
 */
var BubbleSeries = /** @__PURE__ @class */ (function () {
    function BubbleSeries() {
    }
    /**
     * Render the Bubble series.
     *
     * @returns {void}
     * @private
     */
    BubbleSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {
        var marker = series.marker;
        var visiblePoints = series.points;
        var shapeOption;
        var argsData;
        //let bubbleMode: RadiusMode = bubbleOptions.radiusMode;
        var segmentRadius;
        var radius;
        var value = Math.max(series.chart.initialClipRect.height, series.chart.initialClipRect.width);
        var percentChange = value / 100;
        var maxRadius = series.maxRadius * percentChange;
        var minRadius = series.minRadius * percentChange;
        var maximumSize = null;
        var maxValue = null;
        var element;
        var startLocation;
        var redraw = series.chart.redraw;
        if ((series.maxRadius === null || series.minRadius === null)) {
            for (var _i = 0, _a = series.chart.visibleSeries; _i < _a.length; _i++) {
                var value_1 = _a[_i];
                if (value_1.type === 'Bubble' && value_1.visible === true && (value_1.maxRadius === null || value_1.minRadius === null)) {
                    maximumSize = value_1.sizeMax > maximumSize ? value_1.sizeMax : maximumSize;
                }
            }
            maxValue = (value / 5) / 2;
            minRadius = maxRadius = 1;
            radius = maxValue * maxRadius;
        }
        else {
            maximumSize = series.sizeMax;
            radius = maxRadius - minRadius;
        }
        for (var _b = 0, visiblePoints_1 = visiblePoints; _b < visiblePoints_1.length; _b++) {
            var bubblePoint = visiblePoints_1[_b];
            bubblePoint.symbolLocations = [];
            bubblePoint.regions = [];
            if (bubblePoint.visible &&
                withInRange(visiblePoints[bubblePoint.index - 1], bubblePoint, visiblePoints[bubblePoint.index + 1], series)) {
                if ((series.maxRadius === null || series.minRadius === null)) {
                    segmentRadius = radius * Math.abs(+bubblePoint.size / maximumSize);
                }
                else {
                    segmentRadius = minRadius + radius * Math.abs(+bubblePoint.size / maximumSize);
                }
                segmentRadius = segmentRadius || minRadius;
                argsData = {
                    cancel: false, name: pointRender, series: series, point: bubblePoint,
                    fill: series.setPointColor(bubblePoint, series.interior),
                    border: series.setBorderColor(bubblePoint, { width: series.border.width, color: series.border.color }),
                    height: 2 * segmentRadius, width: 2 * segmentRadius
                };
                series.chart.trigger(pointRender, argsData);
                if (!argsData.cancel) {
                    bubblePoint.symbolLocations.push(getPoint(bubblePoint.xValue, bubblePoint.yValue, xAxis, yAxis, isInverted));
                    bubblePoint.color = argsData.fill;
                    shapeOption = new PathOption(series.chart.element.id + '_Series_' + series.index + '_Point_' + bubblePoint.index, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, null);
                    element = drawSymbol(bubblePoint.symbolLocations[0], 'Circle', new Size(argsData.width, argsData.height), marker.imageUrl, shapeOption, bubblePoint.x.toString() + ':' + bubblePoint.yValue.toString(), series.chart.svgRenderer, series.clipRect);
                    appendChildElement(series.chart.enableCanvas, series.seriesElement, element, redraw, false, '', '', null, '', false, false, null, null, true);
                    bubblePoint.regions.push(new Rect(bubblePoint.symbolLocations[0].x - segmentRadius, bubblePoint.symbolLocations[0].y - segmentRadius, 2 * segmentRadius, 2 * segmentRadius));
                    bubblePoint.marker = {
                        border: argsData.border, fill: argsData.fill,
                        height: argsData.height, visible: true,
                        shape: 'Circle', width: argsData.width
                    };
                    if (series.chart.enableCanvas) {
                        series.chart.markerRender.render(series);
                    }
                    startLocation = redraw ? bubblePoint.symbolLocations[0] : null;
                    if (redraw) {
                        animateRedrawElement(element, 300, startLocation, bubblePoint.symbolLocations[0], 'cx', 'cy');
                    }
                }
                else {
                    bubblePoint.marker = { visible: false };
                }
            }
        }
    };
    /**
     * To destroy the Bubble.
     *
     * @returns {void}
     * @private
     */
    BubbleSeries.prototype.destroy = function () {
        /**
         * Destroy method calling here
         */
    };
    /**
     * Get module name.
     */
    BubbleSeries.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'BubbleSeries';
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    BubbleSeries.prototype.doAnimation = function (series) {
        var duration = series.animation.duration;
        var delay = series.animation.delay;
        var rectElements = series.seriesElement.childNodes;
        var count = 1;
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var bubblePoint = _a[_i];
            if (!bubblePoint.symbolLocations.length) {
                continue;
            }
            markerAnimate(rectElements[count], delay, duration, series, bubblePoint.index, bubblePoint.symbolLocations[0], false);
            count++;
        }
    };
    return BubbleSeries;
}());

var __extends$39 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `SplineSeries` module is used to render the spline series.
 */
var SplineSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$39(SplineSeries, _super);
    function SplineSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render the spline series.
     *
     * @returns {void}
     * @private
     */
    SplineSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {
        var firstPoint = null;
        var direction = '';
        var startPoint = 'M';
        var points = [];
        var tempPoints = series.category === 'TrendLine' ? series.points : this.enableComplexProperty(series);
        points = this.filterEmptyPoints(series, tempPoints);
        var previous;
        var getCoordinate = series.chart.chartAreaType === 'PolarRadar' ? TransformToVisible : getPoint;
        for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
            var point = points_1[_i];
            previous = this.getPreviousIndex(points, point.index - 1, series);
            point.symbolLocations = [];
            point.regions = [];
            if (point.visible) {
                if (withInRange(points[previous], point, points[this.getNextIndex(points, point.index - 1, series)], series)) {
                    if (firstPoint !== null) {
                        direction = this.getSplineDirection(series.drawPoints[previous], firstPoint, point, xAxis, yAxis, isInverted, series, startPoint, getCoordinate, direction);
                        startPoint = 'L';
                    }
                    this.storePointLocation(point, series, isInverted, getCoordinate);
                }
                firstPoint = point;
            }
            else {
                startPoint = 'M';
                firstPoint = null;
                point.symbolLocations = [];
            }
        }
        if ((points.length > 0 && series.drawPoints.length > 0) && series.chart.chartAreaType === 'PolarRadar' && series.isClosed) {
            var connectPoints = this.getFirstLastVisiblePoint(points);
            direction = this.getSplineDirection(series.drawPoints[series.drawPoints.length - 1], connectPoints.last, { xValue: connectPoints.first.xValue, yValue: connectPoints.first.yValue }, xAxis, yAxis, isInverted, series, startPoint, getCoordinate, direction);
            startPoint = 'L';
        }
        var name = series.category === 'TrendLine' ? series.chart.element.id + '_Series_' + series.sourceIndex + '_TrendLine_' + series.index :
            series.chart.element.id + '_Series_' + series.index;
        var options = new PathOption(name, 'transparent', series.width, series.interior, series.opacity, series.dashArray, direction);
        this.appendLinePath(options, series, '');
        this.renderMarker(series);
    };
    /**
     * To find the direct of spline using points.
     *
     * @param {ControlPoints} data data
     * @param {Points} firstPoint firstPoint
     * @param {Points} point point
     * @param {Axis} xAxis xAxis
     * @param {Axis} yAxis yAxis
     * @param {boolean} isInverted isInverted
     * @param {Series} series series
     * @param {string} startPoint startPoint
     * @param {Function} getCoordinate getCoordinate
     * @param {string} direction direction
     */
    SplineSeries.prototype.getSplineDirection = function (data, firstPoint, point, xAxis, yAxis, isInverted, series, startPoint, getCoordinate, direction) {
        var controlPoint1 = data.controlPoint1;
        var controlPoint2 = data.controlPoint2;
        var pt1 = getCoordinate(firstPoint.xValue, firstPoint.yValue, xAxis, yAxis, isInverted, series);
        var pt2 = getCoordinate(point.xValue, point.yValue, xAxis, yAxis, isInverted, series);
        var bpt1 = getCoordinate(controlPoint1.x, controlPoint1.y, xAxis, yAxis, isInverted, series);
        var bpt2 = getCoordinate(controlPoint2.x, controlPoint2.y, xAxis, yAxis, isInverted, series);
        return direction.concat((startPoint + ' ' + (pt1.x) + ' ' + (pt1.y) + ' ' + 'C' + ' ' + (bpt1.x) + ' '
            + (bpt1.y) + ' ' + (bpt2.x) + ' ' + (bpt2.y) + ' ' + (pt2.x) + ' ' + (pt2.y) + ' '));
    };
    /**
     * Get module name.
     */
    SplineSeries.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'SplineSeries';
    };
    /**
     * To destroy the spline.
     *
     * @returns {void}
     * @private
     */
    SplineSeries.prototype.destroy = function () {
        /**
         * Destroy method calling here
         */
    };
    return SplineSeries;
}(SplineBase));

var __extends$40 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns-type */
/* eslint-disable radix */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `HistogramSeries` Module used to render the histogram series.
 */
var HistogramSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$40(HistogramSeries, _super);
    function HistogramSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render Histogram series.
     *
     * @returns {void}
     * @private
     */
    HistogramSeries.prototype.render = function (series) {
        _super.prototype.render.call(this, series);
        if (series.showNormalDistribution) {
            this.renderNormalDistribution(series);
        }
    };
    /**
     * To calculate bin interval for Histogram series.
     *
     * @returns {void}
     * @private
     */
    HistogramSeries.prototype.calculateBinInterval = function (yValues, series) {
        var mean = sum(yValues) / yValues.length;
        var sumValue = 0;
        for (var _i = 0, yValues_1 = yValues; _i < yValues_1.length; _i++) {
            var value = yValues_1[_i];
            sumValue += (value - mean) * (value - mean);
        }
        series.histogramValues.mean = mean;
        series.histogramValues.sDValue = Math.sqrt(Math.abs(sumValue / yValues.length));
        series.histogramValues.binWidth = series.binInterval ||
            Math.round((3.5 * series.histogramValues.sDValue) / Math.pow(yValues.length, 1 / 3)) || 1;
    };
    /**
     * Add data points for Histogram series.
     *
     * @returns {object[]} data
     * @private
     */
    HistogramSeries.prototype.processInternalData = function (data, series) {
        var _a;
        var updatedData = [];
        var yValues = [];
        var keys = Object.keys(data);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            yValues.push(data[key][series.yName]);
        }
        series.histogramValues = {
            yValues: yValues
        };
        var min = Math.min.apply(Math, series.histogramValues.yValues);
        var max = Math.max.apply(Math, series.histogramValues.yValues);
        this.calculateBinInterval(series.histogramValues.yValues, series);
        var binWidth = series.histogramValues.binWidth;
        var yCount;
        for (var j = 0; j < data.length;) {
            yCount = yValues.filter(function (y) { return y >= min && y < (min + (binWidth)); }).length;
            if ((min + binWidth) === max) {
                yCount += yValues.filter(function (y) { return y >= max; }).length;
            }
            updatedData.push((_a = {
                    'x': min + binWidth / 2
                }, _a[series.yName] = yCount, _a));
            min = min + binWidth;
            j += yCount;
        }
        return updatedData;
    };
    // eslint-disable-next-line jsdoc/require-returns-check
    /**
     * Calculates bin values.
     *
     * @returns null
     * @private
     */
    HistogramSeries.prototype.calculateBinValues = function (series) {
        var yValuesCount = series.histogramValues.yValues.length;
        var binWidth = series.histogramValues.binWidth;
        var mean = series.histogramValues.mean;
        var sDValue = series.histogramValues.sDValue;
        var pointsCount = 500;
        var min = series.xAxis.minimum ? parseInt(series.xAxis.minimum.toString()) : series.xMin;
        var max = series.xAxis.maximum ? parseInt(series.xAxis.maximum.toString()) : series.xMax;
        var points = series.points.length;
        var xValue;
        var yValue;
        var del = (max - min) / (pointsCount - 1);
        if (points) {
            for (var i = 0; i < pointsCount; i++) {
                xValue = min + i * del;
                yValue = (Math.exp(-(xValue - mean) * (xValue - mean) / (2 * sDValue * sDValue)) /
                    (sDValue * Math.sqrt(2 * Math.PI))) * binWidth * yValuesCount;
                series.yMin = series.yMin > yValue ? yValue : series.yMin;
                series.yMax = series.yMax < yValue ? yValue : series.yMax;
            }
        }
    };
    /**
     * Render Normal Distribution for Histogram series.
     *
     * @returns {void}
     * @private
     */
    HistogramSeries.prototype.renderNormalDistribution = function (series) {
        var min = series.xAxis.actualRange.min;
        var max = series.xAxis.actualRange.max;
        var xValue;
        var pointLocation;
        var yValue;
        var direction = '';
        var startPoint = 'M';
        var yValuesCount = series.histogramValues.yValues.length;
        var binWidth = series.histogramValues.binWidth;
        var mean = series.histogramValues.mean;
        var sDValue = series.histogramValues.sDValue;
        var pointsCount = 500;
        var del = (max - min) / (pointsCount - 1);
        var points = series.points.length;
        if (points) {
            for (var i = 0; i < pointsCount; i++) {
                xValue = min + i * del;
                yValue = Math.exp(-(xValue - mean) * (xValue - mean) / (2 * sDValue * sDValue)) /
                    (sDValue * Math.sqrt(2 * Math.PI));
                pointLocation = getPoint(xValue, yValue * binWidth * yValuesCount, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);
                direction += startPoint + ' ' + (pointLocation.x) + ' ' + (pointLocation.y) + ' ';
                startPoint = 'L';
            }
        }
        var distributionLine = series.chart.renderer.drawPath(new PathOption(series.chart.element.id + '_Series_' + series.index + '_NDLine', 'transparent', 2, series.chart.themeStyle.histogram || series.chart.themeStyle.errorBar, series.opacity, series.dashArray, direction), new Int32Array([series.clipRect.x, series.clipRect.y]));
        distributionLine.style.visibility = (!series.chart.enableCanvas) ? ((((series.animation.enable && animationMode != 'Disable') || animationMode === 'Enable') &&
            series.chart.animateSeries) ? 'hidden' : 'visible') : null;
        if (!series.chart.enableCanvas) {
            series.seriesElement.appendChild(distributionLine);
        }
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    HistogramSeries.prototype.doAnimation = function (series) {
        _super.prototype.doAnimation.call(this, series);
        if (series.showNormalDistribution) {
            templateAnimate(series.seriesElement.lastElementChild, ((series.animation.duration === 0 && animationMode === 'Enable') ? 1000 : series.animation.duration), 500, 'FadeIn');
        }
    };
    /**
     * Get module name.
     */
    HistogramSeries.prototype.getModuleName = function () {
        return 'HistogramSeries';
        /**
         * return the module name
         */
    };
    /**
     * To destroy the histogram series.
     *
     * @returns {void}
     * @private
     */
    HistogramSeries.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return HistogramSeries;
}(ColumnSeries));

var __extends$41 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `SplineAreaSeries` module used to render the spline area series.
 */
var SplineAreaSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$41(SplineAreaSeries, _super);
    function SplineAreaSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render the splineArea series.
     *
     * @returns {void}
     * @private
     */
    SplineAreaSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {
        var firstPoint = null;
        var direction = '';
        var startPoint = null;
        var startPoint1 = null;
        var pt2;
        var bpt1;
        var bpt2;
        var controlPt1;
        var controlPt2;
        var realPoints = [];
        var points = [];
        var point;
        var pointIndex = 0;
        realPoints = this.filterEmptyPoints(series);
        var emptyPointDirection = '';
        for (var i = 0; i < realPoints.length; i++) {
            point = realPoints[i];
            if (point.x === null || point.x === '') {
                continue;
            }
            else {
                point.index = pointIndex;
                pointIndex++;
                points.push(point);
            }
        }
        var pointsLength = points.length;
        var previous;
        var getCoordinate = series.chart.chartAreaType === 'PolarRadar' ? TransformToVisible : getPoint;
        var origin = series.chart.chartAreaType === 'PolarRadar' ? series.points[0].yValue :
            Math.max(series.yAxis.visibleRange.min, 0);
        for (var i = 0; i < pointsLength; i++) {
            point = points[i];
            point.symbolLocations = [];
            point.regions = [];
            previous = this.getPreviousIndex(points, point.index - 1, series);
            if (point.visible &&
                withInRange(points[previous], point, points[this.getNextIndex(points, point.index - 1, series)], series)) {
                if (firstPoint) {
                    controlPt1 = series.drawPoints[previous].controlPoint1;
                    controlPt2 = series.drawPoints[previous].controlPoint2;
                    pt2 = getCoordinate(point.xValue, point.yValue, xAxis, yAxis, isInverted, series);
                    bpt1 = getCoordinate(controlPt1.x, controlPt1.y, xAxis, yAxis, isInverted, series);
                    bpt2 = getCoordinate(controlPt2.x, controlPt2.y, xAxis, yAxis, isInverted, series);
                    direction = direction.concat('C ' + bpt1.x + ' '
                        + bpt1.y + ' ' + bpt2.x + ' ' + bpt2.y + ' ' + pt2.x + ' ' + pt2.y + ' ');
                }
                else {
                    // Start point for the current path
                    startPoint = getCoordinate(point.xValue, origin, xAxis, yAxis, isInverted, series);
                    direction += ('M ' + startPoint.x + ' ' + startPoint.y + ' ');
                    // First Point to draw the area path
                    startPoint1 = getCoordinate(point.xValue, point.yValue, xAxis, yAxis, isInverted, series);
                    direction += ('L ' + startPoint1.x + ' ' + startPoint1.y + ' ');
                }
                this.storePointLocation(point, series, isInverted, getCoordinate);
                firstPoint = point;
            }
            else {
                firstPoint = null;
                point.symbolLocations = [];
            }
            if (((i + 1 < pointsLength && !points[i + 1].visible) || i === pointsLength - 1)
                && pt2 && startPoint) {
                startPoint = getCoordinate(point.xValue, origin, xAxis, yAxis, isInverted, series);
                direction = direction.concat('L ' + (startPoint.x) + ' ' + (startPoint.y) + ' ');
            }
        }
        this.appendLinePath(new PathOption(series.chart.element.id + '_Series_' + series.index, series.interior, 0, 'transparent', series.opacity, series.dashArray, direction), series, '');
        /**
         * To draw border for the path directions of area
         */
        if (series.border.width !== 0) {
            emptyPointDirection = this.removeEmptyPointsBorder(this.getBorderDirection(direction));
            this.appendLinePath(new PathOption(series.chart.element.id + '_Series_border_' + series.index, 'transparent', series.border.width, series.border.color ? series.border.color : series.interior, 1, series.dashArray, emptyPointDirection), series, '');
        }
        this.renderMarker(series);
    };
    /**
     * Get module name.
     */
    SplineAreaSeries.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'SplineAreaSeries';
    };
    /**
     * To destroy the spline.
     *
     * @returns {void}
     * @private
     */
    SplineAreaSeries.prototype.destroy = function () {
        /**
         * Destroy method calling here
         */
    };
    return SplineAreaSeries;
}(SplineBase));

var __extends$43 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * Technical Analysis module helps to predict the market trend
 */
var TechnicalAnalysis = /** @__PURE__ @class */ (function (_super) {
    __extends$43(TechnicalAnalysis, _super);
    function TechnicalAnalysis() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Defines the collection of series, that are used to represent the given technical indicator
     *
     * @private
     */
    TechnicalAnalysis.prototype.initSeriesCollection = function (indicator, chart) {
        indicator.targetSeries = [];
        var signalLine = new Series(indicator, 'targetSeries', {}, true);
        this.setSeriesProperties(signalLine, indicator, indicator.type, indicator.fill, indicator.width, chart);
    };
    /**
     * Initializes the properties of the given series
     *
     * @private
     */
    TechnicalAnalysis.prototype.setSeriesProperties = function (series, indicator, name, fill, width, chart) {
        series.name = name.length <= 4 ? name.toLocaleUpperCase() : name;
        series.xName = 'x';
        series.yName = 'y';
        series.fill = fill || '#606eff';
        series.dashArray = indicator.dashArray;
        series.width = width;
        series.xAxisName = indicator.xAxisName;
        series.animation = indicator.animation;
        series.yAxisName = indicator.yAxisName;
        series.clipRectElement = indicator.clipRectElement;
        series.points = [];
        series.enableTooltip = true;
        series.interior = series.fill;
        series.category = 'Indicator';
        series.index = indicator.index;
        series.chart = chart;
        series.xMin = Infinity;
        series.xMax = -Infinity;
        series.yMin = Infinity;
        series.yMax = -Infinity;
        series.xData = [];
        series.yData = [];
        series.marker.visible = false;
        indicator.targetSeries.push(series);
    };
    /**
     * Creates the elements of a technical indicator
     *
     * @private
     */
    TechnicalAnalysis.prototype.createIndicatorElements = function (chart, indicator, index) {
        if (indicator.seriesName || indicator.dataSource) {
            findClipRect(indicator.targetSeries[0]);
        }
        var clipRect = new Rect(0, 0, 0, 0);
        if (indicator.seriesName || indicator.dataSource) {
            clipRect = indicator.targetSeries[0].clipRect;
        }
        var options = new RectOption(chart.element.id + '_ChartIndicatorClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, {
            x: 0, y: 0, width: clipRect.width,
            height: clipRect.height
        });
        var clipRectElement = appendClipElement(chart.redraw, options, chart.renderer);
        //defines the clip rect element
        //creates the group for an indicator
        indicator.indicatorElement = chart.renderer.createGroup({
            'id': chart.element.id + 'IndicatorGroup' + index,
            'transform': 'translate(' + clipRect.x + ',' + clipRect.y + ')',
            'clip-path': 'url(#' + chart.element.id + '_ChartIndicatorClipRect_' + index + ')'
        });
        indicator.indicatorElement.appendChild(clipRectElement);
        //Defines a group for each series in a technical indicator
        for (var _i = 0, _a = indicator.targetSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            series.clipRectElement = clipRectElement;
            var element = series.chart.renderer.createGroup({
                'id': series.chart.element.id + '_Indicator_' +
                    indicator.index + '_' + series.name + '_Group'
            });
            indicator.indicatorElement.appendChild(element);
            series.seriesElement = element;
        }
        chart.indicatorElements.appendChild(indicator.indicatorElement);
    };
    TechnicalAnalysis.prototype.getDataPoint = function (x, y, sourcePoint, series, index, indicator) {
        if (indicator === void 0) { indicator = null; }
        var point = new Points();
        point.x = x;
        point.y = y;
        point.xValue = sourcePoint.xValue;
        point.color = series.fill;
        point.index = index;
        point.yValue = y;
        point.visible = true;
        series.xMin = Math.min(series.xMin, point.xValue);
        series.yMin = Math.min(series.yMin, point.yValue);
        series.xMax = Math.max(series.xMax, point.xValue);
        series.yMax = Math.max(series.yMax, point.yValue);
        series.xData.push(point.xValue);
        if (indicator && indicator.type === 'Macd' && series.type === 'Column') {
            if (point.y >= 0) {
                point.color = indicator.macdPositiveColor;
            }
            else {
                point.color = indicator.macdNegativeColor;
            }
        }
        return point;
    };
    TechnicalAnalysis.prototype.getRangePoint = function (x, high, low, sourcePoint, series, index) {
        var point = new Points();
        point.x = x;
        point.high = high;
        point.low = low;
        point.xValue = sourcePoint.xValue;
        point.color = series.fill;
        point.index = index;
        point.visible = true;
        series.xData.push(point.xValue);
        return point;
    };
    TechnicalAnalysis.prototype.setSeriesRange = function (points, indicator, series) {
        if (series === void 0) { series = null; }
        if (!series) {
            indicator.targetSeries[0].points = points;
        }
        else {
            series.points = points;
        }
    };
    return TechnicalAnalysis;
}(LineBase));

var __extends$42 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * `SmaIndicator` module is used to render SMA indicator.
 */
var SmaIndicator = /** @__PURE__ @class */ (function (_super) {
    __extends$42(SmaIndicator, _super);
    function SmaIndicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Defines the predictions based on SMA approach
     *
     * @private
     */
    SmaIndicator.prototype.initDataSource = function (indicator) {
        var smaPoints = [];
        var points = indicator.points;
        if (points && points.length) {
            //prepare data
            var validData = points;
            var field = firstToLowerCase(indicator.field);
            var xField = 'x';
            var signalSeries = indicator.targetSeries[0];
            if (validData && validData.length && validData.length >= indicator.period) {
                //find initial average
                var average = 0;
                var sum$$1 = 0;
                for (var i = 0; i < indicator.period; i++) {
                    sum$$1 += validData[i][field];
                }
                average = sum$$1 / indicator.period;
                smaPoints.push(this.getDataPoint(validData[indicator.period - 1][xField], average, validData[indicator.period - 1], signalSeries, smaPoints.length));
                var index = indicator.period;
                while (index < validData.length) {
                    sum$$1 -= validData[index - indicator.period][field];
                    sum$$1 += validData[index][field];
                    average = sum$$1 / indicator.period;
                    smaPoints.push(this.getDataPoint(validData[index][xField], average, validData[index], signalSeries, smaPoints.length));
                    index++;
                }
            }
            this.setSeriesRange(smaPoints, indicator);
        }
    };
    /**
     * To destroy the SMA indicator
     *
     * @returns {void}
     * @private
     */
    SmaIndicator.prototype.destroy = function () {
        /**
         * Destroys the SMA indicator
         */
    };
    /**
     * Get module name.
     */
    SmaIndicator.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'SmaIndicator';
    };
    return SmaIndicator;
}(TechnicalAnalysis));

var __extends$44 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * `EmaIndicator` module is used to render EMA indicator.
 */
var EmaIndicator = /** @__PURE__ @class */ (function (_super) {
    __extends$44(EmaIndicator, _super);
    function EmaIndicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Defines the predictions based on EMA approach
     *
     * @private
     */
    EmaIndicator.prototype.initDataSource = function (indicator) {
        var field = firstToLowerCase(indicator.field);
        var xField = 'x';
        var emaPoints = [];
        var signalSeries = indicator.targetSeries[0];
        //prepare data
        var validData = indicator.points;
        if (validData && validData.length && validData.length >= indicator.period) {
            //find initial average
            var sum$$1 = 0;
            var average = 0;
            //smoothing factor
            var k = (2 / (indicator.period + 1));
            for (var i = 0; i < indicator.period; i++) {
                sum$$1 += validData[i][field];
            }
            average = sum$$1 / indicator.period;
            emaPoints.push(this.getDataPoint(validData[indicator.period - 1][xField], average, validData[indicator.period - 1], signalSeries, emaPoints.length));
            var index = indicator.period;
            while (index < validData.length) {
                //previous average
                var prevAverage = emaPoints[index - indicator.period][signalSeries.yName];
                var yValue = (validData[index][field] - prevAverage) * k + prevAverage;
                emaPoints.push(this.getDataPoint(validData[index][xField], yValue, validData[index], signalSeries, emaPoints.length));
                index++;
            }
        }
        this.setSeriesRange(emaPoints, indicator);
    };
    /**
     * To destroy the EMA Indicator
     *
     * @returns {void}
     * @private
     */
    EmaIndicator.prototype.destroy = function () {
        /**
         * Destroys the EMA Indicator
         */
    };
    /**
     * Get module name.
     */
    EmaIndicator.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'EmaIndicator';
    };
    return EmaIndicator;
}(TechnicalAnalysis));

var __extends$45 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * `TmaIndicator` module is used to render TMA indicator.
 */
var TmaIndicator = /** @__PURE__ @class */ (function (_super) {
    __extends$45(TmaIndicator, _super);
    function TmaIndicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Defines the predictions based on TMA approach
     *
     * @private
     */
    TmaIndicator.prototype.initDataSource = function (indicator) {
        var tmaPoints = [];
        var field = firstToLowerCase(indicator.field);
        var xField = 'x';
        //prepare data
        var validData = indicator.points;
        if (validData && validData.length && validData.length >= indicator.period) {
            var signalSeries = indicator.targetSeries[0];
            //prepare data
            var validData_1 = indicator.points;
            if (validData_1.length && validData_1.length >= indicator.period) {
                var sum$$1 = 0;
                var smaValues = [];
                //sma values
                var index = 0;
                var length_1 = validData_1.length;
                var period = indicator.period;
                while (length_1 >= period) {
                    sum$$1 = 0;
                    index = validData_1.length - length_1;
                    for (var j = index; j < index + period; j++) {
                        sum$$1 = sum$$1 + validData_1[j][field];
                    }
                    sum$$1 = sum$$1 / period;
                    smaValues.push(sum$$1);
                    length_1--;
                }
                //initial values
                for (var k = 0; k < period - 1; k++) {
                    sum$$1 = 0;
                    for (var j = 0; j < k + 1; j++) {
                        sum$$1 = sum$$1 + validData_1[j][field];
                    }
                    sum$$1 = sum$$1 / (k + 1);
                    smaValues.splice(k, 0, sum$$1);
                }
                index = indicator.period;
                while (index <= smaValues.length) {
                    sum$$1 = 0;
                    for (var j = index - indicator.period; j < index; j++) {
                        sum$$1 = sum$$1 + smaValues[j];
                    }
                    sum$$1 = sum$$1 / indicator.period;
                    tmaPoints.push(this.getDataPoint(validData_1[index - 1][xField], sum$$1, validData_1[index - 1], signalSeries, tmaPoints.length));
                    index++;
                }
            }
        }
        this.setSeriesRange(tmaPoints, indicator);
    };
    /**
     * To destroy the TMA indicator.
     *
     * @returns {void}
     * @private
     */
    TmaIndicator.prototype.destroy = function () {
        /**
         * Destroys the TMA Indicator
         */
    };
    /**
     * Get module name.
     */
    TmaIndicator.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'TmaIndicator';
    };
    return TmaIndicator;
}(TechnicalAnalysis));

var __extends$46 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * `AccumulationDistributionIndicator` module is used to render accumulation distribution indicator.
 */
var AccumulationDistributionIndicator = /** @__PURE__ @class */ (function (_super) {
    __extends$46(AccumulationDistributionIndicator, _super);
    function AccumulationDistributionIndicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Defines the predictions using accumulation distribution approach
     *
     * @private
     */
    AccumulationDistributionIndicator.prototype.initDataSource = function (indicator) {
        var adPoints = [];
        var validData = indicator.points;
        if (validData.length > 0 && validData.length > indicator.period) {
            adPoints = this.calculateADPoints(indicator, validData);
        }
        this.setSeriesRange(adPoints, indicator);
    };
    /**
     *  Calculates the Accumulation Distribution values
     *
     * @private
     */
    AccumulationDistributionIndicator.prototype.calculateADPoints = function (indicator, validData) {
        var temp = [];
        var sum = 0;
        var i = 0;
        var value = 0;
        var high = 0;
        var low = 0;
        var close = 0;
        var signalSeries = indicator.targetSeries[0];
        for (i = 0; i < validData.length; i++) {
            high = Number(validData[i].high);
            low = Number(validData[i].low);
            close = Number(validData[i].close);
            /**
             * Money Flow Multiplier = [(Close -  Low) - (High - Close)] /(High - Low)
             * Money Flow Volume = Money Flow Multiplier x Volume for the Period
             * ADL = Previous ADL + Current Period's Money Flow Volume
             */
            value = ((close - low) - (high - close)) / ((high - low) ? (high - low) : 1);
            /**
             * Sum is to calculate the Y values of the Accumulation distribution indicator
             */
            sum = sum + value * Number(validData[i].volume);
            /**
             * To calculate the x and y values for the Accumulation distribution indicator
             */
            temp[i] = this.getDataPoint(validData[i].x, sum, validData[i], signalSeries, temp.length);
        }
        return temp;
    };
    /**
     * To destroy the Accumulation Distribution Technical Indicator.
     *
     * @returns {void}
     * @private
     */
    AccumulationDistributionIndicator.prototype.destroy = function () {
        /**
         * Destroys the Accumulation Distribution Technical indicator
         */
    };
    /**
     * Get module name.
     */
    AccumulationDistributionIndicator.prototype.getModuleName = function () {
        /**
         * Returns the module name of the Indicator
         */
        return 'AccumulationDistributionIndicator';
    };
    return AccumulationDistributionIndicator;
}(TechnicalAnalysis));

var __extends$47 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * `AtrIndicator` module is used to render ATR indicator.
 */
var AtrIndicator = /** @__PURE__ @class */ (function (_super) {
    __extends$47(AtrIndicator, _super);
    function AtrIndicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Defines the predictions using Average True Range approach
     *
     * @private
     */
    AtrIndicator.prototype.initDataSource = function (indicator) {
        var validData = indicator.points;
        if (validData.length > 0 && validData.length > indicator.period) {
            this.calculateATRPoints(indicator, validData);
        }
    };
    /**
     *  To calculate Average True Range indicator points
     *
     * @private
     */
    AtrIndicator.prototype.calculateATRPoints = function (indicator, validData) {
        var average = 0;
        var highLow = 0;
        var highClose = 0;
        var lowClose = 0;
        var trueRange = 0;
        var points = [];
        var temp = [];
        var period = indicator.period;
        var sum = 0;
        var y = 'y';
        var signalSeries = indicator.targetSeries[0];
        for (var i = 0; i < validData.length; i++) {
            /**
             * Current High less the current Low
             * Current High less the previous Close (absolute value)
             * Current Low less the previous Close (absolute value)
             */
            highLow = Number(validData[i].high) - Number(validData[i].low);
            if (i > 0) {
                //
                highClose = Math.abs(Number(validData[i].high) - Number(validData[i - 1].close));
                lowClose = Math.abs(Number(validData[i].low) - Number(validData[i - 1].close));
            }
            /**
             * To find the maximum of highLow, highClose, lowClose
             */
            trueRange = Math.max(highLow, highClose, lowClose);
            sum = sum + trueRange;
            /**
             * Push the x and y values for the Average true range indicator
             */
            if (i >= period) {
                average = (Number(temp[i - 1][y]) * (period - 1) + trueRange) / period;
                points.push(this.getDataPoint(validData[i].x, average, validData[i], signalSeries, points.length));
            }
            else {
                average = sum / period;
                if (i === period - 1) {
                    points.push(this.getDataPoint(validData[i].x, average, validData[i], signalSeries, points.length));
                }
            }
            temp[i] = { x: validData[i].x, y: average };
        }
        this.setSeriesRange(points, indicator);
    };
    /**
     * To destroy the Average true range indicator.
     *
     * @returns {void}
     * @private
     */
    AtrIndicator.prototype.destroy = function () {
        /**
         * Destroy the Average true range indicator
         */
    };
    /**
     * Get module name.
     */
    AtrIndicator.prototype.getModuleName = function () {
        /**
         * Returns the module name of the Indicator
         */
        return 'AtrIndicator';
    };
    return AtrIndicator;
}(TechnicalAnalysis));

var __extends$48 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `MomentumIndicator` module is used to render Momentum indicator.
 */
var MomentumIndicator = /** @__PURE__ @class */ (function (_super) {
    __extends$48(MomentumIndicator, _super);
    function MomentumIndicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Defines the collection of series to represent a momentum indicator
     *
     * @private
     */
    MomentumIndicator.prototype.initSeriesCollection = function (indicator, chart) {
        _super.prototype.initSeriesCollection.call(this, indicator, chart);
        var upperLine = new Series(indicator, 'targetSeries', {}, true);
        _super.prototype.setSeriesProperties.call(this, upperLine, indicator, 'UpperLine', indicator.upperLine.color, indicator.upperLine.width, chart);
    };
    /**
     * Defines the predictions using momentum approach
     *
     * @private
     */
    MomentumIndicator.prototype.initDataSource = function (indicator) {
        var upperCollection = [];
        var signalCollection = [];
        var validData = indicator.points;
        if (validData && validData.length) {
            var upperSeries = indicator.targetSeries[1];
            var signalSeries = indicator.targetSeries[0];
            var length_1 = indicator.period;
            if (validData.length >= indicator.period) {
                for (var i = 0; i < validData.length; i++) {
                    upperCollection.push(this.getDataPoint(validData[i].x, 100, validData[i], upperSeries, upperCollection.length));
                    if (!(i < length_1)) {
                        signalCollection.push(this.getDataPoint(validData[i].x, (Number(validData[i].close) / Number(validData[i - length_1].close) * 100), validData[i], signalSeries, signalCollection.length));
                    }
                }
            }
            this.setSeriesRange(signalCollection, indicator, indicator.targetSeries[0]);
            this.setSeriesRange(upperCollection, indicator, indicator.targetSeries[1]);
        }
    };
    /**
     * To destroy the momentum indicator
     *
     * @returns {void}
     * @private
     */
    MomentumIndicator.prototype.destroy = function () {
        /**
         * Destroys the momentum indicator
         */
    };
    /**
     * Get module name.
     */
    MomentumIndicator.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'MomentumIndicator';
    };
    return MomentumIndicator;
}(TechnicalAnalysis));

var __extends$49 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `RsiIndicator` module is used to render RSI indicator.
 */
var RsiIndicator = /** @__PURE__ @class */ (function (_super) {
    __extends$49(RsiIndicator, _super);
    function RsiIndicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Initializes the series collection to represent the RSI Indicator
     *
     * @private
     */
    RsiIndicator.prototype.initSeriesCollection = function (indicator, chart) {
        _super.prototype.initSeriesCollection.call(this, indicator, chart);
        if (indicator.showZones) {
            var lowerLine = new Series(indicator, 'targetSeries', {}, true);
            _super.prototype.setSeriesProperties.call(this, lowerLine, indicator, 'LowerLine', indicator.lowerLine.color, indicator.lowerLine.width, chart);
            var upperLine = new Series(indicator, 'targetSeries', {}, true);
            _super.prototype.setSeriesProperties.call(this, upperLine, indicator, 'UpperLine', indicator.upperLine.color, indicator.upperLine.width, chart);
        }
    };
    /**
     * Defines the predictions using RSI approach
     *
     * @private
     */
    RsiIndicator.prototype.initDataSource = function (indicator) {
        var signalCollection = [];
        var lowerCollection = [];
        var upperCollection = [];
        var signalSeries = indicator.targetSeries[0];
        //prepare data
        var validData = indicator.points;
        if (validData.length && validData.length >= indicator.period) {
            //Find upper band and lower band values
            if (indicator.showZones) {
                for (var i = 0; i < validData.length; i++) {
                    upperCollection.push(this.getDataPoint(validData[i].x, indicator.overBought, validData[i], indicator.targetSeries[1], upperCollection.length));
                    lowerCollection.push(this.getDataPoint(validData[i].x, indicator.overSold, validData[i], indicator.targetSeries[2], lowerCollection.length));
                }
            }
            //Find signal line value
            var prevClose = Number(validData[0].close);
            var gain = 0;
            var loss = 0;
            for (var i = 1; i <= indicator.period; i++) {
                var close_1 = Number(validData[i].close);
                if (close_1 > prevClose) {
                    gain += close_1 - prevClose;
                }
                else {
                    loss += prevClose - close_1;
                }
                prevClose = close_1;
            }
            gain = gain / indicator.period;
            loss = loss / indicator.period;
            signalCollection.push(this.getDataPoint(validData[indicator.period].x, 100 - (100 / (1 + gain / loss)), validData[indicator.period], signalSeries, signalCollection.length));
            for (var j = indicator.period + 1; j < validData.length; j++) {
                var close_2 = Number(validData[j].close);
                if (close_2 > prevClose) {
                    gain = (gain * (indicator.period - 1) + (close_2 - prevClose)) / indicator.period;
                    loss = (loss * (indicator.period - 1)) / indicator.period;
                }
                else if (close_2 < prevClose) {
                    loss = (loss * (indicator.period - 1) + (prevClose - close_2)) / indicator.period;
                    gain = (gain * (indicator.period - 1)) / indicator.period;
                }
                prevClose = close_2;
                signalCollection.push(this.getDataPoint(validData[j].x, 100 - (100 / (1 + gain / loss)), validData[j], signalSeries, signalCollection.length));
            }
        }
        this.setSeriesRange(signalCollection, indicator, indicator.targetSeries[0]);
        if (indicator.showZones) {
            this.setSeriesRange(upperCollection, indicator, indicator.targetSeries[1]);
            this.setSeriesRange(lowerCollection, indicator, indicator.targetSeries[2]);
        }
    };
    /**
     * To destroy the RSI Indicator.
     *
     * @returns {void}
     * @private
     */
    RsiIndicator.prototype.destroy = function () {
        /**
         * Destroys the RSI Indicator
         */
    };
    /**
     * Get module name.
     */
    RsiIndicator.prototype.getModuleName = function () {
        /**
         * Returns the module name of the indicator.
         */
        return 'RsiIndicator';
    };
    return RsiIndicator;
}(TechnicalAnalysis));

var __extends$50 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `StochasticIndicator` module is used to render stochastic indicator.
 */
var StochasticIndicator = /** @__PURE__ @class */ (function (_super) {
    __extends$50(StochasticIndicator, _super);
    function StochasticIndicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Defines the collection of series that represents the stochastic indicator
     *
     * @private
     */
    StochasticIndicator.prototype.initSeriesCollection = function (indicator, chart) {
        _super.prototype.initSeriesCollection.call(this, indicator, chart);
        var periodLine = new Series(indicator, 'targetSeries', {}, true);
        this.setSeriesProperties(periodLine, indicator, 'PeriodLine', indicator.periodLine.color, indicator.periodLine.width, chart);
        if (indicator.showZones) {
            var upperSeries = new Series(indicator, 'targetSeries', {}, true);
            this.setSeriesProperties(upperSeries, indicator, 'UpperLine', indicator.upperLine.color, indicator.upperLine.width, chart);
            var lowerSeries = new Series(indicator, 'targetSeries', {}, true);
            this.setSeriesProperties(lowerSeries, indicator, 'LowerLine', indicator.lowerLine.color, indicator.lowerLine.width, chart);
        }
    };
    /**
     * Defines the predictions based on stochastic approach
     *
     * @private
     */
    StochasticIndicator.prototype.initDataSource = function (indicator) {
        var signalCollection = [];
        var upperCollection = [];
        var lowerCollection = [];
        var periodCollection = [];
        var source = [];
        //prepare data
        var validData = indicator.points;
        if (validData.length && validData.length >= indicator.period) {
            if (indicator.showZones) {
                for (var i = 0; i < validData.length; i++) {
                    upperCollection.push(this.getDataPoint(validData[i].x, indicator.overBought, validData[i], indicator.targetSeries[2], upperCollection.length));
                    lowerCollection.push(this.getDataPoint(validData[i].x, indicator.overSold, validData[i], indicator.targetSeries[3], lowerCollection.length));
                }
            }
            source = this.calculatePeriod(indicator.period, indicator.kPeriod, validData, indicator.targetSeries[1]);
            periodCollection = this.smaCalculation(indicator.period, indicator.kPeriod, source, indicator.targetSeries[1]);
            signalCollection = this.smaCalculation(indicator.period + indicator.kPeriod - 1, indicator.dPeriod, source, indicator.targetSeries[0]);
        }
        this.setSeriesRange(signalCollection, indicator, indicator.targetSeries[0]);
        this.setSeriesRange(periodCollection, indicator, indicator.targetSeries[1]);
        if (indicator.showZones) {
            this.setSeriesRange(upperCollection, indicator, indicator.targetSeries[2]);
            this.setSeriesRange(lowerCollection, indicator, indicator.targetSeries[3]);
        }
    };
    /**
     * Calculates the SMA Values
     *
     * @private
     */
    StochasticIndicator.prototype.smaCalculation = function (period, kPeriod, data, sourceSeries) {
        var pointCollection = [];
        if (data.length >= period + kPeriod) {
            var count = period + (kPeriod - 1);
            var temp = [];
            var values = [];
            for (var i = 0; i < data.length; i++) {
                var value = Number(data[i].y);
                temp.push(value);
            }
            var length_1 = temp.length;
            while (length_1 >= count) {
                var sum = 0;
                for (var i = period - 1; i < (period + kPeriod - 1); i++) {
                    sum = sum + temp[i];
                }
                sum = sum / kPeriod;
                values.push(sum.toFixed(2));
                temp.splice(0, 1);
                length_1 = temp.length;
            }
            var len = count - 1;
            for (var i = 0; i < data.length; i++) {
                if (!(i < len)) {
                    pointCollection.push(this.getDataPoint(data[i].x, Number(values[i - len]), data[i], sourceSeries, pointCollection.length));
                    data[i].y = Number((values[i - len]));
                }
            }
        }
        return pointCollection;
    };
    /**
     * Calculates the period line values.
     *
     * @private
     */
    StochasticIndicator.prototype.calculatePeriod = function (period, kPeriod, data, series) {
        var lowValues = [];
        var highValues = [];
        var closeValues = [];
        var modifiedSource = [];
        for (var j = 0; j < data.length; j++) {
            lowValues[j] = data[j].low;
            highValues[j] = data[j].high;
            closeValues[j] = data[j].close;
        }
        if (data.length > period) {
            var mins = [];
            var maxs = [];
            for (var i = 0; i < period - 1; ++i) {
                maxs.push(0);
                mins.push(0);
                modifiedSource.push(this.getDataPoint(data[i].x, data[i].close, data[i], series, modifiedSource.length));
            }
            for (var i = period - 1; i < data.length; ++i) {
                var min = Number.MAX_VALUE;
                var max = Number.MIN_VALUE;
                for (var j = 0; j < period; ++j) {
                    min = Math.min(min, lowValues[i - j]);
                    max = Math.max(max, highValues[i - j]);
                }
                maxs.push(max);
                mins.push(min);
            }
            for (var i = period - 1; i < data.length; ++i) {
                var top_1 = 0;
                var bottom = 0;
                top_1 += closeValues[i] - mins[i];
                bottom += maxs[i] - mins[i];
                modifiedSource.push(this.getDataPoint(data[i].x, (top_1 / bottom) * 100, data[i], series, modifiedSource.length));
            }
        }
        return modifiedSource;
    };
    /**
     * To destroy the Stocastic Indicator.
     *
     * @returns {void}
     * @private
     */
    StochasticIndicator.prototype.destroy = function () {
        /**
         * Destroys the stochastic indicator
         */
    };
    /**
     * Get module name.
     */
    StochasticIndicator.prototype.getModuleName = function () {
        /**
         * Returns the module name of the indicator.
         */
        return 'StochasticIndicator';
    };
    return StochasticIndicator;
}(TechnicalAnalysis));

var __extends$51 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `BollingerBands` module is used to render bollinger band indicator.
 */
var BollingerBands = /** @__PURE__ @class */ (function (_super) {
    __extends$51(BollingerBands, _super);
    function BollingerBands() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Initializes the series collection to represent bollinger band.
     */
    BollingerBands.prototype.initSeriesCollection = function (indicator, chart) {
        indicator.targetSeries = [];
        var rangeArea = new Series(indicator, 'targetSeries', {}, true);
        rangeArea.type = 'RangeArea';
        if (indicator.bandColor !== 'transparent' && indicator.bandColor !== 'none') {
            this.setSeriesProperties(rangeArea, indicator, 'BollingerBand', indicator.bandColor, 0, chart);
        }
        var signalLine = new Series(indicator, 'targetSeries', {}, true);
        this.setSeriesProperties(signalLine, indicator, 'BollingerBand', indicator.fill, indicator.width, chart);
        var upperLine = new Series(indicator, 'targetSeries', {}, true);
        this.setSeriesProperties(upperLine, indicator, 'UpperLine', indicator.upperLine.color, indicator.upperLine.width, chart);
        var lowerLine = new Series(indicator, 'targetSeries', {}, true);
        this.setSeriesProperties(lowerLine, indicator, 'LowerLine', indicator.lowerLine.color, indicator.lowerLine.width, chart);
    };
    /**
     * Defines the predictions using Bollinger Band Approach
     *
     * @private
     */
    BollingerBands.prototype.initDataSource = function (indicator) {
        var enableBand = indicator.bandColor !== 'transparent' && indicator.bandColor !== 'none';
        var start = enableBand ? 1 : 0;
        var signalCollection = [];
        var upperCollection = [];
        var lowerCollection = [];
        var bandCollection = [];
        var upperSeries = indicator.targetSeries[start + 1];
        var lowerSeries = indicator.targetSeries[start + 2];
        var signalSeries = indicator.targetSeries[start];
        var rangeAreaSeries = enableBand ? indicator.targetSeries[0] : null;
        //prepare data
        var validData = indicator.points;
        if (validData.length && validData.length >= indicator.period) {
            var sum = 0;
            var deviationSum = 0;
            var multiplier = indicator.standardDeviation;
            var limit = validData.length;
            var length_1 = Math.round(indicator.period);
            var smaPoints = [];
            var deviations = [];
            var bollingerPoints = [];
            for (var i_1 = 0; i_1 < length_1; i_1++) {
                sum += Number(validData[i_1].close);
            }
            var sma = sum / indicator.period;
            for (var i_2 = 0; i_2 < limit; i_2++) {
                var y = Number(validData[i_2].close);
                if (i_2 >= length_1 - 1 && i_2 < limit) {
                    if (i_2 - indicator.period >= 0) {
                        var diff = y - Number(validData[i_2 - length_1].close);
                        sum = sum + diff;
                        sma = sum / (indicator.period);
                        smaPoints[i_2] = sma;
                        deviations[i_2] = Math.pow(y - sma, 2);
                        deviationSum += deviations[i_2] - deviations[i_2 - length_1];
                    }
                    else {
                        smaPoints[i_2] = sma;
                        deviations[i_2] = Math.pow(y - sma, 2);
                        deviationSum += deviations[i_2];
                    }
                    var range = Math.sqrt(deviationSum / (indicator.period));
                    var lowerBand = smaPoints[i_2] - (multiplier * range);
                    var upperBand = smaPoints[i_2] + (multiplier * range);
                    if (i_2 + 1 === length_1) {
                        for (var j_1 = 0; j_1 < length_1 - 1; j_1++) {
                            bollingerPoints[j_1] = {
                                'X': validData[j_1].x, 'mb': smaPoints[i_2],
                                'lb': lowerBand, 'ub': upperBand, visible: true
                            };
                        }
                    }
                    bollingerPoints[i_2] = {
                        'X': validData[i_2].x, 'mb': smaPoints[i_2],
                        'lb': lowerBand, 'ub': upperBand, visible: true
                    };
                }
                else {
                    if (i_2 < indicator.period - 1) {
                        smaPoints[i_2] = sma;
                        deviations[i_2] = Math.pow(y - sma, 2);
                        deviationSum += deviations[i_2];
                    }
                }
            }
            var i = -1;
            var j = -1;
            for (var k = 0; k < limit; k++) {
                if (k >= (length_1 - 1)) {
                    var ub = 'ub';
                    var lb = 'lb';
                    var mb = 'mb';
                    upperCollection.push(this.getDataPoint(validData[k].x, bollingerPoints[k][ub], validData[k], upperSeries, upperCollection.length));
                    lowerCollection.push(this.getDataPoint(validData[k].x, bollingerPoints[k][lb], validData[k], lowerSeries, lowerCollection.length));
                    signalCollection.push(this.getDataPoint(validData[k].x, bollingerPoints[k][mb], validData[k], signalSeries, signalCollection.length));
                    if (enableBand) {
                        bandCollection.push(this.getRangePoint(validData[k].x, upperCollection[++i].y, lowerCollection[++j].y, validData[k], rangeAreaSeries, bandCollection.length));
                    }
                }
            }
        }
        if (enableBand) {
            this.setSeriesRange(bandCollection, indicator, indicator.targetSeries[0]);
        }
        this.setSeriesRange(signalCollection, indicator, indicator.targetSeries[start]);
        this.setSeriesRange(upperCollection, indicator, indicator.targetSeries[start + 1]);
        this.setSeriesRange(lowerCollection, indicator, indicator.targetSeries[start + 2]);
    };
    /**
     * To destroy the Bollinger Band.
     *
     * @returns {void}
     * @private
     */
    BollingerBands.prototype.destroy = function () {
        /**
         * Destroys the bollinger band
         */
    };
    /**
     * Get module name.
     */
    BollingerBands.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'BollingerBandsIndicator';
    };
    return BollingerBands;
}(TechnicalAnalysis));

var __extends$52 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `MacdIndicator` module is used to render MACD indicator.
 */
var MacdIndicator = /** @__PURE__ @class */ (function (_super) {
    __extends$52(MacdIndicator, _super);
    function MacdIndicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Defines the collection of series to represent the MACD indicator
     *
     * @private
     */
    MacdIndicator.prototype.initSeriesCollection = function (indicator, chart) {
        _super.prototype.initSeriesCollection.call(this, indicator, chart);
        if (indicator.macdType === 'Line' || indicator.macdType === 'Both') {
            var macdSeries = new Series(indicator, 'targetSeries', {}, true);
            this.setSeriesProperties(macdSeries, indicator, 'MacdLine', indicator.macdLine.color, indicator.macdLine.width, chart);
        }
        if (indicator.macdType === 'Histogram' || indicator.macdType === 'Both') {
            var histogramSeries = new Series(indicator, 'targetSeries', {}, true);
            histogramSeries.type = 'Column';
            this.setSeriesProperties(histogramSeries, indicator, 'Histogram', indicator.macdPositiveColor, indicator.width, chart);
        }
    };
    /**
     * Defines the predictions using MACD approach
     *
     * @private
     */
    MacdIndicator.prototype.initDataSource = function (indicator) {
        var signalCollection = [];
        var fastPeriod = indicator.fastPeriod;
        var slowPeriod = indicator.slowPeriod;
        var trigger = indicator.period;
        var length = fastPeriod + trigger;
        var macdCollection = [];
        var histogramCollection = [];
        var validData = indicator.points;
        var signalSeries = indicator.targetSeries[0];
        var histogramSeries;
        var macdLineSeries;
        if (indicator.macdType === 'Histogram') {
            histogramSeries = indicator.targetSeries[1];
        }
        else {
            macdLineSeries = indicator.targetSeries[1];
            if (indicator.macdType === 'Both') {
                histogramSeries = indicator.targetSeries[2];
            }
        }
        if (validData && length < validData.length && slowPeriod <= fastPeriod &&
            slowPeriod > 0 && (length - 2) >= 0) {
            var shortEMA = this.calculateEMAValues(slowPeriod, validData, 'close');
            var longEMA = this.calculateEMAValues(fastPeriod, validData, 'close');
            var macdValues = this.getMACDVales(indicator, shortEMA, longEMA);
            macdCollection = this.getMACDPoints(indicator, macdValues, validData, macdLineSeries || signalSeries);
            var signalEMA = this.calculateEMAValues(trigger, macdCollection, 'y');
            signalCollection = this.getSignalPoints(indicator, signalEMA, validData, signalSeries);
            if (histogramSeries) {
                histogramCollection = this.getHistogramPoints(indicator, macdValues, signalEMA, validData, histogramSeries);
            }
        }
        this.setSeriesRange(signalCollection, indicator, indicator.targetSeries[0]);
        if (histogramSeries) {
            this.setSeriesRange(histogramCollection, indicator, histogramSeries);
        }
        if (macdLineSeries) {
            this.setSeriesRange(macdCollection, indicator, macdLineSeries);
        }
    };
    /**
     * Calculates the EMA values for the given period
     */
    MacdIndicator.prototype.calculateEMAValues = function (period, validData, field) {
        var sum = 0;
        var initialEMA = 0;
        var emaValues = [];
        var emaPercent = (2 / (period + 1));
        for (var i = 0; i < period; i++) {
            sum += Number(validData[i][field]);
        }
        initialEMA = (sum / period);
        emaValues.push(initialEMA);
        var emaAvg = initialEMA;
        for (var j = period; j < validData.length; j++) {
            emaAvg = (Number(validData[j][field]) - emaAvg) * emaPercent + emaAvg;
            emaValues.push(emaAvg);
        }
        return emaValues;
    };
    /**
     * Defines the MACD Points
     */
    MacdIndicator.prototype.getMACDPoints = function (indicator, macdPoints, validData, series) {
        var macdCollection = [];
        var dataMACDIndex = indicator.fastPeriod - 1;
        var macdIndex = 0;
        while (dataMACDIndex < validData.length) {
            macdCollection.push(this.getDataPoint(validData[dataMACDIndex].x, macdPoints[macdIndex], validData[dataMACDIndex], series, macdCollection.length));
            dataMACDIndex++;
            macdIndex++;
        }
        return macdCollection;
    };
    /**
     * Calculates the signal points
     */
    MacdIndicator.prototype.getSignalPoints = function (indicator, signalEma, validData, series) {
        var dataSignalIndex = indicator.fastPeriod + indicator.period - 2;
        var signalIndex = 0;
        var signalCollection = [];
        while (dataSignalIndex < validData.length) {
            signalCollection.push(this.getDataPoint(validData[dataSignalIndex].x, signalEma[signalIndex], validData[dataSignalIndex], series, signalCollection.length));
            dataSignalIndex++;
            signalIndex++;
        }
        return signalCollection;
    };
    /**
     * Calculates the MACD values
     */
    MacdIndicator.prototype.getMACDVales = function (indicator, shortEma, longEma) {
        var macdPoints = [];
        var diff = indicator.fastPeriod - indicator.slowPeriod;
        for (var i = 0; i < longEma.length; i++) {
            macdPoints.push((shortEma[i + diff] - longEma[i]));
        }
        return macdPoints;
    };
    /**
     * Calculates the Histogram Points
     */
    MacdIndicator.prototype.getHistogramPoints = function (indicator, macdPoints, signalEma, validData, series) {
        var dataHistogramIndex = indicator.fastPeriod + indicator.period - 2;
        var histogramIndex = 0;
        var histogramCollection = [];
        while (dataHistogramIndex < validData.length) {
            histogramCollection.push(this.getDataPoint(validData[dataHistogramIndex].x, macdPoints[histogramIndex + (indicator.period - 1)] -
                signalEma[histogramIndex], validData[dataHistogramIndex], series, histogramCollection.length, indicator));
            dataHistogramIndex++;
            histogramIndex++;
        }
        return histogramCollection;
    };
    /**
     * To destroy the MACD Indicator.
     *
     * @returns {void}
     * @private
     */
    MacdIndicator.prototype.destroy = function () {
        /**
         * Destroys the MACD indicator
         */
    };
    /**
     * Get module name.
     */
    MacdIndicator.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'MacdIndicator';
    };
    return MacdIndicator;
}(TechnicalAnalysis));

/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `Trendline` module is used to render 6 types of trendlines in chart.
 */
var Trendlines = /** @__PURE__ @class */ (function () {
    function Trendlines() {
    }
    /**
     * Defines the collection of series, that are used to represent a trendline
     *
     * @private
     */
    Trendlines.prototype.initSeriesCollection = function (trendline, chart) {
        var trendLineSeries = new Series(trendline, 'targetSeries', {}, true);
        if (trendline.type === 'Linear' || trendline.type === 'MovingAverage') {
            trendLineSeries.type = 'Line';
        }
        else {
            trendLineSeries.type = 'Spline';
        }
        this.setSeriesProperties(trendLineSeries, trendline, trendline.type, trendline.fill, trendline.width, chart);
    };
    /**
     * Initializes the properties of the trendline series
     */
    Trendlines.prototype.setSeriesProperties = function (series, trendline, name, fill, width, chart) {
        series.name = trendline.name;
        series.xName = 'x';
        series.yName = 'y';
        series.fill = fill || 'blue';
        series.width = width;
        series.dashArray = trendline.dashArray;
        series.clipRectElement = trendline.clipRectElement;
        series.points = [];
        series.enableTooltip = trendline.enableTooltip;
        series.index = trendline.index;
        series.sourceIndex = trendline.sourceIndex;
        series.interior = series.fill;
        series.animation = trendline.animation;
        series.legendShape = 'HorizontalLine';
        series.marker = trendline.marker;
        series.category = 'TrendLine';
        series.chart = chart;
        series.xMin = Infinity;
        series.xMax = -Infinity;
        series.yMin = Infinity;
        series.yMax = -Infinity;
        series.xData = [];
        series.yData = [];
        trendline.targetSeries = series;
        if (chart.isBlazor) {
            trendline.targetSeries.border = {}; // To avoid console error in blazor
            trendline.targetSeries.connector = {}; // To avoid console error in blazor
        }
    };
    /**
     * Creates the elements of a trendline
     */
    Trendlines.prototype.createTrendLineElements = function (chart, trendline, index, element, clipRectElement) {
        trendline.trendLineElement = element;
        trendline.targetSeries.clipRectElement = clipRectElement;
        trendline.targetSeries.seriesElement = element;
        if (chart.trendLineElements) {
            chart.trendLineElements.appendChild(trendline.trendLineElement);
        }
    };
    /**
     * Defines the data point of trendline
     */
    Trendlines.prototype.getDataPoint = function (x, y, series, index) {
        var trendPoint = new Points();
        trendPoint.x = series.xAxis.valueType === 'DateTime' ? new Date(Number(x)) : x;
        trendPoint.y = y;
        trendPoint.xValue = Number(x);
        trendPoint.color = series.fill;
        trendPoint.index = index;
        trendPoint.yValue = Number(y);
        trendPoint.visible = true;
        series.xMin = Math.min(series.xMin, trendPoint.xValue);
        series.yMin = Math.min(series.yMin, trendPoint.yValue);
        series.xMax = Math.max(series.xMax, trendPoint.xValue);
        series.yMax = Math.max(series.yMax, trendPoint.yValue);
        series.xData.push(trendPoint.xValue);
        return trendPoint;
    };
    /**
     * Finds the slope and intercept of trendline
     */
    Trendlines.prototype.findSlopeIntercept = function (xValues, yValues, trendline, points) {
        var xAvg = 0;
        var yAvg = 0;
        var xyAvg = 0;
        var xxAvg = 0;
        var index = 0;
        var slope = 0;
        var intercept = 0;
        while (index < points.length) {
            // To fix trendline not rendered issue while Nan Value is provided for y values.
            if (isNaN(yValues[index])) {
                yValues[index] = ((yValues[index - 1] + yValues[index + 1]) / 2);
            }
            xAvg += xValues[index];
            yAvg += yValues[index];
            xyAvg += xValues[index] * yValues[index];
            xxAvg += xValues[index] * xValues[index];
            index++;
        }
        var type = trendline.type;
        if (trendline.intercept && (type === 'Linear' || type === 'Exponential')) {
            intercept = trendline.intercept;
            switch (type) {
                case 'Linear':
                    slope = ((xyAvg) - (trendline.intercept * xAvg)) / xxAvg;
                    break;
                case 'Exponential':
                    slope = ((xyAvg) - (Math.log(Math.abs(trendline.intercept)) * xAvg)) / xxAvg;
                    break;
            }
        }
        else {
            slope = ((points.length * xyAvg) - (xAvg * yAvg)) / ((points.length * xxAvg) - (xAvg * xAvg));
            slope = (type === 'Linear' ? slope : Math.abs(slope));
            if (type === 'Exponential' || type === 'Power') {
                intercept = Math.exp((yAvg - (slope * xAvg)) / points.length);
            }
            else {
                intercept = (yAvg - (slope * xAvg)) / points.length;
            }
        }
        return { slope: slope, intercept: intercept };
    };
    /**
     * Defines the points to draw the trendlines.
     */
    Trendlines.prototype.initDataSource = function (trendline) {
        var points = trendline.points;
        if (points && points.length) {
            //prepare data
            var trendlineSeries = trendline.targetSeries;
            switch (trendline.type) {
                case 'Linear':
                    this.setLinearRange(points, trendline, trendlineSeries);
                    break;
                case 'Exponential':
                    this.setExponentialRange(points, trendline, trendlineSeries);
                    break;
                case 'MovingAverage':
                    this.setMovingAverageRange(points, trendline, trendlineSeries);
                    break;
                case 'Polynomial':
                    this.setPolynomialRange(points, trendline, trendlineSeries);
                    break;
                case 'Power':
                    this.setPowerRange(points, trendline, trendlineSeries);
                    break;
                case 'Logarithmic':
                    this.setLogarithmicRange(points, trendline, trendlineSeries);
                    break;
            }
            if (trendline.type !== 'Linear' && trendline.type !== 'MovingAverage') {
                trendlineSeries.chart.splineSeriesModule.findSplinePoint(trendlineSeries);
            }
        }
    };
    /**
     * Calculation of exponential points
     */
    Trendlines.prototype.setExponentialRange = function (points, trendline, series) {
        var xValue = [];
        var yValue = [];
        var index = 0;
        while (index < points.length) {
            var point = points[index];
            var yDataValue = point.yValue ? Math.log(point.yValue) : 0;
            xValue.push(point.xValue);
            yValue.push(yDataValue);
            index++;
        }
        var slopeIntercept = this.findSlopeIntercept(xValue, yValue, trendline, points);
        series.points = this.getExponentialPoints(trendline, points, xValue, yValue, series, slopeIntercept);
    };
    /**
     * Calculation of logarithmic points
     */
    Trendlines.prototype.setLogarithmicRange = function (points, trendline, series) {
        var xLogValue = [];
        var yLogValue = [];
        var xPointsLgr = [];
        var index = 0;
        while (index < points.length) {
            var point = points[index];
            var xDataValue = point.xValue ? Math.log(point.xValue) : 0;
            xPointsLgr.push(point.xValue);
            xLogValue.push(xDataValue);
            yLogValue.push(point.yValue);
            index++;
        }
        var slopeIntercept = this.findSlopeIntercept(xLogValue, yLogValue, trendline, points);
        series.points = this.getLogarithmicPoints(trendline, points, xPointsLgr, yLogValue, series, slopeIntercept);
    };
    /**
     * Calculation of polynomial points
     */
    Trendlines.prototype.setPolynomialRange = function (points, trendline, series) {
        var xPolyValues = [];
        var yPolyValues = [];
        var index = 0;
        while (index < points.length) {
            var point = points[index];
            xPolyValues.push(point.xValue);
            yPolyValues.push(point.yValue);
            index++;
        }
        series.points = this.getPolynomialPoints(trendline, points, xPolyValues, yPolyValues, series);
    };
    /**
     * Calculation of power points
     */
    Trendlines.prototype.setPowerRange = function (points, trendline, series) {
        var xValues = [];
        var yValues = [];
        var powerPoints = [];
        var index = 0;
        while (index < points.length) {
            var point = points[index];
            var xDataValue = point.xValue ? Math.log(point.xValue) : 0;
            var yDataValue = point.yValue ? Math.log(point.yValue) : 0;
            powerPoints.push(point.xValue);
            xValues.push(xDataValue);
            yValues.push(yDataValue);
            index++;
        }
        var slopeIntercept = this.findSlopeIntercept(xValues, yValues, trendline, points);
        series.points = this.getPowerPoints(trendline, points, powerPoints, yValues, series, slopeIntercept);
    };
    /**
     * Calculation of linear points
     */
    Trendlines.prototype.setLinearRange = function (points, trendline, series) {
        var xValues = [];
        var yValues = [];
        var index = 0;
        while (index < points.length) {
            var point = points[index];
            xValues.push(point.xValue);
            yValues.push(point.yValue);
            index++;
        }
        var slopeIntercept = this.findSlopeIntercept(xValues, yValues, trendline, points);
        series.points = this.getLinearPoints(trendline, points, xValues, yValues, series, slopeIntercept);
    };
    /**
     * Calculation of moving average points
     */
    Trendlines.prototype.setMovingAverageRange = function (points, trendline, series) {
        var xValues = [];
        var yValues = [];
        var xAvgValues = [];
        var index = 0;
        while (index < points.length) {
            var point = points[index];
            xAvgValues.push(point.xValue);
            xValues.push(index + 1);
            yValues.push(point.yValue);
            index++;
        }
        series.points = this.getMovingAveragePoints(trendline, points, xAvgValues, yValues, series);
    };
    /**
     * Calculation of logarithmic points
     */
    Trendlines.prototype.getLogarithmicPoints = function (trendline, points, xValues, yValues, series, slopeInterceptLog) {
        var midPoint = Math.round((points.length / 2));
        var pts = [];
        var x1Log = xValues[0] - trendline.backwardForecast;
        var x1 = x1Log ? Math.log(x1Log) : 0;
        var y1Log = slopeInterceptLog.intercept + (slopeInterceptLog.slope * x1);
        var x2Log = xValues[midPoint - 1];
        var x2 = x2Log ? Math.log(x2Log) : 0;
        var y2Log = slopeInterceptLog.intercept + (slopeInterceptLog.slope * x2);
        var x3Log = xValues[xValues.length - 1] + trendline.forwardForecast;
        var x3 = x3Log ? Math.log(x3Log) : 0;
        var y3Log = slopeInterceptLog.intercept + (slopeInterceptLog.slope * x3);
        pts.push(this.getDataPoint(x1Log, y1Log, series, pts.length));
        pts.push(this.getDataPoint(x2Log, y2Log, series, pts.length));
        pts.push(this.getDataPoint(x3Log, y3Log, series, pts.length));
        return pts;
    };
    /**
     * Defines the points based on data point
     */
    Trendlines.prototype.getPowerPoints = function (trendline, points, xValues, yValues, series, slopeInterceptPower) {
        var midPoint = Math.round((points.length / 2));
        var pts = [];
        var x1 = xValues[0] - trendline.backwardForecast;
        x1 = x1 > -1 ? x1 : 0;
        var y1 = slopeInterceptPower.intercept * Math.pow(x1, slopeInterceptPower.slope);
        var x2 = xValues[midPoint - 1];
        var y2 = slopeInterceptPower.intercept * Math.pow(x2, slopeInterceptPower.slope);
        var x3 = xValues[xValues.length - 1] + trendline.forwardForecast;
        var y3 = slopeInterceptPower.intercept * Math.pow(x3, slopeInterceptPower.slope);
        pts.push(this.getDataPoint(x1, y1, series, pts.length));
        pts.push(this.getDataPoint(x2, y2, series, pts.length));
        pts.push(this.getDataPoint(x3, y3, series, pts.length));
        return pts;
    };
    /**
     * Get the polynomial points based on polynomial slopes
     */
    Trendlines.prototype.getPolynomialPoints = function (trendline, points, xValues, yValues, series) {
        var pts = [];
        var polynomialOrder = points.length <= trendline.polynomialOrder ? points.length : trendline.polynomialOrder;
        polynomialOrder = Math.max(2, polynomialOrder);
        polynomialOrder = Math.min(6, polynomialOrder);
        trendline.polynomialOrder = polynomialOrder;
        trendline.polynomialSlopes = [];
        trendline.polynomialSlopes.length = trendline.polynomialOrder + 1;
        var index = 0;
        while (index < xValues.length) {
            var xVal = xValues[index];
            var yVal = yValues[index];
            var subIndex = 0;
            while (subIndex <= trendline.polynomialOrder) {
                if (!trendline.polynomialSlopes[subIndex]) {
                    trendline.polynomialSlopes[subIndex] = 0;
                }
                trendline.polynomialSlopes[subIndex] += Math.pow(xVal, subIndex) * yVal;
                ++subIndex;
            }
            index++;
        }
        var numArray = [];
        numArray.length = 1 + 2 * trendline.polynomialOrder;
        var matrix = [];
        matrix.length = trendline.polynomialOrder + 1;
        var newIndex = 0;
        while (newIndex < (trendline.polynomialOrder + 1)) {
            matrix[newIndex] = [];
            matrix[newIndex].length = 3;
            newIndex++;
        }
        var nIndex = 0;
        while (nIndex < xValues.length) {
            var d = xValues[nIndex];
            var num2 = 1.0;
            var nIndex2 = 0;
            while (nIndex2 < numArray.length) {
                if (!numArray[nIndex2]) {
                    numArray[nIndex2] = 0;
                }
                numArray[nIndex2] += num2;
                num2 *= d;
                ++nIndex2;
            }
            ++nIndex;
        }
        var nnIndex = 0;
        while (nnIndex <= trendline.polynomialOrder) {
            var nnIndex2 = 0;
            while (nnIndex2 <= trendline.polynomialOrder) {
                matrix[nnIndex][nnIndex2] = numArray[nnIndex + nnIndex2];
                ++nnIndex2;
            }
            ++nnIndex;
        }
        if (!this.gaussJordanElimination(matrix, trendline.polynomialSlopes)) {
            trendline.polynomialSlopes = null;
        }
        pts = this.getPoints(trendline, points, xValues, series);
        return pts;
    };
    /**
     * Defines the moving average points
     */
    Trendlines.prototype.getMovingAveragePoints = function (trendline, points, xValues, yValues, series) {
        var pts = [];
        var period = trendline.period >= points.length ? points.length - 1 : trendline.period;
        period = Math.max(2, period);
        var index = 0;
        var y;
        var x;
        var count;
        var nullCount;
        while (index < points.length - 1) {
            y = count = nullCount = 0;
            for (var j = index; count < period; j++) {
                count++;
                y += yValues[j];
            }
            y = period - nullCount < 0 ? null : y ? y / (period - nullCount) : y;
            if (!isNullOrUndefined(y) && !isNaN(y)) {
                x = xValues[period - 1 + index];
                pts.push(this.getDataPoint(x, y, series, pts.length));
            }
            index++;
        }
        return pts;
    };
    /**
     * Defines the linear points
     */
    Trendlines.prototype.getLinearPoints = function (trendline, points, xValues, yValues, series, slopeInterceptLinear) {
        var pts = [];
        var max = xValues.indexOf(Math.max.apply(null, xValues));
        var min = xValues.indexOf(Math.min.apply(null, xValues));
        var x1Linear = xValues[min] - trendline.backwardForecast;
        var y1Linear = slopeInterceptLinear.slope * x1Linear + slopeInterceptLinear.intercept;
        var x2Linear = xValues[max] + trendline.forwardForecast;
        var y2Linear = slopeInterceptLinear.slope * x2Linear + slopeInterceptLinear.intercept;
        pts.push(this.getDataPoint(x1Linear, y1Linear, series, pts.length));
        pts.push(this.getDataPoint(x2Linear, y2Linear, series, pts.length));
        return pts;
    };
    /**
     * Defines the exponential points
     */
    Trendlines.prototype.getExponentialPoints = function (trendline, points, xValues, yValues, series, slopeInterceptExp) {
        var midPoint = Math.round((points.length / 2));
        var ptsExp = [];
        var x1 = xValues[0] - trendline.backwardForecast;
        var y1 = slopeInterceptExp.intercept * Math.exp(slopeInterceptExp.slope * x1);
        var x2 = xValues[midPoint - 1];
        var y2 = slopeInterceptExp.intercept * Math.exp(slopeInterceptExp.slope * x2);
        var x3 = xValues[xValues.length - 1] + trendline.forwardForecast;
        var y3 = slopeInterceptExp.intercept * Math.exp(slopeInterceptExp.slope * x3);
        ptsExp.push(this.getDataPoint(x1, y1, series, ptsExp.length));
        ptsExp.push(this.getDataPoint(x2, y2, series, ptsExp.length));
        ptsExp.push(this.getDataPoint(x3, y3, series, ptsExp.length));
        return ptsExp;
    };
    /**
     * Defines the points based on data point
     */
    Trendlines.prototype.getPoints = function (trendline, points, xValues, series) {
        var polynomialSlopes = trendline.polynomialSlopes;
        var pts = [];
        var x1 = 1;
        var index = 1;
        var xValue;
        var yValue;
        // We have to sort the points in ascending order. Because, the data source of the series may be random order.
        points.sort(function (a, b) { return a.xValue - b.xValue; });
        xValues.sort(function (a, b) { return a - b; });
        while (polynomialSlopes !== null && index <= polynomialSlopes.length) {
            if (index === 1) {
                xValue = xValues[0] - trendline.backwardForecast;
                yValue = this.getPolynomialYValue(polynomialSlopes, xValue);
                pts.push(this.getDataPoint(xValue, yValue, series, pts.length));
            }
            else if (index === polynomialSlopes.length) {
                xValue = xValues[points.length - 1] + trendline.forwardForecast;
                yValue = this.getPolynomialYValue(polynomialSlopes, xValue);
                pts.push(this.getDataPoint(xValue, yValue, series, pts.length));
            }
            else {
                x1 += (points.length + (series.xAxis.valueType === 'DateTime' ? index : trendline.forwardForecast)) / polynomialSlopes.length;
                xValue = xValues[parseInt(x1.toString(), 10) - 1];
                yValue = this.getPolynomialYValue(polynomialSlopes, xValue);
                pts.push(this.getDataPoint(xValue, yValue, series, pts.length));
            }
            index++;
        }
        return pts;
    };
    /**
     * Defines the polynomial value of y
     */
    Trendlines.prototype.getPolynomialYValue = function (slopes, x) {
        var sum$$1 = 0;
        var index = 0;
        while (index < slopes.length) {
            sum$$1 += slopes[index] * Math.pow(x, index);
            index++;
        }
        return sum$$1;
    };
    /**
     * Defines the gauss jordan elimination
     */
    Trendlines.prototype.gaussJordanElimination = function (matrix, polynomialSlopes) {
        var length = matrix.length;
        var numArray1 = [];
        var numArray2 = [];
        var numArray3 = [];
        numArray1.length = length;
        numArray2.length = length;
        numArray3.length = length;
        var index = 0;
        while (index < length) {
            numArray3[index] = 0;
            ++index;
        }
        var index1 = 0;
        while (index1 < length) {
            var num1 = 0;
            var index2 = 0;
            var index3 = 0;
            var index4 = 0;
            while (index4 < length) {
                if (numArray3[index4] !== 1) {
                    var index5 = 0;
                    while (index5 < length) {
                        if (numArray3[index5] === 0 && Math.abs(matrix[index4][index5]) >= num1) {
                            num1 = Math.abs(matrix[index4][index5]);
                            index2 = index4;
                            index3 = index5;
                        }
                        ++index5;
                    }
                }
                ++index4;
            }
            ++numArray3[index3];
            if (index2 !== index3) {
                var index4_1 = 0;
                while (index4_1 < length) {
                    var num2 = matrix[index2][index4_1];
                    matrix[index2][index4_1] = matrix[index3][index4_1];
                    matrix[index3][index4_1] = num2;
                    ++index4_1;
                }
                var num3 = polynomialSlopes[index2];
                polynomialSlopes[index2] = polynomialSlopes[index3];
                polynomialSlopes[index3] = num3;
            }
            numArray2[index1] = index2;
            numArray1[index1] = index3;
            if (matrix[index3][index3] === 0.0) {
                return false;
            }
            var num4 = 1.0 / matrix[index3][index3];
            matrix[index3][index3] = 1.0;
            var iindex4 = 0;
            while (iindex4 < length) {
                matrix[index3][iindex4] *= num4;
                ++iindex4;
            }
            polynomialSlopes[index3] *= num4;
            var iandex4 = 0;
            while (iandex4 < length) {
                if (iandex4 !== index3) {
                    var num2 = matrix[iandex4][index3];
                    matrix[iandex4][index3] = 0.0;
                    var index5 = 0;
                    while (index5 < length) {
                        matrix[iandex4][index5] -= matrix[index3][index5] * num2;
                        ++index5;
                    }
                    polynomialSlopes[iandex4] -= polynomialSlopes[index3] * num2;
                }
                ++iandex4;
            }
            ++index1;
        }
        var iindex1 = length - 1;
        while (iindex1 >= 0) {
            if (numArray2[iindex1] !== numArray1[iindex1]) {
                var iindex2 = 0;
                while (iindex2 < length) {
                    var num = matrix[iindex2][numArray2[iindex1]];
                    matrix[iindex2][numArray2[iindex1]] = matrix[iindex2][numArray1[iindex1]];
                    matrix[iindex2][numArray1[iindex1]] = num;
                    ++iindex2;
                }
            }
            --iindex1;
        }
        return true;
    };
    /**
     * Defines the trendline elements.
     */
    Trendlines.prototype.getTrendLineElements = function (series, chart) {
        findClipRect(series);
        var clipRect = series.clipRect;
        var clipRectElement = chart.renderer.drawClipPath(new RectOption(chart.element.id + '_ChartTrendlineClipRect_' + series.index, 'transparent', { width: 1, color: 'Gray' }, 1, {
            x: 0, y: 0, width: clipRect.width,
            height: clipRect.height
        }));
        var element = chart.renderer.createGroup({
            'id': chart.element.id + 'TrendlineSeriesGroup' + series.index,
            'transform': 'translate(' + clipRect.x + ',' + clipRect.y + ')',
            'clip-path': 'url(#' + chart.element.id + '_ChartTrendlineClipRect_' + series.index + ')'
        });
        //defines the clip rect element
        if (element) {
            element.appendChild(clipRectElement);
        }
        for (var _i = 0, _a = series.trendlines; _i < _a.length; _i++) {
            var trendline = _a[_i];
            this.createTrendLineElements(chart, trendline, trendline.index, element, clipRectElement);
        }
    };
    /**
     * To destroy the trendline.
     */
    Trendlines.prototype.destroy = function () {
        /**
         * Destroys the Linear Trendline
         */
    };
    /**
     * Get module name
     */
    Trendlines.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'TrendLine';
    };
    return Trendlines;
}());

/**
 * `Crosshair` module is used to render the crosshair for chart.
 */
var Crosshair = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for crosshair module.
     *
     * @private
     */
    function Crosshair(chart) {
        this.arrowLocation = new ChartLocation(0, 0);
        this.rx = 2;
        this.ry = 2;
        this.chart = chart;
        this.elementID = this.chart.element.id;
        this.svgRenderer = new SvgRenderer(this.chart.element.id);
        this.addEventListener();
    }
    /**
     * @hidden
     */
    Crosshair.prototype.addEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        this.chart.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
        this.chart.on(Browser.touchEndEvent, this.mouseUpHandler, this);
        this.chart.on(cancelEvent, this.mouseLeaveHandler, this);
        this.chart.on('tapHold', this.longPress, this);
    };
    Crosshair.prototype.mouseUpHandler = function () {
        if (this.chart.startMove) {
            this.removeCrosshair(2000);
        }
    };
    Crosshair.prototype.mouseLeaveHandler = function () {
        this.removeCrosshair(1000);
    };
    Crosshair.prototype.mouseMoveHandler = function (event) {
        var chart = this.chart;
        chart.mouseX = chart.mouseX / chart.scaleX;
        chart.mouseY = chart.mouseY / chart.scaleY;
        if (chart.stockChart && chart.stockChart.onPanning) {
            if (chart.mouseY < chart.chartAxisLayoutPanel.seriesClipRect.y) {
                chart.mouseY = chart.chartAxisLayoutPanel.seriesClipRect.y;
            }
            else if (chart.mouseY > chart.chartAxisLayoutPanel.seriesClipRect.y + chart.chartAxisLayoutPanel.seriesClipRect.height) {
                chart.mouseY = chart.chartAxisLayoutPanel.seriesClipRect.y + chart.chartAxisLayoutPanel.seriesClipRect.height;
            }
        }
        if (event.type === 'touchmove' && (Browser.isIos || Browser.isIos7) && chart.startMove && event.preventDefault) {
            event.preventDefault();
        }
        // Tooltip for chart series.
        if (!chart.disableTrackTooltip) {
            if (withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {
                if (chart.startMove || !chart.isTouch) {
                    this.crosshair();
                }
            }
            else {
                this.removeCrosshair(1000);
            }
        }
    };
    /**
     * Handles the long press on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Crosshair.prototype.longPress = function () {
        var chart = this.chart;
        if (withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {
            this.crosshair();
        }
        return false;
    };
    /**
     * Renders the crosshair.
     *
     * @returns {void}
     */
    Crosshair.prototype.crosshair = function () {
        var chart = this.chart;
        var horizontalCross = '';
        var verticalCross = '';
        var options;
        var axisTooltipGroup = document.getElementById(this.elementID + '_crosshair_axis');
        var crosshair = chart.crosshair;
        var tooltipdiv = document.getElementById(this.elementID + '_tooltip');
        var chartRect = chart.chartAxisLayoutPanel.seriesClipRect;
        var crossGroup = chart.enableCanvas ? document.getElementById(this.elementID + '_Secondary_Element') :
            document.getElementById(this.elementID + '_UserInteraction');
        var crosshairsvg;
        var cross = document.getElementById(this.elementID + '_Crosshair');
        if (chart.enableCanvas) {
            if (!cross) {
                cross = createElement('div', {
                    id: this.elementID + '_Crosshair', styles: 'position: absolute; pointer-events: none'
                });
                crossGroup.appendChild(cross);
            }
        }
        this.stopAnimation();
        if (chart.isCrosshair && chart.tooltip.enable && !withInBounds(chart.tooltipModule.valueX, chart.tooltipModule.valueY, chartRect)) {
            return null;
        }
        this.valueX = chart.tooltip.enable && chart.tooltipModule.valueX ? chart.tooltipModule.valueX : chart.mouseX;
        this.valueY = chart.tooltip.enable && chart.tooltipModule.valueY ? chart.tooltipModule.valueY : chart.mouseY;
        if (!chart.enableCanvas) {
            crossGroup.setAttribute('opacity', '1');
        }
        if (crosshair.lineType === 'Both' || crosshair.lineType === 'Horizontal') {
            horizontalCross += 'M ' + chartRect.x + ' ' + this.valueY +
                ' L ' + (chartRect.x + chartRect.width) + ' ' + this.valueY;
        }
        if (crosshair.lineType === 'Both' || crosshair.lineType === 'Vertical') {
            verticalCross += 'M ' + this.valueX + ' ' + chartRect.y +
                ' L ' + this.valueX + ' ' + (chartRect.y + chartRect.height);
        }
        if (chart.enableCanvas) {
            if (!axisTooltipGroup) {
                axisTooltipGroup = this.svgRenderer.createGroup({ 'id': this.elementID + '_crosshair_axis' });
            }
            var elementID = chart.tooltip.enable ? chart.element.id + '_tooltip_svg' : chart.element.id + '_svg';
            crosshairsvg = this.svgRenderer.createSvg({
                id: elementID,
                width: chart.availableSize.width,
                height: chart.availableSize.height
            });
            if (chart.tooltip.enable) {
                tooltipdiv = !tooltipdiv ? chart.tooltipModule.createElement() : tooltipdiv;
                tooltipdiv.appendChild(crosshairsvg);
                crossGroup.appendChild(tooltipdiv);
            }
            options = new PathOption(this.elementID + '_HorizontalLine', 'none', crosshair.line.width, crosshair.horizontalLineColor || crosshair.line.color || chart.themeStyle.crosshairLine, crosshair.opacity, crosshair.dashArray, horizontalCross);
            this.drawCrosshairLine(options, cross, chartRect.x, this.valueY, chartRect.width, 0, horizontalCross);
            /**
             * due to not working for vertical line side I added new option
             * options.d = verticalCross; options.id = this.elementID + '_VerticalLine';
             */
            options = new PathOption(this.elementID + '_VerticalLine', 'none', crosshair.line.width, crosshair.verticalLineColor || crosshair.line.color || chart.themeStyle.crosshairLine, crosshair.opacity, crosshair.dashArray, verticalCross);
            this.drawCrosshairLine(options, cross, this.valueX, chartRect.y, 0, chartRect.height, verticalCross);
            this.renderAxisTooltip(chart, chartRect, axisTooltipGroup);
            crosshairsvg.appendChild(axisTooltipGroup);
            if (!chart.tooltip.enable) {
                cross.appendChild(crosshairsvg);
            }
        }
        else {
            if (crossGroup.childNodes.length === 0) {
                axisTooltipGroup = chart.renderer.createGroup({ 'id': this.elementID + '_crosshair_axis' });
                options = new PathOption(this.elementID + '_HorizontalLine', 'none', crosshair.line.width, crosshair.horizontalLineColor || crosshair.line.color || chart.themeStyle.crosshairLine, crosshair.opacity, crosshair.dashArray, horizontalCross);
                this.renderCrosshairLine(options, crossGroup);
                options = new PathOption(this.elementID + '_VerticalLine', 'none', crosshair.line.width, crosshair.verticalLineColor || crosshair.line.color || chart.themeStyle.crosshairLine, crosshair.opacity, crosshair.dashArray, verticalCross);
                this.renderCrosshairLine(options, crossGroup);
                crossGroup.appendChild(axisTooltipGroup);
                this.renderAxisTooltip(chart, chartRect, crossGroup.lastChild);
            }
            else {
                document.getElementById(this.elementID + '_HorizontalLine').setAttribute('d', horizontalCross);
                document.getElementById(this.elementID + '_VerticalLine').setAttribute('d', verticalCross);
                this.renderAxisTooltip(chart, chartRect, crossGroup.lastChild);
            }
        }
    };
    Crosshair.prototype.renderCrosshairLine = function (options, crossGroup) {
        var htmlObject = this.chart.renderer.drawPath(options);
        crossGroup.appendChild(htmlObject);
    };
    Crosshair.prototype.drawCrosshairLine = function (options, crossGroup, left, top, width, height, direction) {
        if (!document.getElementById(options.id) && direction) {
            var line = createElement('div', {
                id: options.id
            });
            crossGroup.appendChild(line);
        }
        if (document.getElementById(options.id)) {
            var style = 'top:' + top.toString() + 'px;' +
                'left:' + left.toString() + 'px;' +
                'width:' + width + 'px;' +
                'height:' + height + 'px;' +
                'fill:' + options.stroke + ';' +
                'border: 0.5px solid ' + options.stroke + ';' +
                'opacity: ' + options.opacity + ' ; ' +
                'position: absolute';
            var crosshairline = document.getElementById(options.id);
            var crosshairtooltip = document.getElementById(this.elementID + '_crosshair_axis');
            crosshairline.style.cssText = style;
            crossGroup.style.opacity = '1';
            if (crosshairtooltip) {
                crosshairtooltip.style.opacity = '1';
            }
        }
    };
    Crosshair.prototype.renderAxisTooltip = function (chart, chartRect, axisGroup) {
        var axis;
        var text;
        var rect;
        var pathElement;
        var textElem;
        var options;
        var padding = 5;
        var direction;
        var axisRect;
        for (var k = 0, length_1 = chart.axisCollections.length; k < length_1; k++) {
            axis = chart.axisCollections[k];
            axisRect = !axis.placeNextToAxisLine ? axis.rect : axis.updatedRect;
            if (axis.crosshairTooltip.enable) {
                if ((this.valueX <= (axisRect.x + axisRect.width) && axisRect.x <= this.valueX) ||
                    (this.valueY <= (axisRect.y + axisRect.height) && axisRect.y <= this.valueY)) {
                    pathElement = document.getElementById(this.elementID + '_axis_tooltip_' + k);
                    textElem = document.getElementById(this.elementID + '_axis_tooltip_text_' + k);
                    text = this.getAxisText(axis);
                    if (text && text.indexOf('<br') > -1) {
                        text = this.getAxisText(axis).split(/<br.*?>/g);
                    }
                    if (!text) {
                        continue;
                    }
                    rect = this.tooltipLocation(text, axis, chartRect, axisRect);
                    if (rect.y + rect.height / 2 > chart.availableSize.height || rect.y < 0) {
                        continue;
                    }
                    if (pathElement === null) {
                        if (chart.enableCanvas) {
                            pathElement = this.svgRenderer.drawPath({
                                'id': this.elementID + '_axis_tooltip_' + k,
                                'fill': axis.crosshairTooltip.fill || chart.themeStyle.crosshairFill
                            });
                        }
                        else {
                            pathElement = chart.renderer.drawPath({
                                'id': this.elementID + '_axis_tooltip_' + k,
                                'fill': axis.crosshairTooltip.fill || chart.themeStyle.crosshairFill
                            }, null);
                        }
                        axisGroup.appendChild(pathElement);
                        options = new TextOption(this.elementID + '_axis_tooltip_text_' + k, 0, 0, (chart.stockChart && chart.enableRtl) ? 'end' : 'start', text);
                        var render = chart.enableCanvas ? this.svgRenderer : chart.renderer;
                        textElem = textElement$1(render, options, axis.crosshairTooltip.textStyle, axis.crosshairTooltip.textStyle.color || chart.themeStyle.crosshairLabelFont.color, axisGroup, null, null, null, null, null, null, null, null, chart.enableCanvas, null, this.chart.themeStyle.crosshairLabelFont);
                    }
                    direction = findCrosshairDirection(this.rx, this.ry, rect, this.arrowLocation, 9, this.isTop, this.isBottom, this.isLeft, this.valueX, this.valueY);
                    pathElement.setAttribute('d', direction);
                    if (typeof text !== 'string' && text.length > 1) {
                        for (var i = 0; i < text.length; i++) {
                            textElem.childNodes[i].textContent = text[i];
                        }
                    }
                    else {
                        textElem.textContent = text;
                    }
                    textElem.setAttribute('x', (rect.x + padding + (chart.enableRtl ? this.elementSize.width : 0)).toString());
                    textElem.setAttribute('y', (rect.y + padding + 3 * this.elementSize.height / 4).toString());
                    if (typeof text !== 'string' && text.length > 1) {
                        var height = 0;
                        textElem.setAttribute('y', (rect.y + padding + 3 * this.elementSize.height / (4 * text.length)).toString());
                        for (var i = 0; i < textElem.children.length; i++) {
                            height += this.elementSize.height / text.length;
                            textElem.children[i].setAttribute('x', (rect.x + padding + (chart.enableRtl ? this.elementSize.width : 0) + this.elementSize.width / 2).toString());
                            textElem.children[i].setAttribute('y', ((parseInt(textElem.getAttribute('y')) + height).toString()));
                            textElem.children[i].setAttribute('style', 'text-anchor: middle');
                        }
                    }
                    if (this.chart.theme === 'Fluent' || this.chart.theme === 'FluentDark' || this.chart.theme === 'Fabric' || this.chart.theme === 'FabricDark') {
                        var defElement = this.chart.renderer.createDefs();
                        var bordercolor = this.chart.theme === 'Fluent' || this.chart.theme === 'Fabric' ? '#D2D0CE' : null;
                        var borderwidth = this.chart.theme === 'Fluent' || this.chart.theme === 'Fabric' ? 1 : null;
                        defElement.setAttribute('id', this.chart.element.id + 'SVG_tooltip_definition');
                        axisGroup.appendChild(defElement);
                        pathElement.setAttribute('stroke', bordercolor);
                        pathElement.setAttribute('stroke-width', ' ' + borderwidth);
                    }
                }
                else {
                    removeElement$1(this.elementID + '_axis_tooltip_' + k);
                    removeElement$1(this.elementID + '_axis_tooltip_text_' + k);
                }
            }
        }
    };
    Crosshair.prototype.getAxisText = function (axis) {
        var value;
        this.isBottom = false;
        this.isTop = false;
        this.isLeft = false;
        this.isRight = false;
        var labelValue = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks')
            ? 0.5 : 0;
        var isOpposed = axis.isAxisOpposedPosition;
        if (axis.orientation === 'Horizontal') {
            value = getValueXByPoint(Math.abs(this.valueX - axis.rect.x), axis.rect.width, axis) + labelValue;
            this.isBottom = !isOpposed;
            this.isTop = isOpposed;
        }
        else {
            value = getValueYByPoint(Math.abs(this.valueY - axis.rect.y), axis.rect.height, axis) + labelValue;
            this.isRight = isOpposed;
            this.isLeft = !isOpposed;
        }
        if (axis.valueType === 'DateTime') {
            return axis.format(new Date(value));
        }
        else if (axis.valueType === 'Category') {
            return axis.labels[Math.floor(value)];
        }
        else if (axis.valueType === 'DateTimeCategory') {
            return this.chart.dateTimeCategoryModule.getIndexedAxisLabel(axis.labels[Math.round(value)], axis.format);
        }
        else if (axis.valueType === 'Logarithmic') {
            return value = axis.format(Math.pow(axis.logBase, value));
        }
        else {
            var customLabelFormat = axis.labelFormat && axis.labelFormat.match('{value}') !== null;
            return customLabelFormat ? axis.labelFormat.replace('{value}', axis.format(value)) : axis.format(value);
        }
    };
    Crosshair.prototype.tooltipLocation = function (text, axis, bounds, axisRect) {
        var padding = 5;
        var arrowPadding = 9;
        var tooltipRect;
        var boundsX = bounds.x;
        var boundsY = bounds.y;
        var islabelInside = axis.labelPosition === 'Inside';
        var scrollBarHeight = axis.scrollbarSettings.enable || (axis.zoomingScrollBar && axis.zoomingScrollBar.svgObject)
            ? axis.scrollBarHeight : 0;
        this.elementSize = measureText(text, axis.crosshairTooltip.textStyle, this.chart.themeStyle.crosshairLabelFont);
        if (typeof text !== 'string' && text.length > 1) {
            this.elementSize.width = 0;
            this.elementSize.height = 0;
            for (var i = 0; i < text.length; i++) {
                var size = measureText(text[i], axis.crosshairTooltip.textStyle, this.chart.themeStyle.crosshairLabelFont);
                this.elementSize.height += size.height;
                if (this.elementSize.width < size.width) {
                    this.elementSize.width = size.width;
                }
            }
        }
        var isOpposed = axis.isAxisOpposedPosition;
        if (axis.orientation === 'Horizontal') {
            var yLocation = islabelInside ? axisRect.y - this.elementSize.height - (padding * 2 + arrowPadding) :
                axisRect.y + scrollBarHeight;
            var height = islabelInside ? axisRect.y - this.elementSize.height - arrowPadding : axisRect.y + arrowPadding;
            this.arrowLocation = new ChartLocation(this.valueX, yLocation);
            tooltipRect = new Rect((this.valueX - (this.elementSize.width / 2) - padding), height + (!islabelInside ? scrollBarHeight : 0), this.elementSize.width + padding * 2, this.elementSize.height + padding * 2);
            if (isOpposed) {
                tooltipRect.y = islabelInside ? axisRect.y : axisRect.y -
                    (this.elementSize.height + padding * 2 + arrowPadding) - scrollBarHeight;
            }
            if (tooltipRect.x < boundsX) {
                tooltipRect.x = boundsX;
            }
            if (tooltipRect.x + tooltipRect.width > boundsX + bounds.width) {
                tooltipRect.x -= ((tooltipRect.x + tooltipRect.width) - (boundsX + bounds.width));
            }
            if (this.arrowLocation.x + arrowPadding / 2 > tooltipRect.x + tooltipRect.width - this.rx) {
                this.arrowLocation.x = tooltipRect.x + tooltipRect.width - this.rx - arrowPadding;
            }
            if (this.arrowLocation.x - arrowPadding < tooltipRect.x + this.rx) {
                this.arrowLocation.x = tooltipRect.x + this.rx + arrowPadding;
            }
        }
        else {
            scrollBarHeight = scrollBarHeight * (isOpposed ? 1 : -1);
            this.arrowLocation = new ChartLocation(axisRect.x, this.valueY);
            var width = islabelInside ? axisRect.x - scrollBarHeight :
                axisRect.x - (this.elementSize.width) - (padding * 2 + arrowPadding);
            tooltipRect = new Rect(width + scrollBarHeight, this.valueY - (this.elementSize.height / 2) - padding, this.elementSize.width + (padding * 2), this.elementSize.height + padding * 2);
            if (isOpposed) {
                tooltipRect.x = islabelInside ? axisRect.x - this.elementSize.width - arrowPadding :
                    axisRect.x + arrowPadding + scrollBarHeight;
                if ((tooltipRect.x + tooltipRect.width) > this.chart.availableSize.width) {
                    this.arrowLocation.x -= ((tooltipRect.x + tooltipRect.width) - this.chart.availableSize.width);
                    tooltipRect.x -= ((tooltipRect.x + tooltipRect.width) - this.chart.availableSize.width);
                }
            }
            else {
                if (tooltipRect.x < 0) {
                    this.arrowLocation.x -= tooltipRect.x;
                    tooltipRect.x = 0;
                }
            }
            if (tooltipRect.y < boundsY) {
                tooltipRect.y = boundsY;
            }
            if (tooltipRect.y + tooltipRect.height >= boundsY + bounds.height) {
                tooltipRect.y -= ((tooltipRect.y + tooltipRect.height) - (boundsY + bounds.height));
            }
            if (this.arrowLocation.y + arrowPadding / 2 > tooltipRect.y + tooltipRect.height - this.ry) {
                this.arrowLocation.y = tooltipRect.y + tooltipRect.height - this.ry - arrowPadding / 2;
            }
            if (this.arrowLocation.y - arrowPadding / 2 < tooltipRect.y + this.ry) {
                this.arrowLocation.y = tooltipRect.y + this.ry + arrowPadding / 2;
            }
        }
        return tooltipRect;
    };
    Crosshair.prototype.stopAnimation = function () {
        stopTimer(this.crosshairInterval);
    };
    Crosshair.prototype.progressAnimation = function () {
        stopTimer(this.crosshairInterval);
    };
    /**
     * Removes the crosshair on mouse leave.
     *
     * @returns {void}
     * @private
     */
    Crosshair.prototype.removeCrosshair = function (duration) {
        var chart = this.chart;
        var crosshair = chart.enableCanvas ? document.getElementById(this.elementID + '_Crosshair') :
            document.getElementById(this.elementID + '_UserInteraction');
        var crosshairtooltip = chart.enableCanvas ? document.getElementById(this.elementID + '_crosshair_axis') : null;
        this.stopAnimation();
        if (crosshair && crosshair.getAttribute('opacity') !== '0') {
            this.crosshairInterval = +setTimeout(function () {
                new Animation({}).animate(crosshair, {
                    duration: 200,
                    progress: function (args) {
                        // crosshair.removeAttribute('e-animate');
                        crosshair.style.animation = '';
                        if (!chart.enableCanvas) {
                            crosshair.setAttribute('opacity', (1 - (args.timeStamp / args.duration)).toString());
                        }
                        else {
                            crosshair.style.opacity = (1 - (args.timeStamp / args.duration)).toString();
                            crosshairtooltip.style.opacity = (1 - (args.timeStamp / args.duration)).toString();
                        }
                    },
                    end: function () {
                        if (chart.enableCanvas) {
                            crosshair.style.opacity = '0';
                            crosshairtooltip.style.opacity = '0';
                        }
                        else {
                            crosshair.setAttribute('opacity', '0');
                        }
                        chart.startMove = false;
                        if (chart.tooltipModule) {
                            chart.tooltipModule.valueX = null;
                            chart.tooltipModule.valueY = null;
                        }
                    }
                });
            }, duration);
        }
    };
    /**
     * Get module name.
     *
     * @returns {string} module name
     */
    Crosshair.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'Crosshair';
    };
    /**
     * To destroy the crosshair.
     *
     * @returns {void}
     * @private
     */
    Crosshair.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return Crosshair;
}());

var __extends$54 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * Tooltip Module used to render the tooltip for series.
 */
var BaseTooltip = /** @__PURE__ @class */ (function (_super) {
    __extends$54(BaseTooltip, _super);
    /**
     * Constructor for tooltip module.
     *
     * @private
     */
    function BaseTooltip(chart) {
        var _this = _super.call(this, chart) || this;
        _this.element = _this.chart.element;
        _this.textStyle = chart.tooltip.textStyle;
        _this.control = chart;
        _this.template = chart.tooltip.template;
        return _this;
    }
    BaseTooltip.prototype.getElement = function (id) {
        return document.getElementById(id);
    };
    /**
     * Renders the tooltip.
     *
     * @returns {void}
     * @private
     */
    BaseTooltip.prototype.getTooltipElement = function (isTooltip) {
        this.inverted = this.chart.requireInvertedAxis;
        this.header = (this.control.tooltip.header === null) ?
            ((this.control.tooltip.shared) ? '${point.x}' : '${series.name}')
            : (this.control.tooltip.header);
        this.formattedText = [];
        var tooltipDiv = document.getElementById(this.chart.element.id + '_tooltip');
        var isStockChart = this.chart.element.id.indexOf('stockChart') > -1;
        if (!isTooltip && !tooltipDiv || isStockChart) {
            return this.createElement();
        }
        return null;
    };
    BaseTooltip.prototype.createElement = function () {
        var tooltipDiv = document.createElement('div');
        tooltipDiv.id = this.element.id + '_tooltip';
        tooltipDiv.className = 'ejSVGTooltip';
        tooltipDiv.style.pointerEvents = 'none';
        tooltipDiv.style.position = 'absolute';
        tooltipDiv.style.zIndex = '1';
        return tooltipDiv;
    };
    BaseTooltip.prototype.pushData = function (data, isFirst, tooltipDiv, isChart, enable3D) {
        if (data.series.enableTooltip) {
            if (enable3D) {
                this.currentPoints.push(data);
            }
            else if (isChart) {
                this.currentPoints.push(data);
            }
            else {
                this.currentPoints.push(data);
            }
            this.stopAnimation();
            if (tooltipDiv && !document.getElementById(tooltipDiv.id)) {
                if (!this.chart.stockChart) {
                    document.getElementById(this.element.id + '_Secondary_Element').appendChild(tooltipDiv);
                }
                else {
                    document.getElementById(this.chart.stockChart.element.id + '_Secondary_Element').appendChild(tooltipDiv);
                }
            }
            return true;
        }
        return false;
    };
    BaseTooltip.prototype.removeHighlight = function () {
        var item;
        var series;
        for (var i = 0, len = this.previousPoints.length; i < len; i++) {
            item = this.previousPoints[i];
            if (item.series.isRectSeries) {
                if (item.series.visible) {
                    this.highlightPoint(item.series, item.point.index, false);
                }
                continue;
            }
            series = item.series;
        }
    };
    BaseTooltip.prototype.highlightPoint = function (series, pointIndex, highlight) {
        var element = this.getElement(this.element.id + '_Series_' + series.index + '_Point_' + pointIndex);
        var selectionModule = this.control.accumulationSelectionModule;
        var isSelectedElement = selectionModule && selectionModule.selectedDataIndexes.length > 0 ? true : false;
        if (element) {
            if ((!isSelectedElement || isSelectedElement && element.getAttribute('class')
                && element.getAttribute('class').indexOf('_ej2_chart_selection_series_') === -1)) {
                if (this.chart.highlightColor !== '' && !isNullOrUndefined(this.chart.highlightColor)) {
                    element.setAttribute('fill', (highlight && this.chart.highlightColor !== 'transparent' ? this.chart.highlightColor : series.pointColorMapping !== '' ? (series.points[0]).color : series.points[pointIndex].color || series.interior));
                }
                else {
                    element.setAttribute('opacity', (highlight && this.chart.highlightColor !== 'transparent' ? series.opacity / 2 : series.opacity).toString());
                }
            }
            else {
                element.setAttribute('opacity', series.opacity.toString());
            }
        }
    };
    BaseTooltip.prototype.highlightPoints = function () {
        for (var _i = 0, _a = this.currentPoints; _i < _a.length; _i++) {
            var item = _a[_i];
            if (item.series.isRectSeries && item.series.category === 'Series') {
                this.highlightPoint(item.series, item.point.index, true);
            }
        }
    };
    // tslint:disable-next-line:max-func-body-length
    BaseTooltip.prototype.createTooltip = function (chart, isFirst, location, clipLocation, point, shapes, offset, bounds, crosshairEnabled, extraPoints, templatePoint, customTemplate) {
        if (crosshairEnabled === void 0) { crosshairEnabled = false; }
        if (extraPoints === void 0) { extraPoints = null; }
        if (templatePoint === void 0) { templatePoint = null; }
        var series = this.currentPoints[0].series;
        var module = chart.tooltipModule || chart.tooltip3DModule ||
            chart.accumulationTooltipModule;
        if (!module || location === null) { // For the tooltip enable is false.
            removeElement$1(this.chart.element.id + '_tooltip');
            return;
        }
        if (isFirst) {
            this.svgTooltip = new Tooltip({
                opacity: chart.tooltip.opacity ? chart.tooltip.opacity : ((this.chart.theme === 'Material3' || this.chart.theme === 'Material3Dark') ? 1 : 0.75),
                header: this.headerText,
                content: this.text,
                fill: chart.tooltip.fill,
                border: chart.tooltip.border,
                enableAnimation: chart.tooltip.enableAnimation,
                location: location,
                shared: this.control.tooltip.shared,
                crosshair: crosshairEnabled,
                shapes: shapes,
                clipBounds: this.chart.chartAreaType === 'PolarRadar' ? new ChartLocation(0, 0) : clipLocation,
                areaBounds: bounds,
                palette: this.findPalette(),
                template: customTemplate || this.template,
                data: templatePoint,
                theme: chart.theme,
                offset: offset,
                textStyle: chart.tooltip.textStyle,
                isNegative: (series.isRectSeries && series.type !== 'Waterfall' && point && point.y < 0),
                inverted: this.chart.requireInvertedAxis && series.isRectSeries,
                arrowPadding: this.text.length > 1 || this.chart.stockChart || (this.chart.tooltip.location.x !== null || this.chart.tooltip.location.y !== null) ? 0 : 7,
                availableSize: chart.availableSize,
                duration: this.chart.tooltip.duration,
                isCanvas: this.chart.enableCanvas,
                isFixed: (this.chart.tooltip.location.x !== null || this.chart.tooltip.location.y !== null),
                isTextWrap: chart.tooltip.enableTextWrap && chart.getModuleName() === 'chart',
                blazorTemplate: { name: 'Template', parent: this.chart.tooltip },
                controlInstance: this.chart,
                enableRTL: chart.enableRtl,
                controlName: 'Chart',
                allowHighlight: chart.getModuleName() === 'chart' && !series.marker.allowHighlight,
                tooltipRender: function () {
                    module.removeHighlight();
                    module.highlightPoints();
                    module.updatePreviousPoint(extraPoints);
                },
                animationComplete: function (args) {
                    if (args.tooltip.fadeOuted) {
                        module.fadeOut(module.previousPoints);
                    }
                }
            });
            this.svgTooltip.appendTo(this.getElement(this.element.id + '_tooltip'));
        }
        else {
            if (this.svgTooltip) {
                this.svgTooltip.location = location;
                this.svgTooltip.content = this.text;
                this.svgTooltip.header = this.headerText;
                this.svgTooltip.offset = offset;
                this.svgTooltip.palette = this.findPalette();
                this.svgTooltip.shapes = shapes;
                this.svgTooltip.data = templatePoint;
                this.svgTooltip.template = this.template;
                this.svgTooltip.controlName = 'Chart';
                this.svgTooltip.crosshair = crosshairEnabled;
                this.svgTooltip.textStyle = chart.tooltip.textStyle;
                this.svgTooltip.isNegative = (series.isRectSeries && series.type !== 'Waterfall' && point && point.y < 0);
                this.svgTooltip.clipBounds = this.chart.chartAreaType === 'PolarRadar' ? new ChartLocation(0, 0) : clipLocation;
                this.svgTooltip.arrowPadding = this.text.length > 1 || this.chart.stockChart || (this.chart.tooltip.location.x !== null || this.chart.tooltip.location.y !== null) ? 0 : 7;
                this.svgTooltip.allowHighlight = chart.getModuleName() === 'chart' && !series.marker.allowHighlight;
                this.svgTooltip.dataBind();
            }
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (this.chart.isReact) {
            this.chart.renderReactTemplates();
        }
    };
    BaseTooltip.prototype.findPalette = function () {
        var colors = [];
        for (var _i = 0, _a = this.currentPoints; _i < _a.length; _i++) {
            var data = _a[_i];
            colors.push(this.findColor(data, data.series));
        }
        return colors;
    };
    BaseTooltip.prototype.findColor = function (data, series) {
        if (series.isRectSeries && (series.type === 'Candle' || series.type === 'Hilo' || series.type === 'HiloOpenClose')) {
            return data.point.color;
        }
        else {
            return (data.point.color && data.point.color !== '#ffffff' ? data.point.color
                : data.point.interior) ||
                series.marker.fill || series.interior;
        }
    };
    BaseTooltip.prototype.updatePreviousPoint = function (extraPoints) {
        if (extraPoints) {
            this.currentPoints = this.currentPoints.concat(extraPoints);
        }
        this.previousPoints = extend([], this.currentPoints, null, true);
    };
    BaseTooltip.prototype.fadeOut = function (data) {
        var svgElement = this.chart.enableCanvas ? this.getElement(this.element.id + '_tooltip_group') :
            this.getElement(this.element.id + '_tooltip_svg');
        var isTooltip = (svgElement && parseInt(svgElement.getAttribute('opacity'), 10) > 0);
        if (!isTooltip) {
            this.valueX = null;
            this.valueY = null;
            this.currentPoints = [];
            this.removeHighlight();
            this.removeHighlightedMarker(data, true);
            this.svgTooltip = null;
            this.control.trigger('animationComplete', {});
        }
    };
    /*
    * @hidden
    */
    BaseTooltip.prototype.removeHighlightedMarker = function (data, fadeOut) {
        if (this.chart.markerRender) {
            for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
                var item = data_1[_i];
                removeElement$1(this.element.id + '_Series_' + item.series.index +
                    '_Point_' + item.point.index + '_Trackball');
                this.chart.markerRender.removeHighlightedMarker(item.series, item.point, fadeOut);
            }
        }
        this.previousPoints = [];
    };
    // public triggerEvent(point: PointData | AccPointData, isFirst: boolean, textCollection: string, firstText: boolean = true): boolean {
    //     let argsData: ITooltipRenderEventArgs = {
    //         cancel: false, name: tooltipRender, text: textCollection,
    //         point: point.point, series: point.series, textStyle: this.textStyle
    //     };
    //     this.chart.trigger(tooltipRender, argsData);
    //     if (!argsData.cancel) {
    //         if (point.series.type === 'BoxAndWhisker') {
    //             this.removeText();
    //             isFirst = true;
    //         }
    //         this.formattedText = this.formattedText.concat(argsData.text);
    //         this.text = this.formattedText;
    //     }
    //     return !argsData.cancel;
    // }
    BaseTooltip.prototype.removeText = function () {
        this.textElements = [];
        var element = this.getElement(this.element.id + '_tooltip_group');
        if (element && element.childNodes.length > 0) {
            while (element.lastChild && element.childNodes.length !== 1) {
                element.removeChild(element.lastChild);
            }
        }
    };
    BaseTooltip.prototype.stopAnimation = function () {
        stopTimer(this.toolTipInterval);
    };
    /**
     * Removes the tooltip on mouse leave.
     *
     * @returns {void}
     * @private
     */
    BaseTooltip.prototype.removeTooltip = function (duration) {
        var _this = this;
        var tooltipElement = this.getElement(this.element.id + '_tooltip');
        var tooltipTemplate = tooltipElement ? this.getElement(tooltipElement.id + 'parent_template') : null;
        var isTemplateRendered = tooltipTemplate && tooltipTemplate.innerText !== '<div></div>';
        this.stopAnimation();
        if (tooltipElement && this.previousPoints.length > 0) {
            this.toolTipInterval = +setTimeout(function () {
                if (_this.svgTooltip) {
                    _this.svgTooltip.fadeOut();
                }
            }, duration);
        }
    };
    return BaseTooltip;
}(ChartData));

var __extends$53 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * `Tooltip` module is used to render the tooltip for chart series.
 */
var Tooltip$1 = /** @__PURE__ @class */ (function (_super) {
    __extends$53(Tooltip$$1, _super);
    /**
     * Constructor for tooltip module.
     *
     * @private
     */
    function Tooltip$$1(chart) {
        var _this = _super.call(this, chart) || this;
        _this.commonXvalues = [];
        _this.addEventListener();
        return _this;
    }
    /**
     * @hidden
     */
    Tooltip$$1.prototype.addEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        this.chart.on(cancelEvent, this.mouseLeaveHandler, this);
        this.chart.on('tapHold', this.longPress, this);
        this.chart.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
        this.chart.on(Browser.touchEndEvent, this.mouseUpHandler, this);
    };
    Tooltip$$1.prototype.mouseUpHandler = function () {
        var chart = this.control;
        var data = this.getData();
        data.lierIndex = this.lierIndex;
        if (chart.isTouch && !this.isSelected(chart) &&
            ((withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect) && chart.tooltip.shared)
                || !chart.tooltip.shared)) {
            if (!chart.crosshair.enable) {
                this.tooltip();
                if (chart.tooltip.fadeOutMode === 'Move') {
                    this.removeTooltip(chart.tooltip.fadeOutDuration);
                }
            }
            else if (chart.startMove && chart.tooltip.fadeOutMode === 'Move') {
                this.removeTooltip(2000);
            }
        }
        else if (!this.findData(data, this.previousPoints[0]) && chart.tooltip.fadeOutMode === 'Click') {
            this.removeTooltip(0);
        }
    };
    Tooltip$$1.prototype.mouseLeaveHandler = function () {
        this.removeTooltip(this.chart.tooltip.fadeOutDuration);
    };
    Tooltip$$1.prototype.mouseMoveHandler = function () {
        var chart = this.chart;
        chart.mouseX = chart.mouseX / chart.scaleX;
        chart.mouseY = chart.mouseY / chart.scaleY;
        if (chart.stockChart && chart.stockChart.onPanning) {
            if (chart.mouseY < chart.chartAxisLayoutPanel.seriesClipRect.y) {
                chart.mouseY = chart.chartAxisLayoutPanel.seriesClipRect.y;
            }
            else if (chart.mouseY > chart.chartAxisLayoutPanel.seriesClipRect.y + chart.chartAxisLayoutPanel.seriesClipRect.height) {
                chart.mouseY = chart.chartAxisLayoutPanel.seriesClipRect.y + chart.chartAxisLayoutPanel.seriesClipRect.height;
            }
        }
        // Tooltip for chart series.
        if (!chart.disableTrackTooltip && !this.isSelected(chart)) {
            if (!chart.tooltip.shared && (!chart.isTouch || (chart.startMove))) {
                this.tooltip();
            }
            if (withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {
                if (chart.tooltip.shared && (!chart.isTouch || (chart.startMove))) {
                    this.tooltip();
                }
            }
            else {
                if (chart.tooltip.shared && chart.tooltip.fadeOutMode === 'Move') {
                    this.removeTooltip(this.chart.tooltip.fadeOutDuration);
                }
            }
        }
    };
    /**
     * Handles the long press on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Tooltip$$1.prototype.longPress = function () {
        var chart = this.chart;
        if (chart.crosshair.enable && withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {
            this.tooltip();
            chart.markerRender.markerMove(false);
        }
        return false;
    };
    /**
     * Renders the tooltip.
     *
     * @returns {void}
     */
    Tooltip$$1.prototype.tooltip = function () {
        var elementId = this.chart.enableCanvas ? this.element.id + '_tooltip_group' : this.element.id + '_tooltip_svg';
        var svgElement = this.getElement(elementId);
        // To prevent the disappearance of the tooltip, while resize the stock chart.
        var isStockSvg = this.chart.stockChart && svgElement && (svgElement.firstChild.childNodes.length > 1);
        var isTooltip = (svgElement && parseInt(svgElement.getAttribute('opacity'), 10) > 0 && !isStockSvg);
        var tooltipDiv = this.getTooltipElement(isTooltip);
        if (this.chart.enableCanvas && tooltipDiv) {
            document.getElementById(this.chart.element.id + '_Secondary_Element').appendChild(tooltipDiv);
            tooltipDiv.appendChild(document.getElementById(this.chart.element.id + '_tooltip_svg'));
        }
        if (!this.chart.tooltip.shared) {
            this.renderSeriesTooltip(this.chart, !isTooltip, tooltipDiv);
        }
        else {
            this.renderGroupedTooltip(this.chart, !isTooltip, tooltipDiv);
        }
    };
    Tooltip$$1.prototype.findHeader = function (data) {
        if (this.header === '') {
            return '';
        }
        this.header = this.parseTemplate(data.point, data.series, this.header, data.series.xAxis, data.series.yAxis);
        if (this.header.replace(/<b>/g, '').replace(/<\/b>/g, '').trim() !== '') {
            return this.header;
        }
        return '';
    };
    Tooltip$$1.prototype.findShapes = function () {
        if (!this.chart.tooltip.enableMarker) {
            return [];
        }
        var marker = [];
        for (var _i = 0, _a = this.currentPoints; _i < _a.length; _i++) {
            var data = _a[_i];
            marker.push(data.point.marker.shape || data.series.marker.shape || 'Circle');
        }
        return marker;
    };
    Tooltip$$1.prototype.renderSeriesTooltip = function (chart, isFirst, tooltipDiv) {
        var data = this.getData();
        data.lierIndex = this.lierIndex;
        this.currentPoints = [];
        if (this.findData(data, this.previousPoints[0])) {
            if (!(chart.dataEditingModule && chart.dataEditingModule.isPointDragging) && (this.previousPoints[0] &&
                data.point.index === this.previousPoints[0].point.index && data.series.index === this.previousPoints[0].series.index)) {
                return null;
            }
            if (this.pushData(data, isFirst, tooltipDiv, true)) {
                this.triggerTooltipRender(data, isFirst, this.getTooltipText(data), this.findHeader(data));
            }
        }
        else {
            if (!data.point && this.isRemove && chart.tooltip.fadeOutMode === 'Move') {
                this.removeTooltip(this.chart.tooltip.fadeOutDuration);
                this.isRemove = false;
            }
            else {
                var commonXvalues = this.mergeXvalues(this.chart.visibleSeries);
                for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
                    var series = _a[_i];
                    if (series.visible && !(series.category === 'TrendLine')) {
                        data = this.getClosestX(chart, series, commonXvalues) || data;
                    }
                }
            }
        }
        if (data && data.point) {
            this.findMouseValue(data, chart);
        }
    };
    Tooltip$$1.prototype.triggerTooltipRender = function (point, isFirst, textCollection, headerText) {
        var _this = this;
        var tooltipTemplate;
        var argsData = {
            cancel: false, name: tooltipRender, text: textCollection, headerText: headerText, template: tooltipTemplate,
            series: this.chart.isBlazor ? {} : point.series, textStyle: this.textStyle, point: point.point,
            data: { pointX: point.point.x, pointY: point.point.y, seriesIndex: point.series.index, seriesName: point.series.name,
                pointIndex: point.point.index, pointText: point.point.text }
        };
        var borderWidth = this.chart.border.width;
        var padding = 3;
        var tooltip = this.chart.tooltip;
        var chartTooltipSuccess = function (argsData) {
            if (!argsData.cancel) {
                if (point.series.type === 'BoxAndWhisker') {
                    _this.removeText();
                    isFirst = true;
                }
                _this.headerText = argsData.headerText;
                _this.formattedText = _this.formattedText.concat(argsData.text);
                _this.text = _this.formattedText;
                var location_1 = _this.getSymbolLocation(point);
                location_1 = location_1 ? location_1 : new ChartLocation(null, null);
                location_1.x = tooltip.location.x !== null ? tooltip.location.x : location_1.x;
                location_1.y = tooltip.location.y !== null ? tooltip.location.y : location_1.y;
                location_1 = (location_1.x === null && location_1.y === null) ? null : location_1;
                _this.createTooltip(_this.chart, isFirst, location_1, point.series.clipRect, point.point, _this.findShapes(), _this.findMarkerHeight(_this.currentPoints[0]), new Rect(borderWidth, borderWidth, _this.chart.availableSize.width - padding - borderWidth * 2, _this.chart.availableSize.height - padding - borderWidth * 2), _this.chart.crosshair.enable, null, _this.getTemplateText(point), _this.template ? argsData.template : '');
            }
            else {
                _this.removeHighlight();
                remove(_this.getElement(_this.element.id + '_tooltip'));
            }
            _this.isRemove = true;
        };
        chartTooltipSuccess.bind(this, point);
        this.chart.trigger(tooltipRender, argsData, chartTooltipSuccess);
    };
    Tooltip$$1.prototype.findMarkerHeight = function (pointData) {
        var markerHeight = 0;
        var series = pointData.series;
        markerHeight = ((series.marker.visible || (this.chart.tooltip.shared &&
            (!series.isRectSeries || series.marker.visible)) || series.type === 'Scatter' || series.drawType === 'Scatter')
            && !(series.type === 'Candle' || series.type === 'Hilo' || series.type === 'HiloOpenClose')) ?
            ((series.marker.height + 2) / 2 + (2 * series.marker.border.width)) : 0;
        return markerHeight;
    };
    Tooltip$$1.prototype.findData = function (data, previous) {
        return data.point && ((!previous || (previous.point !== data.point)) ||
            (previous && previous.lierIndex > 3 && previous.lierIndex !== this.lierIndex) || (previous.point === data.point));
    };
    Tooltip$$1.prototype.getSymbolLocation = function (data) {
        var location;
        if (data.series.type !== 'BoxAndWhisker') {
            if (!data.point.symbolLocations[0]) {
                return null;
            }
            location = new ChartLocation(data.point.symbolLocations[0].x, data.point.symbolLocations[0].y);
        }
        switch (data.series.type) {
            case 'BoxAndWhisker':
                return this.getBoxLocation(data);
            case 'Waterfall':
                return this.getWaterfallRegion(data, location);
            case 'RangeArea':
            case 'RangeStepArea':
            case 'SplineRangeArea':
            case 'RangeColumn':
                return this.getRangeArea(data, location);
            default:
                return location;
        }
    };
    Tooltip$$1.prototype.getRangeArea = function (data, location) {
        if (data.point.regions[0]) {
            if (!this.inverted) {
                location.y = data.point.regions[0].y + data.point.regions[0].height / 2;
            }
            else {
                location.x = data.point.regions[0].x + data.point.regions[0].width / 2;
            }
            if (data.series.type === 'RangeStepArea') {
                location.y = data.point.regions[0].y + data.point.regions[0].height / 2 + data.point.regions[0].width;
            }
        }
        return location;
    };
    Tooltip$$1.prototype.getWaterfallRegion = function (data, location) {
        if (!this.inverted) {
            location.y = (data.point.y < 0) ?
                location.y - data.point.regions[0].height : location.y;
        }
        else {
            location.x = (data.point.y < 0) ?
                location.x + data.point.regions[0].width : location.x;
        }
        return location;
    };
    Tooltip$$1.prototype.getTooltipText = function (pointData) {
        var series = pointData.series;
        return this.parseTemplate(pointData.point, series, this.getFormat(this.chart, series), series.xAxis, series.yAxis);
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Tooltip$$1.prototype.getTemplateText = function (data) {
        if (this.template && this.chart.tooltip.shared) {
            var point = [];
            for (var i = 0; i < data.length; i++) {
                point[i] = extend({}, data[i].point);
                point[i].x = this.formatPointValue(data[i].point, data[i].series.xAxis, 'x', true, false);
                if ((data[i].series.seriesType === 'XY')) {
                    point[i].y = this.formatPointValue(data[i].point, data[i].series.yAxis, 'y', false, true);
                }
                else {
                    point[i].low = this.formatPointValue(data[i].point, data[i].series.yAxis, 'low', false, true);
                    point[i].high = this.formatPointValue(data[i].point, data[i].series.yAxis, 'high', false, true);
                }
            }
            return point;
        }
        else if (this.template) {
            var point = extend({}, data.point);
            point.x = this.formatPointValue(data.point, data.series.xAxis, 'x', true, false);
            if ((data.series.seriesType === 'XY')) {
                point.y = this.formatPointValue(data.point, data.series.yAxis, 'y', false, true);
            }
            else {
                point.low = this.formatPointValue(data.point, data.series.yAxis, 'low', false, true);
                point.high = this.formatPointValue(data.point, data.series.yAxis, 'high', false, true);
            }
            return point;
        }
        else {
            return data.point;
        }
    };
    Tooltip$$1.prototype.findMouseValue = function (data, chart) {
        if (!chart.requireInvertedAxis) {
            if (chart.chartAreaType === 'PolarRadar') {
                this.valueX = valueToPolarCoefficient(data.point.xValue, data.series.xAxis) * data.series.xAxis.rect.width
                    + data.series.xAxis.rect.x;
            }
            else {
                this.valueX = (data.series.category === 'TrendLine' && chart.tooltip.shared) ? this.valueX :
                    valueToCoefficient(data.point.xValue, data.series.xAxis) * data.series.xAxis.rect.width
                        + data.series.xAxis.rect.x;
            }
            this.valueY = chart.mouseY;
        }
        else {
            this.valueY = (1 - valueToCoefficient(data.point.xValue, data.series.xAxis)) * data.series.xAxis.rect.height
                + data.series.xAxis.rect.y;
            this.valueX = chart.mouseX;
        }
    };
    Tooltip$$1.prototype.renderGroupedTooltip = function (chart, isFirst, tooltipDiv) {
        var data;
        var dataCollection = [];
        var lastData;
        var pointData = chart.chartAreaType === 'PolarRadar' ? this.getData() : null;
        this.stopAnimation();
        this.removeHighlight();
        this.currentPoints = [];
        var extraPoints = [];
        var closestXValue = Number.MAX_VALUE;
        var closetYValue = Number.MAX_VALUE;
        var pointXValue;
        var pointYValue;
        var tempData;
        //let headerContent : string = '';
        if (isFirst) {
            if (!chart.stockChart) {
                if (tooltipDiv) {
                    document.getElementById(this.element.id + '_Secondary_Element').appendChild(tooltipDiv);
                }
            }
            else {
                if (tooltipDiv && !getElement(tooltipDiv.id)) {
                    document.getElementById(chart.stockChart.element.id + '_Secondary_Element').appendChild(tooltipDiv);
                }
            }
        }
        this.removeText();
        var argument = {
            text: [], cancel: false, name: sharedTooltipRender, data: [], point: [], series: [], headerText: '', textStyle: this.textStyle, template: ''
        };
        var i = 0;
        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            if (!series.enableTooltip || !series.visible) {
                continue;
            }
            if (chart.chartAreaType === 'Cartesian' && series.visible) {
                data = this.getClosestX(chart, series, this.commonXValue(this.chart.visibleSeries));
            }
            else if (chart.chartAreaType === 'PolarRadar' && series.visible && pointData.point !== null) {
                data = new PointData(series.points[pointData.point.index], series);
            }
            // if (data && this.header !== '' && this.currentPoints.length === 0) {
            //     headerContent = this.findHeader(data);
            // }
            if (chart.tooltip.showNearestPoint && !data) {
                data = this.getClosestX(chart, series, this.commonXValue([series]));
            }
            if (data) {
                argument.data.push({ pointX: data.point.x, pointY: data.point.y, seriesIndex: data.series.index,
                    seriesName: data.series.name, pointIndex: data.point.index, pointText: data.point.text });
                argument.series[i] = data.series;
                argument.point[i] = data.point;
                argument.headerText = this.findHeader(data);
                this.currentPoints.push(data);
                argument.text.push(this.getTooltipText(data));
                pointXValue = (!chart.requireInvertedAxis) ? chart.mouseX - data.series.clipRect.x : chart.mouseY - data.series.clipRect.y;
                pointYValue = chart.mouseY - data.series.clipRect.y;
                if (data.point.symbolLocations && data.point.symbolLocations.length && Math.abs(pointXValue - data.point.symbolLocations[0].x) <= closestXValue &&
                    Math.abs(data.point.symbolLocations[0].y - pointYValue) < Math.abs(closetYValue - pointYValue)) {
                    closestXValue = Math.abs(pointXValue - data.point.symbolLocations[0].x);
                    closetYValue = data.point.symbolLocations[0].y;
                    tempData = data;
                }
                lastData = (data.series.category === 'TrendLine' && chart.tooltip.shared) ? lastData : tempData || data;
                dataCollection.push(data);
            }
            // if (data && this.triggerEvent(data, isFirst, this.getTooltipText(data)), this.findHeader(data)) {
            //     this.findMouseValue(data, chart);
            //     (<PointData[]>this.currentPoints).push(data);
            //     data = null;
            // } else if (data) {
            //     extraPoints.push(data);
            // }
            i++;
        }
        if (!chart.tooltip.showNearestPoint) {
            var collection = [];
            this.currentPoints = [];
            argument.point = [];
            argument.series = [];
            argument.data = [];
            argument.text = [];
            for (var _b = 0, dataCollection_1 = dataCollection; _b < dataCollection_1.length; _b++) {
                var data_1 = dataCollection_1[_b];
                if (data_1.point.symbolLocations[0].x === lastData.point.symbolLocations[0].x || ((data_1.series.type.indexOf('Column') !== -1 || lastData.series.type.indexOf('Column') !== -1) && (data_1.point.xValue === lastData.point.xValue))) {
                    argument.point.push(data_1.point);
                    argument.series.push(data_1.series);
                    argument.text.push(this.getTooltipText(data_1));
                    argument.headerText = this.findHeader(data_1);
                    collection.push(data_1);
                    argument.data.push({
                        pointX: data_1.point.x, pointY: data_1.point.y, seriesIndex: data_1.series.index,
                        seriesName: data_1.series.name, pointIndex: data_1.point.index, pointText: data_1.point.text
                    });
                }
            }
            dataCollection = collection;
            this.currentPoints = collection;
        }
        if (dataCollection.length > 0 && this.currentPoints.length > 0) { // To avoid console error when we have empty chart with shared tooltip.
            this.triggerSharedTooltip(argument, lastData, extraPoints, chart, isFirst, dataCollection);
        }
        else if (this.getElement(this.element.id + '_tooltip_path')) {
            this.getElement(this.element.id + '_tooltip_path').setAttribute('d', '');
        }
    };
    Tooltip$$1.prototype.triggerSharedTooltip = function (argument, point, extraPoints, chart, isFirst, dataCollection) {
        var _this = this;
        var tooltipTemplate;
        var argsData = {
            cancel: false, name: sharedTooltipRender, text: argument.text, headerText: argument.headerText,
            textStyle: argument.textStyle, template: tooltipTemplate,
            point: argument.point, series: argument.series,
            data: argument.data
        };
        var borderWidth = this.chart.border.width;
        var padding = 3;
        var toolbarHeight;
        var titleHeight;
        var currentPoints = [];
        if (chart.stockChart) {
            toolbarHeight = chart.stockChart.enablePeriodSelector ? chart.stockChart.toolbarHeight : 0;
            titleHeight = measureText(this.chart.stockChart.title, this.chart.stockChart.titleStyle, this.chart.themeStyle.tooltipLabelFont).height + 10;
        }
        var sharedTooltip = function (argsData) {
            if (!argsData.cancel) {
                if (point.series.type === 'BoxAndWhisker') {
                    _this.removeText();
                    isFirst = true;
                }
                for (var i = 0; i < argsData.text.length; i++) {
                    if (argsData.text[i]) {
                        currentPoints.push(_this.currentPoints[i]);
                    }
                }
                _this.currentPoints = currentPoints;
                _this.formattedText = _this.formattedText.concat(argsData.text);
                _this.text = argsData.text;
                _this.headerText = argsData.headerText;
                var tooltip = _this.chart.tooltip;
                _this.findMouseValue(point, _this.chart);
                var location_2 = _this.findSharedLocation();
                location_2 = location_2 ? location_2 : new ChartLocation(null, null);
                location_2.x = tooltip.location.x !== null ? tooltip.location.x : location_2.x;
                location_2.y = tooltip.location.y !== null ? tooltip.location.y : location_2.y;
                location_2 = (location_2.x === null && location_2.y === null) ? null : location_2;
                _this.createTooltip(chart, isFirst, location_2, _this.currentPoints.length === 1 ? _this.currentPoints[0].series.clipRect : null, dataCollection.length === 1 ? dataCollection[0].point : null, _this.findShapes(), _this.findMarkerHeight(_this.currentPoints[0]), new Rect(borderWidth, (chart.stockChart ? (toolbarHeight + titleHeight + borderWidth) : borderWidth), _this.chart.availableSize.width - padding - borderWidth * 2, _this.chart.availableSize.height - padding - borderWidth * 2), _this.chart.crosshair.enable, extraPoints, _this.template ? _this.getTemplateText(dataCollection) : null, _this.template ? argsData.template : '');
                point = null;
            }
            else {
                extraPoints.push(point);
            }
        };
        sharedTooltip.bind(this, point, extraPoints);
        this.chart.trigger(sharedTooltipRender, argsData, sharedTooltip);
    };
    Tooltip$$1.prototype.findSharedLocation = function () {
        var stockChart = this.chart.stockChart;
        if (stockChart) {
            if (this.text.length === 1) {
                this.text.push('');
            }
            var toolbarHeight = stockChart.enablePeriodSelector ? stockChart.toolbarHeight : 0;
            var element = document.getElementById(stockChart.element.id + '_ChartTitle');
            var titleHeight = stockChart.title !== '' ? element.getBoundingClientRect().height + 10 : 0;
            if (stockChart.tooltip.position === 'Nearest') {
                return new ChartLocation(this.valueX, this.valueY + toolbarHeight + titleHeight);
            }
            return new ChartLocation(this.chart.chartAxisLayoutPanel.seriesClipRect.x + 5, this.chart.chartAxisLayoutPanel.seriesClipRect.y + toolbarHeight + 5 + titleHeight);
        }
        else {
            if (this.currentPoints.length > 1) {
                return new ChartLocation(this.valueX, this.valueY);
            }
            else {
                return this.getSymbolLocation(this.currentPoints[0]);
            }
        }
    };
    Tooltip$$1.prototype.getBoxLocation = function (data) {
        var location = this.lierIndex > 3 ? (data.point.outliers.length > 0 ? data.point.symbolLocations[this.lierIndex - 4] : null) :
            {
                x: data.point.regions[0].x + (data.point.regions[0].width / 2),
                y: data.point.regions[0].y + (data.point.regions[0].height / 2)
            };
        return location;
    };
    Tooltip$$1.prototype.parseTemplate = function (point, series, format, xAxis, yAxis) {
        var val;
        var textValue;
        for (var _i = 0, _a = Object.keys(point); _i < _a.length; _i++) {
            var dataValue = _a[_i];
            val = new RegExp('${point' + '.' + dataValue + '}', 'gm');
            format = format.replace(val.source, this.formatPointValue(point, val.source === '${point.x}' ? xAxis : yAxis, dataValue, val.source === '${point.x}', (val.source === '${point.high}' ||
                val.source === '${point.open}' ||
                val.source === '${point.close}' ||
                val.source === '${point.low}' ||
                val.source === '${point.y}' ||
                val.source === '${point.minimum}' ||
                val.source === '${point.maximum}' ||
                val.source === '${point.outliers}' ||
                val.source === '${point.upperQuartile}' ||
                val.source === '${point.lowerQuartile}' ||
                val.source === '${point.median}')));
        }
        for (var _b = 0, _c = Object.keys(Object.getPrototypeOf(series)); _b < _c.length; _b++) {
            var dataValue = _c[_b];
            val = new RegExp('${series' + '.' + dataValue + '}', 'gm');
            textValue = series[dataValue];
            format = format.replace(val.source, textValue);
        }
        return format;
    };
    Tooltip$$1.prototype.formatPointValue = function (point, axis, dataValue, isXPoint, isYPoint) {
        var textValue;
        var customLabelFormat;
        var value;
        if (axis.valueType !== 'Category' && isXPoint) {
            customLabelFormat = axis.labelFormat && axis.labelFormat.match('{value}') !== null;
            textValue = customLabelFormat ? axis.labelFormat.replace('{value}', axis.format(point[dataValue])) :
                axis.format(point[dataValue]);
        }
        else if (isYPoint && !isNullOrUndefined(point[dataValue])) {
            customLabelFormat = axis.labelFormat && axis.labelFormat.match('{value}') !== null;
            value = dataValue === 'outliers' ? axis.format(point[dataValue][this.lierIndex - 4]) :
                axis.format(point[dataValue]);
            textValue = customLabelFormat ? axis.labelFormat.replace('{value}', value) : value;
        }
        else if (dataValue === 'size') {
            var format = this.chart.intl.getNumberFormat({ format: '', useGrouping: this.chart.useGroupingSeparator });
            textValue = typeof point[dataValue] === 'number' ? format(point[dataValue]) : point[dataValue];
        }
        else {
            textValue = point[dataValue];
        }
        return textValue;
    };
    Tooltip$$1.prototype.getFormat = function (chart, series) {
        if (series.tooltipFormat) {
            if (series.seriesType === 'XY' && series.category === 'Indicator') {
                return this.getIndicatorTooltipFormat(series, chart, chart.tooltip.format);
            }
            return series.tooltipFormat;
        }
        if (!series.tooltipFormat && chart.tooltip.format) {
            if (series.seriesType === 'XY' && series.category === 'Indicator') {
                return this.getIndicatorTooltipFormat(series, chart, chart.tooltip.format);
            }
            return chart.tooltip.format;
        }
        var textX = (series.type === 'Histogram') ? '${point.minimum}' + '-' + '${point.maximum}' : '${point.x}';
        var format = !chart.tooltip.shared ? textX : '${series.name}';
        switch (series.seriesType) {
            case 'XY':
                if (series.category === 'Indicator') {
                    this.getIndicatorTooltipFormat(series, chart, chart.tooltip.format);
                }
                return format + ' : ' + ((series.type === 'Bubble') ? '<b>${point.y}</b>  Size : <b>${point.size}</b>' :
                    '<b>${point.y}</b>');
            case 'HighLow':
                return format + ('<br/>High : <b>${point.high}</b><br/>Low : <b>${point.low}</b>');
            case 'HighLowOpenClose':
                return format + ('<br/>High : <b>${point.high}</b><br/>Low : <b>${point.low}</b><br/>' +
                    'Open : <b>${point.open}</b><br/>Close : <b>${point.close}</b>');
            case 'BoxPlot': {
                return format + '<br/>' + (this.lierIndex > 3 ? 'Outliers : <b>${point.outliers}</b>' :
                    'Maximum : <b>${point.maximum}</b><br/>Q3 : <b>${point.upperQuartile}</b><br/>' +
                        'Median : <b>${point.median}</b><br/>Q1 : <b>${point.lowerQuartile}</b><br/>Minimum : <b>${point.minimum}</b>');
            }
            default: return '';
        }
    };
    Tooltip$$1.prototype.getIndicatorTooltipFormat = function (series, chart, format) {
        var toolTip;
        if (series.seriesType === 'XY') {
            toolTip = series.name + ' : <b>${point.y}</b>';
        }
        else {
            toolTip = format;
        }
        return toolTip;
    };
    /*
    * @hidden
    */
    Tooltip$$1.prototype.removeHighlightedMarker = function (data, fadeOut) {
        for (var _i = 0, data_2 = data; _i < data_2.length; _i++) {
            var item = data_2[_i];
            removeElement$1(this.element.id + '_Series_' + item.series.index +
                '_Point_' + item.point.index + '_Trackball');
            if (this.chart.markerRender) {
                this.chart.markerRender.removeHighlightedMarker(item.series, item.point, fadeOut);
            }
        }
        this.previousPoints = [];
    };
    /**
     * Get module name.
     */
    Tooltip$$1.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'Tooltip';
    };
    /**
     * To destroy the tooltip.
     *
     * @returns {void}
     * @private
     */
    Tooltip$$1.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return Tooltip$$1;
}(BaseTooltip));

/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * Zooming Toolkit created here
 *
 * @private
 */
var Toolkit = /** @__PURE__ @class */ (function () {
    /** @private */
    function Toolkit(chart) {
        this.iconRectOverFill = 'transparent';
        this.iconRectSelectionFill = 'transparent';
        /** @private */
        this.zoomCompleteEvtCollection = [];
        this.chart = chart;
        this.elementId = chart.element.id;
        this.chart.svgRenderer = new SvgRenderer(this.elementId);
    }
    /**
     * To create the pan button.
     *
     * @returns {void}
     * @private
     */
    Toolkit.prototype.createPanButton = function (childElement, parentElement) {
        var render = this.chart.svgRenderer;
        var fillColor = this.chart.zoomModule.isPanning ? this.chart.themeStyle.toolkitSelectionColor : this.chart.themeStyle.toolkitFill;
        var direction = 'M5,3h2.3L7.275,5.875h1.4L8.65,3H11L8,0L5,3z M3,11V8.7l2.875,0.025v-1.4L3,7.35V5L0,8L3,';
        direction += '11z M11,13H8.7l0.025-2.875h-1.4L7.35,13H5l3,3L11,13z M13,5v2.3l-2.875-0.025v1.4L13,8.65V11l3-3L13,5z';
        //This is for setting low opacity to PAN Button
        this.elementOpacity = !this.chart.zoomModule.isZoomed && this.chart.zoomSettings.showToolbar ? '0.2' : '1';
        childElement.setAttribute('opacity', this.elementOpacity);
        childElement.id = this.elementId + '_Zooming_Pan';
        childElement.setAttribute('role', 'button');
        childElement.setAttribute('aria-label', this.chart.getLocalizedLabel('Pan'));
        this.panElements = childElement;
        childElement.appendChild(render.drawRectangle(new RectOption(this.elementId + '_Zooming_Pan_1', 'transparent', {}, 1, this.chart.themeStyle.toolkitIconRect)));
        childElement.appendChild(render.drawPath(new PathOption(this.elementId + '_Zooming_Pan_2', fillColor, null, null, 1, null, direction)));
        parentElement.appendChild(childElement);
        this.wireEvents(childElement, this.pan);
    };
    /**
     * To create the zoom button.
     *
     * @returns {void}
     * @private
     */
    Toolkit.prototype.createZoomButton = function (childElement, parentElement) {
        var render = this.chart.svgRenderer;
        //This is for selecting initial fill color to ZOOM button
        var fillColor = this.chart.zoomModule.isPanning || (!this.chart.zoomModule.isZoomed &&
            this.chart.zoomSettings.showToolbar) ? this.chart.themeStyle.toolkitFill : this.chart.themeStyle.toolkitSelectionColor;
        this.elementOpacity = !this.chart.zoomModule.isPanning && !this.chart.zoomModule.isZoomed && this.chart.zoomSettings.showToolbar ? '0.2' : '1';
        var rectColor = this.chart.zoomModule.isPanning ? 'transparent' : this.chart.themeStyle.toolkitIconRectSelectionFill;
        var direction = 'M0.001,14.629L1.372,16l4.571-4.571v-0.685l0.228-0.274c1.051,0.868,2.423,1.417,3.885,1.417c3.291,0,';
        direction += '5.943-2.651,5.943-5.943S13.395,0,10.103,0S4.16,2.651,4.16,5.943c0,1.508,0.503,2.834,1.417,3.885l-0.274,0.228H4.571';
        direction = direction + 'L0.001,14.629L0.001,14.629z M5.943,5.943c0-2.285,1.828-4.114,4.114-4.114s4.114,1.828,4.114,';
        childElement.id = this.elementId + '_Zooming_Zoom';
        childElement.setAttribute('role', 'button');
        childElement.setAttribute('aria-label', this.chart.getLocalizedLabel('Zoom'));
        childElement.setAttribute('opacity', this.elementOpacity);
        this.zoomElements = childElement;
        this.selectedID = this.chart.zoomModule.isPanning ? this.chart.element.id + '_Zooming_Pan_1' : this.elementId + '_Zooming_Zoom_1';
        childElement.appendChild(render.drawRectangle(new RectOption(this.elementId + '_Zooming_Zoom_1', rectColor, {}, 1, this.chart.themeStyle.toolkitIconRect)));
        childElement.appendChild(render.drawPath(new PathOption(this.elementId + '_Zooming_Zoom_3', fillColor, null, null, 1, null, direction + '4.114s-1.828,4.114-4.114,4.114S5.943,8.229,5.943,5.943z')));
        parentElement.appendChild(childElement);
        this.wireEvents(childElement, this.zoom);
    };
    /**
     * To create the ZoomIn button.
     *
     * @returns {void}
     * @private
     */
    Toolkit.prototype.createZoomInButton = function (childElement, parentElement, chart) {
        var render = this.chart.svgRenderer;
        var fillColor = this.chart.themeStyle.toolkitFill;
        var direction = 'M10.103,0C6.812,0,4.16,2.651,4.16,5.943c0,1.509,0.503,2.834,1.417,3.885l-0.274,0.229H4.571L0,';
        direction += '14.628l0,0L1.372,16l4.571-4.572v-0.685l0.228-0.275c1.052,0.868,2.423,1.417,3.885,1.417c3.291,0,5.943-2.651,';
        direction += '5.943-5.943C16,2.651,13.395,0,10.103,0z M10.058,10.058c-2.286,0-4.114-1.828-4.114-4.114c0-2.286,1.828-4.114,';
        childElement.id = this.elementId + '_Zooming_ZoomIn';
        childElement.setAttribute('role', 'button');
        childElement.setAttribute('aria-label', this.chart.getLocalizedLabel('ZoomIn'));
        var polygonDirection = '12.749,5.466 10.749,5.466 10.749,3.466 9.749,3.466 9.749,5.466 7.749,5.466 7.749,6.466';
        childElement.appendChild(render.drawRectangle(new RectOption(this.elementId + '_Zooming_ZoomIn_1', 'transparent', {}, 1, this.chart.themeStyle.toolkitIconRect)));
        childElement.appendChild(render.drawPath(new PathOption(this.elementId + '_Zooming_ZoomIn_2', fillColor, null, null, 1, null, direction + '4.114-4.114c2.286,0,4.114,1.828,4.114,4.114C14.172,8.229,12.344,10.058,10.058,10.058z')));
        childElement.appendChild(render.drawPolygon(new PolygonOption(this.elementId + '_Zooming_ZoomIn_3', polygonDirection + ' 9.749,6.466 9.749,8.466 10.749,8.466 10.749,6.466 12.749,6.466', fillColor)));
        this.zoomInElements = childElement;
        //This is for low opacity to ZOOM IN button
        this.elementOpacity = chart.zoomModule.isPanning || (!chart.zoomModule.isZoomed && !chart.zoomSettings.showToolbar && !this.enableZoomButton) ? '0.2' : '1';
        childElement.setAttribute('opacity', this.elementOpacity);
        parentElement.appendChild(childElement);
        this.wireEvents(childElement, this.zoomIn);
    };
    /**
     * To create the ZoomOut button.
     *
     * @returns {void}
     * @private
     */
    Toolkit.prototype.createZoomOutButton = function (childElement, parentElement, chart) {
        var render = this.chart.svgRenderer;
        var fillColor = this.chart.themeStyle.toolkitFill;
        var direction = 'M0,14.622L1.378,16l4.533-4.533v-0.711l0.266-0.266c1.022,0.889,2.4,1.422,3.866,';
        direction += '1.422c3.289,0,5.955-2.666,5.955-5.955S13.333,0,10.044,0S4.089,2.667,4.134,5.911c0,1.466,0.533,2.844,';
        direction += '1.422,3.866l-0.266,0.266H4.578L0,14.622L0,14.622z M5.911,5.911c0-2.311,1.822-4.133,4.133-4.133s4.133,1.822,4.133,';
        childElement.id = this.elementId + '_Zooming_ZoomOut';
        childElement.setAttribute('role', 'button');
        childElement.setAttribute('aria-label', this.chart.getLocalizedLabel('ZoomOut'));
        childElement.appendChild(render.drawRectangle(new RectOption(this.elementId + '_Zooming_ZoomOut_1', 'transparent', {}, 1, this.chart.themeStyle.toolkitIconRect)));
        childElement.appendChild(render.drawPath(new PathOption(this.elementId + '_Zooming_ZoomOut_2', fillColor, null, null, 1, null, direction + '4.133s-1.866,4.133-4.133,4.133S5.911,8.222,5.911,5.911z M12.567,6.466h-5v-1h5V6.466z')));
        this.zoomOutElements = childElement;
        //This is for low opacity of ZOOM OUT button
        this.elementOpacity = chart.zoomModule.isPanning || (!chart.zoomModule.isZoomed && chart.zoomSettings.showToolbar && !this.enableZoomButton) ? '0.2' : '1';
        childElement.setAttribute('opacity', this.elementOpacity);
        parentElement.appendChild(childElement);
        this.wireEvents(childElement, this.zoomOut);
    };
    /**
     * To create the Reset button.
     *
     * @returns {void}
     * @private
     */
    Toolkit.prototype.createResetButton = function (childElement, parentElement, chart, isDevice) {
        var render = this.chart.svgRenderer;
        var fillColor = this.chart.themeStyle.toolkitFill;
        var size;
        var direction = 'M12.364,8h-2.182l2.909,3.25L16,8h-2.182c0-3.575-2.618-6.5-5.818-6.5c-1.128,0-2.218,0.366-3.091,';
        direction += '1.016l1.055,1.178C6.581,3.328,7.272,3.125,8,3.125C10.4,3.125,12.363,5.319,12.364,8L12.364,8z M11.091,';
        direction += '13.484l-1.055-1.178C9.419,12.672,8.728,12.875,8,12.875c-2.4,0-4.364-2.194-4.364-4.875h2.182L2.909,4.75L0,8h2.182c0,';
        childElement.id = this.elementId + '_Zooming_Reset';
        childElement.setAttribute('role', 'button');
        childElement.setAttribute('aria-label', this.chart.getLocalizedLabel('Reset'));
        //This is for low opacity to RESET button
        this.elementOpacity = !chart.zoomModule.isZoomed && chart.zoomSettings.showToolbar ? '0.2' : '1';
        childElement.setAttribute('opacity', this.elementOpacity);
        if (!isDevice) {
            childElement.appendChild(render.drawRectangle(new RectOption(this.elementId + '_Zooming_Reset_1', 'transparent', {}, 1, this.chart.themeStyle.toolkitIconRect)));
            childElement.appendChild(render.drawPath(new PathOption(this.elementId + '_Zooming_Reset_2', fillColor, null, null, 1, null, direction + '3.575,2.618,6.5,5.818,6.5C9.128,14.5,10.219,14.134,11.091,13.484L11.091,13.484z')));
        }
        else {
            size = measureText(this.chart.getLocalizedLabel('ResetZoom'), { size: '12px' }, { size: '12px', fontStyle: 'Normal', fontWeight: '400', fontFamily: 'Segoe UI' });
            childElement.appendChild(render.drawRectangle(new RectOption(this.elementId + '_Zooming_Reset_1', 'transparent', {}, 1, new Rect(0, 0, size.width, size.height))));
            textElement$1(chart.renderer, new TextOption(this.elementId + '_Zooming_Reset_2', 0 + size.width / 2, 0 + size.height * 3 / 4, 'middle', this.chart.getLocalizedLabel('ResetZoom'), 'rotate(0,' + (0) + ',' + (0) + ')', 'auto'), { size: '12px' }, this.chart.theme === 'Material3Dark' ? 'White' : 'black', childElement, null, null, null, null, null, null, null, null, chart.enableCanvas, null, { size: '12px', fontStyle: 'Normal', fontWeight: '400', fontFamily: 'Segoe UI' });
        }
        parentElement.appendChild(childElement);
        this.wireEvents(childElement, this.reset);
    };
    /**
     * To bind events.
     *
     * @returns {void}
     * @private
     */
    Toolkit.prototype.wireEvents = function (element, process) {
        EventHandler.add(element, 'mousedown touchstart', process, this);
        EventHandler.add(element, 'mouseover', this.showTooltip, this);
        EventHandler.add(element, 'mouseout', this.removeTooltip, this);
    };
    /**
     * To show tooltip.
     *
     * @returns {void}
     * @private
     */
    Toolkit.prototype.showTooltip = function (event) {
        var text = event.currentTarget.id.split('_Zooming_')[1];
        var left = (event.pageX - (measureText(text, { size: '10px' }, { size: '10px', fontStyle: 'Normal', fontWeight: '400', fontFamily: 'Segoe UI' }).width + 5));
        var rect = getElement$1(event.currentTarget.id + '_1');
        var icon2 = getElement$1(event.currentTarget.id + '_2');
        var icon3 = getElement$1(event.currentTarget.id + '_3');
        if (event.currentTarget.getAttribute('opacity') === '1') {
            event.currentTarget.setAttribute('cursor', 'pointer');
        }
        else {
            event.currentTarget.setAttribute('cursor', 'auto');
        }
        if (rect) {
            this.hoveredID = rect.id;
            rect.setAttribute('fill', this.chart.themeStyle.toolkitIconRectOverFill);
        }
        if (icon2) {
            icon2.setAttribute('fill', this.chart.themeStyle.toolkitSelectionColor);
        }
        if (icon3) {
            icon3.setAttribute('fill', this.chart.themeStyle.toolkitSelectionColor);
        }
        if (!this.chart.isTouch) {
            createTooltip('EJ2_Chart_ZoomTip', this.chart.getLocalizedLabel(text), (event.pageY + 10), left, '10px');
        }
    };
    /** @private */
    /* eslint-disable */
    Toolkit.prototype.removeTooltip = function () {
        if (this.hoveredID && getElement$1(this.hoveredID)) {
            var rectColor = this.chart.zoomModule.isPanning ? (this.hoveredID.indexOf('_Pan_') > -1) ? this.chart.themeStyle.toolkitIconRectSelectionFill : 'transparent' : (this.hoveredID.indexOf('_Zoom_') > -1) ? this.chart.themeStyle.toolkitIconRectSelectionFill : 'transparent';
            getElement$1(this.hoveredID).setAttribute('fill', rectColor);
        }
        var icon2 = this.hoveredID ? getElement$1(this.hoveredID.replace('_1', '_2')) : null;
        var icon3 = this.hoveredID ? getElement$1(this.hoveredID.replace('_1', '_3')) : null;
        if (icon2) {
            var iconColor = this.chart.zoomModule.isPanning ? (this.hoveredID.indexOf('_Pan_') > -1) ? this.chart.themeStyle.toolkitSelectionColor : this.chart.themeStyle.toolkitFill : (this.hoveredID.indexOf('_Zoom_') > -1) ? this.chart.themeStyle.toolkitSelectionColor : this.chart.themeStyle.toolkitFill;
            icon2.setAttribute('fill', iconColor);
        }
        if (icon3) {
            //This is used for change color while hover on ZOOM button
            var iconColor = this.chart.zoomModule.isPanning || (!this.chart.isZoomed && this.chart.zoomSettings.showToolbar) ? this.chart.themeStyle.toolkitFill : (this.hoveredID.indexOf('_Zoom_') > -1) ? this.chart.themeStyle.toolkitSelectionColor : this.chart.themeStyle.toolkitFill;
            icon3.setAttribute('fill', iconColor);
        }
        removeElement$1('EJ2_Chart_ZoomTip');
    };
    // Toolkit events function calculation here.
    /** @private */
    Toolkit.prototype.reset = function (event) {
        var _this = this;
        if (!this.chart.zoomModule.isZoomed) {
            return false;
        }
        var chart = this.chart;
        this.enableZoomButton = false;
        if (!chart.zoomModule.isDevice) {
            remove(chart.zoomModule.toolkitElements);
        }
        else if (event.type == 'touchstart') {
            event.stopPropagation();
        }
        var argsData;
        this.removeTooltip();
        chart.svgObject.setAttribute('cursor', 'auto');
        var zoomingEventArgs;
        var zoomedAxisCollection = [];
        this.zoomCompleteEvtCollection = [];
        for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {
            var axis = _a[_i];
            argsData = {
                cancel: false, name: zoomComplete, axis: axis, previousZoomFactor: axis.zoomFactor,
                previousZoomPosition: axis.zoomPosition, currentZoomFactor: 1, currentZoomPosition: 0,
                previousVisibleRange: axis.visibleRange, currentVisibleRange: null
            };
            axis.zoomFactor = 1;
            axis.zoomPosition = 0;
            if (axis.zoomingScrollBar) {
                axis.zoomingScrollBar.isScrollUI = false;
            }
            if (!argsData.cancel) {
                axis.zoomFactor = argsData.currentZoomFactor;
                axis.zoomPosition = argsData.currentZoomPosition;
                this.zoomCompleteEvtCollection.push(argsData);
            }
            zoomedAxisCollection.push({
                zoomFactor: axis.zoomFactor, zoomPosition: axis.zoomFactor, axisName: axis.name,
                axisRange: axis.visibleRange
            });
            if (chart.zoomModule.isDevice && !this.chart.isBlazor) {
                chart.trigger(zoomComplete, argsData);
            }
        }
        zoomingEventArgs = { cancel: false, axisCollection: zoomedAxisCollection, name: onZooming };
        if (!zoomingEventArgs.cancel && this.chart.isBlazor) {
            this.chart.trigger(onZooming, zoomingEventArgs, function () {
                _this.setDefferedZoom(chart);
            });
            return false;
        }
        else {
            return (this.setDefferedZoom(chart));
        }
    };
    Toolkit.prototype.setDefferedZoom = function (chart) {
        chart.disableTrackTooltip = false;
        chart.zoomModule.isZoomed = chart.zoomModule.isPanning = chart.isChartDrag = chart.delayRedraw = false;
        chart.zoomModule.touchMoveList = chart.zoomModule.touchStartList = [];
        chart.zoomModule.pinchTarget = null;
        chart.removeSvg();
        chart.refreshAxis();
        chart.refreshBound();
        this.elementOpacity = '1';
        return false;
    };
    Toolkit.prototype.zoomIn = function (e) {
        this.zoomInOutCalculation(1, this.chart, this.chart.axisCollections, this.chart.zoomSettings.mode);
        return false;
    };
    Toolkit.prototype.zoomOut = function (e) {
        this.enableZoomButton = false;
        this.zoomInOutCalculation(-1, this.chart, this.chart.axisCollections, this.chart.zoomSettings.mode);
        return false;
    };
    Toolkit.prototype.zoom = function (e) {
        this.chart.zoomModule.isPanning = false;
        var zoomModule = this.chart.zoomModule;
        this.elementOpacity = '1';
        this.chart.svgObject.setAttribute('cursor', 'auto');
        this.zoomInElements.setAttribute('opacity', this.elementOpacity);
        this.elementOpacity = (!this.chart.zoomModule.isZoomed && this.chart.zoomSettings.showToolbar) ? '0.2' : '1';
        this.zoomOutElements.setAttribute('opacity', this.elementOpacity);
        this.applySelection(this.zoomElements.childNodes, this.chart.themeStyle.toolkitSelectionColor);
        this.applySelection(this.panElements.childNodes, '#737373');
        if (getElement$1(this.selectedID)) {
            getElement$1(this.selectedID).setAttribute('fill', 'transparent');
        }
        this.selectedID = this.chart.element.id + '_Zooming_Zoom_1';
        getElement$1(this.selectedID).setAttribute('fill', this.chart.themeStyle.toolkitIconRectSelectionFill);
        return false;
    };
    /** @private */
    Toolkit.prototype.pan = function () {
        if (!this.chart.zoomModule.isZoomed) {
            return false;
        }
        var element;
        this.chart.zoomModule.isPanning = true;
        this.chart.svgObject.setAttribute('cursor', 'pointer');
        this.elementOpacity = '0.2';
        element = this.zoomInElements ? this.zoomInElements.setAttribute('opacity', this.elementOpacity) : null;
        element = this.zoomOutElements ? this.zoomOutElements.setAttribute('opacity', this.elementOpacity) : null;
        element = this.panElements ? this.applySelection(this.panElements.childNodes, this.chart.themeStyle.toolkitSelectionColor) : null;
        element = this.zoomElements ? this.applySelection(this.zoomElements.childNodes, '#737373') : null;
        if (getElement$1(this.selectedID)) {
            getElement$1(this.selectedID).setAttribute('fill', 'transparent');
        }
        this.selectedID = this.chart.element.id + '_Zooming_Pan_1';
        getElement$1(this.selectedID).setAttribute('fill', this.chart.themeStyle.toolkitIconRectSelectionFill);
        return false;
    };
    Toolkit.prototype.zoomInOutCalculation = function (scale, chart, axes, mode) {
        var _this = this;
        if (chart.zoomSettings.showToolbar) {
            this.elementOpacity = this.zoomInElements.getAttribute('opacity');
        }
        if (!chart.zoomModule.isPanning && this.elementOpacity !== '0.2') {
            if ((chart.zoomSettings.showToolbar && !chart.isZoomed)) {
                chart.zoomModule.isZoomed = true;
            }
            var zoomFactor = void 0;
            var zoomPosition = void 0;
            var cumulative = void 0;
            chart.disableTrackTooltip = true;
            chart.delayRedraw = true;
            var argsData = void 0;
            this.zoomCompleteEvtCollection = [];
            var zoomedAxisCollection = [];
            for (var _i = 0, _a = axes; _i < _a.length; _i++) {
                var axis = _a[_i];
                argsData = {
                    cancel: false, name: zoomComplete, axis: axis, previousZoomFactor: axis.zoomFactor,
                    previousZoomPosition: axis.zoomPosition, currentZoomFactor: axis.zoomFactor, currentZoomPosition: axis.zoomPosition,
                    previousVisibleRange: axis.visibleRange, currentVisibleRange: null
                };
                if ((axis.orientation === 'Horizontal' && mode !== 'Y') ||
                    (axis.orientation === 'Vertical')) {
                    cumulative = Math.max(Math.max(1 / minMax(axis.zoomFactor, 0, 1), 1) + (0.25 * scale), 1);
                    zoomFactor = (cumulative === 1) ? 1 : minMax(1 / cumulative, 0, 1);
                    zoomPosition = (cumulative === 1) ? 0 : axis.zoomPosition + ((axis.zoomFactor - zoomFactor) * 0.5);
                    if (axis.zoomPosition !== zoomPosition || axis.zoomFactor !== zoomFactor) {
                        zoomFactor = (zoomPosition + zoomFactor) > 1 ? (1 - zoomPosition) : zoomFactor;
                    }
                    argsData.currentZoomFactor = zoomFactor;
                    argsData.currentZoomPosition = zoomPosition;
                    if (!argsData.cancel) {
                        axis.zoomFactor = argsData.currentZoomFactor;
                        axis.zoomPosition = argsData.currentZoomPosition;
                        this.zoomCompleteEvtCollection.push(argsData);
                    }
                    zoomedAxisCollection.push({
                        zoomFactor: axis.zoomFactor, zoomPosition: axis.zoomFactor, axisName: axis.name,
                        axisRange: axis.visibleRange
                    });
                }
            }
            var zoomingEventArgs_1 = { cancel: false, axisCollection: zoomedAxisCollection, name: onZooming };
            this.chart.trigger(onZooming, zoomingEventArgs_1, function () {
                if (zoomingEventArgs_1.cancel) {
                    var zoom = new Zoom(chart);
                    zoom.zoomCancel(axes, _this.zoomCompleteEvtCollection);
                }
            });
        }
    };
    Toolkit.prototype.applySelection = function (elements, color) {
        for (var i = 1, length_1 = elements.length; i < length_1; i++) {
            elements[i].setAttribute('fill', color);
        }
    };
    return Toolkit;
}());

/**
 * `Zooming` module handles the zooming for chart.
 */
var Zoom = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for Zooming module.
     *
     * @private
     */
    function Zoom(chart) {
        this.zoomCompleteEvtCollection = [];
        this.chart = chart;
        this.isPointer = Browser.isPointer;
        this.browserName = Browser.info.name;
        this.wheelEvent = this.browserName === 'mozilla' ? (this.isPointer ? 'mousewheel' : 'DOMMouseScroll') : 'mousewheel';
        this.cancelEvent = this.isPointer ? 'pointerleave' : 'mouseleave';
        this.addEventListener();
        this.isDevice = Browser.isDevice;
        var zooming = chart.zoomSettings;
        this.toolkit = new Toolkit(chart);
        this.zooming = zooming;
        this.elementId = chart.element.id;
        this.zoomingRect = new Rect(0, 0, 0, 0);
        this.zoomAxes = [];
        this.zoomkitOpacity = 1;
        this.isIOS = Browser.isIos || Browser.isIos7;
        this.isZoomed = this.performedUI = this.zooming.enablePan ||
            ((this.chart.primaryXAxis.zoomFactor < 1 && this.chart.primaryXAxis.zoomPosition > 0) ||
                (this.chart.primaryYAxis.zoomFactor < 1 && this.chart.primaryYAxis.zoomPosition > 0) || this.isAxisZoomed(this.chart.axes));
        if (zooming.enableScrollbar) {
            chart.scrollElement = createElement('div', { id: chart.element.id + '_scrollElement' });
        }
    }
    /**
     * Function that handles the Rectangular zooming.
     *
     * @returns {void}
     */
    Zoom.prototype.renderZooming = function (e, chart, isTouch) {
        this.calculateZoomAxesRange(chart);
        if (this.zooming.enableSelectionZooming && (!isTouch
            || (chart.isDoubleTap && this.touchStartList.length === 1)) && (!this.isPanning || chart.isDoubleTap)) {
            this.isPanning = this.isDevice ? true : this.isPanning;
            this.performedUI = true;
            this.drawZoomingRectangle(chart);
        }
        else if (this.isPanning && chart.isChartDrag) {
            if (!isTouch || (isTouch && this.touchStartList.length === 1)) {
                this.pinchTarget = isTouch ? e.target : null;
                this.doPan(chart, chart.axisCollections);
            }
        }
    };
    // Zooming rectangle drawn here
    Zoom.prototype.drawZoomingRectangle = function (chart) {
        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
        var startLocation = new ChartLocation(chart.previousMouseMoveX, chart.previousMouseMoveY);
        var endLocation = new ChartLocation(chart.mouseX, chart.mouseY);
        var rect = this.zoomingRect = getRectLocation(startLocation, endLocation, areaBounds);
        if (rect.width > 0 && rect.height > 0) {
            this.isZoomed = true;
            chart.disableTrackTooltip = true;
            chart.svgObject.setAttribute('cursor', 'crosshair');
            if (this.zooming.mode === 'Y') {
                rect.width = areaBounds.width;
                rect.x = areaBounds.x;
            }
            var svg = chart.enableCanvas ? document.getElementById(this.elementId + '_tooltip_svg') : chart.svgObject;
            svg.appendChild(chart.svgRenderer.drawRectangle(new RectOption(this.elementId + '_ZoomArea', chart.themeStyle.selectionRectFill, { color: chart.themeStyle.selectionRectStroke, width: 1 }, 1, rect, 0, 0, '', '3')));
        }
    };
    // Panning performed here
    Zoom.prototype.doPan = function (chart, axes, xDifference, yDifference) {
        var _this = this;
        if (xDifference === void 0) { xDifference = 0; }
        if (yDifference === void 0) { yDifference = 0; }
        if (chart.startMove && chart.crosshair.enable) {
            return null;
        }
        var currentScale;
        var offset;
        this.isZoomed = true;
        this.offset = !chart.delayRedraw ? chart.chartAxisLayoutPanel.seriesClipRect : this.offset;
        chart.delayRedraw = true;
        this.zoomCompleteEvtCollection = [];
        chart.disableTrackTooltip = true;
        var argsData;
        var zoomedAxisCollection = [];
        for (var _i = 0, _a = axes; _i < _a.length; _i++) {
            var axis = _a[_i];
            argsData = {
                cancel: false, name: zoomComplete, axis: axis, previousZoomFactor: axis.zoomFactor,
                previousZoomPosition: axis.zoomPosition, currentZoomFactor: axis.zoomFactor,
                currentZoomPosition: axis.zoomPosition, previousVisibleRange: axis.visibleRange,
                currentVisibleRange: null
            };
            currentScale = Math.max(1 / minMax(axis.zoomFactor, 0, 1), 1);
            if (axis.orientation === 'Horizontal') {
                offset = (xDifference !== 0 ? xDifference : (chart.previousMouseMoveX - chart.mouseX)) / axis.rect.width / currentScale;
                argsData.currentZoomPosition = minMax(axis.zoomPosition + offset, 0, (1 - axis.zoomFactor));
            }
            else {
                offset = (yDifference !== 0 ? yDifference : (chart.previousMouseMoveY - chart.mouseY)) / axis.rect.height / currentScale;
                argsData.currentZoomPosition = minMax(axis.zoomPosition - offset, 0, (1 - axis.zoomFactor));
            }
            if (!argsData.cancel) {
                axis.zoomFactor = argsData.currentZoomFactor;
                axis.zoomPosition = argsData.currentZoomPosition;
                this.zoomCompleteEvtCollection.push(argsData);
            }
            zoomedAxisCollection.push({
                zoomFactor: axis.zoomFactor, zoomPosition: axis.zoomFactor, axisName: axis.name,
                axisRange: axis.visibleRange
            });
        }
        var zoomingEventArgs = { cancel: false, axisCollection: zoomedAxisCollection, name: onZooming };
        if (!zoomingEventArgs.cancel && this.chart.isBlazor) {
            this.chart.trigger(onZooming, zoomingEventArgs, function () {
                if (zoomingEventArgs.cancel) {
                    _this.zoomCancel(axes, _this.zoomCompleteEvtCollection);
                }
                else {
                    _this.performDefferedZoom(chart);
                }
            });
        }
        else {
            this.chart.trigger(onZooming, zoomingEventArgs, function () {
                if (zoomingEventArgs.cancel) {
                    _this.zoomCancel(axes, _this.zoomCompleteEvtCollection);
                }
                else {
                    _this.performDefferedZoom(chart);
                    _this.redrawOnZooming(chart, false);
                }
            });
        }
    };
    Zoom.prototype.performDefferedZoom = function (chart) {
        var translateX;
        var translateY;
        if (this.zooming.enableDeferredZooming) {
            translateX = chart.mouseX - chart.mouseDownX;
            translateY = chart.mouseY - chart.mouseDownY;
            switch (this.zooming.mode) {
                case 'Y':
                    translateX = 0;
                    break;
            }
            this.setTransform(translateX, translateY, null, null, chart, false);
            this.refreshAxis(chart.chartAxisLayoutPanel, chart, chart.axisCollections);
            if (chart.enableCanvas) {
                this.performZoomRedraw(chart);
            }
        }
        else {
            this.performZoomRedraw(chart);
        }
        chart.previousMouseMoveX = chart.mouseX;
        chart.previousMouseMoveY = chart.mouseY;
    };
    /**
     * Redraw the chart on zooming.
     *
     * @returns {void}
     * @private
     */
    Zoom.prototype.performZoomRedraw = function (chart) {
        var rect = this.zoomingRect;
        chart.animateSeries = false;
        if (this.isZoomed) {
            if (rect.width > 0 && rect.height > 0) {
                this.performedUI = true;
                chart.svgObject.setAttribute('cursor', 'auto');
                this.doZoom(chart, chart.axisCollections, chart.chartAxisLayoutPanel.seriesClipRect);
                chart.isDoubleTap = false;
            }
            else if (chart.disableTrackTooltip) {
                chart.disableTrackTooltip = false;
                chart.delayRedraw = false;
                chart.enableCanvas ? chart.createChartSvg() : chart.removeSvg();
                chart.refreshAxis();
                chart.refreshBound();
            }
        }
    };
    Zoom.prototype.refreshAxis = function (layout, chart, axes) {
        var mode = chart.zoomSettings.mode;
        layout.measureAxis(new Rect(chart.initialClipRect.x, chart.initialClipRect.y, chart.initialClipRect.width, chart.initialClipRect.height));
        axes.map(function (axis, index) {
            if (axis.orientation === 'Horizontal' && mode !== 'Y') {
                layout.drawXAxisLabels(axis, index, null, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));
            }
            if (axis.orientation === 'Vertical') {
                layout.drawYAxisLabels(axis, index, null, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));
            }
        });
    };
    // Rectangular zoom calculated here performed here
    Zoom.prototype.doZoom = function (chart, axes, bounds) {
        var _this = this;
        var zoomRect = this.zoomingRect;
        var mode = this.zooming.mode;
        var argsData;
        this.isPanning = chart.zoomSettings.enablePan || this.isPanning;
        var zoomedAxisCollections = [];
        this.zoomCompleteEvtCollection = [];
        for (var _i = 0, _a = axes; _i < _a.length; _i++) {
            var axis = _a[_i];
            argsData = {
                cancel: false, name: zoomComplete, axis: axis,
                previousZoomFactor: axis.zoomFactor,
                previousZoomPosition: axis.zoomPosition,
                currentZoomFactor: axis.zoomFactor,
                currentZoomPosition: axis.zoomPosition,
                previousVisibleRange: axis.visibleRange, currentVisibleRange: null
            };
            if (axis.orientation === 'Horizontal') {
                if (mode !== 'Y') {
                    argsData.currentZoomPosition += Math.abs((zoomRect.x - bounds.x) / (bounds.width)) * axis.zoomFactor;
                    argsData.currentZoomFactor *= (zoomRect.width / bounds.width);
                }
            }
            else {
                argsData.currentZoomPosition += (1 - Math.abs((zoomRect.height + (zoomRect.y - bounds.y)) / (bounds.height)))
                    * axis.zoomFactor;
                argsData.currentZoomFactor *= (zoomRect.height / bounds.height);
            }
            if (parseFloat(argsData.currentZoomFactor.toFixed(3)) <= 0.001) {
                argsData.currentZoomFactor = argsData.previousZoomFactor;
                argsData.currentZoomPosition = argsData.previousZoomPosition;
            }
            if (!argsData.cancel) {
                axis.zoomFactor = argsData.currentZoomFactor;
                axis.zoomPosition = argsData.currentZoomPosition;
                this.zoomCompleteEvtCollection.push(argsData);
            }
            zoomedAxisCollections.push({
                zoomFactor: axis.zoomFactor, zoomPosition: axis.zoomFactor, axisName: axis.name,
                axisRange: axis.visibleRange
            });
        }
        var onZoomingEventArg = { cancel: false, axisCollection: zoomedAxisCollections, name: onZooming };
        if (!onZoomingEventArg.cancel && this.chart.isBlazor) {
            this.chart.trigger(onZooming, onZoomingEventArg, function () {
                if (onZoomingEventArg.cancel) {
                    _this.zoomCancel(axes, _this.zoomCompleteEvtCollection);
                }
                else {
                    _this.zoomingRect = new Rect(0, 0, 0, 0);
                    _this.performZoomRedraw(chart);
                }
            });
        }
        else {
            this.chart.trigger(onZooming, onZoomingEventArg, function () {
                if (onZoomingEventArg.cancel) {
                    _this.zoomCancel(axes, _this.zoomCompleteEvtCollection);
                }
                else {
                    _this.zoomingRect = new Rect(0, 0, 0, 0);
                    _this.redrawOnZooming(chart);
                }
            });
        }
    };
    /** It is used to redraw the chart and trigger zoomComplete event */
    Zoom.prototype.redrawOnZooming = function (chart, isRedraw, isMouseUp) {
        if (isRedraw === void 0) { isRedraw = true; }
        if (isMouseUp === void 0) { isMouseUp = false; }
        var zoomCompleteCollection = isMouseUp ? this.toolkit.zoomCompleteEvtCollection :
            this.zoomCompleteEvtCollection;
        if (isRedraw) {
            this.performZoomRedraw(chart);
        }
        var argsData;
        for (var i = 0; i < zoomCompleteCollection.length; i++) {
            if (!zoomCompleteCollection[i].cancel) {
                argsData = {
                    cancel: false, name: zoomComplete,
                    axis: chart.axisCollections[i],
                    previousZoomFactor: zoomCompleteCollection[i].previousZoomFactor,
                    previousZoomPosition: zoomCompleteCollection[i].previousZoomPosition,
                    currentZoomFactor: chart.axisCollections[i].zoomFactor,
                    currentZoomPosition: chart.axisCollections[i].zoomPosition,
                    currentVisibleRange: chart.axisCollections[i].visibleRange,
                    previousVisibleRange: zoomCompleteCollection[i].previousVisibleRange
                };
                chart.trigger(zoomComplete, argsData);
            }
        }
    };
    /**
     * Function that handles the Mouse wheel zooming.
     *
     * @returns {void}
     * @private
     */
    Zoom.prototype.performMouseWheelZooming = function (e, mouseX, mouseY, chart, axes) {
        var _this = this;
        var direction = (this.browserName === 'mozilla' && !this.isPointer) ?
            -(e.detail) / 3 > 0 ? 1 : -1 : (e['wheelDelta'] > 0 ? 1 : -1);
        var mode = this.zooming.mode;
        var origin = 0.5;
        var cumulative;
        var zoomFactor;
        var zoomPosition;
        this.isZoomed = true;
        this.calculateZoomAxesRange(chart);
        chart.disableTrackTooltip = true;
        this.performedUI = true;
        this.isPanning = chart.zoomSettings.enablePan || this.isPanning;
        this.zoomCompleteEvtCollection = [];
        var argsData;
        var zoomedAxisCollection = [];
        for (var _i = 0, _a = axes; _i < _a.length; _i++) {
            var axis = _a[_i];
            argsData = {
                cancel: false, name: zoomComplete, axis: axis, previousZoomFactor: axis.zoomFactor,
                previousZoomPosition: axis.zoomPosition,
                currentZoomFactor: axis.zoomFactor,
                currentZoomPosition: axis.zoomPosition, currentVisibleRange: null,
                previousVisibleRange: axis.visibleRange
            };
            if ((axis.orientation === 'Vertical') ||
                (axis.orientation === 'Horizontal' && mode !== 'Y')) {
                cumulative = Math.max(Math.max(1 / minMax(axis.zoomFactor, 0, 1), 1) + (0.25 * direction), 1);
                cumulative = (cumulative > 50000000000) ? 50000000000 : cumulative;
                if (cumulative >= 1) {
                    origin = axis.orientation === 'Horizontal' ? mouseX / axis.rect.width : 1 - (mouseY / axis.rect.height);
                    origin = origin > 1 ? 1 : origin < 0 ? 0 : origin;
                    zoomFactor = (cumulative === 1) ? 1 : minMax((direction > 0 ? 0.9 : 1.1) / cumulative, 0, 1);
                    zoomPosition = (cumulative === 1) ? 0 : axis.zoomPosition + ((axis.zoomFactor - zoomFactor) * origin);
                    if (axis.zoomPosition !== zoomPosition || axis.zoomFactor !== zoomFactor) {
                        zoomFactor = (zoomPosition + zoomFactor) > 1 ? (1 - zoomPosition) : zoomFactor;
                    }
                    argsData.currentZoomFactor = zoomFactor;
                    argsData.currentZoomPosition = zoomPosition;
                }
                if (argsData.currentZoomFactor === argsData.previousZoomFactor && argsData.currentZoomPosition === argsData.previousZoomPosition) {
                    chart.disableTrackTooltip = false;
                }
                if (!argsData.cancel) {
                    axis.zoomFactor = argsData.currentZoomFactor;
                    axis.zoomPosition = argsData.currentZoomPosition;
                    this.zoomCompleteEvtCollection.push(argsData);
                }
            }
            zoomedAxisCollection.push({
                zoomFactor: axis.zoomFactor, zoomPosition: axis.zoomFactor, axisName: axis.name,
                axisRange: axis.visibleRange
            });
        }
        var onZoomingEventArgs = { cancel: false, axisCollection: zoomedAxisCollection, name: onZooming };
        if (!onZoomingEventArgs.cancel && this.chart.isBlazor) {
            this.chart.trigger(onZooming, onZoomingEventArgs, function () {
                if (onZoomingEventArgs.cancel) {
                    _this.zoomCancel(axes, _this.zoomCompleteEvtCollection);
                }
                else {
                    _this.performZoomRedraw(chart);
                }
            });
        }
        else {
            this.chart.trigger(onZooming, onZoomingEventArgs, function () {
                if (onZoomingEventArgs.cancel) {
                    _this.zoomCancel(axes, _this.zoomCompleteEvtCollection);
                }
                else {
                    _this.redrawOnZooming(chart);
                }
            });
        }
    };
    /**
     * Function that handles the Pinch zooming.
     *
     * @returns {void}
     * @private
     */
    Zoom.prototype.performPinchZooming = function (e, chart) {
        if ((this.zoomingRect.width > 0 && this.zoomingRect.height > 0) || (chart.startMove && chart.crosshair.enable)) {
            return false;
        }
        this.calculateZoomAxesRange(chart);
        this.isZoomed = true;
        this.isPanning = true;
        this.performedUI = true;
        this.offset = !chart.delayRedraw ? chart.chartAxisLayoutPanel.seriesClipRect : this.offset;
        chart.delayRedraw = true;
        chart.disableTrackTooltip = true;
        var elementOffset = chart.element.getBoundingClientRect();
        var touchDown = this.touchStartList;
        var touchMove = this.touchMoveList;
        var touch0StartX = touchDown[0].pageX - elementOffset.left;
        var touch0StartY = touchDown[0].pageY - elementOffset.top;
        var touch0EndX = touchMove[0].pageX - elementOffset.left;
        var touch0EndY = touchMove[0].pageY - elementOffset.top;
        var touch1StartX = touchDown[1].pageX - elementOffset.left;
        var touch1StartY = touchDown[1].pageY - elementOffset.top;
        var touch1EndX = touchMove[1].pageX - elementOffset.left;
        var touch1EndY = touchMove[1].pageY - elementOffset.top;
        var scaleX = Math.abs(touch0EndX - touch1EndX) / Math.abs(touch0StartX - touch1StartX);
        var scaleY = Math.abs(touch0EndY - touch1EndY) / Math.abs(touch0StartY - touch1StartY);
        var clipX = ((this.offset.x - touch0EndX) / scaleX) + touch0StartX;
        var clipY = ((this.offset.y - touch0EndY) / scaleY) + touch0StartY;
        var pinchRect = new Rect(clipX, clipY, this.offset.width / scaleX, this.offset.height / scaleY);
        var translateXValue = (touch0EndX - (scaleX * touch0StartX));
        var translateYValue = (touch0EndY - (scaleY * touch0StartY));
        if (!isNaN(scaleX - scaleX) && !isNaN(scaleY - scaleY)) {
            switch (this.zooming.mode) {
                case 'XY':
                case 'X':
                    this.setTransform(translateXValue, translateYValue, scaleX, scaleY, chart, true);
                    break;
                case 'Y':
                    this.setTransform(0, translateYValue, 1, scaleY, chart, true);
                    break;
            }
        }
        if (!this.calculatePinchZoomFactor(chart, pinchRect)) {
            this.refreshAxis(chart.chartAxisLayoutPanel, chart, chart.axisCollections);
            this.redrawOnZooming(chart, false);
        }
        return true;
    };
    Zoom.prototype.calculatePinchZoomFactor = function (chart, pinchRect) {
        var mode = this.zooming.mode;
        var selectionMin;
        var selectionMax;
        var rangeMin;
        var rangeMax;
        var value;
        var axisTrans;
        var argsData;
        var currentZF;
        var currentZP;
        var zoomedAxisCollection = [];
        this.zoomCompleteEvtCollection = [];
        for (var index = 0; index < chart.axisCollections.length; index++) {
            var axis = chart.axisCollections[index];
            if ((axis.orientation === 'Horizontal' && mode !== 'Y') ||
                (axis.orientation === 'Vertical')) {
                currentZF = axis.zoomFactor;
                currentZP = axis.zoomPosition;
                argsData = {
                    cancel: false, name: zoomComplete, axis: axis, previousZoomFactor: axis.zoomFactor,
                    previousZoomPosition: axis.zoomPosition, currentZoomFactor: currentZF,
                    currentZoomPosition: currentZP, previousVisibleRange: axis.visibleRange,
                    currentVisibleRange: null
                };
                if (axis.orientation === 'Horizontal') {
                    value = pinchRect.x - this.offset.x;
                    axisTrans = axis.rect.width / this.zoomAxes[index].delta;
                    rangeMin = value / axisTrans + this.zoomAxes[index].min;
                    value = pinchRect.x + pinchRect.width - this.offset.x;
                    rangeMax = value / axisTrans + this.zoomAxes[index].min;
                }
                else {
                    value = pinchRect.y - this.offset.y;
                    axisTrans = axis.rect.height / this.zoomAxes[index].delta;
                    rangeMin = (value * -1 + axis.rect.height) / axisTrans + this.zoomAxes[index].min;
                    value = pinchRect.y + pinchRect.height - this.offset.y;
                    rangeMax = (value * -1 + axis.rect.height) / axisTrans + this.zoomAxes[index].min;
                }
                selectionMin = Math.min(rangeMin, rangeMax);
                selectionMax = Math.max(rangeMin, rangeMax);
                currentZP = (selectionMin - this.zoomAxes[index].actualMin) / this.zoomAxes[index].actualDelta;
                currentZF = (selectionMax - selectionMin) / this.zoomAxes[index].actualDelta;
                argsData.currentZoomPosition = currentZP < 0 ? 0 : currentZP;
                argsData.currentZoomFactor = currentZF > 1 ? 1 : (currentZF < 0.03) ? 0.03 : currentZF;
                if (!argsData.cancel) {
                    axis.zoomFactor = argsData.currentZoomFactor;
                    axis.zoomPosition = argsData.currentZoomPosition;
                    this.zoomCompleteEvtCollection.push(argsData);
                }
                zoomedAxisCollection.push({
                    zoomFactor: axis.zoomFactor, zoomPosition: axis.zoomFactor, axisName: axis.name,
                    axisRange: axis.visibleRange
                });
            }
        }
        var onZoomingEventArgs = { cancel: false, axisCollection: zoomedAxisCollection, name: onZooming };
        if (!onZoomingEventArgs.cancel) {
            this.chart.trigger(onZooming, onZoomingEventArgs);
            if (onZoomingEventArgs.cancel) {
                this.zoomCancel(chart.axisCollections, this.zoomCompleteEvtCollection);
                return true;
            }
        }
        return false;
    };
    // Series transformation style applied here.
    Zoom.prototype.setTransform = function (transX, transY, scaleX, scaleY, chart, isPinch) {
        if (!chart.enableCanvas) {
            chart.seriesElements.setAttribute('clip-path', 'url(#' + this.elementId + '_ChartAreaClipRect_)');
        }
        if (chart.indicatorElements) {
            chart.indicatorElements.setAttribute('clip-path', 'url(#' + this.elementId + '_ChartAreaClipRect_)');
        }
        var translate;
        var xAxisLoc;
        var yAxisLoc;
        var element;
        if (transX !== null && transY !== null) {
            for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
                var value = _a[_i];
                xAxisLoc = chart.requireInvertedAxis ? value.yAxis.rect.x : value.xAxis.rect.x;
                yAxisLoc = chart.requireInvertedAxis ? value.xAxis.rect.y : value.yAxis.rect.y;
                translate = 'translate(' + (transX + (isPinch ? (scaleX * xAxisLoc) : xAxisLoc)) +
                    ',' + (transY + (isPinch ? (scaleY * yAxisLoc) : yAxisLoc)) + ')';
                translate = (scaleX || scaleY) ? translate + ' scale(' + scaleX + ' ' + scaleY + ')' : translate;
                if (value.visible) {
                    if (value.category === 'Indicator') {
                        value.seriesElement.parentNode.setAttribute('transform', translate);
                    }
                    else {
                        if (!chart.enableCanvas) {
                            value.seriesElement.setAttribute('transform', translate);
                        }
                    }
                    element = getElement$1(chart.element.id + '_Series_' + value.index + '_DataLabelCollections');
                    if (value.errorBarElement) {
                        value.errorBarElement.setAttribute('transform', translate);
                    }
                    if (value.symbolElement) {
                        value.symbolElement.setAttribute('transform', translate);
                    }
                    if (value.textElement) {
                        value.textElement.setAttribute('visibility', 'hidden');
                        value.shapeElement.setAttribute('visibility', 'hidden');
                    }
                    if (element) {
                        element.style.visibility = 'hidden';
                    }
                }
            }
        }
    };
    Zoom.prototype.calculateZoomAxesRange = function (chart) {
        var range;
        var axisRange;
        for (var index = 0; index < chart.axisCollections.length; index++) {
            var axis = chart.axisCollections[index];
            axisRange = axis.visibleRange;
            if (this.zoomAxes[index]) {
                if (!chart.delayRedraw) {
                    this.zoomAxes[index].min = axisRange.min;
                    this.zoomAxes[index].delta = axisRange.delta;
                }
            }
            else {
                range = {
                    actualMin: axis.actualRange.min,
                    actualDelta: axis.actualRange.delta,
                    min: axisRange.min,
                    delta: axisRange.delta
                };
                this.zoomAxes[index] = range;
            }
        }
    };
    // Zooming Toolkit created here
    Zoom.prototype.showZoomingToolkit = function (chart) {
        var toolboxItems = this.zooming.toolbarItems;
        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
        var spacing = 10;
        var render = chart.svgRenderer;
        var length = this.isDevice ? 1 : toolboxItems.length;
        var iconSize = this.isDevice ? measureText('Reset Zoom', { size: '12px' }, { size: '12px', fontStyle: 'Normal', fontWeight: '400', fontFamily: 'Segoe UI' }).width : 16;
        var height = this.isDevice ? measureText('Reset Zoom', { size: '12px' }, { size: '12px', fontStyle: 'Normal', fontWeight: '400', fontFamily: 'Segoe UI' }).height : 22;
        var width = (length * iconSize) + ((length + 1) * spacing) + ((length - 1) * spacing);
        var transX = areaBounds.x + areaBounds.width - width - spacing;
        var transY = (areaBounds.y + spacing);
        var xPosition = spacing;
        var toolkit = this.toolkit;
        var element;
        var shadowElement = '<filter id="chart_shadow" height="130%"><feGaussianBlur in="SourceAlpha" stdDeviation="5"/>';
        shadowElement += '<feOffset dx="-3" dy="4" result="offsetblur"/><feComponentTransfer><feFuncA type="linear" slope="1"/>';
        shadowElement += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
        if (length === 0 || getElement$1(this.elementId + '_Zooming_KitCollection')) {
            return false;
        }
        var defElement = render.createDefs();
        toolboxItems = this.isDevice ? ['Reset'] : toolboxItems;
        defElement.innerHTML = shadowElement;
        this.toolkitElements = render.createGroup({
            id: this.elementId + '_Zooming_KitCollection',
            transform: 'translate(' + transX + ',' + transY + ')'
        });
        this.toolkitElements.appendChild(defElement);
        var zoomFillColor = this.chart.theme === 'Tailwind' ? '#F3F4F6' : this.chart.theme === 'Fluent' ? '#F3F2F1' :
            (this.chart.theme === 'Material3' ? '#FFFFFF' : this.chart.theme === 'Material3Dark' ? '#1C1B1F' : '#fafafa');
        this.toolkitElements.appendChild(render.drawRectangle(new RectOption(this.elementId + '_Zooming_Rect', zoomFillColor, { color: 'transparent', width: 1 }, 1, new Rect(0, 0, width, (height + (spacing * 2))), 4, 4)));
        var outerElement = render.drawRectangle(new RectOption(this.elementId + '_Zooming_Rect', zoomFillColor, { color: 'transparent', width: 1 }, 0.1, new Rect(0, 0, width, (height + (spacing * 2))), 4, 4));
        if (this.chart.theme === 'Tailwind' || this.chart.theme === 'TailwindDark') {
            outerElement.setAttribute('box-shadow', '0px 1px 2px rgba(0, 0, 0, 0.06), 0px 1px 3px rgba(0, 0, 0, 0.1)');
        }
        else if (this.chart.theme === 'Material3' || this.chart.theme === 'Material3Dark') {
            outerElement.setAttribute('filter', 'drop-shadow(0px 1px 3px rgba(0, 0, 0, 0.15)) drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3))');
            outerElement.setAttribute('fill', this.chart.theme === 'Material3' ? '#FFFFFF' : '#1C1B1F');
            outerElement.setAttribute('rx', '4px');
            outerElement.setAttribute('ry', '4px');
            outerElement.setAttribute('opacity', '1');
        }
        else {
            outerElement.setAttribute('filter', 'url(#chart_shadow)');
        }
        this.toolkitElements.appendChild(outerElement);
        var currentItem;
        var panIcon = false;
        for (var i = 1; i <= length; i++) {
            currentItem = toolboxItems[i - 1];
            element = render.createGroup({
                transform: 'translate(' + xPosition + ',' + (this.isDevice ? spacing : (spacing + 3)) + ')'
            });
            // for desktop toolkit hight is 32 and top padding is 8 icon size 16
            switch (currentItem) {
                case 'Pan':
                    toolkit.createPanButton(element, this.toolkitElements);
                    panIcon = true;
                    break;
                case 'Zoom':
                    toolkit.createZoomButton(element, this.toolkitElements);
                    break;
                case 'ZoomIn':
                    toolkit.createZoomInButton(element, this.toolkitElements, chart);
                    break;
                case 'ZoomOut':
                    toolkit.createZoomOutButton(element, this.toolkitElements, chart);
                    break;
                case 'Reset':
                    toolkit.createResetButton(element, this.toolkitElements, chart, this.isDevice);
                    break;
            }
            xPosition += iconSize + (spacing * 2);
        }
        this.toolkitElements.setAttribute('opacity', this.isDevice ? '1' : '' + this.zoomkitOpacity);
        this.toolkitElements.setAttribute('cursor', 'auto');
        if (chart.enableCanvas) {
            var zoomDiv = document.createElement('div');
            zoomDiv.id = chart.element.id + '_zoom';
            zoomDiv.style.cssText = 'position:absolute; z-index:1';
            var zoomheight = chart.availableSize.height / 2;
            var svg = chart.svgRenderer.createSvg({
                id: chart.element.id + '_zoomkit_svg',
                width: chart.availableSize.width,
                height: zoomheight
            });
            svg.style.position = 'absolute';
            svg.appendChild(this.toolkitElements);
            zoomDiv.appendChild(svg);
            document.getElementById(this.elementId + '_Secondary_Element').appendChild(zoomDiv);
        }
        else {
            chart.svgObject.appendChild(this.toolkitElements);
        }
        if (!this.isDevice) {
            EventHandler.add(this.toolkitElements, 'mousemove touchstart', this.zoomToolkitMove, this);
            EventHandler.add(this.toolkitElements, 'mouseleave touchend', this.zoomToolkitLeave, this);
            if (this.isPanning && panIcon) {
                toolkit.pan();
            }
        }
        return true;
    };
    /**
     * To the show the zooming toolkit.
     *
     * @returns {void}
     * @private
     */
    Zoom.prototype.applyZoomToolkit = function (chart, axes) {
        var showToolkit = this.isAxisZoomed(axes);
        if (showToolkit) {
            this.showZoomingToolkit(chart);
            this.isZoomed = true;
        }
        else if (chart.zoomSettings.showToolbar) {
            this.isZoomed = showToolkit;
            this.showZoomingToolkit(chart);
        }
        else {
            this.toolkit.removeTooltip();
            this.isPanning = false;
            this.isZoomed = false;
            chart.isZoomed = false;
            chart.svgObject.setAttribute('cursor', 'auto');
        }
    };
    /**
     * To cancel zoom event.
     *
     * @returns {void}
     * @public
     */
    Zoom.prototype.zoomCancel = function (axes, zoomCompleteEventCollection) {
        for (var _i = 0, _a = zoomCompleteEventCollection; _i < _a.length; _i++) {
            var zoomCompleteEvent = _a[_i];
            for (var _b = 0, _c = axes; _b < _c.length; _b++) {
                var axis = _c[_b];
                if (axis.name === zoomCompleteEvent.axis.name) {
                    axis.zoomFactor = zoomCompleteEvent.previousZoomFactor;
                    axis.zoomPosition = zoomCompleteEvent.previousZoomPosition;
                    axis.visibleRange = zoomCompleteEvent.previousVisibleRange;
                    break;
                }
            }
        }
    };
    /**
     * Return boolean property to show zooming toolkit.
     *
     * @returns {void}
     * @private
     */
    Zoom.prototype.isAxisZoomed = function (axes) {
        var showToolkit = false;
        for (var _i = 0, _a = axes; _i < _a.length; _i++) {
            var axis = _a[_i];
            showToolkit = (showToolkit || (axis.zoomFactor !== 1 || axis.zoomPosition !== 0));
        }
        return showToolkit;
    };
    Zoom.prototype.zoomToolkitMove = function () {
        var element = this.toolkitElements;
        this.zoomkitOpacity = 1;
        element.setAttribute('opacity', '' + this.zoomkitOpacity);
        return false;
    };
    Zoom.prototype.zoomToolkitLeave = function () {
        var element = this.toolkitElements;
        this.zoomkitOpacity = 1;
        element.setAttribute('opacity', '' + this.zoomkitOpacity);
        return false;
    };
    /**
     * @hidden
     */
    Zoom.prototype.addEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        EventHandler.add(this.chart.element, this.wheelEvent, this.chartMouseWheel, this);
        this.chart.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
        this.chart.on(Browser.touchStartEvent, this.mouseDownHandler, this);
        this.chart.on(Browser.touchEndEvent, this.mouseUpHandler, this);
        this.chart.on(this.cancelEvent, this.mouseCancelHandler, this);
    };
    /**
     * @hidden
     */
    Zoom.prototype.removeEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        EventHandler.remove(this.chart.element, this.wheelEvent, this.chartMouseWheel);
        this.chart.off(Browser.touchMoveEvent, this.mouseMoveHandler);
        this.chart.off(Browser.touchStartEvent, this.mouseDownHandler);
        this.chart.off(Browser.touchEndEvent, this.mouseUpHandler);
        this.chart.off(this.cancelEvent, this.mouseCancelHandler);
    };
    /**
     * Handles the mouse wheel on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Zoom.prototype.chartMouseWheel = function (e) {
        var chart = this.chart;
        var offset = chart.element.getBoundingClientRect();
        var svgRect = getElement$1(chart.svgId).getBoundingClientRect();
        var mouseX = (e.clientX - offset.left) - Math.max(svgRect.left - offset.left, 0);
        var mouseY = (e.clientY - offset.top) - Math.max(svgRect.top - offset.top, 0);
        if (this.zooming.enableMouseWheelZooming &&
            withInBounds(mouseX, mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {
            e.preventDefault();
            this.performMouseWheelZooming(e, mouseX, mouseY, chart, chart.axisCollections);
        }
        return false;
    };
    /**
     * @hidden
     */
    Zoom.prototype.mouseMoveHandler = function (e) {
        //Zooming for chart
        var chart = this.chart;
        var touches = null;
        if (e.type === 'touchmove') {
            if (e.preventDefault && this.isIOS &&
                (this.isPanning || (chart.isDoubleTap)
                    || (this.zooming.enablePinchZooming && this.touchStartList.length > 1))) {
                e.preventDefault();
            }
            touches = e.touches;
        }
        if (chart.isChartDrag) {
            if (chart.isTouch) {
                this.touchMoveList = this.addTouchPointer(this.touchMoveList, e, touches);
                if (this.zooming.enablePinchZooming && this.touchMoveList.length > 1
                    && this.touchStartList.length > 1) {
                    this.performPinchZooming(e, chart);
                }
            }
            this.renderZooming(e, chart, chart.isTouch);
        }
    };
    /**
     * @hidden
     */
    Zoom.prototype.mouseDownHandler = function (e) {
        //Zooming for chart
        var chart = this.chart;
        var touches = null;
        var target;
        if (e.type === 'touchstart') {
            touches = e.touches;
            target = e.target;
        }
        else {
            target = e.target;
        }
        if (target.id.indexOf(chart.element.id + '_Zooming_') === -1 &&
            (chart.zoomSettings.enablePinchZooming || chart.zoomSettings.enableSelectionZooming) &&
            withInBounds(chart.previousMouseMoveX, chart.previousMouseMoveY, chart.chartAxisLayoutPanel.seriesClipRect)) {
            chart.isChartDrag = true;
        }
        if (chart.isTouch) {
            this.touchStartList = this.addTouchPointer(this.touchStartList, e, touches);
        }
    };
    /**
     * @hidden
     */
    Zoom.prototype.mouseUpHandler = function (e) {
        var chart = this.chart;
        var performZoomRedraw = e.target.id.indexOf(chart.element.id + '_ZoomOut_') === -1 ||
            e.target.id.indexOf(chart.element.id + '_ZoomIn_') === -1;
        if (chart.isChartDrag || performZoomRedraw) {
            this.redrawOnZooming(chart, true, true);
        }
        if (chart.isTouch) {
            if (chart.isDoubleTap && withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)
                && this.touchStartList.length === 1 && this.isZoomed) {
                this.toolkit.reset(e);
            }
            this.touchStartList = [];
            chart.isDoubleTap = false;
        }
    };
    /**
     * @hidden
     */
    Zoom.prototype.mouseCancelHandler = function () {
        if (this.isZoomed) {
            this.performZoomRedraw(this.chart);
        }
        this.pinchTarget = null;
        this.touchStartList = [];
        this.touchMoveList = [];
    };
    /**
     * Handles the touch pointer.
     *
     * @returns {ITouches[]} touchList collection
     * @private
     */
    Zoom.prototype.addTouchPointer = function (touchList, e, touches) {
        if (touches) {
            touchList = [];
            for (var i = 0, length_1 = touches.length; i < length_1; i++) {
                touchList.push({ pageX: touches[i].clientX, pageY: touches[i].clientY, pointerId: null });
            }
        }
        else {
            touchList = touchList ? touchList : [];
            if (touchList.length === 0) {
                touchList.push({ pageX: e.clientX, pageY: e.clientY, pointerId: e.pointerId });
            }
            else {
                for (var i = 0, length_2 = touchList.length; i < length_2; i++) {
                    if (touchList[i].pointerId === e.pointerId) {
                        touchList[i] = { pageX: e.clientX, pageY: e.clientY, pointerId: e.pointerId };
                    }
                    else {
                        touchList.push({ pageX: e.clientX, pageY: e.clientY, pointerId: e.pointerId });
                    }
                }
            }
        }
        return touchList;
    };
    /**
     * Get module name.
     */
    Zoom.prototype.getModuleName = function () {
        // Returns te module name
        return 'Zoom';
    };
    /**
     * To destroy the zooming.
     *
     * @returns {void}
     * @private
     */
    Zoom.prototype.destroy = function () {
        // Destroy method performed here
        this.removeEventListener();
    };
    return Zoom;
}());

/**
 * Selection src file
 */
/**
 * Selection Module handles the selection for chart.
 *
 * @private
 */
var BaseSelection = /** @__PURE__ @class */ (function () {
    function BaseSelection(control) {
        this.control = control;
    }
    /**
     * To create selection styles for series
     *
     * @returns {void}
     */
    BaseSelection.prototype.seriesStyles = function () {
        var seriesclass;
        var style = document.getElementById(this.styleId);
        var pattern = '{}';
        var fill;
        var opacity;
        var selectionPattern = this.control.selectionPattern;
        var highlightPattern = this.control.highlightPattern;
        if ((this.styleId.indexOf('highlight') > 0 && this.control.highlightColor !== '') || isNullOrUndefined(style) || selectionPattern !== 'None' || highlightPattern !== 'None') {
            style = document.createElement('style');
            style.setAttribute('id', this.styleId);
            for (var _i = 0, _a = this.control.visibleSeries; _i < _a.length; _i++) {
                var series = _a[_i];
                var visibleSeries = this.control.visibleSeries[series.index] ||
                    this.control.visibleSeries[series.index];
                if ((this.styleId.indexOf('highlight') > 0 && this.control.highlightColor !== '') || (!isNullOrUndefined(selectionPattern) || !isNullOrUndefined(highlightPattern)) &&
                    (selectionPattern !== 'None' || highlightPattern !== 'None')) {
                    var patternName = this.styleId.indexOf('highlight') > 0 ? highlightPattern : selectionPattern;
                    if ((visibleSeries.type === 'Pie' || visibleSeries.type === 'Funnel' ||
                        visibleSeries.type === 'Pyramid') && this.control.highlightColor !== 'transparent') {
                        for (var i = 0; i < visibleSeries.points.length; i++) {
                            opacity = visibleSeries.opacity;
                            fill = this.pattern(this.control, (this.styleId.indexOf('highlight') > 0 && this.control.highlightColor !== '') ? this.control.highlightColor : (visibleSeries.points[i]).color, series.points[i].index, patternName, opacity);
                            pattern = '{ fill:' + fill + '}';
                            seriesclass = series.selectionStyle || this.styleId + '_series_' + series.index + '_point_' + series.points[i].index + ',' + '.' +
                                this.styleId + '_series_' + series.index + '_point_' + series.points[i].index + '> *';
                            if (this.control.highlightMode === 'None' && this.control.legendSettings.enableHighlight) {
                                style.innerText += '.' + this.styleId + '_series_' + series.index + '> *' + ' { stroke-width:' + (3) + ';} ';
                            }
                            pattern = (pattern.indexOf('None') > -1) ? '{fill:' + this.control.highlightColor + '!important}' : pattern;
                            style.innerText += series.selectionStyle ? '' : '.' + seriesclass + pattern;
                        }
                    }
                    else if (visibleSeries.type && this.control.highlightColor !== 'transparent') {
                        opacity = visibleSeries.opacity;
                        fill = this.pattern(this.control, (this.styleId.indexOf('highlight') > 0 && this.control.highlightColor !== '') ? this.control.highlightColor :
                            (visibleSeries.pointColorMapping !== '' || (this.control.rangeColorSettings && this.control.rangeColorSettings.length > 1)) ? (visibleSeries.points[0]).color
                                : visibleSeries.interior, series.index, patternName, opacity);
                        pattern = '{ fill:' + fill + '}';
                    }
                }
                seriesclass = series.selectionStyle || this.styleId + '_series_' + series.index + ',' + '.' +
                    this.styleId + '_series_' + series.index + '> *';
                if (this.control.highlightMode === 'None' && this.control.legendSettings.enableHighlight) {
                    style.innerText += '.' + this.styleId + '_series_' + series.index + '> *' + ' { stroke-width:' + (parseFloat((series.width ? series.width.toString() : '0')) + 1) + ';} ';
                }
                pattern = (pattern.indexOf('None') > -1) ? '{}' : pattern;
                style.innerText += series.selectionStyle ? '' : '.' + seriesclass + pattern;
            }
            var unSelectOpacity = (this.control).highlightColor !== 'transparent' ? 0.3 : opacity;
            if (isNullOrUndefined(this.control.selectionModule) && this.control.selectionMode === 'None' && this.control.highlightColor !== '') {
                unSelectOpacity = 1;
            }
            style.innerText += '.' + this.unselected + ' { opacity:' + (unSelectOpacity) + ';} ';
            document.body.appendChild(style);
        }
    };
    /**
     * To create the pattern for series/points.
     *
     * @param chart
     * @param color
     * @param index
     * @param patternName
     * @param opacity
     * @param chart
     * @param color
     * @param index
     * @param patternName
     * @param opacity
     * @param chart
     * @param color
     * @param index
     * @param patternName
     * @param opacity
     * @param chart
     * @param color
     * @param index
     * @param patternName
     * @param opacity
     * @param chart
     * @param color
     * @param index
     * @param patternName
     * @param opacity
     */
    BaseSelection.prototype.pattern = function (chart, color, index, patternName, opacity) {
        var backgroundColor = '#ffffff';
        var svg = chart.svgObject;
        var pathOptions = [];
        var patternGroup = {
            'id': chart.element.id + '_' + patternName + '_Selection' + '_' + index, 'patternUnits': 'userSpaceOnUse'
        };
        
        var heightStr = 'height';
        var widthStr = 'width';
        var width = 10;
        var height = 12;
        var patternNum = 6;
        var turquoiseNum = 17;
        var turstrokewidth = 1;
        var starNum = 21;
        var circleNum = 9;
        var tileNum = 18;
        var strokeWidth = 1;
        var bubNum = 20;
        switch (patternName) {
            case 'Dots':
                patternGroup[heightStr] = patternGroup[widthStr] = patternNum;
                patternGroup[widthStr] = patternNum;
                pathOptions[0] = {
                    'x': 0, 'y': 0, 'width': 7, 'height': 7, 'transform': 'translate(0,0)',
                    'fill': backgroundColor, 'opacity': opacity, 'name': 'rect'
                };
                pathOptions[1] = {
                    'cx': 3,
                    'cy': 3,
                    'r': 2,
                    'stroke-width': 1,
                    'fill': color,
                    'name': 'circle'
                };
                break;
            case 'Pacman':
                patternGroup[heightStr] = '18.384';
                patternGroup[widthStr] = '17.917';
                pathOptions[0] = {
                    'name': 'rect', 'x': 0, 'y': 0, 'width': 17.917, 'height': 18.384,
                    'transform': 'translate(0,0)', 'fill': backgroundColor, 'opacity': opacity
                };
                pathOptions[1] = {
                    'name': 'path', 'd': 'M9.081,9.194l5.806-3.08c-0.812-1.496-2.403-3.052-4.291-3.052H8.835C6.138,3.063,3,6.151,3,8.723v1.679   c0,2.572,3.138,5.661,5.835,5.661h1.761c2.085,0,3.835-1.76,4.535-3.514L9.081,9.194z', 'stroke-width': 1, 'stroke': color, 'fill': color
                };
                break;
            case 'Chessboard':
                patternGroup[heightStr] = patternGroup[widthStr] = width;
                pathOptions[0] = {
                    'x': 0, 'y': 0, 'width': width, 'height': width, 'fill': backgroundColor, 'opacity': opacity,
                    'name': 'rect'
                };
                pathOptions[1] = { 'x': 0, 'y': 0, 'width': 5, 'height': 5, 'fill': color, 'opacity': opacity, 'name': 'rect' };
                pathOptions[2] = { 'x': 5, 'y': 5, 'width': 5, 'height': 5, 'fill': color, 'opacity': opacity, 'name': 'rect' };
                break;
            case 'Crosshatch':
                patternGroup[heightStr] = patternGroup[widthStr] = '8';
                pathOptions[0] = {
                    'x': 0, 'y': 0, 'width': 8, 'height': 8, 'transform': 'translate(0,0)',
                    'fill': backgroundColor, 'opacity': opacity, 'name': 'rect'
                };
                pathOptions[1] = {
                    'd': 'M0 0L8 8ZM8 0L0 8Z',
                    'stroke-width': 1,
                    'stroke': color,
                    'name': 'path'
                };
                break;
            case 'DiagonalForward':
                patternGroup[heightStr] = patternGroup[widthStr] = patternNum;
                pathOptions[0] = {
                    'x': 0, 'y': 0, 'width': patternNum, 'height': patternNum, 'transform': 'translate(0,0)',
                    'fill': backgroundColor, 'opacity': opacity, 'name': 'rect'
                };
                pathOptions[1] = {
                    'd': 'M 3 -3 L 9 3 M 6 6 L 0 0 M 3 9 L -3 3',
                    'stroke-width': 2,
                    'stroke': color,
                    'name': 'path'
                };
                break;
            case 'DiagonalBackward':
                patternGroup[heightStr] = patternGroup[widthStr] = patternNum;
                pathOptions[0] = {
                    'x': 0, 'y': 0, 'width': patternNum, 'height': patternNum, 'transform': 'translate(0,0)',
                    'fill': backgroundColor, 'opacity': opacity, 'name': 'rect'
                };
                pathOptions[1] = {
                    'd': 'M 3 -3 L -3 3 M 0 6 L 6 0 M 9 3 L 3 9',
                    'stroke-width': 2,
                    'stroke': color,
                    'name': 'path'
                };
                break;
            case 'Grid':
                patternGroup[heightStr] = patternGroup[widthStr] = patternNum;
                pathOptions[0] = {
                    'name': 'rect', 'x': 0, 'y': 0, 'width': patternNum, 'height': patternNum, 'transform': 'translate(0,0)',
                    'fill': backgroundColor, 'opacity': opacity
                };
                pathOptions[1] = {
                    'name': 'path',
                    'd': 'M1 3.5L11 3.5 M0 3.5L11 3.5 M0 7.5L11 7.5 M0 11.5L11 11.5 M5.5 0L5.5 12 M11.5 0L11.5 12Z',
                    'stroke-width': 1,
                    'stroke': color
                };
                break;
            case 'Turquoise':
                patternGroup[heightStr] = patternGroup[widthStr] = turquoiseNum;
                pathOptions[0] = {
                    'name': 'rect', 'x': 0, 'y': 0, 'width': turquoiseNum, 'height': turquoiseNum, 'transform': 'translate(0,0)',
                    'fill': backgroundColor, 'opacity': opacity
                };
                pathOptions[1] = {
                    'name': 'path', 'd': 'M0.5739999999999998,2.643a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0',
                    'stroke-width': turstrokewidth, 'stroke-miterlimit': width, 'stroke': color, 'fill': color
                };
                pathOptions[2] = {
                    'name': 'path', 'd': 'M11.805,2.643a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0',
                    'stroke-width': turstrokewidth, 'stroke-miterlimit': width, 'stroke': color, 'fill': color
                };
                pathOptions[3] = {
                    'name': 'path', 'd': 'M6.19,2.643a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0',
                    'stroke-width': turstrokewidth, 'stroke-miterlimit': width, 'stroke': color, 'fill': color
                };
                pathOptions[4] = {
                    'name': 'path', 'd': 'M11.805,8.217a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0',
                    'stroke-width': turstrokewidth, 'stroke-miterlimit': width, 'stroke': color, 'fill': color
                };
                pathOptions[5] = {
                    'name': 'path', 'd': 'M6.19,8.217a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0',
                    'stroke-width': turstrokewidth, 'stroke-miterlimit': width, 'stroke': color, 'fill': color
                };
                pathOptions[6] = {
                    'name': 'path', 'd': 'M11.805,13.899a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0',
                    'stroke-width': turstrokewidth, 'stroke-miterlimit': width, 'stroke': color, 'fill': color
                };
                pathOptions[7] = {
                    'name': 'path', 'd': 'M6.19,13.899a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0',
                    'stroke-width': turstrokewidth, 'stroke-miterlimit': width, 'stroke': color, 'fill': color
                };
                break;
            case 'Star':
                patternGroup[heightStr] = patternGroup[widthStr] = starNum;
                pathOptions[0] = {
                    'name': 'rect', 'x': 0, 'y': 0, 'width': starNum, 'height': starNum, 'transform': 'translate(0,0)',
                    'fill': backgroundColor, 'opacity': opacity
                };
                pathOptions[1] = {
                    'name': 'path',
                    'd': 'M15.913,18.59L10.762 12.842 5.613 18.75 8.291 11.422 0.325 9.91 8.154 8.33 5.337 0.91 10.488 6.658 15.637 0.75 12.959 8.078 20.925 9.59 13.096 11.17 z',
                    'stroke-width': 1,
                    'stroke': color,
                    'fill': color
                };
                break;
            case 'Triangle':
                patternGroup[heightStr] = patternGroup[widthStr] = width;
                pathOptions[0] = {
                    'name': 'rect', 'x': 0, 'y': 0, 'width': width, 'height': width, 'transform': 'translate(0,0)',
                    'fill': backgroundColor, 'opacity': opacity
                };
                pathOptions[1] = {
                    'name': 'path',
                    'd': 'M4.987,0L7.48 4.847 9.974 9.694 4.987 9.694 0 9.694 2.493 4.847 z',
                    'stroke-width': 1,
                    'stroke': color,
                    'fill': color
                };
                break;
            case 'Circle':
                patternGroup[heightStr] = patternGroup[widthStr] = circleNum;
                pathOptions[0] = {
                    'name': 'rect', 'x': 0, 'y': 0, 'width': circleNum, 'height': circleNum, 'transform': 'translate(0,0)',
                    'fill': backgroundColor, 'opacity': opacity
                };
                pathOptions[1] = {
                    'name': 'circle',
                    'cx': 5.125,
                    'cy': 3.875,
                    'r': 3.625,
                    'stroke-width': 1,
                    'fill': color
                };
                break;
            case 'Tile':
                patternGroup[heightStr] = patternGroup[widthStr] = tileNum;
                pathOptions[0] = {
                    'name': 'rect', 'x': 0, 'y': 0, 'width': tileNum, 'height': tileNum, 'transform': 'translate(0,0)',
                    'fill': backgroundColor, 'opacity': opacity
                };
                pathOptions[1] = { 'name': 'path', 'd': 'M0,9L0 0 9 0 z', 'stroke-width': strokeWidth, 'stroke': color, 'fill': color };
                pathOptions[2] = { 'name': 'path', 'd': 'M9,9L9 0 18 0 z', 'stroke-width': strokeWidth, 'stroke': color, 'fill': color };
                pathOptions[3] = { 'name': 'path', 'd': 'M0,18L0 9 9 9 z', 'stroke-width': strokeWidth, 'stroke': color, 'fill': color };
                pathOptions[4] = { 'name': 'path', 'd': 'M9,18L9 9 18 9 z', 'stroke-width': strokeWidth, 'stroke': color, 'fill': color };
                break;
            case 'HorizontalDash':
                patternGroup[heightStr] = patternGroup[widthStr] = height;
                pathOptions[0] = {
                    'name': 'rect', 'x': 0, 'y': 0, 'width': height, 'height': height, 'transform': 'translate(0,0)',
                    'fill': backgroundColor, 'opacity': opacity
                };
                pathOptions[1] = {
                    'name': 'path', 'd': 'M0,1.5 L10 1.5 M0,5.5 L10 5.5 M0,9.5 L10 9.5 z', 'stroke-width': 1,
                    'stroke': color, 'fill': color
                };
                break;
            case 'VerticalDash':
                patternGroup[heightStr] = patternGroup[widthStr] = height;
                pathOptions[0] = {
                    'name': 'rect', 'x': 0, 'y': 0, 'width': height, 'height': height, 'transform': 'translate(0,0)',
                    'fill': backgroundColor, 'opacity': opacity
                };
                pathOptions[1] = {
                    'name': 'path', 'd': 'M1.5,0 L1.5 10 M5.5,0 L5.5 10 M9.5,0 L9.5 10 z', 'stroke-width': 1,
                    'stroke': color, 'fill': color
                };
                break;
            case 'Rectangle':
                patternGroup[heightStr] = patternGroup[widthStr] = height;
                pathOptions[0] = { 'name': 'rect', 'width': height, 'height': height, 'fill': backgroundColor, 'opacity': opacity };
                pathOptions[1] = { 'name': 'rect', 'x': 1, 'y': 2, 'width': 4, 'height': 9, 'fill': color, 'opacity': opacity };
                pathOptions[2] = { 'name': 'rect', 'x': 7, 'y': 2, 'width': 4, 'height': 9, 'fill': color, 'opacity': opacity };
                break;
            case 'Box':
                patternGroup[heightStr] = patternGroup[widthStr] = width;
                pathOptions[0] = { 'name': 'rect', 'width': 13, 'height': 13, 'fill': backgroundColor, 'opacity': opacity };
                pathOptions[1] = {
                    'name': 'rect', 'x': 1.5, 'y': 1.5, 'width': width, 'height': 9, 'fill': color,
                    'opacity': opacity
                };
                break;
            case 'HorizontalStripe':
                patternGroup[heightStr] = height;
                patternGroup[widthStr] = width;
                pathOptions[0] = {
                    'name': 'rect', 'x': 0, 'y': 0, 'width': width, 'height': height,
                    'transform': 'translate(0,0)', 'fill': backgroundColor, 'opacity': opacity
                };
                pathOptions[1] = {
                    'name': 'path', 'd': 'M0,0.5 L10 0.5 M0,4.5 L10 4.5 M0,8.5 L10 8.5 z', 'stroke-width': 1,
                    'stroke': color, 'fill': color
                };
                break;
            case 'VerticalStripe':
                patternGroup[heightStr] = width;
                patternGroup[widthStr] = height;
                pathOptions[0] = {
                    'name': 'rect', 'x': 0, 'y': 0, 'width': height, 'height': width, 'transform': 'translate(0,0)',
                    'fill': backgroundColor, 'opacity': opacity
                };
                pathOptions[1] = {
                    'name': 'path', 'd': 'M0.5,0 L0.5 10 M4.5,0 L4.5 10 M8.5,0 L8.5 10 z', 'stroke-width': 1,
                    'stroke': color, 'fill': color
                };
                break;
            case 'Bubble':
                patternGroup[heightStr] = patternGroup[widthStr] = bubNum;
                pathOptions[0] = {
                    'name': 'rect', 'x': 0, 'y': 0, 'width': bubNum, 'height': bubNum, 'transform': 'translate(0,0)',
                    'fill': backgroundColor, 'opacity': opacity
                };
                pathOptions[1] = { 'name': 'circle', 'cx': 5.217, 'cy': 11.325, 'r': 3.429, 'stroke-width': 1, 'fill': '#D0A6D1' };
                pathOptions[2] = { 'name': 'circle', 'cx': 13.328, 'cy': 6.24, 'r': 4.884, 'stroke-width': 1, 'fill': color };
                pathOptions[3] = {
                    'name': 'circle', 'cx': 13.277, 'cy': 14.66, 'r': 3.018, 'stroke-width': 1,
                    'fill': '#D0A6D1'
                };
                break;
        }
        var svgRenderer = (chart.svgRenderer || chart.renderer);
        var pattern = svgRenderer.createPattern(patternGroup, 'pattern');
        this.loadPattern(chart, pathOptions, pattern, svgRenderer);
        svg.appendChild(pattern);
        return 'url(#' + chart.element.id + '_' + patternName + '_' + 'Selection' + '_' + index + ')';
    };
    /**
     * To load the pattern into svg
     *
     * @param chart
     * @param options
     * @param pattern
     * @param svgRenderer
     * @param chart
     * @param options
     * @param pattern
     * @param svgRenderer
     * @param chart
     * @param options
     * @param pattern
     * @param svgRenderer
     * @param chart
     * @param options
     * @param pattern
     * @param svgRenderer
     */
    BaseSelection.prototype.loadPattern = function (chart, options, pattern, svgRenderer) {
        var i;
        for (i = 0; i < options.length; i++) {
            var path = svgRenderer.createPattern(options[i], options[i].name);
            pattern.appendChild(path);
        }
    };
    /**
     * To concat indexes
     *
     * @param userIndexes
     * @param localIndexes
     * @param userIndexes
     * @param localIndexes
     */
    BaseSelection.prototype.concatIndexes = function (userIndexes, localIndexes) {
        return userIndexes.concat(localIndexes);
    };
    /**
     * Selected points series visibility checking on legend click
     *
     * @param selectedIndexes
     */
    BaseSelection.prototype.checkVisibility = function (selectedIndexes, chart) {
        if (chart === void 0) { chart = null; }
        if (!selectedIndexes) {
            return false;
        }
        var visible = false;
        var uniqueSeries = [];
        for (var _i = 0, selectedIndexes_1 = selectedIndexes; _i < selectedIndexes_1.length; _i++) {
            var index = selectedIndexes_1[_i];
            if (uniqueSeries.indexOf(index.series) === -1) {
                uniqueSeries.push(index.series);
            }
        }
        for (var _a = 0, uniqueSeries_1 = uniqueSeries; _a < uniqueSeries_1.length; _a++) {
            var index = uniqueSeries_1[_a];
            if (chart != null && chart.rangeColorSettings && chart.rangeColorSettings.length > 0 &&
                chart.rangeColorSettings[0].colors.length > 0) {
                if (this.control.series[0].visible) {
                    visible = true;
                    break;
                }
            }
            else {
                if (this.control.visibleSeries[index].visible) {
                    visible = true;
                    break;
                }
            }
        }
        return visible;
    };
    /**
     * To add svg element style class
     *
     * @param element
     * @param className
     * @param element
     * @param className
     * @private
     */
    BaseSelection.prototype.addSvgClass = function (element, className) {
        var elementClassName = element.getAttribute('class') || '';
        elementClassName += ((elementClassName !== '') ? ' ' : '');
        if (elementClassName.indexOf(className) === -1) {
            element.setAttribute('class', elementClassName + className);
        }
    };
    /**
     * To remove svg element style class
     *
     * @param element
     * @param className
     * @param element
     * @param className
     * @private
     */
    BaseSelection.prototype.removeSvgClass = function (element, className) {
        var elementClassName = element.getAttribute('class') || '';
        if (elementClassName.indexOf(className) > -1) {
            element.setAttribute('class', elementClassName.replace(className, ''));
        }
    };
    /**
     * To get children from parent element
     *
     * @param parent
     */
    BaseSelection.prototype.getChildren = function (parent) {
        var children = [];
        for (var i = 0; i < parent.childNodes.length; i++) {
            if (parent.childNodes[i].tagName !== 'defs') {
                children.push(parent.childNodes[i]);
            }
        }
        return children;
    };
    return BaseSelection;
}());

var __extends$55 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable no-constant-condition */
/* eslint-disable max-len */
/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * Selection src file
 */
/**
 * `Selection` module handles the selection for chart.
 *
 * @private
 */
var Selection = /** @__PURE__ @class */ (function (_super) {
    __extends$55(Selection, _super);
    /**
     * Constructor for selection module.
     *
     * @private
     */
    function Selection(chart) {
        var _this = _super.call(this, chart) || this;
        _this.isdrawRect = true;
        _this.multiDataIndexes = [];
        _this.pathIndex = 0;
        _this.seriesIndex = 0;
        _this.count = -1;
        _this.dragRectArray = [];
        _this.filterArray = [];
        _this.totalSelectedPoints = [];
        _this.chart = chart;
        _this.renderer = chart.renderer;
        var mode = chart.selectionMode;
        _this.isMultiDrag = chart.isMultiSelect && (mode.indexOf('Drag') > -1);
        _this.addEventListener();
        return _this;
    }
    /**
     * Binding events for selection module.
     */
    Selection.prototype.addEventListener = function () {
        if (this.chart.isDestroyed || (this.chart.stockChart && this.chart.stockChart.onPanning)) {
            return;
        }
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
        this.chart.on(cancelEvent, this.mouseLeave, this);
        this.chart.on('click', this.mouseClick, this);
        this.chart.on(Browser.touchStartEvent, this.mousedown, this);
        this.chart.on(Browser.touchEndEvent, this.mouseLeave, this);
    };
    /**
     * Chart mouse down
     */
    Selection.prototype.mousedown = function (e) {
        var chart = this.chart;
        if (chart.isPointMouseDown || chart.selectionMode === 'None' || chart.isChartDrag) {
            return;
        }
        if (chart.isDoubleTap || !chart.isTouch || this.rectPoints) {
            this.dragStart(chart, chart.chartAxisLayoutPanel.seriesClipRect, chart.mouseDownX, chart.mouseDownY, e);
        }
    };
    /**
     * UnBinding events for selection module.
     */
    Selection.prototype.removeEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.off(Browser.touchMoveEvent, this.mouseMove);
        this.chart.off('pointerleave' || 'mouseleave', this.mouseLeave);
        this.chart.off('click', this.mouseClick);
        this.chart.off(Browser.touchStartEvent, this.mousedown);
        this.chart.off(Browser.touchEndEvent, this.mouseLeave);
    };
    /**
     * To find private variable values
     */
    Selection.prototype.initPrivateVariables = function (chart) {
        this.styleId = chart.element.id + '_ej2_chart_selection';
        this.unselected = chart.element.id + '_ej2_deselected';
        this.closeIconId = chart.element.id + '_ej2_drag_close';
        this.draggedRectGroup = chart.element.id + '_ej2_drag_group';
        this.multiRectGroup = chart.element.id + '_ej2_drag_multi_group';
        this.draggedRect = chart.element.id + '_ej2_drag_rect';
        this.lassoPath = chart.element.id + '_ej2_drag_path';
        this.selectedDataIndexes = [];
        this.rectPoints = null;
        this.isSeriesMode = chart.selectionMode === 'Series';
    };
    /**
     * Method to select the point and series.
     *
     * @returns {void}
     */
    Selection.prototype.invokeSelection = function (chart) {
        this.initPrivateVariables(chart);
        this.series = extend({}, chart.visibleSeries, null, true);
        this.seriesStyles();
        this.currentMode = chart.selectionMode;
        if (!(chart.selectionMode.indexOf('Drag') > -1)) {
            this.selectDataIndex(chart, this.concatIndexes(chart.selectedDataIndexes, this.selectedDataIndexes));
        }
    };
    Selection.prototype.generateStyle = function (series) {
        if (series) {
            if (this.styleId.indexOf('selection') > 1 && this.chart.selectionMode !== 'None') {
                this.unselected = series.unSelectedStyle || this.unselected;
            }
            if (this.styleId.indexOf('highlight') > 0 && (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight)) {
                this.unselected = series.nonHighlightStyle || this.unselected;
            }
            return (series.selectionStyle || this.styleId + '_series_' + series.index);
        }
        return 'undefined';
    };
    /**
     *  Method to get the selected data index
     *
     * @private
     */
    Selection.prototype.selectDataIndex = function (chart, indexes) {
        for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {
            var index = indexes_1[_i];
            this.performSelection(index, chart, this.getElementByIndex(chart, index, '', this.series[index.series].marker.visible)[0]);
        }
    };
    /**
     *  Method to get the selected index element
     *
     * @private
     */
    Selection.prototype.getElementByIndex = function (chart, index, suffix, marker) {
        if (suffix === void 0) { suffix = ''; }
        var elementId = chart.element.id + '_Series_' + index.series + '_Point' + '_' + index.point;
        var series = chart.series[index.series];
        elementId = (series.type !== 'Scatter' && series.type !== 'Bubble' && marker) ? (elementId + '_Symbol' + suffix) : elementId;
        return [getElement$1(elementId), ((series.type === 'RangeArea' || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea') && series.marker.visible) ?
                getElement$1(elementId + '1') : null];
    };
    /**
     *  Method to get the selected cluster element
     *
     * @private
     */
    Selection.prototype.getClusterElements = function (chart, index) {
        var clusters = [];
        var seriesStyle;
        var selectedElements;
        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            if (series.visible) {
                index = new Index(series.index, index.point);
                if (series.isRectSeries) {
                    clusters.push(this.getElementByIndex(chart, index)[0]);
                }
                clusters.push(this.getElementByIndex(chart, index, '', series.marker.visible)[0]);
                seriesStyle = this.generateStyle(chart.visibleSeries[index.series]);
                selectedElements = document.querySelectorAll('.' + seriesStyle);
                this.findTrackballElements(selectedElements, seriesStyle);
                var clusterIndex = series.marker.visible && series.isRectSeries ? 2 : 1;
                if (!chart.isMultiSelect && selectedElements.length > 0 &&
                    selectedElements[0].id !== (clusters[clusters.length - clusterIndex] ? clusters[clusters.length - clusterIndex].id : '')) {
                    this.removeSelection(chart, index.series, selectedElements, seriesStyle, true);
                }
            }
        }
        return clusters;
    };
    /**
     *  Method to get trackball elements
     *
     * @private
     */
    Selection.prototype.findTrackballElements = function (selectedElements, className) {
        var trackballElements;
        var elements;
        for (var i = 0; i < selectedElements.length; i++) {
            if (!isNullOrUndefined(selectedElements[i])) {
                trackballElements = !isNullOrUndefined(selectedElements[i].parentNode) ?
                    [].slice.call(selectedElements[0].parentNode.querySelectorAll('.' + className)) : [];
                if (trackballElements.length > 0) {
                    elements = [];
                    for (var i_1 = 0; i_1 < trackballElements.length; i_1++) {
                        if (trackballElements[i_1].id.indexOf('Trackball') > -1) {
                            elements.push(trackballElements[i_1]);
                        }
                    }
                    this.removeStyles(elements);
                }
            }
        }
    };
    /**
     *  Method to get the selected element
     *
     * @private
     */
    Selection.prototype.findElements = function (chart, series, index, suffix, marker) {
        if (suffix === void 0) { suffix = ''; }
        if (this.isSeriesMode) {
            return this.getSeriesElements(series);
        }
        else if (this.currentMode === 'Cluster') {
            return this.getClusterElements(chart, index);
        }
        else {
            return this.getElementByIndex(chart, index, suffix, marker);
        }
    };
    /**
     * To find the selected element.
     *
     * @returns {void}
     * @private
     */
    Selection.prototype.isAlreadySelected = function (targetElem, eventType) {
        if (eventType === 'click') {
            this.currentMode = this.chart.selectionMode;
            this.styleId = this.chart.element.id + '_ej2_chart_selection';
        }
        else if (eventType === 'mousemove' || eventType === 'pointermove') {
            this.currentMode = this.chart.highlightMode;
            this.highlightDataIndexes = [];
            this.styleId = this.chart.element.id + '_ej2_chart_highlight';
        }
        if (this.chart.highlightMode !== 'None' && this.chart.selectionMode === 'None') {
            if (eventType === 'click') {
                return false;
            }
        }
        if (((this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight) && this.previousSelectedEle && this.previousSelectedEle[0])) {
            var parentNodeId = targetElem.parentNode.id;
            var isElement = void 0;
            if (targetElem.parentNode) {
                isElement = (parentNodeId.indexOf('SeriesGroup') > 0 || parentNodeId.indexOf('SymbolGroup') > 0) ? true : false;
            }
            for (var i = 0; i < this.previousSelectedEle.length; i++) {
                if (this.previousSelectedEle[i] && this.previousSelectedEle[i].hasAttribute('class')) {
                    if (this.previousSelectedEle[i].getAttribute('class').indexOf('highlight') > -1 &&
                        (isElement || eventType === 'click')) {
                        this.previousSelectedEle[i].removeAttribute('class');
                        if (this.chart.highlightColor !== '' && !isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightPattern === 'None') {
                            if (this.previousSelectedEle[i].id.indexOf('Group') > 0) {
                                for (var j = 0; j < this.previousSelectedEle[i].children.length; j++) {
                                    this.previousSelectedEle[i].children[j].setAttribute('fill', this.control.visibleSeries[this.indexFinder(this.previousSelectedEle[i].id).series].interior);
                                }
                            }
                            else {
                                this.previousSelectedEle[i].setAttribute('fill', this.control.visibleSeries[this.indexFinder(this.previousSelectedEle[i].id).series].interior);
                            }
                        }
                        this.addOrRemoveIndex(this.highlightDataIndexes, this.indexFinder(this.previousSelectedEle[i].id));
                    }
                    else if (!isElement && this.previousSelectedEle[i].getAttribute('class').indexOf('highlight') > -1) {
                        this.performSelection(this.indexFinder(this.previousSelectedEle[i].id), this.chart, this.previousSelectedEle[i]);
                    }
                }
            }
        }
        return true;
    };
    Selection.prototype.mouseClick = function (event) {
        this.calculateSelectedElements(event.target, event.type);
    };
    /**
     * To find the selected element.
     *
     * @returns {void}
     * @private
     */
    Selection.prototype.calculateSelectedElements = function (targetElement, eventType) {
        if (isNullOrUndefined(targetElement)) {
            return;
        }
        if ((this.chart.selectionMode === 'None' && this.chart.highlightMode === 'None') ||
            targetElement.id && targetElement.id.indexOf(this.chart.element.id + '_') === -1) {
            return;
        }
        if (eventType === 'mousemove' || eventType === 'pointermove') {
            if (targetElement.hasAttribute('class') && (targetElement.getAttribute('class').indexOf('highlight') > -1 ||
                targetElement.getAttribute('class').indexOf('selection') > -1)) {
                return;
            }
            if (!isNullOrUndefined(targetElement.parentNode) && targetElement.parentNode.hasAttribute('class') &&
                (targetElement.parentNode.getAttribute('class').indexOf('highlight') > 0 ||
                    targetElement.parentNode.getAttribute('class').indexOf('selection') > 0)) {
                return;
            }
        }
        this.isAlreadySelected(targetElement, eventType);
        if (targetElement.id && targetElement.id.indexOf('_Series_') > -1 && targetElement.id.indexOf('_Text_') === -1) {
            var element = void 0;
            if (targetElement.id.indexOf('_Trackball_1') > -1) {
                element = getElement$1(targetElement.id.split('_Trackball_')[0] + '_Symbol');
                element = isNullOrUndefined(element) ? getElement$1(targetElement.id.split('_Trackball_')[0]) : element;
            }
            else if (targetElement.id.indexOf('_Trackball_0') > -1) {
                return null;
            }
            this.performSelection(this.indexFinder(targetElement.id), this.chart, element || targetElement);
        }
    };
    /**
     *  Method to perform the selection
     *
     * @private
     */
    Selection.prototype.performSelection = function (index, chart, element) {
        this.isSeriesMode = this.currentMode === 'Series';
        if (chart.visibleSeries[index.series].type === 'BoxAndWhisker' && element &&
            element.id === chart.element.id + '_Series_' + index.series + '_Point_' + index.point + '_BoxPath') {
            element = element.parentNode;
        }
        if (chart.visibleSeries[index.series].type === 'Area' && (this.currentMode === 'Point' || this.currentMode === 'Cluster') && element &&
            (element.id === this.chart.element.id + '_Series_' + index.series)) {
            var className = this.generateStyle(chart.series[index.series]);
            var selectionEle = document.querySelectorAll('.' + className);
            this.findTrackballElements(selectionEle, className);
            this.blurEffect(chart.element.id, chart.visibleSeries, false, index.point);
        }
        switch (this.currentMode) {
            case 'Series':
                this.selection(chart, index, this.getSeriesElements(chart.series[index.series]));
                this.selectionComplete(chart, index, this.currentMode);
                this.blurEffect(chart.element.id, chart.visibleSeries, false, index.point);
                break;
            case 'Point':
                if (!isNaN(index.point) && element) {
                    var pointElements = [];
                    pointElements.push(element);
                    if (pointElements[0] !== null && chart.series[index.series].marker.visible &&
                        (chart.series[index.series].type.indexOf('Column') !== -1 || chart.series[index.series].type.indexOf('Bar') !== -1)) {
                        if (!(element.id.indexOf('_Symbol') !== -1) && getElement$1(element.id + '_Symbol')) {
                            pointElements.push(getElement$1(element.id + '_Symbol'));
                        }
                        else if (element.id.indexOf('_Symbol') !== -1 && getElement$1(element.id.replace('_Symbol', ''))) {
                            pointElements.push(getElement$1(element.id.replace('_Symbol', '')));
                        }
                    }
                    this.selection(chart, index, pointElements);
                    this.selectionComplete(chart, index, this.currentMode);
                    this.blurEffect(chart.element.id, chart.visibleSeries, false, index.point);
                }
                break;
            case 'Cluster':
                if (!isNaN(index.point)) {
                    this.clusterSelection(chart, index);
                    this.selectionComplete(chart, index, this.currentMode);
                    this.blurEffect(chart.element.id, chart.visibleSeries, false, index.point);
                }
                break;
        }
    };
    /**
     *  Method to get the selected data index
     *
     * @private
     */
    Selection.prototype.selectionComplete = function (chart, index, selectionMode) {
        var points;
        var pointIndex;
        var seriesIndex;
        var selectedPointValues = [];
        var yValue;
        var selectedPointX;
        if (selectionMode === 'Cluster') {
            for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
                var series = _a[_i];
                if (series.visible) {
                    for (var i = 0; i < this.selectedDataIndexes.length; i++) {
                        pointIndex = chart.isMultiSelect ? this.selectedDataIndexes[i].point : index.point;
                        seriesIndex = series.index;
                        points = series.points;
                        if (!isNaN(pointIndex) && (pointIndex < points.length)) {
                            yValue = (series.type !== 'RangeArea' || 'SplineRangeArea' || 'RangeStepArea') ? points[pointIndex].yValue :
                                points[pointIndex].regions[0].y;
                            selectedPointX = points[pointIndex].xValue;
                            if (chart.primaryXAxis.valueType === 'Category') {
                                selectedPointX = points[pointIndex].x.toLocaleString();
                            }
                            else if (chart.primaryXAxis.valueType === 'DateTime') {
                                selectedPointX = new Date(points[pointIndex].xValue);
                            }
                            if (series.category !== 'Indicator') {
                                selectedPointValues.push({
                                    x: selectedPointX, y: yValue, seriesIndex: seriesIndex,
                                    pointIndex: pointIndex
                                });
                            }
                            if (series.type === 'RangeArea' || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea') {
                                selectedPointValues.push({
                                    x: selectedPointX, y: points[pointIndex].regions[0].y,
                                    seriesIndex: seriesIndex, pointIndex: pointIndex
                                });
                            }
                        }
                    }
                }
            }
        }
        else if (selectionMode === 'Series') {
            if (chart.isMultiSelect) {
                for (var i = 0; i < this.selectedDataIndexes.length; i++) {
                    seriesIndex = this.selectedDataIndexes[i].series;
                    if (this.selectedDataIndexes.length > 0) {
                        selectedPointValues.push({
                            seriesIndex: seriesIndex
                        });
                    }
                }
            }
            else {
                seriesIndex = (this.selectedDataIndexes.length > 0) ? this.selectedDataIndexes[0].series : (this.highlightDataIndexes && this.highlightDataIndexes.length > 0) ? this.highlightDataIndexes[0].series : 0;
                if (this.selectedDataIndexes.length > 0 || (this.highlightDataIndexes && this.highlightDataIndexes.length > 0)) {
                    selectedPointValues.push({
                        seriesIndex: seriesIndex
                    });
                }
            }
        }
        else if (selectionMode === 'Point') {
            var selectedData = [];
            if (this.styleId.indexOf('highlight') > -1) {
                selectedData = this.highlightDataIndexes;
            }
            else {
                selectedData = this.selectedDataIndexes;
            }
            for (var i = 0; i < selectedData.length; i++) {
                pointIndex = selectedData[i].point;
                seriesIndex = selectedData[i].series;
                var series = chart.series[seriesIndex];
                points = series.points;
                if (!isNaN(pointIndex)) {
                    selectedPointX = points[pointIndex].xValue;
                    yValue = (series.type !== 'RangeArea' || 'SplineRangeArea' || 'RangeStepArea') ? points[pointIndex].yValue :
                        points[pointIndex].regions[0].y;
                    if (chart.primaryXAxis.valueType === 'Category') {
                        selectedPointX = points[pointIndex].x.toLocaleString();
                    }
                    else if (chart.primaryXAxis.valueType === 'DateTime') {
                        selectedPointX = new Date(points[pointIndex].xValue);
                    }
                    selectedPointValues.push({
                        x: selectedPointX, y: yValue, seriesIndex: seriesIndex,
                        pointIndex: pointIndex
                    });
                }
            }
        }
        var args = {
            name: selectionComplete,
            selectedDataValues: selectedPointValues,
            cancel: false,
            chart: chart
        };
        chart.trigger(selectionComplete, args);
    };
    /**
     *  Method to perform selection
     *
     * @private
     */
    Selection.prototype.selection = function (chart, index, selectedElements) {
        if (!(this.currentMode === 'Lasso')) {
            if (!chart.isMultiSelect && (this.currentMode.indexOf('Drag') === -1 && this.styleId.indexOf('highlight') === -1 &&
                chart.selectionMode !== 'None')) {
                this.removeMultiSelectElements(chart, this.selectedDataIndexes, index, chart.series);
            }
        }
        var indexValue = (this.rangeColorMappingEnabled()) ? 0 : index.series;
        if (!isNullOrUndefined(selectedElements[0])) {
            if (chart.visibleSeries[indexValue].isRectSeries) {
                if (selectedElements[0].id) {
                    if (document.getElementById(selectedElements[0].id + '_Symbol')) {
                        selectedElements.push(getElement$1(selectedElements[0].id + '_Symbol'));
                    }
                    else if (selectedElements[0].id.indexOf('SeriesGroup') !== -1) {
                        if (document.getElementById(selectedElements[0].id.replace('SeriesGroup', 'SymbolGroup'))) {
                            selectedElements.push(getElement$1(selectedElements[0].id.replace('SeriesGroup', 'SymbolGroup')));
                        }
                    }
                }
            }
            var isAdd = void 0;
            var className = selectedElements[0] && (selectedElements[0].getAttribute('class') || '');
            var pClassName = selectedElements[0].parentNode &&
                (selectedElements[0].parentNode.getAttribute('class') || '');
            if (className !== '' && this.currentMode !== 'Cluster') {
                this.findTrackballElements(selectedElements, className);
            }
            if (selectedElements[0] && className.indexOf(this.getSelectionClass(selectedElements[0].id)) > -1) {
                this.removeStyles(selectedElements);
            }
            else if (selectedElements[0].parentNode && pClassName.indexOf(this.getSelectionClass(selectedElements[0].id)) > -1) {
                this.removeStyles([selectedElements[0].parentNode]);
            }
            else {
                this.previousSelectedEle = (chart.highlightMode !== 'None' || chart.legendSettings.enableHighlight) ? selectedElements : [];
                this.applyStyles(selectedElements);
                isAdd = true;
            }
            if (this.styleId.indexOf('highlight') > 0 && (chart.highlightMode !== 'None' || chart.legendSettings.enableHighlight)) {
                this.addOrRemoveIndex(this.highlightDataIndexes, index, isAdd);
            }
            else {
                this.addOrRemoveIndex(this.selectedDataIndexes, index, isAdd);
            }
        }
    };
    /**
     *  Method to get the cluster selection element
     *
     * @private
     */
    Selection.prototype.clusterSelection = function (chart, index) {
        this.selection(chart, index, this.getClusterElements(chart, new Index(index.series, index.point)));
    };
    /**
     * Method to remove the multi selected elements
     *
     * @private
     */
    Selection.prototype.removeMultiSelectElements = function (chart, index, currentIndex, seriesCollection) {
        var series;
        for (var i = 0; i < index.length; i++) {
            series = seriesCollection[index[i].series];
            if ((this.isSeriesMode && !this.toEquals(index[i], currentIndex, this.isSeriesMode)) ||
                (this.currentMode === 'Cluster' && !this.toEquals(index[i], currentIndex, false)) ||
                (!this.isSeriesMode && this.toEquals(index[i], currentIndex, true) &&
                    !this.toEquals(index[i], currentIndex, false))) {
                this.removeStyles(this.findElements(chart, series, index[i], '', false));
                if (series.marker.visible) {
                    this.removeStyles(this.findElements(chart, series, index[i], '', true));
                }
                index.splice(i, 1);
                i--;
            }
        }
    };
    /**
     * Method to remove the selection
     *
     * @private
     */
    Selection.prototype.blurEffect = function (chartId, visibleSeries, isLegend, index) {
        if (isLegend === void 0) { isLegend = false; }
        if (index === void 0) { index = 0; }
        var visibility = (this.checkVisibility(this.highlightDataIndexes, this.chart) ||
            this.checkVisibility(this.selectedDataIndexes, this.chart)); // legend click scenario
        for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
            var series = visibleSeries_1[_i];
            var legendIndex = void 0;
            var legendStrokeColor = void 0;
            if (this.rangeColorMappingEnabled()) {
                if (isLegend === false) {
                    legendIndex = Object.keys(series.rangeColorPoints).indexOf(series.points[index].interior);
                    legendStrokeColor = series.points[index].interior;
                }
                else {
                    legendIndex = index;
                    legendStrokeColor = document.getElementById(chartId + '_chart_legend_shape_' + index).getAttribute('fill');
                }
            }
            else {
                legendIndex = series.index;
                legendStrokeColor = this.chart.visibleSeries[series.index].interior;
            }
            if (series.visible) {
                this.checkSelectionElements(getElement$1(chartId + 'SeriesGroup' + series.index), this.generateStyle(series), visibility, isLegend, legendIndex, legendStrokeColor);
                if (!isNullOrUndefined(getElement$1(chartId + 'SymbolGroup' + series.index))) {
                    this.checkSelectionElements(getElement$1(chartId + 'SymbolGroup' + series.index), this.generateStyle(series), visibility, isLegend, legendIndex, legendStrokeColor);
                }
            }
        }
    };
    /**
     * Method to add the add/remove class to element
     *
     * @private
     */
    Selection.prototype.checkSelectionElements = function (element, className, visibility, isLegend, series, legendStrokeColor) {
        if (isLegend === void 0) { isLegend = true; }
        if (series === void 0) { series = 0; }
        if (legendStrokeColor === void 0) { legendStrokeColor = '#D3D3D3'; }
        var children = (this.isSeriesMode ? element.childNodes || [element] : element.childNodes || element);
        if (this.chart.selectionMode !== 'None' && (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight)) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            children = (element.childNodes || element);
        }
        var elementClassName;
        var parentClassName;
        var legendShape;
        var selectElement = element;
        for (var i = 0; i < children.length; i++) {
            elementClassName = children[i].getAttribute('class') || '';
            parentClassName = children[i].parentNode.getAttribute('class') || '';
            if (this.chart.selectionMode !== 'None' && (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight)) {
                className = elementClassName.indexOf('selection') > 0 ||
                    elementClassName.indexOf('highlight') > 0 ? elementClassName : className;
                className = (parentClassName.indexOf('selection') > 0 ||
                    parentClassName.indexOf('highlight') > 0) ? parentClassName : className;
            }
            if (elementClassName.indexOf(className) === -1 &&
                parentClassName.indexOf(className) === -1 && visibility) {
                this.addSvgClass(children[i], this.unselected);
            }
            else {
                selectElement = children[i];
                this.removeSvgClass(children[i], this.unselected);
                this.removeSvgClass(children[i].parentNode, this.unselected);
            }
            if (children[i].id.indexOf('Trackball') > 0 && selectElement.classList[0] === className) {
                this.removeSvgClass(children[i], this.unselected);
                this.removeSvgClass(children[i].parentNode, this.unselected);
                this.addSvgClass(children[i], className);
            }
        }
        if (element.id.indexOf('Symbol') > -1) {
            if ((element.querySelectorAll('.' + className)[0]) && element.querySelectorAll('.' + className)[0].getAttribute('class')
                === className) {
                var symbolEle = getElement$1(this.control.element.id + '_Series_' + element.id[element.id.length - 1]);
                var seriesClassName = symbolEle && symbolEle.hasAttribute('class') ? symbolEle.getAttribute('class') : '';
                if (seriesClassName.indexOf(this.unselected) > -1) {
                    this.removeSvgClass(symbolEle, this.unselected);
                }
            }
        }
        if (this.control.legendModule && this.control.legendSettings.visible) {
            legendShape = getElement$1(this.control.element.id + '_chart_legend_shape_' + series);
            if (legendShape) {
                if (legendShape.hasAttribute('class')) {
                    this.removeSvgClass(legendShape, legendShape.getAttribute('class'));
                    if (!isNullOrUndefined(this.chart.highlightColor && this.chart.highlightColor !== '') && !this.chart.legendSettings.enableHighlight) {
                        legendShape.setAttribute('stroke', legendStrokeColor);
                        if (this.chart.highlightPattern === 'None') {
                            legendShape.setAttribute('fill', legendStrokeColor);
                        }
                    }
                }
                elementClassName = selectElement.getAttribute('class') || '';
                parentClassName = selectElement.parentNode.getAttribute('class') || '';
                if (elementClassName.indexOf(className) === -1 && parentClassName.indexOf(className) === -1 && visibility) {
                    this.addSvgClass(legendShape, (this.chart.highlightMode === 'None' && this.chart.legendSettings.enableHighlight) ? className : this.unselected);
                    this.removeSvgClass(legendShape, className);
                    if (this.chart.highlightColor !== '' && !isNullOrUndefined(this.chart.highlightColor)) {
                        legendShape.setAttribute('stroke', this.control.visibleSeries[series].interior);
                        if (this.chart.highlightPattern === 'None') {
                            legendShape.setAttribute('fill', this.control.visibleSeries[series].interior);
                        }
                    }
                }
                else {
                    this.removeSvgClass(legendShape, this.unselected);
                    if (!isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightColor !== '') {
                        legendShape.setAttribute('stroke', this.control.visibleSeries[series].interior);
                        if (this.chart.highlightPattern === 'None') {
                            legendShape.setAttribute('fill', this.control.visibleSeries[series].interior);
                        }
                    }
                    if ((elementClassName === '' && parentClassName === '') || elementClassName.trim() === 'EJ2-Trackball') {
                        this.removeSvgClass(legendShape, className);
                    }
                    else {
                        this.addSvgClass(legendShape, className);
                        if (className.indexOf('highlight') > 0 && this.chart.highlightColor !== '' && this.chart.highlightColor !== 'transparent' && !isNullOrUndefined(this.chart.highlightColor)) {
                            legendShape.setAttribute('stroke', this.chart.highlightColor);
                            if (this.styleId.indexOf('highlight') > 0 && this.chart.highlightPattern === 'None') {
                                legendShape.setAttribute('fill', this.chart.highlightColor);
                            }
                        }
                    }
                }
                var legendItemsId = void 0;
                if (this.rangeColorMappingEnabled()) {
                    for (var i = 0; i < this.chart.rangeColorSettings.length; i++) {
                        legendItemsId = document.getElementById(this.chart.element.id + '_chart_legend_shape_' + i);
                        if (legendShape !== legendItemsId) {
                            this.addSvgClass(legendItemsId, this.unselected);
                        }
                        else if (isLegend === true) {
                            this.addSvgClass(legendItemsId, className);
                        }
                        if (elementClassName.indexOf(className) === -1 && isLegend === false) {
                            this.removeSvgClass(legendItemsId, this.unselected);
                        }
                    }
                }
                if (isLegend && parentClassName.indexOf(className) > -1) {
                    this.addSvgClass(legendShape, className);
                }
            }
        }
    };
    /**
     *  Method to apply the styles
     *
     * @private
     */
    Selection.prototype.applyStyles = function (elements) {
        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
            var element = elements_1[_i];
            if (element) {
                this.removeSvgClass(element.parentNode, this.unselected);
                this.removeSvgClass(element, this.unselected);
                if (this.chart.series[0].pointColorMapping === 'fill' || this.rangeColorMappingEnabled()) {
                    var className = this.getSelectionClass(element.id);
                    var index = className.indexOf('highlight') > -1 ? parseInt(className.split(this.chart.element.id + '_ej2_chart_highlight_series_')[1], 10) : parseInt(className.split(this.chart.element.id + '_ej2_chart_selection_series_')[1], 10);
                    var patternName = this.styleId.indexOf('highlight') > 0 ? this.chart.highlightPattern : this.chart.selectionPattern;
                    var pattern = void 0;
                    if (className.indexOf('highlight') > -1 || className.indexOf('selection') > -1) {
                        pattern = document.getElementById(this.chart.element.id + '_' + patternName + '_' + 'Selection' + '_' + index);
                    }
                    if (element.id.indexOf('legend') === -1 && element.id.indexOf('Group') === -1 && pattern != null) {
                        for (var i = 1; i < pattern.children.length; i++) {
                            pattern.children[i].setAttribute('fill', element.getAttribute('fill'));
                            pattern.children[i].setAttribute('stroke', element.getAttribute('fill'));
                        }
                    }
                }
                this.addSvgClass(element, this.getSelectionClass(element.id));
                if (this.styleId.indexOf('highlight') > 0 && this.chart.highlightColor !== '' && !isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightPattern === 'None' && this.chart.highlightColor !== 'transparent') {
                    if (element.id.indexOf('Group') > 0) {
                        for (var i = 0; i < element.children.length; i++) {
                            element.children[i].setAttribute('fill', this.chart.highlightColor);
                        }
                    }
                    else {
                        element.setAttribute('fill', this.chart.highlightColor);
                    }
                }
            }
        }
    };
    /**
     *  Method to get the selection class
     *
     * @private
     */
    Selection.prototype.getSelectionClass = function (id) {
        return this.generateStyle(this.control.visibleSeries[this.indexFinder(id).series]);
    };
    /**
     *  Method to remove styles
     *
     * @private
     */
    Selection.prototype.removeStyles = function (elements) {
        for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {
            var element = elements_2[_i];
            if (element) {
                this.removeSvgClass(element, this.getSelectionClass(element.id));
                if (this.chart.highlightPattern === 'None' && this.chart.highlightColor !== '' && !isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightColor !== 'transparent') {
                    if (element.id.indexOf('Group') > 0) {
                        for (var i = 0; i < element.children.length; i++) {
                            element.children[i].setAttribute('fill', this.control.visibleSeries[this.indexFinder(element.id).series].interior);
                        }
                    }
                    else {
                        element.setAttribute('fill', this.control.visibleSeries[this.indexFinder(element.id).series].interior);
                    }
                }
            }
        }
    };
    /**
     *  Method to remove the selected data index
     *
     * @private
     */
    Selection.prototype.addOrRemoveIndex = function (indexes, index, isAdd) {
        for (var i = 0; i < indexes.length; i++) {
            if (this.toEquals(indexes[i], index, this.isSeriesMode)) {
                indexes.splice(i, 1);
                i--;
            }
        }
        if (isAdd) {
            indexes.push(index);
        }
    };
    /**
     *  Method to get the equal index
     *
     * @private
     */
    Selection.prototype.toEquals = function (first, second, checkSeriesOnly) {
        return ((first.series === second.series || (this.currentMode === 'Cluster' && !checkSeriesOnly))
            && (checkSeriesOnly || (first.point === second.point)));
    };
    /**
     * To redraw the selected points.
     *
     * @returns {void}
     * @private
     */
    Selection.prototype.redrawSelection = function (chart, oldMode, chartRedraw) {
        this.isSeriesMode = oldMode === 'Series';
        if (!isNullOrUndefined(oldMode)) {
            if (oldMode.indexOf('Drag') !== -1 || oldMode === 'Lasso' || chartRedraw) {
                chart.isRedrawSelection = false;
            }
            else {
                chart.isRedrawSelection = true;
            }
        }
        var selectedDataIndexes = extend([], this.selectedDataIndexes, null, true);
        var highlightDataIndexes = extend([], this.highlightDataIndexes, null, true);
        if (this.styleId.indexOf('highlight') > 0 && highlightDataIndexes.length > 0) {
            this.removeSelectedElements(chart, this.highlightDataIndexes, chart.series);
            selectedDataIndexes = highlightDataIndexes;
        }
        else {
            this.removeSelectedElements(chart, this.selectedDataIndexes, chart.series);
        }
        this.blurEffect(chart.element.id, chart.visibleSeries, false);
        this.selectDataIndex(chart, selectedDataIndexes);
    };
    /** @private */
    Selection.prototype.legendSelection = function (chart, series, targetElement, eventType) {
        if (eventType === 'mousemove') {
            if (targetElement.id.indexOf('text') > 1) {
                targetElement = getElement$1(targetElement.id.replace('text', 'shape'));
            }
            if (targetElement.id.indexOf('marker') > 1) {
                targetElement = getElement$1(targetElement.id.replace('_marker', ''));
            }
            if (targetElement.id.indexOf('g') > 1) {
                targetElement = getElement$1(targetElement.id.replace('_g_', '_shape_'));
            }
            if (targetElement.hasAttribute('class') && (targetElement.getAttribute('class').indexOf('highlight') > -1 ||
                targetElement.getAttribute('class').indexOf('selection') > -1)) {
                return;
            }
            this.currentMode = this.chart.highlightMode;
        }
        var isPreSelected = this.isAlreadySelected(targetElement, eventType);
        if (isPreSelected) {
            var seriesStyle = this.generateStyle(chart.visibleSeries[series]);
            var selectedElements = (document.querySelectorAll('.' + seriesStyle));
            this.isSeriesMode = this.currentMode === 'Series';
            var isBlurEffectNeeded = true;
            if (selectedElements.length > 0) {
                this.removeSelection(chart, series, selectedElements, seriesStyle, isBlurEffectNeeded);
            }
            else {
                for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
                    var element = _a[_i];
                    if (element.index !== series && !chart.isMultiSelect) {
                        seriesStyle = this.generateStyle(chart.visibleSeries[element.index]);
                        selectedElements = document.querySelectorAll('.' + seriesStyle);
                        this.removeSelection(chart, series, selectedElements, seriesStyle, isBlurEffectNeeded);
                    }
                }
                var seriesElements = [];
                if (this.rangeColorMappingEnabled()) {
                    // eslint-disable-next-line @typescript-eslint/tslint/config
                    for (var i = 0, a = chart.visibleSeries[0].seriesElement.children; i < a.length; i++) {
                        var point = a[i];
                        if (targetElement.getAttribute('fill') === point.getAttribute('fill')) {
                            seriesElements.push(point);
                        }
                    }
                    for (var _b = 0, seriesElements_1 = seriesElements; _b < seriesElements_1.length; _b++) {
                        var element = seriesElements_1[_b];
                        if (isNullOrUndefined(element)) {
                            return;
                        }
                        this.checkSelectionElements(element, seriesStyle, false, true, series);
                    }
                }
                else {
                    seriesElements = this.getSeriesElements(chart.visibleSeries[series]);
                    for (var _c = 0, seriesElements_2 = seriesElements; _c < seriesElements_2.length; _c++) {
                        var seriesElement = seriesElements_2[_c];
                        if (isNullOrUndefined(seriesElement)) {
                            return;
                        }
                        this.checkSelectionElements(seriesElement, seriesStyle, false, true, series);
                    }
                }
                this.isSeriesMode = true;
                this.selection(chart, new Index(series, NaN), seriesElements);
                this.isSeriesMode = chart.selectionMode === 'Series';
                this.blurEffect(chart.element.id, chart.visibleSeries, true, series);
            }
        }
    };
    /** @private */
    Selection.prototype.rangeColorMappingEnabled = function () {
        if ((this.chart.rangeColorSettings && this.chart.rangeColorSettings.length > 0 && this.chart.visibleSeries.length === 1 &&
            this.chart.rangeColorSettings[0].colors.length > 0 &&
            (this.chart.series[0].type === 'Column' || this.chart.series[0].type === 'Bar' ||
                this.chart.series[0].type === 'Scatter' || this.chart.series[0].type === 'Bubble'))) {
            return true;
        }
        else {
            return false;
        }
    };
    Selection.prototype.removeSelection = function (chart, series, selectedElements, seriesStyle, isBlurEffectNeeded) {
        if (selectedElements.length > 0) {
            var elements = [];
            for (var i = 0; i < selectedElements.length; i++) {
                elements.push(selectedElements[i]);
            }
            this.removeStyles(elements);
            this.isSeriesMode = true;
            this.addOrRemoveIndex(this.selectedDataIndexes, new Index(series, NaN));
            for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
                var value = _a[_i];
                seriesStyle = this.generateStyle(value);
                if (document.querySelectorAll('.' + seriesStyle).length > 0) {
                    for (var _b = 0, elements_3 = elements; _b < elements_3.length; _b++) {
                        var element = elements_3[_b];
                        this.checkSelectionElements(element, seriesStyle, true, true, series);
                    }
                    isBlurEffectNeeded = false;
                    break;
                }
            }
            if (isBlurEffectNeeded) {
                this.isSeriesMode = chart.selectionMode === 'Series';
                this.blurEffect(chart.element.id, chart.visibleSeries);
            }
        }
    };
    /** @private */
    Selection.prototype.getSeriesElements = function (series) {
        var seriesElements = [series.seriesElement];
        if (series.marker.visible && series.type !== 'Scatter' && series.type !== 'Bubble' && !series.isRectSeries) {
            seriesElements.push(series.symbolElement);
        }
        else if (series.marker.visible && series.isRectSeries) {
            seriesElements.push(series.symbolElement);
        }
        return seriesElements;
    };
    /** @private */
    Selection.prototype.indexFinder = function (id) {
        var ids = ['NaN', 'NaN'];
        if (id.indexOf('SeriesGroup') > -1) {
            ids = id.split('SeriesGroup');
            ids[0] = ids[1];
        }
        else if (id.indexOf('SymbolGroup') > -1) {
            ids = id.split('SymbolGroup');
            ids[0] = ids[1];
        }
        else if (id.indexOf('_Point_') > -1) {
            ids = id.split('_Series_')[1].split('_Point_');
        }
        else if (id.indexOf('_border_') > -1) {
            ids[0] = id.split('_border_')[1];
        }
        else if (id.indexOf('_Series_') > -1) {
            ids[0] = id.split('_Series_')[1];
        }
        else if (id.indexOf('_chart_legend_shape_') > -1) {
            ids = id.split('_chart_legend_shape_');
            ids[0] = ids[1];
        }
        return new Index(parseInt(ids[0], 10), parseInt(ids[1], 10));
    };
    /**
     * Drag selection that returns the selected data.
     *
     * @returns {void}
     * @private
     */
    Selection.prototype.calculateDragSelectedElements = function (chart, dragRect, isClose) {
        this.removeSelectedElements(chart, this.selectedDataIndexes, chart.series);
        var isLasso = chart.selectionMode === 'Lasso';
        var rect = new Rect(dragRect.x, dragRect.y, dragRect.width, dragRect.height);
        var axisOffset = new ChartLocation(chart.chartAxisLayoutPanel.seriesClipRect.x, chart.chartAxisLayoutPanel.seriesClipRect.y);
        this.removeOffset(rect, axisOffset);
        var points;
        var index;
        var selectedPointValues = [];
        var selectedSeriesValues = [];
        this.isSeriesMode = false;
        var isDragResize = (chart.allowMultiSelection) && (this.rectGrabbing || this.resizing);
        this.rectPoints = this.dragRectArray[isDragResize ? this.targetIndex : this.count] =
            new Rect(dragRect.x, dragRect.y, dragRect.width, dragRect.height);
        if (dragRect.width && dragRect.height && !isClose) {
            var rt = new Rect(dragRect.x, dragRect.y, dragRect.width, dragRect.height);
            this.removeOffset(rt, axisOffset);
            this.filterArray[isDragResize ? this.targetIndex : this.count] = rt;
        }
        var _loop_1 = function (series) {
            if (series.visible) {
                points = series.points;
                selectedPointValues = [];
                var xAxisOffset_1;
                var yAxisOffset_1;
                if ((chart.isTransposed || series.type.indexOf('Bar') !== -1) &&
                    !(chart.isTransposed && series.type.indexOf('Bar') !== -1)) {
                    xAxisOffset_1 = series.xAxis.rect.y - axisOffset.y;
                    yAxisOffset_1 = series.yAxis.rect.x - axisOffset.x;
                }
                else {
                    xAxisOffset_1 = series.xAxis.rect.x - axisOffset.x;
                    yAxisOffset_1 = series.yAxis.rect.y - axisOffset.y;
                }
                for (var j = 0; j < points.length; j++) {
                    var yValue = (series.type !== 'RangeArea' || 'SplineRangeArea' || 'RangeStepArea') ? points[j].yValue :
                        points[j].regions[0].y;
                    var isCurrentPoint = void 0;
                    var selectedPointX = points[j].xValue;
                    if (chart.primaryXAxis.valueType === 'Category') {
                        selectedPointX = points[j].x.toLocaleString();
                    }
                    else if (chart.primaryXAxis.valueType === 'DateTime') {
                        selectedPointX = new Date(points[j].xValue);
                    }
                    if (series.type === 'BoxAndWhisker') {
                        isCurrentPoint = points[j].regions.some(function (region) {
                            return withInBounds(region.x + xAxisOffset_1, region.y + yAxisOffset_1, rect);
                        });
                    }
                    else {
                        if (chart.selectionMode === 'Lasso') {
                            isCurrentPoint = points[j].isSelect;
                        }
                        else {
                            isCurrentPoint = (chart.allowMultiSelection) ?
                                this_1.isPointSelect(points[j], xAxisOffset_1, yAxisOffset_1, this_1.filterArray) :
                                points[j].symbolLocations.some(function (location) {
                                    return location && withInBounds(location.x + xAxisOffset_1, location.y + yAxisOffset_1, rect);
                                });
                        }
                    }
                    if (isCurrentPoint && series.category !== 'Indicator') {
                        index = new Index(series.index, points[j].index);
                        this_1.selection(chart, index, this_1.findElements(chart, series, index, '', !series.isRectSeries ? series.marker.visible : false));
                        selectedPointValues.push({ x: selectedPointX, y: yValue });
                    }
                    if (isCurrentPoint && (series.type === 'RangeArea' || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea')) {
                        selectedPointValues.push({ x: selectedPointX, y: points[j].regions[0].y });
                    }
                }
                selectedSeriesValues.push(selectedPointValues);
            }
        };
        var this_1 = this;
        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            _loop_1(series);
        }
        this.blurEffect(chart.element.id, chart.visibleSeries);
        var x = isLasso ? chart.mouseDownX : (dragRect.x + dragRect.width);
        var y = isLasso ? chart.mouseDownY : dragRect.y;
        if (!isClose) {
            this.createCloseButton(x, y);
        }
        var args = {
            name: dragComplete,
            selectedDataValues: selectedSeriesValues,
            cancel: false
        };
        chart.trigger(dragComplete, args);
    };
    Selection.prototype.removeOffset = function (rect, clip) {
        rect.x -= clip.x;
        rect.y -= clip.y;
    };
    Selection.prototype.isPointSelect = function (points, xAxisOffset, yAxisOffset, rectCollection) {
        var location = points.symbolLocations[0];
        for (var _i = 0, rectCollection_1 = rectCollection; _i < rectCollection_1.length; _i++) {
            var rect = rectCollection_1[_i];
            if (rect && location && withInBounds(location.x + xAxisOffset, location.y + yAxisOffset, rect)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Method to draw dragging rect.
     *
     * @returns {void}
     * @private
     */
    Selection.prototype.drawDraggingRect = function (chart, dragRect) {
        var cartesianLayout = chart.chartAxisLayoutPanel.seriesClipRect;
        var border = chart.chartArea.border.width;
        var rectFill = chart.themeStyle.selectionRectFill;
        var rectStroke = chart.themeStyle.selectionRectStroke;
        var isLasso = chart.selectionMode === 'Lasso';
        if (this.isdrawRect) {
            cartesianLayout.x = cartesianLayout.x - border / 2;
            cartesianLayout.y = cartesianLayout.y - border / 2;
            cartesianLayout.width = cartesianLayout.width + border;
            cartesianLayout.height = cartesianLayout.height + border;
            this.isdrawRect = false;
        }
        switch (chart.selectionMode) {
            case 'DragX':
                dragRect.y = cartesianLayout.y;
                dragRect.height = cartesianLayout.height;
                break;
            case 'DragY':
                dragRect.x = cartesianLayout.x;
                dragRect.width = cartesianLayout.width;
                break;
        }
        if ((dragRect.width < 5 || dragRect.height < 5) && !isLasso) {
            return null;
        }
        var isDragMode = chart.selectionMode.indexOf('Drag') > -1 || chart.selectionMode === 'Lasso';
        if ((chart.allowMultiSelection) && isDragMode) {
            var element = void 0;
            var dragGroup = void 0;
            var multiGroup = getElement$1(this.multiRectGroup);
            if (!multiGroup) {
                multiGroup = chart.svgRenderer.createGroup({ id: this.multiRectGroup });
                chart.svgObject.appendChild(multiGroup);
            }
            if (this.rectGrabbing || this.resizing) {
                var rectElement = getElement$1(this.draggedRect + this.targetIndex);
                if (rectElement.nextSibling) {
                    remove(rectElement.nextSibling);
                }
                this.setAttributes(rectElement, dragRect);
            }
            else if (!getElement$1(this.draggedRectGroup + this.count)) {
                dragGroup = chart.svgRenderer.createGroup({ id: this.draggedRectGroup + this.count });
                var svgElement = document.getElementById(chart.element.id + '_series_svg');
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                chart.enableCanvas ? svgElement.appendChild(dragGroup) : multiGroup.appendChild(dragGroup);
            }
            if (!(chart.selectionMode === 'Lasso')) {
                element = chart.svgRenderer.drawRectangle(new RectOption(this.draggedRect + this.count, rectFill, { color: rectStroke, width: 1 }, 1, dragRect));
                element.style.cursor = 'move';
            }
            else {
                element = chart.svgRenderer.drawPath(new PathOption(this.lassoPath + this.count, rectFill, 3, rectStroke, 1, '', this.path));
            }
            if (!dragGroup && !this.rectGrabbing && !this.resizing) {
                getElement$1(this.draggedRectGroup + this.count).appendChild(element);
            }
            else if (!this.rectGrabbing && !this.resizing) {
                dragGroup.appendChild(element);
            }
        }
        else {
            var element = isLasso ?
                getElement$1(this.lassoPath) : getElement$1(this.draggedRect);
            if (this.closeIcon) {
                removeElement$1(this.closeIconId);
            }
            if (element) {
                if (isLasso) {
                    element.setAttribute('d', this.path);
                }
                else {
                    this.setAttributes(element, dragRect);
                }
            }
            else {
                var dragGroup = chart.svgRenderer.createGroup({ id: this.draggedRectGroup });
                var svgElement = document.getElementById(chart.element.id + '_series_svg');
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                chart.enableCanvas ? svgElement.appendChild(dragGroup) : chart.svgObject.appendChild(dragGroup);
                if (!(chart.selectionMode === 'Lasso')) {
                    element = chart.svgRenderer.drawRectangle(new RectOption(this.draggedRect, rectFill, { color: rectStroke, width: 1 }, 1, dragRect));
                }
                else {
                    element = chart.svgRenderer.drawPath(new PathOption(this.lassoPath, rectFill, 3, rectStroke, 1, '', this.path));
                }
                //element.setAttribute('style', 'cursor:move;');
                dragGroup.appendChild(element);
            }
        }
    };
    /**
     * To get drag selected group element index from its id
     *
     * @param {string} id element id
     */
    Selection.prototype.getIndex = function (id) {
        var i;
        for (i = id.length - 1; i > 0; i--) {
            var x = Number(id[i]);
            if (!isNaN(x)) {
                continue;
            }
            else {
                break;
            }
        }
        var index = +id.substr(i + 1, id.length - 1);
        return index;
    };
    Selection.prototype.createCloseButton = function (x, y) {
        var isMultiDrag = this.chart.allowMultiSelection;
        var circleStroke = this.chart.themeStyle.selectionCircleStroke;
        var isDrag = this.rectGrabbing || this.resizing;
        var closeIcon = this.chart.svgRenderer.createGroup({
            id: this.closeIconId + (isMultiDrag ? (isDrag ? this.targetIndex : this.count) : ''),
            style: 'cursor:pointer; visibility: visible;'
        });
        closeIcon.appendChild(this.chart.svgRenderer.drawCircle(new CircleOption(this.closeIconId + '_circle' + (isMultiDrag ? (isDrag ? this.targetIndex : this.count) : ''), '#FFFFFF', { color: circleStroke, width: 1 }, 1, x, y, 10)));
        var direction = 'M ' + (x - 4) + ' ' + (y - 4) + ' L ' + (x + 4) + ' ' + (y + 4) + ' M ' + (x - 4) + ' ' + (y + 4) +
            ' L ' + (x + 4) + ' ' + (y - 4);
        closeIcon.appendChild(this.chart.svgRenderer.drawPath({
            id: this.closeIconId + '_cross' +
                (isMultiDrag ? (isDrag ? this.targetIndex : this.count) : ''), d: direction,
            stroke: circleStroke, 'stroke-width': 2, fill: circleStroke
        }));
        this.closeIcon = closeIcon;
        var pathElement = getElement$1(this.draggedRectGroup + (isMultiDrag ? (isDrag ? this.targetIndex : this.count) : ''));
        if (pathElement) {
            pathElement.appendChild(closeIcon);
        }
    };
    /**
     * Method to remove dragged element.
     *
     * @returns {void}
     * @private
     */
    Selection.prototype.removeDraggedElements = function (chart, targetElement, eventType) {
        if ((targetElement.id && targetElement.id.indexOf(this.closeIconId) > -1) && (eventType.indexOf('move') === -1)) {
            var isSelectedvalues = true;
            if ((chart.allowMultiSelection)) {
                var index = this.getIndex(targetElement.id);
                var multiRectGroupElement = getElement$1(this.multiRectGroup);
                remove(getElement$1(this.draggedRectGroup + index));
                this.dragRectArray[index] = null;
                this.filterArray[index] = null;
                this.totalSelectedPoints[index] = null;
                if (multiRectGroupElement && multiRectGroupElement.childElementCount === 0) {
                    removeElement$1(multiRectGroupElement);
                    this.dragRectArray = [];
                    this.filterArray = [];
                    this.totalSelectedPoints = [];
                }
                if (this.currentMode === 'Lasso') {
                    if (this.multiDataIndexes[index] != null) {
                        for (var i = 0; i < this.multiDataIndexes[index].length; i++) {
                            this.multiDataIndexes[index][i].isSelect = false;
                        }
                    }
                    this.multiDataIndexes[index] = null;
                    for (var j = 0; j < this.multiDataIndexes.length; j++) {
                        if (this.multiDataIndexes[j] != null) {
                            isSelectedvalues = false;
                            for (var k = 0; k < this.multiDataIndexes[j].length; k++) {
                                this.multiDataIndexes[j][k].isSelect = true;
                            }
                        }
                    }
                    this.calculateDragSelectedElements(chart, this.dragRect, true);
                }
                else if (this.filterArray.length) {
                    for (var i = 0; i < this.filterArray.length; i++) {
                        if (this.filterArray[i]) {
                            isSelectedvalues = false;
                            this.calculateDragSelectedElements(chart, this.filterArray[i], true);
                        }
                    }
                }
                else {
                    this.calculateDragSelectedElements(chart, new Rect(0, 0, 0, 0), true);
                }
            }
            else {
                remove(getElement$1(this.draggedRectGroup));
                this.removeSelectedElements(chart, this.selectedDataIndexes, chart.series);
            }
            this.blurEffect(chart.element.id, chart.visibleSeries);
            this.changeCursorStyle(false, chart.svgObject, 'auto');
            if (!(chart.allowMultiSelection) || isSelectedvalues) {
                this.rectPoints = null;
            }
        }
    };
    /**
     * Method to resize the drag rect.
     *
     * @returns {void}
     * @private
     */
    Selection.prototype.resizingSelectionRect = function (chart, location, tapped, target) {
        var rect;
        if (((chart.allowMultiSelection) && (target.id.indexOf('_ej2_drag_rect') > -1)) ||
            this.dragRectArray[this.targetIndex]) {
            if (target.id.indexOf('_ej2_drag_rect') > -1) {
                this.targetIndex = this.getIndex(target.id);
            }
            var r = this.dragRectArray[this.targetIndex];
            rect = new Rect(r.x, r.y, r.width, r.height);
        }
        if (!(chart.allowMultiSelection)) {
            rect = new Rect(this.rectPoints.x, this.rectPoints.y, this.rectPoints.width, this.rectPoints.height);
        }
        if (rect) {
            var resize = this.findResizeMode(chart.svgObject, rect, location);
            if (this.resizing) {
                rect = getDraggedRectLocation(rect.x, rect.y, (rect.x + rect.width), (rect.y + rect.height), chart.chartAxisLayoutPanel.seriesClipRect);
                this.drawDraggingRect(chart, rect);
                this.dragRect = rect;
            }
            if (tapped) {
                this.resizing = resize;
            }
        }
        else {
            return;
        }
    };
    Selection.prototype.findResizeMode = function (chartSvgObject, rect, location) {
        var cursorStyle = 'se-resize';
        var resize = false;
        if (!this.resizing) {
            var resizeEdges = [new Rect(rect.x, (rect.y), rect.width - 5, 5),
                new Rect((rect.x), rect.y, 5, rect.height),
                new Rect(rect.x, (rect.y + rect.height - 5), rect.width - 5, 5),
                new Rect((rect.x + rect.width - 5), rect.y + 5, 5, rect.height - 15),
                new Rect((rect.x + rect.width - 10), (rect.y + rect.height - 10), 10, 10)]; //corner
            for (var i = 0; i < resizeEdges.length; i++) {
                if (withInBounds(location.x, location.y, resizeEdges[i])) {
                    cursorStyle = (i === 4) ? cursorStyle : (i % 2 === 0) ? 'ns-resize' : 'ew-resize';
                    resize = true;
                    this.resizeMode = i;
                    break;
                }
            }
        }
        else {
            var x = rect.x;
            var y = rect.y;
            var width = (location.x - x);
            var height = (location.y - y);
            switch (this.resizeMode) {
                case 0:
                    height = Math.abs((rect.height + rect.y) - location.y);
                    rect.y = Math.min((rect.height + rect.y), location.y);
                    rect.height = height;
                    break;
                case 1:
                    width = Math.abs((rect.width + rect.x) - location.x);
                    rect.x = Math.min((rect.width + rect.x), location.x);
                    rect.width = width;
                    break;
                case 2:
                    rect.height = Math.abs(height);
                    rect.y = Math.min(location.y, y);
                    break;
                case 3:
                    rect.width = Math.abs(width);
                    rect.x = Math.min(location.x, x);
                    break;
                case 4:
                    rect.width = Math.abs(width);
                    rect.height = Math.abs(height);
                    rect.x = Math.min(location.x, x);
                    rect.y = Math.min(location.y, y);
                    break;
            }
        }
        if (this.currentMode !== 'Lasso') {
            this.changeCursorStyle(resize, getElement$1((this.chart.allowMultiSelection) ? this.draggedRect +
                this.targetIndex : this.draggedRect), cursorStyle);
        }
        this.changeCursorStyle(resize, chartSvgObject, cursorStyle);
        return resize;
    };
    Selection.prototype.changeCursorStyle = function (isResize, rectelement, cursorStyle) {
        cursorStyle = isResize ? cursorStyle : (this.control.svgObject === rectelement) ? 'auto' : 'move';
        if (rectelement) {
            rectelement.style.cursor = cursorStyle;
        }
    };
    Selection.prototype.removeSelectedElements = function (chart, index, seriesCollection) {
        index = chart.isRedrawSelection ? index : index.splice(0, index.length); // No need to remove selected indexes while redrawing
        var seriesElements;
        for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {
            var series = seriesCollection_1[_i];
            if (series.visible) {
                seriesElements = this.getSeriesElements(series);
                this.removeStyles(seriesElements);
                for (var _a = 0, seriesElements_3 = seriesElements; _a < seriesElements_3.length; _a++) {
                    var seriesElement = seriesElements_3[_a];
                    this.removeStyles(this.getChildren(seriesElement));
                }
            }
        }
    };
    Selection.prototype.setAttributes = function (ele, object) {
        var keys = Object.keys(object);
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            ele.setAttribute(key, object[key]);
        }
    };
    /**
     * Method to move the dragged rect.
     *
     * @returns {void}
     * @private
     */
    Selection.prototype.draggedRectMoved = function (chart, grabbedPoint, doDrawing, target) {
        var rect;
        if ((this.resizing || this.rectGrabbing) && (chart.allowMultiSelection)) {
            var r = this.dragRectArray[this.targetIndex];
            rect = new Rect(r.x, r.y, r.width, r.height);
        }
        else {
            rect = new Rect(this.rectPoints.x, this.rectPoints.y, this.rectPoints.width, this.rectPoints.height);
        }
        rect.x -= (grabbedPoint.x - chart.mouseX);
        rect.y -= (grabbedPoint.y - chart.mouseY);
        rect = getDraggedRectLocation(rect.x, rect.y, rect.x + rect.width, rect.height + rect.y, chart.chartAxisLayoutPanel.seriesClipRect);
        if (doDrawing) {
            this.drawDraggingRect(chart, rect);
        }
        else {
            this.calculateDragSelectedElements(chart, rect);
        }
    };
    Selection.prototype.mouseLeave = function (event) {
        this.completeSelection(event.target, event.type);
    };
    /**
     * To complete the selection.
     *
     * @returns {void}
     * @private
     */
    Selection.prototype.completeSelection = function (target, eventType) {
        var chart = this.chart;
        if (chart.selectionMode === 'None') {
            return;
        }
        this.currentMode = chart.selectionMode;
        if ((this.dragging || this.resizing) && this.dragRect.width > 5 && this.dragRect.height > 5) {
            this.calculateDragSelectedElements(chart, this.dragRect);
        }
        else if (!(chart.allowMultiSelection) && this.rectGrabbing &&
            this.rectPoints.width && this.rectPoints.height) {
            this.draggedRectMoved(chart, this.dragRect);
        }
        else if (this.rectGrabbing && this.dragRectArray[this.targetIndex].width && this.dragRectArray[this.targetIndex].height) {
            this.draggedRectMoved(chart, this.dragRect);
        }
        if (chart.selectionMode === 'Lasso' && this.dragging && this.path) {
            if (this.path.indexOf('L') !== -1) {
                if (!(chart.allowMultiSelection)) {
                    getElement$1(this.lassoPath).setAttribute('d', this.path + 'Z');
                    this.pointChecking(getElement$1(this.lassoPath));
                }
                else if (getElement$1(this.lassoPath + this.count)) {
                    getElement$1(this.lassoPath + this.count).setAttribute('d', this.path + 'Z');
                    this.pointChecking(getElement$1(this.lassoPath + this.count));
                }
                if (this.dragging || this.resizing) {
                    this.calculateDragSelectedElements(chart, this.dragRect);
                }
            }
        }
        this.dragging = false;
        this.rectGrabbing = false;
        this.resizing = false;
        this.removeDraggedElements(chart, target, eventType);
    };
    Selection.prototype.getDragRect = function (chart, seriesClipRect) {
        return getDraggedRectLocation(chart.mouseDownX, chart.mouseDownY, chart.mouseX, chart.mouseY, seriesClipRect);
    };
    /** @private */
    Selection.prototype.dragStart = function (chart, seriesClipRect, mouseDownX, mouseDownY, event) {
        var mode = chart.selectionMode;
        this.currentMode = chart.selectionMode;
        this.dragging = (mode.indexOf('Drag') > -1 || mode === 'Lasso') && (chart.isDoubleTap || !chart.isTouch) &&
            chart.chartAreaType !== 'PolarRadar';
        var target = event.target;
        this.path = undefined;
        if (this.dragging) {
            this.count = getElement$1(this.multiRectGroup) ? (this.count + 1) : 0;
            this.dragRect = new Rect(chart.mouseDownX, chart.mouseDownY, 0, 0);
            if (chart.mouseDownX < seriesClipRect.x || chart.mouseDownX > (seriesClipRect.x + seriesClipRect.width) ||
                chart.mouseDownY < seriesClipRect.y || chart.mouseDownY > (seriesClipRect.y + seriesClipRect.height)) {
                this.dragging = false;
            }
        }
        if (mode === 'Lasso') {
            for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
                var series = _a[_i];
                if (series.visible) {
                    for (var _b = 0, _c = series.points; _b < _c.length; _b++) {
                        var point = _c[_b];
                        if (!(chart.allowMultiSelection)) {
                            point.isSelect = false;
                        }
                    }
                }
            }
        }
        if (!(mode === 'Lasso')) {
            if (this.rectPoints && !(chart.allowMultiSelection)) {
                this.dragRect = new Rect(chart.mouseDownX, chart.mouseDownY, 0, 0);
                this.resizingSelectionRect(chart, new ChartLocation(mouseDownX, mouseDownY), true);
                this.rectGrabbing = withInBounds(mouseDownX, mouseDownY, this.rectPoints);
            }
            if ((chart.allowMultiSelection)) {
                var index = this.getIndex(target.id);
                this.targetIndex = this.isDragRect(target.id) ? index : undefined;
                if (this.dragRectArray.length && this.isDragRect(target.id)) {
                    this.resizingSelectionRect(chart, new ChartLocation(mouseDownX, mouseDownY), true, target);
                    this.rectGrabbing = withInBounds(mouseDownX, mouseDownY, this.dragRectArray[index]);
                }
            }
        }
    };
    Selection.prototype.isDragRect = function (id) {
        return id.indexOf('_ej2_drag_rect') > -1;
    };
    /** @private */
    Selection.prototype.mouseMove = function (event) {
        var chart = this.chart;
        var target = event.target;
        var eventType = event.type;
        this.highlightChart(target, eventType);
        if (chart.selectionMode === 'None') {
            return;
        }
        if (eventType === 'touchmove' && (Browser.isIos || Browser.isIos7) && this.dragging && event.preventDefault) {
            event.preventDefault();
        }
        this.selectionAndDrag(chart, target, eventType);
    };
    /**
     * highlight parts
     *
     * @private
     */
    Selection.prototype.highlightChart = function (target, eventType) {
        if (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight) {
            if (!isNullOrUndefined(target)) {
                if (target.id.indexOf('_legend_text') > 1) {
                    target = getElement$1(target.id.replace('text', 'shape'));
                }
                if ((target).hasAttribute('class') && ((target).getAttribute('class').indexOf('highlight') > -1 ||
                    target.getAttribute('class').indexOf('selection') > -1)) {
                    return;
                }
                this.calculateSelectedElements(target, eventType);
                if (this.chart.highlightModule.highlightDataIndexes && this.chart.highlightModule.highlightDataIndexes.length > 0 &&
                    target.id.indexOf('_chart_legend_') === -1 && target.id.indexOf('_Series_') === -1) {
                    this.removeLegendHighlightStyles();
                }
            }
            return;
        }
    };
    /**
     * selection and drag selection
     *
     * @private
     */
    Selection.prototype.selectionAndDrag = function (chart, target, eventType) {
        var insideMoving = withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect);
        if (insideMoving) {
            if (this.rectGrabbing && !this.resizing) {
                this.draggedRectMoved(chart, this.dragRect, true, target);
            }
            else if (this.dragging && !this.resizing) {
                if (chart.selectionMode === 'Lasso') {
                    this.getPath(chart.mouseDownX, chart.mouseDownY, chart.mouseX, chart.mouseY);
                    this.drawDraggingRect(chart, this.dragRect);
                }
                else {
                    this.dragRect = this.getDragRect(chart, chart.chartAxisLayoutPanel.seriesClipRect);
                    this.drawDraggingRect(chart, this.dragRect);
                }
            }
            if (this.rectPoints && !(chart.allowMultiSelection)) {
                this.resizingSelectionRect(chart, new ChartLocation(chart.mouseX, chart.mouseY), null, target);
            }
            else if (((chart.allowMultiSelection) && !this.dragging) || this.resizing) {
                this.resizingSelectionRect(chart, new ChartLocation(chart.mouseX, chart.mouseY), null, target);
            }
        }
        else {
            this.completeSelection(target, eventType);
        }
    };
    /**
     * remove highlighted legend when not focused.
     *
     * @private
     */
    Selection.prototype.removeLegendHighlightStyles = function () {
        this.chart.highlightModule.highlightDataIndexes = [];
        var elementCollection;
        for (var i = 0; i < this.chart.visibleSeries.length; i++) {
            elementCollection = document.getElementsByClassName(this.generateStyle(this.chart.visibleSeries[i]));
            if (this.selectedDataIndexes.length === 0) {
                elementCollection = document.getElementsByClassName(this.generateStyle(this.chart.visibleSeries[i]));
                while (elementCollection.length > 0) {
                    var element = elementCollection[0];
                    if (element) {
                        this.removeSvgClass(element, element.getAttribute('class'));
                    }
                }
                elementCollection = document.getElementsByClassName(this.unselected);
                while (elementCollection.length > 0) {
                    var element = elementCollection[0];
                    if (element) {
                        this.removeSvgClass(element, element.getAttribute('class'));
                    }
                }
            }
            else {
                elementCollection = document.getElementsByClassName(this.generateStyle(this.chart.visibleSeries[i]));
                while (elementCollection.length > 0) {
                    var element = elementCollection[0];
                    if (element) {
                        this.removeSvgClass(element, element.getAttribute('class'));
                        this.addSvgClass(element, this.unselected);
                    }
                }
            }
        }
    };
    Selection.prototype.getPath = function (startX, startY, endX, endY) {
        if (this.dragging) {
            if (this.path) {
                this.path = this.path + ' L' + endX + ' ' + endY;
            }
            else {
                this.path = 'M ' + startX + ' ' + startY;
            }
        }
    };
    Selection.prototype.pointChecking = function (path) {
        var _this = this;
        var chart = this.chart;
        var element;
        var svgRect = getElement$1(chart.svgId).getBoundingClientRect();
        var offsetX = chart.chartAxisLayoutPanel.seriesClipRect.x + Math.max(svgRect.left, 0);
        var offsetY = chart.chartAxisLayoutPanel.seriesClipRect.y + Math.max(svgRect.top, 0);
        this.multiDataIndexes[this.count] = [];
        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            series.points.filter(function (point) {
                // To check whether the point have symbol location value or not.
                if (point.symbolLocations && point.symbolLocations.length) {
                    element = document.elementFromPoint(point.symbolLocations[0].x + offsetX, point.symbolLocations[0].y + offsetY);
                }
                if (element === path) {
                    point.isSelect = true;
                    if ((_this.chart.allowMultiSelection) && _this.currentMode === 'Lasso') {
                        _this.multiDataIndexes[_this.count][_this.seriesIndex] = point;
                        _this.seriesIndex++;
                    }
                }
                else if (!(chart.allowMultiSelection)) {
                    point.isSelect = false;
                }
            });
        }
        this.seriesIndex = 0;
    };
    /**
     * Get module name.
     *
     * @private
     */
    Selection.prototype.getModuleName = function () {
        return 'Selection';
    };
    /**
     * To destroy the selection.
     *
     * @returns {void}
     * @private
     */
    Selection.prototype.destroy = function () {
        this.removeEventListener();
        // Destroy method performed here
    };
    return Selection;
}(BaseSelection));

/**
 * `DataEditing` module handles data editing.
 */
var DataEditing = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for DataEditing module.
     *
     * @private
     */
    function DataEditing(chart) {
        /**
         * It is used to identify point is dragging for data editing in other modules.
         *
         * @private
         */
        this.isPointDragging = false;
        this.chart = chart;
    }
    /**
     * Point drag start here.
     */
    DataEditing.prototype.pointMouseDown = function () {
        var chart = this.chart;
        var series;
        var data = new ChartData(chart);
        var pointData = data.getData();
        var isZooming = chart.zoomSettings.enableSelectionZooming || chart.zoomSettings.enablePinchZooming;
        if (pointData.point && (data.insideRegion || !pointData.series.isRectSeries)) {
            this.seriesIndex = pointData.series.index;
            this.pointIndex = pointData.point.index;
            series = chart.series[this.seriesIndex];
            if (series.dragSettings.enable && !isZooming) {
                chart.trigger(dragStart, {
                    series: pointData.series, seriesIndex: this.seriesIndex, pointIndex: this.pointIndex, point: pointData.point,
                    oldValue: chart.visibleSeries[this.seriesIndex].yData[this.pointIndex],
                    newValue: chart.visibleSeries[this.seriesIndex].points[this.pointIndex].yValue
                });
                chart.isPointMouseDown = true;
                chart.zoomSettings.enableDeferredZooming = false;
            }
        }
    };
    /**
     * Point dragging.
     */
    DataEditing.prototype.pointMouseMove = function (event) {
        var chart = this.chart;
        var series;
        if (event.type === 'touchmove' && event.preventDefault) {
            event.preventDefault();
        }
        var data = new ChartData(chart);
        var pointData = data.getData();
        if (pointData.series.dragSettings.enable && pointData.point && (data.insideRegion || !pointData.series.isRectSeries)) {
            this.getCursorStyle(pointData);
        }
        else {
            chart.svgObject.style.cursor = 'null';
        }
        if (chart.isPointMouseDown) {
            series = chart.series[this.seriesIndex];
            if (series.type.indexOf('Spline') > -1) {
                chart[firstToLowerCase(series.type) + 'SeriesModule'].findSplinePoint(series);
            }
            this.pointDragging(this.seriesIndex, this.pointIndex);
        }
    };
    /**
     * Get cursor style.
     */
    DataEditing.prototype.getCursorStyle = function (pointData) {
        var chart = this.chart;
        if (pointData.series.type.indexOf('Stacking') > -1) {
            chart.svgObject.style.cursor = '';
        }
        else if (pointData.series.type === 'Bar' && chart.isTransposed) {
            chart.svgObject.style.cursor = 'ns-resize';
        }
        else if (chart.isTransposed || pointData.series.type === 'Bar') {
            chart.svgObject.style.cursor = 'ew-resize';
        }
        else {
            chart.svgObject.style.cursor = 'ns-resize';
        }
    };
    /**
     * Dragging calculation.
     */
    DataEditing.prototype.pointDragging = function (si, pi) {
        var chart = this.chart;
        var yValueArray = [];
        var y;
        var ySize;
        var yValue;
        var series = chart.visibleSeries[si];
        var pointDrag = series.dragSettings;
        var xAxis = series.xAxis;
        var yAxis = series.yAxis;
        // To get drag region for column and bar series
        var extra = series.isRectSeries ? 1 : 0;
        var axis = getTransform(xAxis, yAxis, chart.requireInvertedAxis);
        if (series.type === 'Bar') {
            y = chart.isTransposed ? (axis.y + axis.height) - chart.mouseY : chart.mouseX - axis.x;
            ySize = chart.isTransposed ? axis.height : axis.width;
        }
        else {
            y = chart.isTransposed ? chart.mouseX - axis.x : (axis.y + axis.height) - chart.mouseY;
            ySize = chart.isTransposed ? axis.width : axis.height;
        }
        yValue = yAxis.isAxisInverse ? (1 - (y / ySize)) : (y / ySize);
        yValue = (yValue * yAxis.visibleRange.delta) + yAxis.visibleRange.min;
        var minRange = yAxis.minimum !== null ? yAxis.visibleRange.min + extra : (isNullOrUndefined(pointDrag.minY) ?
            (yValue) : pointDrag.minY);
        var maxRange = yAxis.maximum !== null ? yAxis.visibleRange.max + extra : (isNullOrUndefined(pointDrag.maxY) ?
            (yValue) : pointDrag.maxY);
        if (maxRange >= yValue && minRange <= yValue) {
            series.points[pi].yValue = series.points[pi].y = chart.dragY = (yAxis.valueType === 'Logarithmic') ?
                Math.pow(yAxis.logBase, yValue) : parseFloat(yValue.toFixed(2));
            series.points[pi].interior = pointDrag.fill;
            for (var i = 0; i < series.points.length; i++) {
                yValueArray[i] = series.points[i].yValue;
            }
            series.yMin = Math.min.apply(null, yValueArray);
            series.yMax = Math.max.apply(null, yValueArray);
            this.isPointDragging = true;
            chart.refreshBound();
            chart.trigger(drag, {
                seriesIndex: si, pointIndex: pi, series: series, point: series.points[pi],
                oldValue: chart.visibleSeries[this.seriesIndex].yData[this.pointIndex], newValue: series.points[pi].yValue
            });
        }
    };
    /**
     * Point drag ends here.
     */
    DataEditing.prototype.pointMouseUp = function () {
        var chart = this.chart;
        if (chart.isPointMouseDown) {
            if (chart.series[this.seriesIndex].dragSettings.enable) {
                chart.trigger(dragEnd, {
                    series: chart.series[this.seriesIndex], point: chart.visibleSeries[this.seriesIndex].points[this.pointIndex],
                    seriesIndex: this.seriesIndex,
                    pointIndex: this.pointIndex, oldValue: chart.visibleSeries[this.seriesIndex].yData[this.pointIndex],
                    newValue: chart.visibleSeries[this.seriesIndex].points[this.pointIndex].yValue
                });
                chart.visibleSeries[this.seriesIndex].points[this.pointIndex].y =
                    chart.visibleSeries[this.seriesIndex].points[this.pointIndex].yValue;
                chart.isPointMouseDown = false;
                this.isPointDragging = false;
                this.seriesIndex = this.pointIndex = undefined;
            }
        }
    };
    /**
     * Get module name.
     */
    DataEditing.prototype.getModuleName = function () {
        // Returns te module name
        return 'DataEditing';
    };
    /**
     * To destroy the DataEditing.
     *
     * @returns {void}
     * @private
     */
    DataEditing.prototype.destroy = function () {
        // Destroy method performed here
    };
    return DataEditing;
}());

var __extends$56 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * Highlight src file
 */
/**
 * `Highlight` module handles the selection for chart.
 *
 * @private
 */
var Highlight = /** @__PURE__ @class */ (function (_super) {
    __extends$56(Highlight, _super);
    /**
     * Constructor for selection module.
     *
     * @private
     */
    function Highlight(chart) {
        var _this = _super.call(this, chart) || this;
        _this.chart = chart;
        _this.renderer = chart.renderer;
        _this.wireEvents();
        return _this;
    }
    /**
     * Binding events for selection module.
     */
    Highlight.prototype.wireEvents = function () {
        if (this.chart.isDestroyed || (this.chart.stockChart && this.chart.stockChart.onPanning)) {
            return;
        }
        this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
    };
    /**
     * UnBinding events for selection module.
     */
    Highlight.prototype.unWireEvents = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.off(Browser.touchMoveEvent, this.mouseMove);
    };
    /**
     * To find private variable values
     */
    Highlight.prototype.declarePrivateVariables = function (chart) {
        this.styleId = chart.element.id + '_ej2_chart_highlight';
        this.unselected = chart.element.id + '_ej2_deselected';
        this.selectedDataIndexes = [];
        this.highlightDataIndexes = [];
        this.isSeriesMode = chart.highlightMode === 'Series';
    };
    /**
     * Method to select the point and series.
     *
     * @returns {void}
     */
    Highlight.prototype.invokeHighlight = function (chart) {
        this.declarePrivateVariables(chart);
        this.series = extend({}, chart.visibleSeries, null, true);
        this.seriesStyles();
        this.currentMode = chart.highlightMode;
    };
    /**
     * Get module name.
     *
     * @private
     */
    Highlight.prototype.getModuleName = function () {
        return 'Highlight';
    };
    /**
     * To destroy the highlight.
     *
     * @returns {void}
     * @private
     */
    Highlight.prototype.destroy = function () {
        this.unWireEvents();
        // Destroy method performed here
    };
    return Highlight;
}(Selection));

/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `DataLabel` module is used to render data label for the data point.
 */
var DataLabel = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for the data label module.
     *
     * @private
     */
    function DataLabel(chart) {
        this.errorHeight = 0;
        this.chart = chart;
    }
    DataLabel.prototype.initPrivateVariables = function (series, marker) {
        var transform = '';
        var clipPath = '';
        var render = series.chart.renderer;
        var index = (series.index === undefined) ? series.category : series.index;
        if (series.chart.chartAreaType === 'Cartesian') {
            transform = 'translate(' + series.clipRect.x + ',' + (series.clipRect.y) + ')';
            clipPath = 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')';
        }
        if (marker.dataLabel.visible && !this.chart.enableCanvas) {
            series.shapeElement = render.createGroup({
                'id': this.chart.element.id + 'ShapeGroup' + index,
                'transform': transform,
                'clip-path': 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')'
            });
            series.textElement = render.createGroup({
                'id': this.chart.element.id + 'TextGroup' + index,
                'transform': transform,
                'clip-path': clipPath
            });
            series.textElement.setAttribute('aria-hidden', 'true');
        }
        this.markerHeight = ((series.type === 'Scatter' || marker.visible)) ? (marker.height / 2) : 0;
        this.commonId = this.chart.element.id + '_Series_' + index + '_Point_';
        this.calculateErrorHeight(series, series.marker.dataLabel.position);
        this.chartBackground = this.chart.chartArea.background === 'transparent' ?
            this.chart.background || this.chart.themeStyle.background : this.chart.chartArea.background;
    };
    DataLabel.prototype.calculateErrorHeight = function (series, position) {
        if (!series.errorBar.visible) {
            return null;
        }
        else if (series.errorBar.visible && this.chart.chartAreaType !== 'PolarRadar') {
            var direction = series.errorBar.direction;
            var positiveHeight = this.chart.errorBarModule.positiveHeight;
            var negativeHeight = this.chart.errorBarModule.negativeHeight;
            if (this.isRectSeries(series)) {
                if (position === 'Top' || position === 'Auto') {
                    if (direction === 'Both' || direction === 'Minus') {
                        this.errorHeight = negativeHeight;
                    }
                    else {
                        this.errorHeight = 0;
                    }
                }
                if (position === 'Outer' || position === 'Auto') {
                    if (direction === 'Both' || direction === 'Plus') {
                        this.errorHeight = positiveHeight;
                    }
                    else {
                        this.errorHeight = 0;
                    }
                }
            }
            else {
                if (position === 'Top' || position === 'Outer' || position === 'Auto') {
                    if ((direction === 'Both' || direction === 'Plus') && (!series.chart.isTransposed)) {
                        this.errorHeight = positiveHeight;
                    }
                    else {
                        this.errorHeight = 0;
                    }
                }
                if (position === 'Bottom' || position === 'Auto') {
                    if (direction === 'Both' || direction === 'Minus') {
                        this.errorHeight = negativeHeight;
                    }
                    else {
                        this.errorHeight = 0;
                    }
                }
            }
        }
        else {
            this.errorHeight = 0;
        }
    };
    DataLabel.prototype.isRectSeries = function (series) {
        return series.isRectSeries || series.type === 'RangeArea' || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea';
    };
    /**
     * Render the data label for series.
     *
     * @returns {void}
     */
    DataLabel.prototype.render = function (series, chart, dataLabel) {
        // initialize the private variable
        this.initPrivateVariables(series, series.marker);
        var rect;
        var labelLocation = { x: 0, y: 0 };
        var rgbValue;
        var contrast;
        var argsData;
        var border;
        var textSize;
        var angle;
        var degree;
        this.inverted = chart.requireInvertedAxis;
        this.yAxisInversed = series.yAxis.isAxisInverse;
        var redraw = chart.redraw;
        var isDataLabelOverlap = false;
        var coordinatesAfterRotation = [];
        var templateId = chart.element.id + '_Series_' +
            (series.index === undefined ? series.category : series.index) + '_DataLabelCollections';
        var element = createElement('div', {
            id: templateId
        });
        var visiblePoints = getVisiblePoints(series);
        var point;
        var rectCenterX;
        var rectCenterY;
        // Data label point iteration started
        for (var i = 0; i < visiblePoints.length; i++) {
            point = visiblePoints[i];
            if (!dataLabel.showZero && ((point.y !== 0) || (point.y === 0 && series.emptyPointSettings.mode === 'Zero'))) {
                return null;
            }
            this.margin = dataLabel.margin;
            var labelText = [];
            var labelLength = void 0;
            var xPos = void 0;
            var yPos = void 0;
            var xValue = void 0;
            var yValue = void 0;
            var isRender = true;
            var clip = series.clipRect;
            var shapeRect = void 0;
            isDataLabelOverlap = false;
            dataLabel.angle = dataLabel.labelIntersectAction === 'Rotate90' ? 90 : dataLabel.angle;
            dataLabel.enableRotation = dataLabel.labelIntersectAction === 'Rotate90' ? true : dataLabel.enableRotation;
            angle = degree = dataLabel.angle;
            border = { width: dataLabel.border.width, color: dataLabel.border.color };
            var argsFont = (extend({}, getValue('properties', dataLabel.font), null, true));
            if ((point.symbolLocations.length && point.symbolLocations[0]) ||
                (series.type === 'BoxAndWhisker' && point.regions.length)) {
                labelText = getLabelText(point, series, chart);
                labelLength = labelText.length;
                for (var i_1 = 0; i_1 < labelLength; i_1++) {
                    argsData = {
                        cancel: false, name: textRender, series: series,
                        point: point, text: labelText[i_1], border: border,
                        color: dataLabel.fill, template: dataLabel.template, font: argsFont, location: labelLocation,
                        textSize: measureText(labelText[i_1], dataLabel.font, this.chart.themeStyle.datalabelFont)
                    };
                    chart.trigger(textRender, argsData);
                    if (!argsData.cancel) {
                        this.fontBackground = argsData.color;
                        this.isDataLabelShape(argsData);
                        this.markerHeight = series.type === 'Bubble' ? (point.regions[0].height / 2) : this.markerHeight;
                        if (argsData.template !== null) {
                            this.createDataLabelTemplate(element, series, dataLabel, point, argsData, i_1, redraw);
                        }
                        else {
                            textSize = measureText(argsData.text, dataLabel.font, this.chart.themeStyle.datalabelFont);
                            rect = this.calculateTextPosition(point, series, textSize, dataLabel, i_1);
                            // To check whether the polar radar chart datalabel intersects the axis label or not
                            if (chart.chartAreaType === 'PolarRadar') {
                                for (var _i = 0, _a = chart.chartAxisLayoutPanel.visibleAxisLabelRect; _i < _a.length; _i++) {
                                    var rectRegion = _a[_i];
                                    if (isOverlap(new Rect(rect.x, rect.y, rect.width, rect.height), rectRegion)) {
                                        isRender = false;
                                        break;
                                    }
                                }
                            }
                            var actualRect = new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height);
                            //let notOverlapping: boolean;
                            if (dataLabel.enableRotation) {
                                var rectCoordinates = this.getRectanglePoints(rect);
                                rectCenterX = rect.x + (rect.width / 2);
                                rectCenterY = (rect.y + (rect.height / 2));
                                coordinatesAfterRotation = getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle);
                                isDataLabelOverlap = (dataLabel.labelIntersectAction === 'Rotate90' || angle == -90) ? false : this.isDataLabelOverlapWithChartBound(coordinatesAfterRotation, chart, clip);
                                if (!isDataLabelOverlap) {
                                    this.chart.rotatedDataLabelCollections.push(coordinatesAfterRotation);
                                    var currentPointIndex = this.chart.rotatedDataLabelCollections.length - 1;
                                    for (var index = currentPointIndex; index >= 0; index--) {
                                        if (this.chart.rotatedDataLabelCollections[currentPointIndex] &&
                                            this.chart.rotatedDataLabelCollections[index - 1] &&
                                            isRotatedRectIntersect(this.chart.rotatedDataLabelCollections[currentPointIndex], this.chart.rotatedDataLabelCollections[index - 1])) {
                                            isDataLabelOverlap = true;
                                            this.chart.rotatedDataLabelCollections[currentPointIndex] = null;
                                            break;
                                        }
                                    }
                                }
                            }
                            else {
                                isDataLabelOverlap = isCollide(rect, chart.dataLabelCollections, clip);
                            }
                            if ((!isDataLabelOverlap || dataLabel.labelIntersectAction === 'None') && isRender) {
                                chart.dataLabelCollections.push(actualRect);
                                if (this.isShape) {
                                    shapeRect = chart.renderer.drawRectangle(new RectOption(this.commonId + point.index + '_TextShape_' + i_1, argsData.color, argsData.border, dataLabel.opacity, rect, dataLabel.rx, dataLabel.ry), new Int32Array([clip.x, clip.y]));
                                    if (series.shapeElement) {
                                        series.shapeElement.appendChild(shapeRect);
                                    }
                                }
                                // Checking the font color
                                var backgroundColor = this.fontBackground === 'transparent' ? ((this.chart.theme.indexOf('Dark') > -1 || this.chart.theme === 'HighContrast') ? 'black' : 'white') : this.fontBackground;
                                rgbValue = convertHexToColor(colorNameToHex(backgroundColor));
                                contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);
                                xPos = (rect.x + this.margin.left + textSize.width / 2) + labelLocation.x;
                                yPos = (rect.y + this.margin.top + textSize.height * 3 / 4) + labelLocation.y;
                                labelLocation = { x: 0, y: 0 };
                                if (angle !== 0 && dataLabel.enableRotation) {
                                    // xValue = xPos - (dataLabel.margin.left) / 2 + (dataLabel.margin.right / 2);
                                    xValue = rectCenterX;
                                    //yValue = yPos - (dataLabel.margin.top) / 2 - (textSize.height / dataLabel.margin.top) +
                                    // (dataLabel.margin.bottom) / 2;
                                    yValue = rectCenterY;
                                    degree = (angle > 360) ? angle - 360 : (angle < -360) ? angle + 360 : angle;
                                }
                                else {
                                    degree = 0;
                                    xValue = rect.x;
                                    yValue = rect.y;
                                    xPos -= chart.chartAreaType == 'Cartesian' && xPos + (textSize.width / 2) > clip.width ? (xPos + textSize.width / 2) - clip.width : 0;
                                    yPos -= (yPos + textSize.height > clip.y + clip.height && !(series.type.indexOf('Bar') > -1)) ? (yPos + textSize.height) - (clip.y + clip.height) : 0;
                                }
                                var textAnchor = dataLabel.labelIntersectAction === 'Rotate90' ? (dataLabel.position == 'Top' ? 'start' : (dataLabel.position == 'Middle' ? 'middle' : 'end')) :
                                    ((angle == -90 && dataLabel.enableRotation) ? (dataLabel.position == 'Top' ? 'end' : (dataLabel.position == 'Middle' ? 'middle' : 'start')) : 'middle');
                                textElement$1(chart.renderer, new TextOption(this.commonId + point.index + '_Text_' + i_1, xPos, yPos, textAnchor, argsData.text, 'rotate(' + degree + ',' + (xValue) + ',' + (yValue) + ')', 'auto', degree), argsData.font, argsData.font.color ||
                                    ((contrast >= 128 || series.type === 'Hilo' || series.type === 'HiloOpenClose') ? 'black' : 'white'), series.textElement, false, redraw, true, false, series.chart.duration, series.clipRect, null, null, chart.enableCanvas, null, this.chart.themeStyle.datalabelFont);
                            }
                        }
                    }
                }
            }
        }
        if (element.childElementCount) {
            if (!chart.enableCanvas) {
                appendChildElement(chart.enableCanvas, getElement$1(chart.element.id + '_Secondary_Element'), element, chart.redraw, 
                // eslint-disable-next-line @typescript-eslint/indent
                false, 'x', 'y', null, '', false, false, null, chart.duration);
            }
            else {
                getElement$1(chart.element.id + '_Secondary_Element').appendChild(element);
            }
        }
    };
    /**
     * Get rect coordinates
     */
    DataLabel.prototype.getRectanglePoints = function (rect) {
        var loc1 = new ChartLocation(rect.x, rect.y);
        var loc2 = new ChartLocation(rect.x + rect.width, rect.y);
        var loc3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);
        var loc4 = new ChartLocation(rect.x, rect.y + rect.height);
        return [loc1, loc2, loc3, loc4];
    };
    DataLabel.prototype.isDataLabelOverlapWithChartBound = function (rectCoordinates, chart, clip) {
        for (var index = 0; index < rectCoordinates.length; index++) {
            if (!withInBounds(rectCoordinates[index].x + clip.x, rectCoordinates[index].y + clip.y, chart.initialClipRect)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Render the data label template.
     *
     * @returns {void}
     * @private
     */
    DataLabel.prototype.createDataLabelTemplate = function (parentElement, series, dataLabel, point, data, labelIndex, redraw) {
        this.margin = { left: 0, right: 0, bottom: 0, top: 0 };
        var clip = series.clipRect;
        var childElement = createTemplate(createElement('div', {
            id: this.chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabel_'
                + point.index + (labelIndex ? ('_' + labelIndex) : ''),
            styles: 'position: absolute;background-color:' + data.color + ';' +
                getFontStyle(dataLabel.font) + ';border:' + data.border.width + 'px solid ' + data.border.color + ';'
        }), point.index, data.template, this.chart, point, series, this.chart.element.id + '_DataLabel', labelIndex);
        this.calculateTemplateLabelSize(parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw);
    };
    DataLabel.prototype.calculateTemplateLabelSize = function (parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw, isReactCallback) {
        var elementRect = measureElementRect(childElement, redraw, isReactCallback);
        var rect = this.calculateTextPosition(point, series, { width: elementRect.width, height: elementRect.height }, dataLabel, labelIndex);
        var clipWidth = 0;
        var clipHeight = 0;
        var isOverlap$$1 = false;
        if (isReactCallback) {
            isOverlap$$1 = (elementRect.width === 0 || elementRect.height === 0); // To check the data label already overlap before react callback call
            // clipWidth = ((series.clipRect.x + rect.x) + elementRect.width) > parentElement.clientWidth ?
            //     (parentElement.clientWidth - (series.clipRect.x + rect.x)) : 0;
            // clipHeight = (series.points.length - 1 === point.index) ? elementRect.height / 2 : 0;
        }
        childElement.style.left = ((this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.x) + rect.x - clipWidth) + 'px';
        childElement.style.top = ((this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.y) + rect.y + clipHeight) + 'px';
        var backgroundColor = this.fontBackground === 'transparent' ? (this.chart.theme.indexOf('Dark') > -1 ? 'black' : 'white') : this.fontBackground;
        var rgbValue = convertHexToColor(colorNameToHex(backgroundColor));
        var vAxis = series.chart.requireInvertedAxis ? series.xAxis : series.yAxis;
        var hAxis = series.chart.requireInvertedAxis ? series.yAxis : series.xAxis;
        childElement.style.color = dataLabel.font.color ||
            ((Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000)) >= 128 ? 'black' : 'white');
        if (childElement.childElementCount && !isOverlap$$1 && (!isCollide(rect, this.chart.dataLabelCollections, clip) ||
            dataLabel.labelIntersectAction === 'None') && (series.seriesType !== 'XY' || point.yValue === undefined ||
            withIn(point.yValue, series.yAxis.visibleRange) || (series.type.indexOf('Stacking') > -1) ||
            (series.type.indexOf('100') > -1 && withIn(series.stackedValues.endValues[point.index], series.yAxis.visibleRange))) &&
            withIn(point.xValue, series.xAxis.visibleRange) && parseFloat(childElement.style.top) >= vAxis.rect.y &&
            parseFloat(childElement.style.left) >= hAxis.rect.x &&
            parseFloat(childElement.style.top) <= vAxis.rect.y + vAxis.rect.height &&
            parseFloat(childElement.style.left) <= hAxis.rect.x + hAxis.rect.width) {
            this.chart.dataLabelCollections.push(new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));
            appendChildElement(this.chart.enableCanvas, parentElement, childElement, redraw, true, 'left', 'top');
            if (series.animation.enable && this.chart.animateSeries && !this.chart.enableCanvas) {
                this.doDataLabelAnimation(series, childElement);
            }
            else if (this.chart.enableCanvas) {
                parentElement.appendChild(childElement);
            }
        }
    };
    DataLabel.prototype.calculateTextPosition = function (point, series, textSize, dataLabel, labelIndex) {
        var labelRegion = labelIndex > 1 ? (series.type === 'Candle') ? point.regions[1] : point.regions[0] : point.regions[0];
        if (labelIndex > 1 && series.type === 'HiloOpenClose') {
            labelRegion = (labelIndex === 2) ? point.regions[1] : point.regions[2];
        }
        var location;
        location = this.getLabelLocation(point, series, textSize, labelIndex);
        var padding = 5;
        var clipRect = series.clipRect;
        // calculating alignment
        if (!this.chart.requireInvertedAxis || !this.isRectSeries(series) || series.type === 'BoxAndWhisker') {
            this.locationX = location.x;
            var alignmentValue = textSize.height + (this.borderWidth * 2) + this.markerHeight +
                this.margin.bottom + this.margin.top + padding;
            location.x = (dataLabel.position === 'Auto') ? location.x :
                this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, this.isRectSeries(series) ? point.yValue < 0 : false);
            // calculating position
            location.y = (!this.isRectSeries(series) || series.type === 'BoxAndWhisker') ?
                this.calculatePathPosition(location.y, dataLabel.position, series, point, textSize, labelIndex) :
                this.calculateRectPosition(location.y, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);
            if (this.isRectSeries(series) && this.chart.chartAreaType === 'PolarRadar') {
                location = this.calculatePolarRectPosition(location, dataLabel.position, series, point, textSize, labelIndex, dataLabel.alignment, alignmentValue);
            }
        }
        else {
            this.locationY = location.y;
            var alignmentValue = textSize.width + this.borderWidth + this.margin.left + this.margin.right - padding;
            location.x = dataLabel.position === 'Auto' ? location.x :
                this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, point.yValue < 0);
            location.x = this.calculateRectPosition(location.x, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);
        }
        var rect = calculateRect(location, textSize, this.margin);
        // Checking the condition whether data Label has been exist the clip rect
        if (!(dataLabel.enableRotation === true && dataLabel.angle !== 0) &&
            !((rect.y > (clipRect.y + clipRect.height)) || (rect.x > (clipRect.x + clipRect.width)) ||
                (rect.x + rect.width < 0) || (rect.y + rect.height < 0))) {
            rect.x = rect.x < 0 ? padding : rect.x;
            rect.y = (rect.y < 0) && !(dataLabel.labelIntersectAction === 'None') ? padding : rect.y;
            rect.x -= (rect.x + rect.width) > (clipRect.x + clipRect.width) ? (rect.x + rect.width)
                - (clipRect.x + clipRect.width) + padding : 0;
            rect.y -= (rect.y + rect.height) > (clipRect.y + clipRect.height) ? (rect.y + rect.height)
                - (clipRect.y + clipRect.height) + padding : 0;
            this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;
        }
        var dataLabelOutRegion;
        if (this.inverted && series.isRectSeries && (rect.x + rect.width > labelRegion.x + labelRegion.width)) {
            dataLabelOutRegion = true;
        }
        this.fontBackground = dataLabelOutRegion ? this.chartBackground : this.fontBackground;
        return rect;
    };
    // Calculation label location for polar column draw types
    DataLabel.prototype.calculatePolarRectPosition = function (location, position, series, point, size, labelIndex, alignment, alignmentValue) {
        var padding = 5;
        var columnRadius;
        var chartWidth = this.chart.availableSize.width;
        var alignmentSign = (alignment === 'Center') ? 0 : (alignment === 'Far' ? 1 : -1);
        var angle = (point.regionData.startAngle - 0.5 * Math.PI) + (point.regionData.endAngle - point.regionData.startAngle) / 2;
        if (labelIndex === 0) {
            columnRadius = point.regionData.radius < point.regionData.innerRadius ? point.regionData.innerRadius
                : point.regionData.radius;
        }
        else {
            columnRadius = point.regionData.radius > point.regionData.innerRadius ? point.regionData.innerRadius
                : point.regionData.radius;
        }
        this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;
        if (series.drawType.indexOf('Stacking') > -1) {
            position = position === 'Outer' ? 'Top' : position;
        }
        else if (series.drawType.indexOf('Range') > -1) {
            position = (position === 'Outer' || position === 'Top') ? position : 'Auto';
        }
        if (position === 'Outer') {
            columnRadius = labelIndex === 0 ? columnRadius + 2 * padding + this.markerHeight :
                columnRadius - 2 * padding - this.markerHeight;
        }
        else if (position === 'Middle') {
            columnRadius = columnRadius / 2 + padding;
            if (series.drawType === 'StackingColumn') {
                columnRadius = point.regionData.innerRadius + ((point.regionData.radius - point.regionData.innerRadius) / 2)
                    + padding - (size.height / 2);
            }
        }
        else if (position === 'Top') {
            columnRadius = labelIndex === 0 ? columnRadius - 2 * padding - this.markerHeight :
                columnRadius + 2 * padding + this.markerHeight;
        }
        else if (position === 'Bottom') {
            columnRadius = 2 * padding;
            columnRadius += (series.drawType === 'StackingColumn') ? (point.regionData.innerRadius + this.markerHeight) : 0;
        }
        else {
            if (labelIndex === 0) {
                columnRadius = columnRadius >= series.chart.radius ? columnRadius - padding :
                    series.drawType === 'StackingColumn' ? columnRadius - 2 * padding : columnRadius + 2 * padding;
            }
            else {
                columnRadius = columnRadius >= series.chart.radius ? columnRadius + padding : columnRadius - 2 * padding;
            }
        }
        columnRadius += (alignmentValue * alignmentSign);
        location.x = series.clipRect.width / 2 + series.clipRect.x + columnRadius * Math.cos(angle);
        // To change x location based on text anchor for column and stackingcolumn chart
        if (series.drawType === 'StackingColumn') {
            location.x = location.x < chartWidth / 2 ? location.x + size.width / 2 :
                (location.x > chartWidth / 2 ? location.x - size.width / 2 : location.x);
        }
        else if (series.drawType === 'Column') {
            location.x = location.x < chartWidth / 2 ? location.x - size.width / 2 :
                (location.x > chartWidth / 2 ? location.x + size.width / 2 : location.x);
        }
        location.y = series.clipRect.height / 2 + series.clipRect.y + columnRadius * Math.sin(angle);
        return location;
    };
    /**
     * Get the label location
     */
    DataLabel.prototype.getLabelLocation = function (point, series, textSize, labelIndex) {
        var location = new ChartLocation(0, 0);
        var labelRegion = (series.type === 'Candle' && labelIndex > 1) ? point.regions[1] : point.regions[0];
        if (series.type === 'HiloOpenClose') {
            labelRegion = (labelIndex === 2) ? point.regions[1] : point.regions[2];
        }
        var xAxis = series.xAxis;
        var yAxis = series.yAxis;
        var isInverted = series.chart.requireInvertedAxis;
        if (series.type === 'BoxAndWhisker') {
            this.markerHeight = 0;
            switch (labelIndex) {
                case 0:
                    location = getPoint(point.xValue, point.median, xAxis, yAxis, isInverted);
                    break;
                case 1:
                    location = getPoint(point.xValue, point.maximum, xAxis, yAxis, isInverted);
                    break;
                case 2:
                    location = getPoint(point.xValue, point.minimum, xAxis, yAxis, isInverted);
                    break;
                case 3:
                    location = getPoint(point.xValue, point.upperQuartile, xAxis, yAxis, isInverted);
                    break;
                case 4:
                    location = getPoint(point.xValue, point.lowerQuartile, xAxis, yAxis, isInverted);
                    break;
                default: {
                    location = getPoint(point.xValue, point.outliers[labelIndex - 5], xAxis, yAxis, isInverted);
                    this.markerHeight = series.marker.height / 2;
                    break;
                }
            }
            if (isInverted) {
                location.y = point.regions[0].y + (point.regions[0].height / 2);
            }
            else {
                location.x = point.regions[0].x + (point.regions[0].width / 2);
            }
        }
        else if (labelIndex === 0 || labelIndex === 1) {
            location = new ChartLocation(point.symbolLocations[0].x, point.symbolLocations[0].y);
        }
        else if ((labelIndex === 2 || labelIndex === 3) && series.type === 'Candle') {
            location = new ChartLocation(point.symbolLocations[1].x, point.symbolLocations[1].y);
        }
        else if (isInverted) {
            location = { x: labelRegion.x + (labelRegion.width) / 2, y: labelRegion.y };
        }
        else {
            location = { x: labelRegion.x + labelRegion.width, y: labelRegion.y + (labelRegion.height) / 2 };
        }
        //Aligning the label at the beginning of the tick, when tick size is less than text size
        if (labelIndex > 1 && series.type === 'HiloOpenClose') {
            if (series.chart.requireInvertedAxis) {
                var height = labelRegion.height;
                location.y = labelRegion.y + height / 2 + 2 * (labelIndex === 2 ? 1 : -1);
            }
            else {
                var width = labelRegion.width;
                location.x = labelRegion.x + width / 2 + 2 * (labelIndex === 2 ? 1 : -1);
            }
        }
        return location;
    };
    DataLabel.prototype.calculateRectPosition = function (labelLocation, rect, isMinus, position, series, textSize, labelIndex, point) {
        if (series.chart.chartAreaType === 'PolarRadar') {
            return null;
        }
        var padding = 5;
        var margin = this.margin;
        var textLength = !this.inverted ? textSize.height : textSize.width;
        var extraSpace = this.borderWidth + textLength / 2 + (position !== 'Outer' && series.type.indexOf('Column') > -1 &&
            (Math.abs(rect.height - textSize.height) < padding) ? 0 : padding);
        if (series.type === 'StackingColumn100' || series.type === 'StackingBar100') {
            position = (position === 'Outer') ? 'Top' : position;
        }
        else if (series.type.indexOf('Range') > -1) {
            position = (position === 'Outer' || position === 'Top') ? position : 'Auto';
        }
        else if (series.type === 'Waterfall') {
            position = position === 'Auto' ? 'Middle' : position;
        }
        switch (position) {
            case 'Bottom':
                labelLocation = !this.inverted ?
                    isMinus ? (labelLocation + (series.type === 'Waterfall' ? (-extraSpace - margin.top - this.markerHeight) : (-rect.height + extraSpace + margin.top))) :
                        (labelLocation + rect.height - extraSpace - margin.bottom) :
                    isMinus ? (labelLocation + (series.type === 'Waterfall' ? (+extraSpace + margin.left + this.markerHeight) : (+rect.width - extraSpace - margin.left))) :
                        (labelLocation - rect.width + extraSpace + margin.right);
                break;
            case 'Middle':
                labelLocation = labelLocation = !this.inverted ?
                    (isMinus ? labelLocation - (rect.height / 2) : labelLocation + (rect.height / 2)) :
                    (isMinus ? labelLocation + (rect.width / 2) : labelLocation - (rect.width / 2));
                break;
            case 'Auto':
                labelLocation = this.calculateRectActualPosition(labelLocation, rect, isMinus, series, textSize, labelIndex, point);
                break;
            default:
                extraSpace += this.errorHeight;
                labelLocation = this.calculateTopAndOuterPosition(labelLocation, rect, position, series, labelIndex, extraSpace, isMinus);
                break;
        }
        var check = !this.inverted ? (labelLocation < rect.y || labelLocation > rect.y + rect.height) :
            (labelLocation < rect.x || labelLocation > rect.x + rect.width);
        this.fontBackground = check ?
            (this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground)
            : this.fontBackground === 'transparent' ? (point.color || series.interior) : this.fontBackground;
        var seriesLength = series.chart.series.length;
        if (position === 'Outer' && (series.type.indexOf('Stacking') > -1) && ((seriesLength - 1) > series.index)) {
            var nextSeries = void 0;
            var nextSeriesPoint = void 0;
            for (var i = series.index + 1; i < seriesLength; i++) {
                nextSeries = series.chart.series[i];
                nextSeriesPoint = nextSeries.points[point.index];
                if ((nextSeries.type.indexOf('Stacking') > -1) && (nextSeries.type.indexOf('100') === -1)) {
                    this.fontBackground = (nextSeriesPoint && ((nextSeriesPoint.yValue < 0 && point.yValue < 0) ||
                        (nextSeriesPoint.yValue > 0 && point.yValue > 0))) ? (nextSeriesPoint ? nextSeriesPoint.color :
                        nextSeries.interior) : this.fontBackground;
                    break;
                }
            }
        }
        return labelLocation;
    };
    DataLabel.prototype.calculatePathPosition = function (labelLocation, position, series, point, size, labelIndex) {
        var padding = 5;
        if ((series.type.indexOf('Area') > -1 && series.type !== 'RangeArea' && series.type !== 'SplineRangeArea' && series.type !== 'RangeStepArea')
            && this.yAxisInversed && series.marker.dataLabel.position !== 'Auto') {
            position = position === 'Top' ? 'Bottom' : position === 'Bottom' ? 'Top' : position;
        }
        this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;
        switch (position) {
            case 'Top':
            case 'Outer':
                labelLocation = labelLocation - this.markerHeight - this.borderWidth - size.height / 2 - this.margin.bottom - padding -
                    this.errorHeight;
                break;
            case 'Bottom':
                labelLocation = labelLocation + this.markerHeight + this.borderWidth + size.height / 2 + this.margin.top + padding +
                    this.errorHeight;
                break;
            case 'Auto':
                labelLocation = this.calculatePathActualPosition(labelLocation, this.markerHeight, series, point, size, labelIndex);
                break;
        }
        return labelLocation;
    };
    DataLabel.prototype.isDataLabelShape = function (style) {
        this.isShape = (style.color !== 'transparent' || style.border.width > 0);
        this.borderWidth = style.border.width;
        if (!this.isShape) {
            this.margin = { left: 0, right: 0, bottom: 0, top: 0 };
        }
    };
    DataLabel.prototype.calculateRectActualPosition = function (labelLocation, rect, isMinus, series, size, labelIndex, point) {
        var location;
        var labelRect;
        var isOverLap = true;
        var position = 0;
        var collection = this.chart.dataLabelCollections;
        var finalPosition = series.type.indexOf('Range') !== -1 || series.type === 'Hilo' ? 2 : 4;
        while (isOverLap && position < finalPosition) {
            var actualPosition = this.getPosition(position);
            if (series.type.indexOf('Stacking') > -1 && actualPosition === 'Outer') {
                actualPosition = 'Top';
                position++;
            }
            location = this.calculateRectPosition(labelLocation, rect, isMinus, actualPosition, series, size, labelIndex, point);
            if (!this.inverted) {
                labelRect = calculateRect(new ChartLocation(this.locationX, location), size, this.margin);
                isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y > series.clipRect.height;
            }
            else {
                labelRect = calculateRect(new ChartLocation(location, this.locationY), size, this.margin);
                isOverLap = labelRect.x < 0 || isCollide(labelRect, collection, series.clipRect) ||
                    labelRect.x + labelRect.width > series.clipRect.width;
            }
            position++;
        }
        return location;
    };
    // alignment calculation assigned here
    DataLabel.prototype.calculateAlignment = function (value, labelLocation, alignment, isMinus) {
        switch (alignment) {
            case 'Far':
                labelLocation = !this.inverted ? (isMinus ? labelLocation + value : labelLocation - value) :
                    (isMinus ? labelLocation - value : labelLocation + value);
                break;
            case 'Near':
                labelLocation = !this.inverted ? (isMinus ? labelLocation - value : labelLocation + value) :
                    (isMinus ? labelLocation + value : labelLocation - value);
                break;
            // eslint-disable-next-line no-self-assign
            case 'Center':
                labelLocation = labelLocation;
                break;
        }
        return labelLocation;
    };
    //calculation for top and outer position of datalabel for rect series
    DataLabel.prototype.calculateTopAndOuterPosition = function (location, rect, position, series, index, extraSpace, isMinus) {
        var margin = this.margin;
        var top;
        switch (series.type) {
            case 'RangeColumn':
            case 'RangeArea':
            case 'RangeStepArea':
            case 'SplineRangeArea':
            case 'Hilo':
                top = (index === 0 && !this.yAxisInversed) || (index === 1 && this.yAxisInversed);
                location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);
                break;
            case 'Candle':
                top = (index === 0 || index === 2) && !this.yAxisInversed
                    || (index === 1 || index === 3) && this.yAxisInversed;
                location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top, index > 1);
                break;
            case 'HiloOpenClose':
                if (index <= 1) {
                    top = (index === 0 && !this.yAxisInversed) || (index === 1 && this.yAxisInversed);
                    location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);
                }
                else {
                    if (this.yAxisInversed) {
                        location = !this.inverted ? location + extraSpace + margin.top : location - extraSpace - margin.right;
                    }
                    else {
                        location = !this.inverted ? location - extraSpace - margin.bottom : location + extraSpace + margin.left;
                    }
                }
                break;
            default:
                if ((isMinus && position === 'Top') || (!isMinus && position === 'Outer')) {
                    location = !this.inverted ? location + (isMinus && series.type === 'Waterfall' ? (-rect.height + extraSpace + margin.bottom) : (-extraSpace - margin.bottom - this.markerHeight)) :
                        location + (isMinus && series.type === 'Waterfall' ? (+rect.width - extraSpace - margin.left) : (+extraSpace + margin.left + this.markerHeight));
                }
                else {
                    location = !this.inverted ? location + (isMinus && series.type === 'Waterfall' ? (-rect.height - extraSpace - margin.top) : (+extraSpace + margin.top + this.markerHeight)) :
                        location + (isMinus && series.type === 'Waterfall' ? (+rect.width + extraSpace + margin.top) : (-extraSpace - margin.right - this.markerHeight));
                }
                break;
        }
        return location;
    };
    /**
     * Updates the label location
     */
    DataLabel.prototype.updateLabelLocation = function (position, location, extraSpace, margin, rect, top, inside$$1) {
        if (inside$$1 === void 0) { inside$$1 = false; }
        if (!this.inverted) {
            if (top) {
                location = (position === 'Outer' && !inside$$1) ? location - extraSpace - margin.bottom - this.markerHeight :
                    location + extraSpace + margin.top + this.markerHeight;
            }
            else {
                location = (position === 'Outer' && !inside$$1) ? location + rect.height + extraSpace + margin.top + this.markerHeight :
                    location + rect.height - extraSpace - margin.bottom - this.markerHeight;
            }
        }
        else {
            if (top) {
                location = (position === 'Outer' && !inside$$1) ? location + extraSpace + margin.left + this.markerHeight :
                    location - extraSpace - margin.right - this.markerHeight;
            }
            else {
                location = (position === 'Outer' && !inside$$1) ? location - rect.width - extraSpace - margin.right - this.markerHeight :
                    location - rect.width + extraSpace + margin.left + this.markerHeight;
            }
        }
        return location;
    };
    DataLabel.prototype.calculatePathActualPosition = function (y, markerSize, series, point, size, labelIndex) {
        var points = series.points;
        var index = point.index;
        var yValue = points[index].yValue;
        var position;
        var nextPoint = points.length - 1 > index ? points[index + 1] : null;
        var previousPoint = index > 0 ? points[index - 1] : null;
        var yLocation;
        var isOverLap = true;
        var labelRect;
        var isBottom;
        var positionIndex;
        var collection = this.chart.dataLabelCollections;
        if (series.type === 'Bubble') {
            position = 'Top';
        }
        else if (series.type.indexOf('Step') > -1) {
            position = 'Top';
            if (index) {
                position = (!previousPoint || !previousPoint.visible || (yValue > previousPoint.yValue !== this.yAxisInversed)
                    || yValue === previousPoint.yValue) ? 'Top' : 'Bottom';
            }
        }
        else if (series.type === 'BoxAndWhisker') {
            if (labelIndex === 1 || labelIndex === 3 || labelIndex > 4) {
                position = series.yAxis.isAxisInverse ? 'Bottom' : 'Top';
            }
            else if (labelIndex === 2 || labelIndex === 4) {
                position = series.yAxis.isAxisInverse ? 'Top' : 'Bottom';
            }
            else {
                isOverLap = false;
                position = 'Middle';
                yLocation = this.calculatePathPosition(y, position, series, point, size, labelIndex);
            }
        }
        else {
            if (index === 0) {
                position = (!nextPoint || !nextPoint.visible || yValue > nextPoint.yValue ||
                    (yValue < nextPoint.yValue && this.yAxisInversed)) ? 'Top' : 'Bottom';
            }
            else if (index === points.length - 1) {
                position = (!previousPoint || !previousPoint.visible || yValue > previousPoint.yValue ||
                    (yValue < previousPoint.yValue && this.yAxisInversed)) ? 'Top' : 'Bottom';
            }
            else {
                if (!nextPoint.visible && !(previousPoint && previousPoint.visible)) {
                    position = 'Top';
                }
                else if (!nextPoint.visible || !previousPoint) {
                    position = (nextPoint.yValue > yValue || (previousPoint && previousPoint.yValue > yValue)) ?
                        'Bottom' : 'Top';
                }
                else {
                    var slope = (nextPoint.yValue - previousPoint.yValue) / 2;
                    var intersectY = (slope * index) + (nextPoint.yValue - (slope * (index + 1)));
                    position = !this.yAxisInversed ? intersectY < yValue ? 'Top' : 'Bottom' :
                        intersectY < yValue ? 'Bottom' : 'Top';
                }
            }
        }
        isBottom = position === 'Bottom';
        positionIndex = ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'].indexOf(position);
        while (isOverLap && positionIndex < 4) {
            yLocation = this.calculatePathPosition(y, this.getPosition(positionIndex), series, point, size, labelIndex);
            labelRect = calculateRect(new ChartLocation(this.locationX, yLocation), size, this.margin);
            isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect)
                || (labelRect.y + labelRect.height) > series.clipRect.height;
            positionIndex = isBottom ? positionIndex - 1 : positionIndex + 1;
            isBottom = false;
        }
        return yLocation;
    };
    /**
     * Animates the data label.
     *
     * @param  {Series} series - Data label of the series gets animated.
     * @returns {void}
     */
    DataLabel.prototype.doDataLabelAnimation = function (series, element) {
        var shapeElements = series.shapeElement.childNodes;
        var textNode = series.textElement.childNodes;
        var delay = series.animation.delay + series.animation.duration;
        var duration = series.chart.animated ? series.chart.duration : 200;
        var location;
        var length = element ? 1 : textNode.length;
        var tempElement;
        for (var i = 0; i < length; i++) {
            tempElement = textNode[i];
            if (element) {
                element.style.visibility = 'hidden';
                templateAnimate(element, delay, duration, 'ZoomIn');
            }
            else {
                location = new ChartLocation((+tempElement.getAttribute('x')) + ((+tempElement.getAttribute('width')) / 2), (+tempElement.getAttribute('y')) + ((+tempElement.getAttribute('height')) / 2));
                markerAnimate(tempElement, delay, duration, series, null, location, true);
                if (shapeElements[i]) {
                    tempElement = shapeElements[i];
                    location = new ChartLocation((+tempElement.getAttribute('x')) + ((+tempElement.getAttribute('width')) / 2), (+tempElement.getAttribute('y')) + ((+tempElement.getAttribute('height')) / 2));
                    markerAnimate(tempElement, delay, duration, series, null, location, true);
                }
            }
        }
    };
    DataLabel.prototype.getPosition = function (index) {
        return (['Outer', 'Top', 'Bottom', 'Middle', 'Auto'][index]);
    };
    /**
     * Get module name.
     */
    DataLabel.prototype.getModuleName = function () {
        // Returns the module name
        return 'DataLabel';
    };
    /**
     * To destroy the dataLabel for series.
     *
     * @returns {void}
     * @private
     */
    DataLabel.prototype.destroy = function () {
        // Destroy method performed here
    };
    return DataLabel;
}());

/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * `ErrorBar` module is used to render the error bar for series.
 */
var ErrorBar = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for the error bar module.
     *
     * @private
     */
    function ErrorBar(chart) {
        this.chart = chart;
    }
    /**
     * Render the error bar for series.
     *
     * @returns {void}
     */
    ErrorBar.prototype.render = function (series) {
        if (this.chart.chartAreaType === 'PolarRadar') {
            return null;
        }
        this.createElement(series, this.chart);
        this.renderErrorBar(series);
    };
    ErrorBar.prototype.renderErrorBar = function (series) {
        var seriesIndex = series.index;
        var symbolId;
        var capId;
        var errorbar = series.errorBar;
        var errorBarCap = series.errorBar.errorBarCap;
        var errorDirection = ['', ''];
        var redraw = series.chart.redraw;
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var point = _a[_i];
            if (point.visible && point.symbolLocations[0]) {
                var errorX = 0;
                var errorY = 0;
                switch (errorbar.mode) {
                    case 'Vertical':
                        errorY = point.verticalError;
                        break;
                    case 'Horizontal':
                        errorX = point.horizontalError;
                        break;
                    case 'Both':
                        errorX = point.horizontalError;
                        errorY = point.verticalError;
                        break;
                }
                errorDirection = this['calculate' + errorbar.type + 'Value'](point, series, this.chart.requireInvertedAxis, errorX, errorY);
                symbolId = this.chart.element.id + '_Series_' + '_ErrorBarGroup_' + seriesIndex + '_Point_' + point.index;
                capId = this.chart.element.id + '_Series_' + '_ErrorBarCap_' + seriesIndex + '_Point_' + point.index;
                var shapeOption = new PathOption(symbolId, '', errorbar.width, (errorbar.errorBarColorMapping ? point.errorBarColor : errorbar.color || this.chart.themeStyle.errorBar), null, '', errorDirection[0]);
                var element = getElement$1(shapeOption.id);
                var previousDirection = element ? element.getAttribute('d') : null;
                series.errorBarElement.appendChild(this.chart.renderer.drawPath(shapeOption));
                pathAnimation(element, errorDirection[0], redraw, previousDirection);
                var capOption = new PathOption(capId, '', errorBarCap.width, (errorbar.errorBarCap.color ? errorBarCap.color : (errorbar.errorBarColorMapping ? point.errorBarColor : errorbar.color || this.chart.themeStyle.errorBar)), null, '', errorDirection[1]);
                element = getElement$1(capOption.id);
                previousDirection = element ? element.getAttribute('d') : null;
                appendChildElement(this.chart.enableCanvas, series.errorBarElement, this.chart.renderer.drawPath(capOption), redraw);
                pathAnimation(element, errorDirection[1], redraw, previousDirection);
            }
        }
    };
    // path calculation for error bar
    ErrorBar.prototype.findLocation = function (point, series, isInverted, x1, y1) {
        var errorbar = series.errorBar;
        var direction = errorbar.direction;
        var location = [];
        var yValue = series.type.indexOf('Stacking') > -1 ? series.stackedValues.endValues[point.index] :
            (series.seriesType === 'HighLow' || series.seriesType === 'HighLowOpenClose') ? (series.points[point.index].high) :
                point.yValue;
        var startPoint = getPoint(point.xValue + ((direction === 'Plus' || direction === 'Both') ? (errorbar.type === 'Custom' &&
            (errorbar.mode === 'Horizontal' || errorbar.mode === 'Both')) ? x1 = point.horizontalPositiveError : x1 : 0), yValue + ((direction === 'Plus' || direction === 'Both') ? (errorbar.type === 'Custom' &&
            (errorbar.mode === 'Vertical' || errorbar.mode === 'Both')) ? y1 = point.verticalPositiveError : y1 : 0), series.xAxis, series.yAxis, isInverted);
        location.push(startPoint);
        if (series.isRectSeries) {
            var midPoint = point.symbolLocations[0];
            location.push(midPoint);
        }
        else {
            var midPoint = getPoint(point.xValue, point.yValue, series.xAxis, series.yAxis, isInverted);
            location.push(midPoint);
        }
        var endPoint = getPoint(point.xValue - ((direction === 'Minus' || direction === 'Both') ? (errorbar.type === 'Custom' &&
            (errorbar.mode === 'Horizontal' || errorbar.mode === 'Both')) ? x1 = point.horizontalNegativeError : x1 : 0), yValue - ((direction === 'Minus' || direction === 'Both') ? (errorbar.type === 'Custom' &&
            (errorbar.mode === 'Vertical' || errorbar.mode === 'Both')) ? y1 = point.verticalNegativeError : y1 : 0), series.xAxis, series.yAxis, isInverted);
        location.push(endPoint);
        // calculate error height for datalabel position alignment
        point.error = (errorbar.mode === 'Vertical') ? errorbar.verticalError : errorbar.horizontalError;
        this.negativeHeight = (errorbar.mode === 'Vertical' || errorbar.mode === 'Both') ? (isInverted ? (location[1].x - location[2].x) :
            (location[2].y - location[1].y)) : 0;
        this.positiveHeight = (errorbar.mode === 'Vertical' || errorbar.mode === 'Both') ? (isInverted ? (location[0].x - location[1].x) :
            (location[1].y - location[0].y)) : 0;
        return this.getErrorDirection(location[0], location[1], location[2], series, isInverted);
    };
    //calculations for eror bar types
    ErrorBar.prototype.calculateFixedValue = function (point, series, isInverted, errorX, errorY, xAxis, yAxis) {
        var errorbar = series.errorBar;
        return this.findLocation(point, series, isInverted, errorX, errorY);
    };
    ErrorBar.prototype.calculatePercentageValue = function (point, series, isInverted, errorX, errorY, xAxis, yAxis) {
        errorX = (errorX / 100) * point.xValue;
        errorY = (errorY / 100) * point.yValue;
        return this.findLocation(point, series, isInverted, errorX, errorY);
    };
    ErrorBar.prototype.calculateStandardDeviationValue = function (point, series, isInverted, errorX, errorY, xAxis, yAxis) {
        var getMean = this.meanCalculation(series, series.errorBar.mode);
        errorX = errorX * (getMean.horizontalSquareRoot + getMean.horizontalMean);
        errorY = errorY * (getMean.verticalSquareRoot + getMean.verticalMean);
        return this.findLocation(point, series, isInverted, errorX, errorY);
    };
    ErrorBar.prototype.calculateStandardErrorValue = function (point, series, isInverted, errorX, errorY, xAxis, yAxis) {
        var length = series.points.length;
        var getMean = this.meanCalculation(series, series.errorBar.mode);
        errorX = ((errorX * getMean.horizontalSquareRoot) / Math.sqrt(length));
        errorY = ((errorY * getMean.verticalSquareRoot) / Math.sqrt(length));
        return this.findLocation(point, series, isInverted, errorX, errorY);
    };
    ErrorBar.prototype.calculateCustomValue = function (point, series, isInverted, errorX, errorY, xAxis, yAxis) {
        var errorbar = series.errorBar;
        return this.findLocation(point, series, isInverted, errorX, errorY);
    };
    ErrorBar.prototype.getHorizontalDirection = function (start, mid, end, direction, errorMode, capLength) {
        var path = '';
        var capDirection = '';
        path += 'M ' + start.x + ' ' + mid.y + ' L ' + end.x + ' ' + mid.y;
        capDirection += (direction === 'Plus' || direction === 'Both') ? 'M ' + (start.x) + ' ' + (mid.y - capLength) + ' L '
            + (start.x) + ' ' + (mid.y + capLength) : '';
        capDirection += (direction === 'Minus' || direction === 'Both') ? 'M ' + (end.x) + ' ' + (mid.y - capLength) + ' L '
            + (end.x) + ' ' + (mid.y + capLength) : ' ';
        return [path, capDirection];
    };
    ErrorBar.prototype.getVerticalDirection = function (start, mid, end, direction, errorMode, capLength) {
        var path = '';
        var capDirection = '';
        path += 'M ' + mid.x + ' ' + start.y + ' L ' + mid.x + ' ' + end.y;
        capDirection += (direction === 'Plus' || direction === 'Both') ? 'M ' + (mid.x - capLength) + ' ' + start.y + ' L '
            + (mid.x + capLength) + ' ' + start.y : '';
        capDirection += (direction === 'Minus' || direction === 'Both') ? 'M ' + (mid.x - capLength) + ' ' + end.y + ' L '
            + (mid.x + capLength) + ' ' + end.y : '';
        return [path, capDirection];
    };
    ErrorBar.prototype.getBothDirection = function (start, mid, end, direction, errorMode, capLength) {
        var capDirection = '';
        var path = '';
        var pathH = this.getHorizontalDirection(start, mid, end, direction, errorMode, capLength);
        var pathV = this.getVerticalDirection(start, mid, end, direction, errorMode, capLength);
        path = pathH[0].concat(pathV[0]);
        capDirection = pathH[1].concat(pathV[1]);
        return [path, capDirection];
    };
    ErrorBar.prototype.getErrorDirection = function (start, mid, end, series, isInverted) {
        var direction = series.errorBar.direction;
        var mode = series.errorBar.mode;
        var capLength = series.errorBar.errorBarCap.length;
        var paths;
        var errorMode = mode;
        switch (mode) {
            case 'Both':
                errorMode = mode;
                break;
            case 'Horizontal':
                errorMode = (isInverted) ? 'Vertical' : mode;
                break;
            case 'Vertical':
                errorMode = (isInverted) ? 'Horizontal' : mode;
                break;
        }
        switch (errorMode) {
            case 'Horizontal':
                paths = this.getHorizontalDirection(start, mid, end, direction, errorMode, capLength);
                break;
            case 'Vertical':
                paths = this.getVerticalDirection(start, mid, end, direction, errorMode, capLength);
                break;
            case 'Both':
                paths = this.getBothDirection(start, mid, end, direction, errorMode, capLength);
                break;
        }
        return [paths[0], paths[1]];
    };
    // mean calculation for standard deviation and standard error
    ErrorBar.prototype.meanCalculation = function (series, mode) {
        var sumOfX = 0;
        var sumOfY = 0;
        var verticalMean = 0;
        var horizontalMean = 0;
        var length = series.points.length;
        switch (mode) {
            case 'Vertical':
                sumOfY = sum(series.yData);
                verticalMean = sumOfY / length;
                break;
            case 'Horizontal':
                sumOfX = sum(series.xData);
                horizontalMean = sumOfX / length;
                break;
            case 'Both':
                sumOfY = sum(series.yData);
                verticalMean = sumOfY / length;
                sumOfX = sum(series.xData);
                horizontalMean = sumOfX / length;
        }
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var point = _a[_i];
            if (mode === 'Vertical') {
                sumOfY = sumOfY + Math.pow((point.yValue - verticalMean), 2);
            }
            else if (mode === 'Horizontal') {
                sumOfX = sumOfX + Math.pow((point.xValue - horizontalMean), 2);
            }
            else {
                sumOfY = sumOfY + Math.pow((point.yValue - verticalMean), 2);
                sumOfX = sumOfX + Math.pow((point.xValue - horizontalMean), 2);
            }
        }
        var verStandardMean = sumOfY / (length - 1);
        var verSquareRoot = Math.sqrt(sumOfY / (length - 1));
        var horStandardMean = sumOfX / (length - 1);
        var horSquareRoot = Math.sqrt(sumOfX / (length - 1));
        return new Mean(verStandardMean, verSquareRoot, horStandardMean, horSquareRoot, verticalMean, horizontalMean);
    };
    ErrorBar.prototype.createElement = function (series, chart) {
        var transform = chart.chartAreaType === 'Cartesian' ?
            'translate(' + series.clipRect.x + ',' + (series.clipRect.y) + ')' : '';
        var markerHeight = (series.marker.height) / 2;
        var markerWidth = (series.marker.width) / 2;
        if (chart.chartAreaType === 'Cartesian') {
            var options = new RectOption(chart.element.id + '_ChartErrorBarClipRect_' + series.index, 'transparent', { width: 1, color: 'Gray' }, 1, {
                x: -markerWidth, y: -markerHeight,
                width: series.clipRect.width + markerWidth * 2, height: series.clipRect.height + markerHeight * 2
            });
            series.errorBarElement = chart.renderer.createGroup({
                'id': chart.element.id + 'ErrorBarGroup' + series.index,
                'transform': transform,
                'clip-path': 'url(#' + chart.element.id + '_ChartErrorBarClipRect_' + series.index + ')'
            });
            series.errorBarElement.appendChild(appendClipElement(chart.redraw, options, chart.renderer));
        }
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    ErrorBar.prototype.doErrorBarAnimation = function (series) {
        var errorBarElements = series.errorBarElement.childNodes;
        if (!errorBarElements) {
            return null;
        }
        var delay = series.animation.delay + ((series.animation.duration === 0 && animationMode === 'Enable') ? 1000 : series.animation.duration);
        var j = 1;
        while (j < errorBarElements.length) {
            for (var i = 0; i < series.points.length; i++) {
                if (!series.points[i].symbolLocations[0]) {
                    continue;
                }
                errorBarElements[j].style.visibility = 'hidden';
                templateAnimate(errorBarElements[j], delay, 350, series.chart.requireInvertedAxis ? 'SlideLeftIn' : 'SlideBottomIn', false);
            }
            j++;
        }
    };
    /**
     * Get module name.
     */
    ErrorBar.prototype.getModuleName = function () {
        // Returns the module name
        return 'ErrorBar';
    };
    /**
     * To destroy the errorBar for series.
     *
     * @returns {void}
     * @private
     */
    ErrorBar.prototype.destroy = function () {
        // Destroy method performed here
    };
    return ErrorBar;
}());

var __extends$57 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable curly */
/* eslint-disable max-len */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * Chart legend
 */
/**
 * `Legend` module is used to render legend for the chart.
 */
var Legend = /** @__PURE__ @class */ (function (_super) {
    __extends$57(Legend, _super);
    function Legend(chart) {
        var _this = _super.call(this, chart) || this;
        _this.library = _this;
        _this.addEventListener();
        return _this;
    }
    /**
     * Binding events for legend module.
     */
    Legend.prototype.addEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
        this.chart.on('click', this.click, this);
        this.chart.on(Browser.touchEndEvent, this.mouseEnd, this);
    };
    /**
     * UnBinding events for legend module.
     */
    Legend.prototype.removeEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.off(Browser.touchMoveEvent, this.mouseMove);
        this.chart.off('click', this.click);
        this.chart.off(Browser.touchEndEvent, this.mouseEnd);
    };
    /**
     * To handle mosue move for legend module
     */
    Legend.prototype.mouseMove = function (e) {
        if (this.chart.legendSettings.visible && !this.chart.isTouch) {
            this.move(e);
            if (this.chart.highlightModule && (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight)) {
                var legendItemsId = [this.legendID + '_text_', this.legendID + '_shape_marker_',
                    this.legendID + '_shape_', this.legendID + '_g_'];
                var targetId = e.target.id;
                var index = void 0;
                for (var _i = 0, legendItemsId_1 = legendItemsId; _i < legendItemsId_1.length; _i++) {
                    var id = legendItemsId_1[_i];
                    if (targetId.indexOf(id) > -1) {
                        index = parseInt(targetId.split(id)[1], 10);
                        this.chart.highlightModule.legendSelection(this.chart, index, e.target, e.type);
                        break;
                    }
                }
                // this.click(e);
            }
        }
    };
    /**
     * To handle mosue end for legend module
     */
    Legend.prototype.mouseEnd = function (e) {
        if (this.chart.legendSettings.visible && this.chart.isTouch) {
            this.move(e);
        }
    };
    /**
     * Get the legend options.
     *
     * @returns {void}
     * @private
     */
    Legend.prototype.getLegendOptions = function (visibleSeriesCollection, chart) {
        this.legendCollections = [];
        var seriesType;
        var fill;
        var dashArray;
        var colors = [];
        this.isRtlEnable = chart.enableRtl;
        this.isReverse = !this.isRtlEnable && chart.legendSettings.reverse;
        if (visibleSeriesCollection.length > 1) {
            this.legend.mode = 'Series';
        }
        for (var _i = 0, visibleSeriesCollection_1 = visibleSeriesCollection; _i < visibleSeriesCollection_1.length; _i++) {
            var series = visibleSeriesCollection_1[_i];
            if (this.legend.mode === 'Series') {
                if (series.category !== 'Indicator') {
                    seriesType = (chart.chartAreaType === 'PolarRadar') ? series.drawType :
                        series.type;
                    dashArray = !series.marker.visible && (seriesType.indexOf('Line') > -1 && seriesType.indexOf('Area') === -1) ? series.dashArray : '';
                    // To set legend color when use pointColorMapping
                    fill = (series.pointColorMapping && series.points.length > 0) ?
                        (series.points[0].interior ? series.points[0].interior : series.interior) : series.interior;
                    this.legendCollections.push(new LegendOptions(series.name, fill, series.legendShape, (series.category === 'TrendLine' ?
                        this.chart.series[series.sourceIndex].trendlines[series.index].visible : series.visible), seriesType, series.legendImageUrl ? series.legendImageUrl : (series.type === 'Scatter' && series.marker.shape === 'Image' ?
                        series.marker.imageUrl : ''), series.marker.shape, series.marker.visible, null, null, dashArray));
                }
            }
            else if (this.legend.mode === 'Point') {
                var _loop_1 = function (points) {
                    seriesType = (chart.chartAreaType === 'PolarRadar') ? series.drawType :
                        series.type;
                    fill = points.interior ? points.interior : series.interior;
                    if (this_1.legendCollections.filter(function (i) { return i.text === points.x.toString(); }).length === 0) {
                        this_1.legendCollections.push(new LegendOptions(points.x.toString(), fill, series.legendShape, (series.category === 'TrendLine' ?
                            this_1.chart.series[series.sourceIndex].trendlines[series.index].visible : points.visible), seriesType, (series.type === 'Scatter' && series.marker.shape === 'Image') ? series.marker.imageUrl : '', series.marker.shape, series.marker.visible));
                    }
                };
                var this_1 = this;
                for (var _a = 0, _b = series.points; _a < _b.length; _a++) {
                    var points = _b[_a];
                    _loop_1(points);
                }
            }
            else if (this.legend.mode === 'Range') {
                for (var _c = 0, _d = series.points; _c < _d.length; _c++) {
                    var points = _d[_c];
                    seriesType = (chart.chartAreaType === 'PolarRadar') ? series.drawType :
                        series.type;
                    fill = points.interior ? points.interior : series.interior;
                    var legendLabel = 'Others';
                    if (colors.indexOf(fill) < 0) {
                        colors.push(fill);
                        if (chart.rangeColorSettings.length >= 1 && chart.rangeColorSettings[0].colors.length === 1) {
                            for (var _e = 0, _f = chart.rangeColorSettings; _e < _f.length; _e++) {
                                var rangeMap = _f[_e];
                                if (rangeMap.colors[0] === fill) {
                                    legendLabel = rangeMap.label;
                                }
                            }
                            this.legendCollections.push(new LegendOptions(legendLabel, fill, series.legendShape, (series.category === 'TrendLine' ?
                                this.chart.series[series.sourceIndex].trendlines[series.index].visible : points.visible), seriesType, (series.type === 'Scatter' && series.marker.shape === 'Image') ? series.marker.imageUrl : '', series.marker.shape, series.marker.visible));
                        }
                    }
                }
            }
            else {
                if (this.legendCollections.length === 0 && chart.rangeColorSettings.length > 0) {
                    var startLabel = chart.rangeColorSettings[0].start.toString();
                    var endLabel = chart.rangeColorSettings[chart.rangeColorSettings.length - 1].end.toString();
                    this.legendCollections.push(new LegendOptions(startLabel, series.interior, 'Rectangle', true, seriesType, '', series.marker.shape, series.marker.visible));
                    this.legendCollections.push(new LegendOptions(endLabel, series.interior, 'Rectangle', true, seriesType, '', series.marker.shape, series.marker.visible));
                }
            }
        }
        if (this.isReverse && chart.legendSettings.mode !== 'Gradient') {
            this.legendCollections.reverse();
        }
    };
    /** @private */
    Legend.prototype.getLegendBounds = function (availableSize, legendBounds, legend) {
        this.calculateLegendTitle(legend, legendBounds);
        this.isTitle = legend.title ? true : false;
        this.chartRowCount = 1;
        this.rowHeights = [];
        this.columnHeights = [];
        this.pageHeights = [];
        var padding = legend.padding;
        var titlePosition = legend.titlePosition;
        var extraHeight = 0;
        var legendOption;
        var extraWidth = 0;
        var arrowWidth = this.arrowWidth;
        var arrowHeight = this.arrowHeight;
        var verticalArrowSpace = this.isVertical && !legend.enablePages ? arrowHeight : 0;
        var titleSpace = this.isTitle && titlePosition === 'Top' ? this.legendTitleSize.height + this.fivePixel : 0;
        titleSpace = this.isTitle && this.isVertical && titlePosition !== 'Top' ? this.legendTitleSize.height + this.fivePixel : titleSpace;
        if (!this.isVertical) {
            extraHeight = !legend.height ? ((availableSize.height / 100) * 5) : 0;
        }
        else {
            extraWidth = !legend.width ? ((availableSize.width / 100) * 5) : 0;
        }
        legendBounds.height += (extraHeight);
        legendBounds.width += extraWidth;
        var shapeWidth = legend.shapeWidth;
        var shapePadding = legend.shapePadding;
        var maximumWidth = 0;
        var rowWidth = 0;
        var legendWidth = 0;
        var columnHeight = 0;
        var columnCount = 0;
        var rowCount = 0;
        var titlePlusArrowSpace = 0;
        var legendEventArgs;
        var render = false;
        this.maxItemHeight = Math.max(measureText('MeasureText', legend.textStyle, this.chart.themeStyle.legendLabelFont).height, legend.shapeHeight);
        for (var i = 0; i < this.legendCollections.length; i++) {
            legendOption = this.legendCollections[i];
            if (regSub.test(legendOption.text)) {
                legendOption.text = getUnicodeText(legendOption.text, regSub);
            }
            if (regSup.test(legendOption.text)) {
                legendOption.text = getUnicodeText(legendOption.text, regSup);
            }
            legendEventArgs = {
                fill: legendOption.fill, text: legendOption.text, shape: legendOption.shape,
                markerShape: legendOption.markerShape, name: legendRender, cancel: false
            };
            this.chart.trigger(legendRender, legendEventArgs);
            legendOption.render = !legendEventArgs.cancel;
            legendOption.text = legendEventArgs.text;
            legendOption.fill = legendEventArgs.fill;
            legendOption.shape = legendEventArgs.shape;
            legendOption.markerShape = legendEventArgs.markerShape;
            legendOption.textSize = measureText(legendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont);
            shapeWidth = legendOption.text ? legend.shapeWidth : 0;
            shapePadding = legendOption.text ? legend.shapePadding : 0;
            if (legendOption.render && legendOption.text) {
                render = true;
                legendWidth = shapeWidth + shapePadding + (legend.maximumLabelWidth ? legend.maximumLabelWidth : legendOption.textSize.width) + (!this.isVertical ? (i === 0) ? padding : this.itemPadding : padding);
                rowWidth = rowWidth + legendWidth;
                if (!legend.enablePages && !this.isVertical) {
                    titlePlusArrowSpace = this.isTitle && titlePosition !== 'Top' ? this.legendTitleSize.width + this.fivePixel : 0;
                    titlePlusArrowSpace += arrowWidth;
                }
                this.getLegendHeight(legendOption, legend, legendBounds, rowWidth, this.maxItemHeight, padding);
                if (legendBounds.width < (padding + rowWidth + titlePlusArrowSpace) || this.isVertical) {
                    maximumWidth = Math.max(maximumWidth, (rowWidth + padding + titlePlusArrowSpace - (this.isVertical ? 0 : legendWidth)));
                    if (rowCount === 0 && (legendWidth !== rowWidth)) {
                        rowCount = 1;
                    }
                    rowWidth = this.isVertical ? 0 : legendWidth;
                    rowCount++;
                    columnCount = 0;
                    columnHeight = verticalArrowSpace;
                    //columnHeight = (rowCount * (this.maxItemHeight + padding)) + padding + titleSpace + verticalArrowSpace;
                }
                var len = (rowCount > 0 ? (rowCount - 1) : 0);
                this.rowHeights[len] = Math.max((this.rowHeights[len] ? this.rowHeights[len] : 0), legendOption.textSize.height);
                // this.maxItemHeight = Math.max(this.maxItemHeight, legendOption.textSize.height);
                this.columnHeights[columnCount] = (this.columnHeights[columnCount] ? this.columnHeights[columnCount] : 0) + legendOption.textSize.height + (this.isVertical ? (i === 0) ? padding : this.itemPadding : padding);
                columnCount++;
            }
        }
        columnHeight = Math.max.apply(null, this.columnHeights) + padding + titleSpace;
        columnHeight = Math.max(columnHeight, (this.maxItemHeight + padding) + padding + titleSpace);
        this.isPaging = legendBounds.height < columnHeight;
        if (this.isPaging && !legend.enablePages) {
            if (this.isVertical) {
                // eslint-disable-next-line no-self-assign
                columnHeight = columnHeight;
            }
            else {
                columnHeight = (this.maxItemHeight + padding) + padding + (titlePosition === 'Top' ? titleSpace : 0);
            }
        }
        this.totalPages = rowCount;
        if (!this.isPaging && !this.isVertical) {
            rowWidth += this.isTitle && titlePosition !== 'Top' ? (this.fivePixel + this.legendTitleSize.width + this.fivePixel) : 0;
        }
        if (render) {
            this.setBounds(Math.max((rowWidth + padding), maximumWidth), columnHeight, legend, legendBounds);
        }
        else {
            this.setBounds(0, 0, legend, legendBounds);
        }
    };
    /** @private */
    Legend.prototype.getLegendHeight = function (legendOption, legend, legendBounds, rowWidth, legendHeight, padding) {
        var legendWidth = legendOption.textSize.width;
        var textPadding = legend.shapePadding + (padding * 2) + legend.shapeWidth;
        switch (legend.textWrap) {
            case 'Wrap':
            case 'AnyWhere':
                if (legendWidth > legend.maximumLabelWidth || legendWidth + rowWidth > legendBounds.width) {
                    legendOption.textCollection = textWrap(legendOption.text, (legend.maximumLabelWidth ? Math.min(legend.maximumLabelWidth, (legendBounds.width - textPadding)) : (legendBounds.width - textPadding)), legend.textStyle, this.chart.enableRtl, null, null, this.chart.themeStyle.legendLabelFont);
                }
                else {
                    legendOption.textCollection.push(legendOption.text);
                }
                legendOption.textSize.height = (legendHeight * legendOption.textCollection.length);
                break;
        }
    };
    /** @private */
    Legend.prototype.getRenderPoint = function (legendOption, start, textPadding, prevLegend, rect, count, firstLegend, rowCount) {
        var padding = this.legend.padding;
        var textWidth = textPadding + (this.legend.maximumLabelWidth ? this.legend.maximumLabelWidth : prevLegend.textSize.width);
        var previousBound = prevLegend.location.x + ((!this.isRtlEnable) ? textWidth : -textWidth);
        if (this.isWithinBounds(previousBound, (this.legend.maximumLabelWidth ? this.legend.maximumLabelWidth : legendOption.textSize.width) + textPadding - this.itemPadding, rect) || this.isVertical) {
            legendOption.location.x = start.x;
            if (count !== firstLegend)
                this.chartRowCount++;
            legendOption.location.y = (count === firstLegend) ? prevLegend.location.y :
                prevLegend.location.y + (this.isVertical ? prevLegend.textSize.height : this.rowHeights[(this.chartRowCount - 2)]) + (this.isVertical ? this.itemPadding : padding);
        }
        else {
            legendOption.location.x = (count === firstLegend) ? prevLegend.location.x : previousBound;
            legendOption.location.y = prevLegend.location.y;
        }
        var availwidth = (!this.isRtlEnable) ? (this.legendBounds.x + this.legendBounds.width) - (legendOption.location.x +
            textPadding - this.itemPadding - this.legend.shapeWidth / 2) : (legendOption.location.x - textPadding + this.itemPadding + (this.legend.shapeWidth / 2)) - this.legendBounds.x;
        if (!this.isVertical && this.isPaging && !this.legend.enablePages) {
            availwidth = this.legendBounds.width - legendOption.location.x - this.fivePixel;
        }
        availwidth = this.legend.maximumLabelWidth ? Math.min(this.legend.maximumLabelWidth, availwidth) : availwidth;
        if (this.legend.textOverflow === 'Ellipsis' && this.legend.textWrap === 'Normal') {
            legendOption.text = textTrim(+availwidth.toFixed(4), legendOption.text, this.legend.textStyle, this.chart.enableRtl, this.chart.themeStyle.legendLabelFont);
        }
    };
    Legend.prototype.isWithinBounds = function (previousBound, textWidth, rect) {
        if (!this.isRtlEnable) {
            return (previousBound + textWidth) > (rect.x + rect.width + (this.legend.shapeWidth / 2));
        }
        else {
            return (previousBound - textWidth) < (rect.x - (this.legend.shapeWidth / 2));
        }
    };
    /** @private */
    Legend.prototype.LegendClick = function (index, event) {
        var chart = this.chart;
        var seriesIndex = chart.legendSettings.mode === 'Series' ? index : 0;
        var legendIndex = !this.isReverse ? index : (this.legendCollections.length - 1) - index;
        var series = chart.visibleSeries[seriesIndex];
        var legend = this.legendCollections[legendIndex];
        var changeDetection = 'isProtectedOnChange';
        if (chart.legendSettings.mode === 'Series') {
            var legendClickArgs = {
                legendText: legend.text, legendShape: legend.shape,
                chart: chart.isBlazor ? {} : chart, series: series, points: series.points, name: legendClick, cancel: false
            };
            this.chart.trigger(legendClick, legendClickArgs);
            series.legendShape = legendClickArgs.legendShape;
            if (!legendClickArgs.cancel) {
                if (series.fill !== null) {
                    chart.visibleSeries[index].interior = series.fill;
                }
                if (chart.legendSettings.toggleVisibility) {
                    series.chart[changeDetection] = true;
                    if (series.category === 'TrendLine') {
                        if (!chart.series[series.sourceIndex].trendlines[series.index].visible && chart.series[series.sourceIndex].visible) {
                            chart.series[series.sourceIndex].trendlines[series.index].visible = true;
                        }
                        else {
                            chart.series[series.sourceIndex].trendlines[series.index].visible = false;
                        }
                    }
                    else {
                        this.changeSeriesVisiblity(series, series.visible);
                    }
                    legend.visible = series.category === 'TrendLine' ? chart.series[series.sourceIndex].trendlines[series.index].visible :
                        (series.visible);
                    this.refreshLegendToggle(chart, series);
                }
                else if (chart.highlightModule) {
                    chart.highlightModule.legendSelection(chart, index, event.target, event.type);
                }
                else if (chart.selectionModule) {
                    chart.selectionModule.legendSelection(chart, index, event.target, event.type);
                }
                series.chart[changeDetection] = false;
            }
        }
        else if (chart.legendSettings.mode === 'Point') {
            var point = series.points[index];
            var legendClickArgs = {
                legendText: legend.text, legendShape: legend.shape,
                chart: chart.isBlazor ? {} : chart, series: series, points: [point], name: legendClick, cancel: false
            };
            this.chart.trigger(legendClick, legendClickArgs);
            if (chart.legendSettings.toggleVisibility && !legendClickArgs.cancel) {
                point.visible = !point.visible;
                var legendOption = this.legendCollections[index];
                legendOption.visible = point.visible;
                this.refreshLegendToggle(chart, series);
            }
        }
        else if (chart.legendSettings.mode === 'Range') {
            var points = [];
            var legendOption = this.legendCollections[index];
            for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
                var point = _a[_i];
                if (legendOption.fill === (point.interior || series.interior)) {
                    points.push(point);
                }
            }
            var legendClickArgs = {
                legendText: legend.text, legendShape: legend.shape,
                chart: chart.isBlazor ? {} : chart, series: series, points: points, name: legendClick, cancel: false
            };
            this.chart.trigger(legendClick, legendClickArgs);
            if (chart.legendSettings.toggleVisibility && !legendClickArgs.cancel) {
                legendOption.visible = !legendOption.visible;
                for (var _b = 0, points_1 = points; _b < points_1.length; _b++) {
                    var point = points_1[_b];
                    point.visible = !point.visible;
                }
                this.refreshLegendToggle(chart, series);
            }
        }
    };
    Legend.prototype.refreshLegendToggle = function (chart, series) {
        var selectedDataIndexes = [];
        if (chart.selectionModule) {
            selectedDataIndexes = extend([], chart.selectionModule.selectedDataIndexes, null, true);
        }
        if ((chart.svgObject.childNodes.length > 0) && !chart.enableAnimation && !chart.enableCanvas) {
            while (chart.svgObject.lastChild) {
                chart.svgObject.removeChild(chart.svgObject.lastChild);
            }
            remove(chart.svgObject);
        }
        chart.animateSeries = false;
        chart.redraw = chart.enableAnimation;
        chart.rotatedDataLabelCollections = [];
        removeElement$1(getElement(chart.element.id + '_Secondary_Element').querySelectorAll('.ejSVGTooltip')[0]);
        blazorTemplatesReset(chart);
        this.redrawSeriesElements(series, chart);
        chart.removeSvg();
        chart.refreshAxis();
        series.refreshAxisLabel();
        this.refreshSeries(chart.visibleSeries);
        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
            var series_1 = _a[_i];
            if (!isNullOrUndefined(series_1)) {
                chart.markerRender.removeHighlightedMarker(series_1, null, true);
            }
        }
        chart.refreshBound();
        chart.trigger('loaded', { chart: chart });
        if (selectedDataIndexes.length > 0) {
            chart.selectionModule.selectedDataIndexes = selectedDataIndexes;
            chart.selectionModule.redrawSelection(chart, chart.selectionMode);
        }
        if (chart.highlightModule && chart.highlightMode !== 'None' || chart.legendSettings.enableHighlight) {
            chart.highlightModule.redrawSelection(chart, chart.highlightMode);
        }
        chart.redraw = false;
    };
    Legend.prototype.changeSeriesVisiblity = function (series, visibility) {
        series.visible = !visibility;
        if (this.isSecondaryAxis(series.xAxis)) {
            series.xAxis.internalVisibility = series.xAxis.series.some(function (value) { return (value.visible); });
        }
        if (this.isSecondaryAxis(series.yAxis) || (series.category == 'Pareto' && series.type == 'Line')) {
            series.yAxis.internalVisibility = series.yAxis.series.some(function (value) { return (value.visible); });
        }
        if (series.trendlines.length && series.visible) {
            series.trendlines.forEach(function (trendline) {
                trendline.visible = true;
            });
        }
    };
    Legend.prototype.isSecondaryAxis = function (axis) {
        return (this.chart.axes.indexOf(axis) > -1);
    };
    Legend.prototype.redrawSeriesElements = function (series, chart) {
        if (!chart.redraw) {
            return null;
        }
        removeElement$1(chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) +
            '_DataLabelCollections');
    };
    Legend.prototype.refreshSeries = function (seriesCollection) {
        for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {
            var series = seriesCollection_1[_i];
            if (series.type.indexOf('Spline') > -1) {
                var isArea = (series.type.indexOf('Area') > -1 || series.drawType.indexOf('Area') > -1);
                var isRange = series.type.indexOf('Range') > -1;
                this.chart['spline' + (isArea ? isRange ? 'RangeArea' : 'Area' : '') + 'SeriesModule'].findSplinePoint(series);
            }
            series.position = undefined;
        }
    };
    /**
     * To show the tooltip for the trimmed text in legend.
     *
     * @returns {void}
     */
    Legend.prototype.click = function (event) {
        var _this = this;
        if (!this.chart.legendSettings.visible) {
            return;
        }
        var pageX = this.chart.mouseX;
        var pageY = this.chart.mouseY;
        var legendRegion = [];
        var targetId = event.target.id.indexOf('_chart_legend_g_') > -1 ?
            event.target.firstChild['id'] : event.target.id;
        var legendItemsId = [this.legendID + '_text_', this.legendID + '_shape_marker_',
            this.legendID + '_shape_'];
        var seriesIndex;
        for (var _i = 0, legendItemsId_2 = legendItemsId; _i < legendItemsId_2.length; _i++) {
            var id = legendItemsId_2[_i];
            if (targetId.indexOf(id) > -1) {
                seriesIndex = parseInt(targetId.split(id)[1], 10);
                this.LegendClick(seriesIndex, event);
                break;
            }
        }
        if (targetId.indexOf(this.legendID + '_pageup') > -1) {
            this.changePage(event, true);
        }
        else if (targetId.indexOf(this.legendID + '_pagedown') > -1) {
            this.changePage(event, false);
        }
        if (this.chart.enableCanvas && this.pagingRegions.length) {
            this.checkWithinBounds(pageX, pageY);
        }
        legendRegion = this.legendRegions.filter(function (region) {
            return (withInBounds(pageX, (pageY + (_this.isPaging ? (_this.currentPageNumber - 1) * _this.translatePage(_this.chart.enableCanvas, null, 1, 2) : 0)), region.rect));
        });
        if (legendRegion.length && this.chart.enableCanvas) {
            this.LegendClick(legendRegion[0].index, event);
        }
    };
    /**
     * To check click position is within legend bounds
     */
    Legend.prototype.checkWithinBounds = function (pageX, pageY) {
        var cRender = this.chart.renderer;
        var bounds = this.legendBounds;
        var borderWidth = this.chart.legendSettings.border.width;
        var canvasRect = new Rect(bounds.x, bounds.y, bounds.width, bounds.height);
        canvasRect.x = canvasRect.x - borderWidth / 2;
        canvasRect.y = canvasRect.y - borderWidth / 2;
        canvasRect.width = canvasRect.width + borderWidth;
        canvasRect.height = canvasRect.height + borderWidth;
        if (withInBounds(pageX, pageY, this.pagingRegions[0])) {
            // pageDown calculations are performing here
            if (!this.isRtlEnable) {
                this.canvasPageDown(cRender, canvasRect, bounds);
            }
            else {
                this.canvasPageUp(cRender, canvasRect, bounds);
            }
            return null;
        }
        if (withInBounds(pageX, pageY, this.pagingRegions[1])) {
            // pageUp calculations are performing here
            if (!this.isRtlEnable) {
                this.canvasPageUp(cRender, canvasRect, bounds);
            }
            else {
                this.canvasPageDown(cRender, canvasRect, bounds);
            }
            return null;
        }
    };
    Legend.prototype.canvasPageDown = function (cRender, canvasRect, bounds) {
        if (--this.currentPageNumber > 0) {
            this.legendRegions = [];
            cRender.clearRect(canvasRect);
            cRender.canvasClip(new RectOption('legendClipPath', 'transparent', { width: 0, color: '' }, null, canvasRect));
            this.renderLegend(this.chart, this.legend, bounds);
            cRender.canvasRestore();
        }
        else {
            ++this.currentPageNumber;
        }
    };
    Legend.prototype.canvasPageUp = function (cRender, canvasRect, bounds) {
        if (++this.currentPageNumber > 0 && this.currentPageNumber <= this.totalNoOfPages) {
            this.legendRegions = [];
            cRender.clearRect(canvasRect);
            cRender.canvasClip(new RectOption('legendClipPath', 'transpaent', { width: 0, color: '' }, null, canvasRect));
            this.renderLegend(this.chart, this.legend, bounds);
            cRender.canvasRestore();
        }
        else {
            --this.currentPageNumber;
        }
    };
    /**
     * Get module name
     */
    Legend.prototype.getModuleName = function () {
        return 'Legend';
    };
    /**
     * To destroy the Legend.
     *
     * @returns {void}
     * @private
     */
    Legend.prototype.destroy = function () {
        this.removeEventListener();
    };
    return Legend;
}(BaseLegend));

/**
 * Annotation Module handles the Annotation for chart and accumulation series.
 */
var AnnotationBase = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for chart and accumulation annotation
     *
     * @param control
     */
    function AnnotationBase(control) {
        this.control = control;
    }
    /**
     * Method to render the annotation for chart and accumulation series.
     *
     * @private
     * @param annotation
     * @param index
     */
    AnnotationBase.prototype.render = function (annotation, index) {
        this.isChart = this.control.getModuleName() === 'chart';
        this.annotation = annotation;
        var childElement = createTemplate(createElement('div', {
            id: this.control.element.id + '_Annotation_' + index,
            styles: 'position: absolute; z-index: 1' //by default z-index set for annotation elements
        }), index, annotation.content, this.control);
        return childElement;
    };
    /**
     * Method to calculate the location for annotation - coordinate unit as pixel.
     *
     * @private
     * @param location
     */
    AnnotationBase.prototype.setAnnotationPixelValue = function (location) {
        var rect = this.annotation.region === 'Chart' ?
            new Rect(0, 0, this.control.availableSize.width, this.control.availableSize.height) :
            this.isChart ?
                this.control.chartAxisLayoutPanel.seriesClipRect :
                this.control.series[0].accumulationBound;
        location.x = ((typeof this.annotation.x !== 'string') ?
            ((typeof this.annotation.x === 'number') ? this.annotation.x : 0) :
            stringToNumber(this.annotation.x, rect.width)) + rect.x;
        location.y = ((typeof this.annotation.y === 'number') ? this.annotation.y :
            stringToNumber(this.annotation.y, rect.height)) + rect.y;
        return true;
    };
    /**
     * Method to calculate the location for annotation - coordinate unit as point.
     *
     * @private
     * @param location
     */
    AnnotationBase.prototype.setAnnotationPointValue = function (location) {
        var symbolLocation = new ChartLocation(0, 0);
        if (this.isChart) {
            var chart = this.control;
            var annotation = this.annotation;
            var xAxisName = annotation.xAxisName;
            var yAxisName = annotation.yAxisName;
            var isInverted = chart.requireInvertedAxis;
            var stockChart = this.control.stockChart;
            var xAxis = void 0;
            var yAxis = void 0;
            var xValue = void 0;
            for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {
                var axis = _a[_i];
                if (xAxisName === axis.name || (xAxisName == null && axis.name === 'primaryXAxis')) {
                    xAxis = axis;
                    if (xAxis.valueType.indexOf('Category') > -1) {
                        var xAnnotation = xAxis.valueType === 'DateTimeCategory' ? (annotation.x.getTime()).toString() :
                            annotation.x;
                        if (xAxis.labels.indexOf(xAnnotation) < 0) {
                            return false;
                        }
                        else {
                            xValue = xAxis.labels.indexOf(xAnnotation);
                        }
                    }
                    else if (xAxis.valueType === 'DateTime') {
                        var option = { skeleton: 'full', type: 'dateTime' };
                        xValue = (typeof this.annotation.x === 'object' || typeof new Date(this.annotation.x) === 'object') ?
                            Date.parse(chart.intl.getDateParser(option)(chart.intl.getDateFormat(option)(new Date(DataUtil.parse.parseJson({ val: annotation.x }).val)))) : 0;
                    }
                    else {
                        xValue = +annotation.x;
                    }
                }
                else if (yAxisName === axis.name || (yAxisName == null && axis.name === 'primaryYAxis')) {
                    yAxis = axis;
                }
            }
            if (xAxis && yAxis && withIn(xAxis.valueType === 'Logarithmic' ? logBase(xValue, xAxis.logBase) : xValue, xAxis.visibleRange) && withIn(yAxis.valueType === 'Logarithmic' ? logBase(+annotation.y, yAxis.logBase) : +annotation.y, yAxis.visibleRange)) {
                symbolLocation = getPoint(xValue, +annotation.y, xAxis, yAxis, isInverted);
                location.x = symbolLocation.x + (isInverted ? yAxis.rect.x : xAxis.rect.x);
                // for stockchart, stockchart's toolbar height and title size is added for annotation content
                location.y = symbolLocation.y + (isInverted ? xAxis.rect.y : yAxis.rect.y) +
                    ((stockChart && stockChart.enablePeriodSelector) ? stockChart.toolbarHeight + stockChart.titleSize.height : 0);
            }
            else {
                return false;
            }
            return true;
        }
        else {
            return this.setAccumulationPointValue(location);
        }
    };
    /**
     * To process the annotation for accumulation chart.
     *
     * @param annotation
     * @param index
     * @param parentElement
     */
    AnnotationBase.prototype.processAnnotation = function (annotation, index, parentElement) {
        var chart = this.control;
        var location = new ChartLocation(0, 0);
        var annotationElement = this.render(annotation, index);
        var annotationRendered = function () {
            annotationElement.style.transform = 'translate(-50%, -50%)';
        };
        annotationRendered.bind(location, this);
        if (this['setAnnotation' + annotation.coordinateUnits + 'Value'](location)) {
            this.setElementStyle(location, annotationElement, parentElement);
        }
        else if (this.control.redraw) {
            removeElement$1(annotationElement.id);
        }
        updateBlazorTemplate((this.control.element.id + 'Annotation' + index).replace(/[^a-zA-Z0-9]/g, ''), 'ContentTemplate', chart.stockChart ? chart.stockChart.annotations[index] : this.control.annotations[index], undefined, annotationRendered);
    };
    /**
     * Method to calculate the location for annotation - coordinate unit as point in accumulation chart.
     *
     * @private
     * @param location
     */
    AnnotationBase.prototype.setAccumulationPointValue = function (location) {
        var accumulation = this.control;
        var point;
        for (var _i = 0, _a = accumulation.visibleSeries[0].points; _i < _a.length; _i++) {
            var accPoint = _a[_i];
            if (typeof accPoint.x === 'object') {
                if (Date.parse(accPoint.x) === Date.parse(this.annotation.x) &&
                    accPoint.y === this.annotation.y) {
                    point = accPoint;
                    break;
                }
            }
            else {
                if (accPoint.x === this.annotation.x && accPoint.y === this.annotation.y) {
                    point = accPoint;
                    break;
                }
            }
        }
        if (point && point.visible) {
            location.x = point.symbolLocation.x;
            location.y = point.symbolLocation.y;
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Method to set the element style for accumulation / chart annotation.
     *
     * @private
     * @param location
     * @param element
     * @param parentElement
     */
    AnnotationBase.prototype.setElementStyle = function (location, element, parentElement) {
        var elementRect = measureElementRect(element, this.control.redraw);
        var argsData = {
            cancel: false, name: annotationRender, content: element,
            location: location
        };
        this.control.trigger(annotationRender, argsData);
        if (!argsData.cancel) {
            argsData.content.style.left = this.setAlignmentValue(this.annotation.horizontalAlignment, elementRect.width, argsData.location.x) + 'px';
            argsData.content.style.top = this.setAlignmentValue(this.annotation.verticalAlignment, elementRect.height, argsData.location.y) + 'px';
            argsData.content.setAttribute('aria-label', this.annotation.description || 'Annotation');
            appendElement(argsData.content, parentElement, this.control.redraw, true, 'left', 'top');
        }
    };
    /**
     * Method to calculate the alignment value for annotation.
     *
     * @private
     * @param alignment
     * @param size
     * @param value
     */
    AnnotationBase.prototype.setAlignmentValue = function (alignment, size, value) {
        switch (alignment) {
            case 'Top':
            case 'Near':
                value -= size;
                break;
            case 'Bottom':
            case 'Far':
                value += 0;
                break;
            case 'Middle':
            case 'Center':
                value -= (size / 2);
                break;
        }
        return value;
    };
    return AnnotationBase;
}());

var __extends$58 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * `ChartAnnotation` module handles the annotation for chart.
 */
var ChartAnnotation = /** @__PURE__ @class */ (function (_super) {
    __extends$58(ChartAnnotation, _super);
    /**
     * Constructor for chart annotation.
     *
     * @private
     */
    function ChartAnnotation(control, annotations) {
        var _this = _super.call(this, control) || this;
        _this.chart = control;
        _this.annotations = annotations;
        return _this;
    }
    /**
     * Method to render the annotation for chart
     *
     * @param {Element} element annotation element
     * @private
     */
    ChartAnnotation.prototype.renderAnnotations = function (element) {
        var _this = this;
        this.annotations = this.chart.annotations;
        this.parentElement = redrawElement(this.chart.redraw, this.chart.element.id + '_Annotation_Collections') ||
            createElement('div', {
                id: this.chart.element.id + '_Annotation_Collections'
            });
        this.annotations.map(function (annotation, index) {
            _this.processAnnotation(annotation, index, _this.parentElement);
        });
        appendElement(this.parentElement, element, this.chart.redraw);
    };
    /**
     * To destroy the annotation.
     *
     * @returns {void}
     * @private
     */
    ChartAnnotation.prototype.destroy = function () {
        // Destroy method performed here
    };
    /**
     * Get module name.
     */
    ChartAnnotation.prototype.getModuleName = function () {
        // Returns te module name
        return 'Annotation';
    };
    return ChartAnnotation;
}(AnnotationBase));

var __extends$59 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `BoxAndWhiskerSeries` module is used to render the box and whisker series.
 */
var BoxAndWhiskerSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$59(BoxAndWhiskerSeries, _super);
    function BoxAndWhiskerSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render BoxAndWhisker series.
     *
     * @returns {void}
     * @private
     */
    BoxAndWhiskerSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {
        var sideBySideInfo = this.getSideBySideInfo(series);
        var argsData;
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var point = _a[_i];
            point.symbolLocations = [];
            point.regions = [];
            var centerRegion = void 0;
            if (point.visible && withInRange(series.points[point.index - 1], point, series.points[point.index + 1], series)) {
                this.findBoxPlotValues(point.y, point, series.boxPlotMode);
                //region to cover the top and bottom ticks
                this.updateTipRegion(series, point, sideBySideInfo);
                //get middle rect
                centerRegion = this.getRectangle((point.xValue + sideBySideInfo.start), point.upperQuartile, (point.xValue + sideBySideInfo.end), point.lowerQuartile, series);
                point.regions.push(centerRegion);
                argsData = this.triggerEvent(series, point, series.interior, {
                    color: (!isNullOrUndefined(series.border.color) && series.border.color !== 'transparent') ? series.border.color :
                        getSaturationColor(series.interior, -0.6),
                    width: series.border.width ? series.border.width : 1
                });
                if (!argsData.cancel) {
                    this.renderBoxAndWhisker(series, point, argsData, this.getPathString(point, series, getPoint(point.xValue, point.median, xAxis, yAxis, isInverted), getPoint(point.xValue + sideBySideInfo.median, point.average, xAxis, yAxis, isInverted)), sideBySideInfo.median);
                }
            }
        }
        if (series.marker.visible) {
            series.chart.markerRender.render(series);
        }
    };
    /**
     * update the tip region fo box plot
     *
     * @param {Series} series series
     * @param {Points} point point
     * @param {DoubleRange} sideBySideInfo sideBySideInfo
     * @returns {void}
     */
    BoxAndWhiskerSeries.prototype.updateTipRegion = function (series, point, sideBySideInfo) {
        var tipRegion = this.getRectangle((point.xValue + sideBySideInfo.median), point.maximum, (point.xValue + sideBySideInfo.median), point.minimum, series);
        this.updateTipSize(series, point, tipRegion, series.chart.requireInvertedAxis);
    };
    /**
     * Update tip size to tip regions
     *
     * @param {Series} series Series
     * @param {Points} point Points
     * @param {Rect} region rect region
     * @param {boolean} isInverted isInverted
     * @returns {void}
     */
    BoxAndWhiskerSeries.prototype.updateTipSize = function (series, point, region, isInverted) {
        var borderWidth = series.border.width || 1;
        if (!isInverted) {
            region.x -= borderWidth / 2;
            region.width = region.width || borderWidth;
        }
        else {
            region.y -= borderWidth / 2;
            region.height = region.height || borderWidth;
        }
        point.regions.push(region);
    };
    /**
     * Calculation for path direction performed here.
     *
     * @param {Points} point point
     * @param {Series} series series
     * @param {ChartLocation} median median
     * @param {ChartLocation} average average
     * @returns {string} direction
     */
    BoxAndWhiskerSeries.prototype.getPathString = function (point, series, median, average) {
        var topRect = point.regions[0];
        var midRect = point.regions[1];
        var direction = '';
        var center = series.chart.requireInvertedAxis ? topRect.y + topRect.height / 2 :
            topRect.x + topRect.width / 2;
        var midWidth = midRect.x + midRect.width;
        var midHeight = midRect.y + midRect.height;
        var topWidth = topRect.x + topRect.width;
        var topHeight = topRect.y + topRect.height;
        if (!series.chart.requireInvertedAxis) {
            this.updateTipSize(series, point, { x: midRect.x, y: topRect.y, width: midWidth - midRect.x, height: 0 }, true);
            this.updateTipSize(series, point, { x: midRect.x, y: topHeight, width: midWidth - midRect.x, height: 0 }, true);
            direction += 'M ' + midRect.x + ' ' + topRect.y + ' ' + ' L ' + midWidth + ' ' + topRect.y;
            direction += ' M ' + center + ' ' + topRect.y + ' ' + ' L ' + center + ' ' + midRect.y;
            direction += ' M ' + midRect.x + ' ' + midRect.y + ' ' + ' L ' + midWidth + ' ' + midRect.y +
                ' L ' + midWidth + ' ' + midHeight + ' L ' + midRect.x + ' ' + midHeight + ' Z';
            direction += ' M ' + center + ' ' + midHeight + ' L ' + center + ' ' + topHeight;
            direction += ' M ' + midRect.x + ' ' + topHeight + ' L ' + midWidth + ' ' + topHeight;
            direction += ' M ' + midRect.x + ' ' + median.y + ' L ' + midWidth + ' ' + median.y;
            direction += series.showMean ?
                ' M ' + (average.x - 5) + ' ' + (average.y - 5) + ' L ' + (average.x + 5) + ' ' + (average.y + 5) +
                    ' M ' + (average.x + 5) + ' ' + (average.y - 5) + ' L ' + (average.x - 5) + ' ' + (average.y + 5) : '';
        }
        else {
            this.updateTipSize(series, point, { x: topRect.x, y: midRect.y, width: 0, height: midHeight - midRect.y }, false);
            this.updateTipSize(series, point, { x: topWidth, y: midRect.y, width: 0, height: midHeight - midRect.y }, true);
            direction += 'M ' + topRect.x + ' ' + midRect.y + ' L ' + topRect.x + ' ' + midHeight;
            direction += 'M ' + topRect.x + ' ' + center + ' ' + ' L ' + midRect.x + ' ' + center;
            direction += ' M ' + midRect.x + ' ' + midRect.y + ' ' + ' L ' + midWidth + ' ' + midRect.y +
                ' L ' + midWidth + ' ' + midHeight + ' L ' + midRect.x + ' ' + midHeight + ' Z';
            direction += ' M ' + midWidth + ' ' + center + ' L ' + topWidth + ' ' + center;
            direction += ' M ' + topWidth + ' ' + midRect.y + ' L ' + topWidth + ' ' + midHeight;
            direction += ' M ' + median.x + ' ' + midRect.y + ' ' + ' L ' + median.x + ' ' + midHeight;
            direction += series.showMean ?
                'M ' + (average.x + 5) + ' ' + (average.y - 5) + ' L ' + (average.x - 5) + ' ' + (average.y + 5) +
                    'M ' + (average.x - 5) + ' ' + (average.y - 5) + ' L ' + (average.x + 5) + ' ' + (average.y + 5) : '';
        }
        return direction;
    };
    /**
     * Rendering for box and whisker append here.
     *
     * @param {Series} series series
     * @param {Points} point point
     * @param {IPointRenderEventArgs} argsData argsData
     * @param {string} direction path direction
     * @param {number} median median
     * @returns {void}
     */
    BoxAndWhiskerSeries.prototype.renderBoxAndWhisker = function (series, point, argsData, direction, median) {
        var location;
        var size;
        var symbolId = series.chart.element.id + '_Series_' + series.index + '_Point_' + point.index;
        var element = series.chart.renderer.drawPath(new PathOption(symbolId + '_BoxPath', argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.dashArray, direction));
        element.setAttribute('role', 'img');
        element.setAttribute('aria-label', point.x.toString() + ':' + point.maximum.toString()
            + ':' + point.minimum.toString() + ':' + point.lowerQuartile.toString() + ':' + point.upperQuartile.toString());
        var parentElement = series.chart.renderer.createGroup({
            'id': symbolId
        });
        parentElement.appendChild(element);
        for (var i = 0; i < point.outliers.length; i++) {
            location = getPoint((point.xValue + median), point.outliers[i], series.xAxis, series.yAxis, series.chart.requireInvertedAxis);
            size = new Size(series.marker.width, series.marker.height);
            point.symbolLocations.push(location);
            this.updateTipSize(series, point, {
                x: location.x - (size.width / 2), y: location.y - (size.height / 2),
                width: size.width, height: size.height
            }, true);
        }
        series.seriesElement.appendChild(parentElement);
    };
    /**
     * To find the box plot values.
     *
     * @param {number[]} yValues yValues
     * @param {Points} point point
     * @param {BoxPlotMode} mode mode
     * @returns {void}
     */
    BoxAndWhiskerSeries.prototype.findBoxPlotValues = function (yValues, point, mode) {
        var yCount = yValues.length;
        var quartile = {
            average: sum(yValues) / yCount,
            lowerQuartile: 0, upperQuartile: 0,
            maximum: 0, minimum: 0,
            median: 0, outliers: []
        };
        if (mode === 'Exclusive') {
            quartile.lowerQuartile = this.getExclusiveQuartileValue(yValues, yCount, 0.25);
            quartile.upperQuartile = this.getExclusiveQuartileValue(yValues, yCount, 0.75);
            quartile.median = this.getExclusiveQuartileValue(yValues, yCount, 0.5);
        }
        else if (mode === 'Inclusive') {
            quartile.lowerQuartile = this.getInclusiveQuartileValue(yValues, yCount, 0.25);
            quartile.upperQuartile = this.getInclusiveQuartileValue(yValues, yCount, 0.75);
            quartile.median = this.getInclusiveQuartileValue(yValues, yCount, 0.5);
        }
        else {
            quartile.median = getMedian(yValues);
            this.getQuartileValues(yValues, yCount, quartile);
        }
        this.getMinMaxOutlier(yValues, yCount, quartile);
        point.minimum = quartile.minimum;
        point.maximum = quartile.maximum;
        point.lowerQuartile = quartile.lowerQuartile;
        point.upperQuartile = quartile.upperQuartile;
        point.median = quartile.median;
        point.outliers = quartile.outliers;
        point.average = quartile.average;
    };
    /**
     * to find the exclusive quartile values
     *
     * @param {number[]} yValues yValues
     * @param {number} count count
     * @param {number} percentile percentile
     * @returns {number} exclusive quartile value
     */
    BoxAndWhiskerSeries.prototype.getExclusiveQuartileValue = function (yValues, count, percentile) {
        if (count === 0) {
            return 0;
        }
        else if (count === 1) {
            return yValues[0];
        }
        var value = 0;
        var rank = percentile * (count + 1);
        var integerRank = Math.floor(Math.abs(rank));
        var fractionRank = rank - integerRank;
        if (integerRank === 0) {
            value = yValues[0];
        }
        else if (integerRank > count - 1) {
            value = yValues[count - 1];
        }
        else {
            value = fractionRank * (yValues[integerRank] - yValues[integerRank - 1]) + yValues[integerRank - 1];
        }
        return value;
    };
    /**
     * to find the inclusive quartile values
     *
     * @param {number[]} yValues yValues
     * @param {number} count count
     * @param {number} percentile percentile
     * @returns {number} inclusive quartile value
     */
    BoxAndWhiskerSeries.prototype.getInclusiveQuartileValue = function (yValues, count, percentile) {
        if (count === 0) {
            return 0;
        }
        else if (count === 1) {
            return yValues[0];
        }
        var value = 0;
        var rank = percentile * (count - 1);
        var integerRank = Math.floor(Math.abs(rank));
        var fractionRank = rank - integerRank;
        value = fractionRank * (yValues[integerRank + 1] - yValues[integerRank]) + yValues[integerRank];
        return value;
    };
    /**
     * To find the quartile values
     *
     * @param {number[]} yValues yValues
     * @param {number} count count
     * @param {IBoxPlotQuartile} quartile quartile
     * @returns {void}
     */
    BoxAndWhiskerSeries.prototype.getQuartileValues = function (yValues, count, quartile) {
        if (count === 1) {
            quartile.lowerQuartile = yValues[0];
            quartile.upperQuartile = yValues[0];
            return null;
        }
        var isEvenList = count % 2 === 0;
        var halfLength = count / 2;
        var lowerQuartileArray = yValues.slice(0, halfLength);
        var upperQuartileArray = yValues.slice(isEvenList ? halfLength : halfLength + 1, count);
        quartile.lowerQuartile = getMedian(lowerQuartileArray);
        quartile.upperQuartile = getMedian(upperQuartileArray);
    };
    /**
     * To find the min, max and outlier values
     *
     * @param {number[]} yValues yValues
     * @param {number} count count
     * @param {IBoxPlotQuartile} quartile quartile
     * @returns {void}
     */
    BoxAndWhiskerSeries.prototype.getMinMaxOutlier = function (yValues, count, quartile) {
        var interquartile = quartile.upperQuartile - quartile.lowerQuartile;
        var rangeIQR = 1.5 * interquartile;
        for (var i = 0; i < count; i++) {
            if (yValues[i] < quartile.lowerQuartile - rangeIQR) {
                quartile.outliers.push(yValues[i]);
            }
            else {
                quartile.minimum = yValues[i];
                break;
            }
        }
        for (var i = count - 1; i >= 0; i--) {
            if (yValues[i] > quartile.upperQuartile + rangeIQR) {
                quartile.outliers.push(yValues[i]);
            }
            else {
                quartile.maximum = yValues[i];
                break;
            }
        }
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    BoxAndWhiskerSeries.prototype.doAnimation = function (series) {
        this.animate(series);
    };
    /**
     * Get module name.
     *
     * @returns {string} module name
     */
    BoxAndWhiskerSeries.prototype.getModuleName = function () {
        return 'BoxAndWhiskerSeries';
        /**
         * return the module name
         */
    };
    /**
     * To destroy the candle series.
     *
     * @returns {void}
     * @private
     */
    BoxAndWhiskerSeries.prototype.destroy = function () {
        /**
         * Destroys the candle series.
         */
    };
    return BoxAndWhiskerSeries;
}(ColumnBase));

var __extends$60 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `MultiColoredAreaSeries` module used to render the area series with multi color.
 */
var MultiColoredAreaSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$60(MultiColoredAreaSeries, _super);
    function MultiColoredAreaSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render Area series.
     *
     * @returns {void}
     * @private
     */
    MultiColoredAreaSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {
        var _this = this;
        var firstPoint;
        var startPoint = null;
        var direction = '';
        var origin = Math.max(series.yAxis.visibleRange.min, 0);
        var options = [];
        var startRegion;
        var previous;
        var rendered;
        var segments = this.sortSegments(series, series.segments);
        var emptyPointDirection = '';
        series.visiblePoints.map(function (point, i, seriesPoints) {
            point.symbolLocations = [];
            point.regions = [];
            rendered = false;
            if (point.visible && withInRange(seriesPoints[i - 1], point, seriesPoints[i + 1], series)) {
                direction += _this.getAreaPathDirection(point.xValue, origin, series, isInverted, getPoint, startPoint, 'M');
                startPoint = startPoint || new ChartLocation(point.xValue, origin);
                firstPoint = getPoint(point.xValue, point.yValue, xAxis, yAxis, isInverted);
                if (previous && _this.setPointColor(point, previous, series, series.segmentAxis === 'X', segments)) {
                    rendered = true;
                    startRegion = getPoint(startPoint.x, origin, xAxis, yAxis, isInverted);
                    direction += ('L' + ' ' + (firstPoint.x) + ' ' + (firstPoint.y) + ' ');
                    direction += ('L' + ' ' + (firstPoint.x) + ' ' + (startRegion.y) + ' ');
                    _this.generatePathOption(options, series, previous, direction, '_Point_' + previous.index);
                    direction = 'M' + ' ' + (firstPoint.x) + ' ' + (startRegion.y) + ' ' + 'L' + ' ' +
                        (firstPoint.x) + ' ' + (firstPoint.y) + ' ';
                }
                else {
                    direction += ('L' + ' ' + (firstPoint.x) + ' ' + (firstPoint.y) + ' ');
                    _this.setPointColor(point, null, series, series.segmentAxis === 'X', segments);
                }
                if (seriesPoints[i + 1] && !seriesPoints[i + 1].visible && series.emptyPointSettings.mode !== 'Drop') {
                    direction += _this.getAreaEmptyDirection({ 'x': point.xValue, 'y': origin }, startPoint, series, isInverted, getPoint);
                    startPoint = null;
                }
                previous = point;
                _this.storePointLocation(point, series, isInverted, getPoint);
            }
        });
        if (!isNullOrUndefined(rendered) && !rendered) {
            direction = series.points.length > 1 ?
                (direction + this.getAreaPathDirection(previous.xValue, origin, series, isInverted, getPoint, null, 'L')) : '';
            this.generatePathOption(options, series, previous, direction, '');
        }
        if (series.border.width !== 0) {
            emptyPointDirection = this.removeEmptyPointsBorder(this.getBorderDirection(direction));
            this.generateBorderPathOption(options, series, previous, emptyPointDirection, '');
        }
        this.applySegmentAxis(series, options, segments);
        this.renderMarker(series);
    };
    /**
     * To Store the path directions of the area
     */
    MultiColoredAreaSeries.prototype.generatePathOption = function (options, series, point, direction, id) {
        options.push(new PathOption(series.chart.element.id + '_Series_' + series.index + id, series.setPointColor(point, series.interior), 0, 'transparent', series.opacity, series.dashArray, direction));
    };
    /**
     * To draw border for the path directions of area
     */
    MultiColoredAreaSeries.prototype.generateBorderPathOption = function (options, series, point, emptyPointDirection, id) {
        options.push(new PathOption(series.chart.element.id + '_Series_border_' + series.index + id, 'transparent', series.border.width, series.border.color ? series.border.color : series.interior, 1, series.dashArray, emptyPointDirection));
    };
    /**
     * To destroy the area series.
     *
     * @returns {void}
     * @private
     */
    MultiColoredAreaSeries.prototype.destroy = function () {
        /**
         * Destroy method calling here
         */
    };
    /**
     * Get module name
     */
    MultiColoredAreaSeries.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'MultiColoredAreaSeries';
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    MultiColoredAreaSeries.prototype.doAnimation = function (series) {
        this.doLinearAnimation(series, series.animation);
    };
    return MultiColoredAreaSeries;
}(MultiColoredSeries));

var __extends$61 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * `MultiColoredLineSeries` used to render the line series with multi color.
 */
var MultiColoredLineSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$61(MultiColoredLineSeries, _super);
    function MultiColoredLineSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render Line Series.
     *
     * @returns {void}
     * @private
     */
    MultiColoredLineSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {
        var previous = null;
        var startPoint = 'M';
        var visiblePoints = this.enableComplexProperty(series);
        var options = [];
        var direction = '';
        var lastPoint;
        var segmentPoint = null;
        var segments = this.sortSegments(series, series.segments);
        for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {
            var point = visiblePoints_1[_i];
            point.regions = [];
            if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {
                lastPoint = point;
                direction += this.getLineDirection(previous, point, series, isInverted, getPoint, startPoint);
                if (previous != null) {
                    if (this.setPointColor(point, previous, series, series.segmentAxis === 'X', segments)) {
                        options.push(new PathOption(series.chart.element.id + '_Series_' + series.index + '_Point_' + previous.index, 'none', series.width, series.setPointColor(previous, series.interior), series.opacity, series.dashArray, direction));
                        startPoint = 'M';
                        direction = '';
                    }
                    else {
                        startPoint = 'L';
                    }
                }
                else {
                    if (this.setPointColor(point, segmentPoint, series, series.segmentAxis === 'X', segments) && direction !== '') {
                        options.push(new PathOption(series.chart.element.id + '_Series_' + series.index + '_Point_' + segmentPoint.index, 'none', series.width, series.setPointColor(segmentPoint, series.interior), series.opacity, series.dashArray, direction));
                        startPoint = 'M';
                        direction = '';
                    }
                }
                previous = point;
                segmentPoint = point;
                this.storePointLocation(point, series, isInverted, getPoint);
            }
            else {
                previous = (series.emptyPointSettings.mode === 'Drop') ? previous : null;
                startPoint = (series.emptyPointSettings.mode === 'Drop') ? startPoint : 'M';
                point.symbolLocations = [];
            }
        }
        if (direction !== '') {
            options.push(new PathOption(series.chart.element.id + '_Series_' + series.index, 'none', series.width, series.setPointColor(lastPoint, series.interior), series.opacity, series.dashArray, direction));
        }
        this.applySegmentAxis(series, options, segments);
        this.renderMarker(series);
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    MultiColoredLineSeries.prototype.doAnimation = function (series) {
        this.doLinearAnimation(series, series.animation);
    };
    /**
     * Get module name.
     */
    MultiColoredLineSeries.prototype.getModuleName = function () {
        /**
         * Returns the module name of the series
         */
        return 'MultiColoredLineSeries';
    };
    /**
     * To destroy the line series.
     *
     * @returns {void}
     * @private
     */
    MultiColoredLineSeries.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return MultiColoredLineSeries;
}(MultiColoredSeries));

/**
 * `MultiLevelLabel` module is used to render the multi level label in chart.
 */
var MultiLevelLabel = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for the logerithmic module.
     *
     * @private
     */
    function MultiLevelLabel(chart) {
        /** @private */
        this.xAxisPrevHeight = [];
        /** @private */
        this.xAxisMultiLabelHeight = [];
        /** @private */
        this.yAxisPrevHeight = [];
        /** @private */
        this.yAxisMultiLabelHeight = [];
        /** @private */
        this.multiLevelLabelRectXRegion = [];
        /** @private */
        this.xLabelCollection = [];
        this.chart = chart;
        this.addEventListener();
    }
    /**
     * Binding events for multi level module.
     */
    MultiLevelLabel.prototype.addEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.on('click', this.click, this);
    };
    /**
     * Finds multilevel label height.
     *
     * @returns {void}
     */
    MultiLevelLabel.prototype.getMultilevelLabelsHeight = function (axis) {
        var _this = this;
        var value = 0;
        var multiLevelLabelsHeight = [];
        var prevHeight = [];
        var isVertical = axis.orientation === 'Vertical';
        var axisValue = isVertical ? axis.rect.height : axis.rect.width;
        var labelSize;
        var height;
        var padding = 10;
        var gap;
        axis.multiLevelLabels.map(function (multiLevel, index) {
            multiLevel.categories.map(function (categoryLabel, i) {
                if (categoryLabel.text !== '' && categoryLabel.start !== null && categoryLabel.end !== null) {
                    labelSize = measureText(categoryLabel.text, multiLevel.textStyle, _this.chart.themeStyle.axisLabelFont);
                    height = isVertical ? labelSize.width : labelSize.height;
                    height += 2 * multiLevel.border.width +
                        (multiLevel.border.type === 'CurlyBrace' ? padding : 0);
                    gap = (categoryLabel.maximumTextWidth !== null) ? categoryLabel.maximumTextWidth :
                        (valueToCoefficient(typeof categoryLabel.end === 'string' ? Number(new Date(categoryLabel.end)) :
                            categoryLabel.end, axis) * axisValue) -
                            (valueToCoefficient(typeof categoryLabel.start === 'string' ? Number(new Date(categoryLabel.start)) :
                                categoryLabel.start, axis) * axisValue);
                    var len = axis.multiLevelLabels[index].categories.length;
                    gap = ((i === 0 || i === len - 1) && axis.labelPlacement === 'OnTicks' && axis.edgeLabelPlacement === 'Shift') ? gap / 2 : gap;
                    if ((labelSize.width > gap - padding) && gap > 0 && (multiLevel.overflow === 'Wrap') && !isVertical) {
                        height = (height * (textWrap(categoryLabel.text, gap - padding, multiLevel.textStyle, _this.chart.enableRtl, null, null, _this.chart.themeStyle.axisLabelFont).length));
                    }
                    multiLevelLabelsHeight[index] = !multiLevelLabelsHeight[index] ? height :
                        ((multiLevelLabelsHeight[index] < height) ? height : multiLevelLabelsHeight[index]);
                }
            });
            prevHeight[index] = value;
            value += multiLevelLabelsHeight[index] ? (multiLevelLabelsHeight[index] + padding) : 0;
        });
        axis.multiLevelLabelHeight = value + ((axis.title !== '' || (this.chart.legendModule && this.chart.legendSettings.visible))
            ? padding / 2 : 0);
        if (isVertical) {
            this.yAxisMultiLabelHeight = multiLevelLabelsHeight;
            this.yAxisPrevHeight = prevHeight;
        }
        else {
            this.xAxisMultiLabelHeight = multiLevelLabelsHeight;
            this.xAxisPrevHeight = prevHeight;
        }
    };
    /**
     * render x axis multi level labels
     *
     * @private
     * @returns {void}
     */
    MultiLevelLabel.prototype.renderXAxisMultiLevelLabels = function (axis, index, parent, axisRect) {
        var _this = this;
        var x;
        var y;
        var padding = 10;
        var startX;
        var pointIndex;
        var startY = (axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0) +
            (axis.maxLabelSize.height) + padding;
        var endX;
        var pathRect = '';
        var start;
        var end;
        var labelSize;
        var isOutside = axis.labelPosition === 'Outside';
        var gap;
        var anchor;
        var isInversed = axis.isAxisInverse;
        var argsData;
        var opposedPosition = axis.isAxisOpposedPosition;
        var len;
        var scrollBarHeight = axis.scrollbarSettings.enable || (isOutside && isNullOrUndefined(axis.crossesAt)) ?
            axis.scrollBarHeight : 0;
        var clipY = ((opposedPosition && !isOutside) || (!opposedPosition && isOutside)) ?
            (axisRect.y + startY - axis.majorTickLines.width) : (axisRect.y - startY - axis.multiLevelLabelHeight);
        this.createClipRect(axisRect.x - axis.majorTickLines.width, clipY + scrollBarHeight, axis.multiLevelLabelHeight + padding, axisRect.width + 2 * axis.majorTickLines.width, this.chart.element.id + '_XAxis_Clippath_' + index, this.chart.element.id + 'XAxisMultiLevelLabel' + index);
        axis.multiLevelLabels.map(function (multiLevel, level) {
            pointIndex = 0;
            _this.labelElement = _this.chart.renderer.createGroup({ id: _this.chart.element.id + index + '_MultiLevelLabel' + level });
            multiLevel.categories.map(function (categoryLabel, i) {
                len = multiLevel.categories.length;
                pathRect = '';
                start = typeof categoryLabel.start === 'string' ? Number(new Date(categoryLabel.start)) : categoryLabel.start;
                end = typeof categoryLabel.end === 'string' ? Number(new Date(categoryLabel.end)) : categoryLabel.end;
                argsData = _this.triggerMultiLabelRender(axis, categoryLabel.text, axis.multiLevelLabels[level].textStyle, axis.multiLevelLabels[level].alignment, categoryLabel.customAttributes);
                if (!argsData.cancel) {
                    startX = valueToCoefficient(start, axis) * axisRect.width;
                    endX = valueToCoefficient(end, axis) * axisRect.width;
                    endX = isInversed ? [startX, startX = endX][0] : endX;
                    labelSize = measureText(argsData.text, argsData.textStyle, _this.chart.themeStyle.axisLabelFont);
                    gap = ((categoryLabel.maximumTextWidth === null) ? endX - startX : categoryLabel.maximumTextWidth) - padding;
                    x = startX + axisRect.x + padding;
                    y = (((opposedPosition && !isOutside) || (!opposedPosition && isOutside)) ? (startY + axisRect.y +
                        labelSize.height / 2 + padding + _this.xAxisPrevHeight[level]) : (axisRect.y - startY + labelSize.height / 2 -
                        _this.xAxisMultiLabelHeight[level] - _this.xAxisPrevHeight[level])) + scrollBarHeight;
                    if (argsData.alignment === 'Center') {
                        x += (endX - startX - padding) / 2;
                        anchor = 'middle';
                    }
                    else if (argsData.alignment === 'Far') {
                        x = x + (endX - startX - padding) - multiLevel.border.width / 2;
                        if (axis.labelPlacement === 'OnTicks' && (i === 0 || i === len - 1)) {
                            x += (endX - startX - padding) / 2;
                            x = x - labelSize.width / 2;
                        }
                        anchor = 'end';
                    }
                    else {
                        anchor = 'start';
                        x += multiLevel.border.width / 2;
                    }
                    y = multiLevel.border.type === 'CurlyBrace' ?
                        (((!opposedPosition && isOutside) || (opposedPosition && !isOutside)) ? y + padding : y - padding / 2) : y;
                    var options = new TextOption(_this.chart.element.id + index + '_Axis_MultiLevelLabel_Level_' + level + '_Text_' + i, x, y, anchor, argsData.text);
                    if (multiLevel.overflow !== 'None') {
                        if (axis.edgeLabelPlacement && axis.labelPlacement === 'OnTicks') {
                            switch (axis.edgeLabelPlacement) {
                                case 'None':
                                    break;
                                case 'Shift':
                                    if ((i === 0 || (isInversed && i === len - 1))) {
                                        if (argsData.alignment === 'Center' && ((options.x < axisRect.x + padding) || (options.x - labelSize.width / 2)) < axis.rect.x) {
                                            options.x += axisRect.x / 2;
                                            if ((options.x / 2) < axisRect.x) {
                                                options.x = axisRect.x + padding / 2;
                                                options.anchor = 'start';
                                            }
                                        }
                                        else if (argsData.alignment === 'Far' && ((options.x < axisRect.x + padding) || (options.x > axisRect.x + padding))) {
                                            options.x += labelSize.width / 2 - gap / 2;
                                        }
                                        else if (argsData.alignment === 'Near' && ((options.x < axisRect.x + padding) || (options.x > axisRect.x + padding))) {
                                            options.x = axisRect.x + padding;
                                        }
                                        gap = gap / 2;
                                    }
                                    else if ((i === len - 1 || (isInversed && i === 0))) {
                                        if (argsData.alignment === 'Center' && (options.x) > axisRect.x + axisRect.width) {
                                            options.x -= padding;
                                            if (options.x > axisRect.width) {
                                                options.x = axisRect.width + axisRect.x;
                                                options.anchor = 'end';
                                            }
                                        }
                                        else if (argsData.alignment === 'Far') {
                                            options.x = axisRect.width + axisRect.x;
                                        }
                                        else {
                                            options.x = options.x;
                                        }
                                        gap = gap / 2;
                                    }
                                    break;
                            }
                        }
                        options.text = (multiLevel.overflow === 'Wrap') ?
                            textWrap(argsData.text, gap, argsData.textStyle, _this.chart.enableRtl, null, null, _this.chart.themeStyle.axisLabelFont) : textTrim(gap, argsData.text, argsData.textStyle, _this.chart.enableRtl, _this.chart.themeStyle.axisLabelFont);
                        options.x = options.x - padding / 2;
                    }
                    textElement$1(_this.chart.renderer, options, argsData.textStyle, argsData.textStyle.color || _this.chart.themeStyle.axisLabelFont.color, _this.labelElement, false, _this.chart.redraw, true, null, null, null, null, null, _this.chart.enableCanvas, null, _this.chart.themeStyle.axisLabelFont);
                    if (_this.chart.enableCanvas) {
                        var textSize = measureText(argsData.text, argsData.textStyle, _this.chart.themeStyle.axisLabelFont);
                        _this.multiLevelLabelRectXRegion.push(new Rect(options.x, options.y, textSize.width, textSize.height));
                        _this.xLabelCollection.push(options);
                    }
                    if (multiLevel.border.width > 0 && multiLevel.border.type !== 'WithoutBorder') {
                        pathRect = _this.renderXAxisLabelBorder(level, endX - startX - padding, axis, startX, startY, labelSize, options, axisRect, argsData.alignment, pathRect, isOutside, opposedPosition, pointIndex);
                        // fix for generating seperate rect
                        if (pathRect !== '') {
                            _this.createBorderElement(level, index, axis, pathRect, pointIndex);
                            pointIndex++;
                        }
                    }
                    if (!_this.chart.enableCanvas) {
                        _this.multiElements.appendChild(_this.labelElement);
                    }
                }
            });
        });
        if (!this.chart.enableCanvas) {
            parent.appendChild(this.multiElements);
        }
    };
    /**
     * render x axis multi level labels border
     *
     * @private
     * @returns {void}
     */
    MultiLevelLabel.prototype.renderXAxisLabelBorder = function (labelIndex, gap, axis, startX, startY, labelSize, textOptions, axisRect, alignment, path, isOutside, opposedPosition, categoryIndex) {
        var padding = 10;
        var padding1;
        var padding2;
        var value;
        var value1;
        var groupLabel = axis.multiLevelLabels[labelIndex];
        var categoryType = groupLabel.categories[categoryIndex].type;
        var width = gap + padding;
        var height = this.xAxisMultiLabelHeight[labelIndex] + padding;
        var scrollBarHeight = axis.labelPosition === 'Outside' ? axis.scrollBarHeight : 0;
        var x = startX + axisRect.x;
        var y = ((!opposedPosition && isOutside) || (opposedPosition && !isOutside)) ? (startY + axisRect.y +
            this.xAxisPrevHeight[labelIndex] + scrollBarHeight) : (axisRect.y - startY -
            this.xAxisPrevHeight[labelIndex] - scrollBarHeight);
        var borderType = categoryType ? categoryType : groupLabel.border.type;
        switch (borderType) {
            case 'WithoutTopandBottomBorder':
            case 'Rectangle':
            case 'WithoutTopBorder':
                var len = axis.multiLevelLabels[labelIndex].categories.length;
                var lastX = (categoryIndex === len - 1 && (x + width > axisRect.width)) ? axisRect.width + axisRect.x : x + width;
                var initialX = (categoryIndex === 0 && axis.multiLevelLabels[labelIndex].categories[0].start <= 0) ? axisRect.x : x;
                height = ((!opposedPosition && isOutside) || (opposedPosition && !isOutside)) ? height : -height;
                path += 'M ' + initialX + ' ' + y + ' L ' + initialX + ' ' + (y + height) + ' M ' + (lastX) + ' '
                    + y + ' L ' + (lastX) + ' ' + (y + height);
                path += (borderType !== 'WithoutTopandBottomBorder') ? (' L' + ' ' + (initialX) + ' ' + (y + height) + ' ') : ' ';
                path += (borderType === 'Rectangle') ? ('M ' + initialX + ' ' + y + ' L ' + (lastX) + ' ' + y) : ' ';
                break;
            case 'Brace':
                if (alignment === 'Near') {
                    value = textOptions.x;
                    value1 = textOptions.x + labelSize.width + 2;
                }
                else if (alignment === 'Center') {
                    value = textOptions.x - labelSize.width / 2 - 2;
                    value1 = textOptions.x + labelSize.width / 2 + 2;
                }
                else {
                    value = textOptions.x - labelSize.width - 2;
                    value1 = textOptions.x;
                }
                height = ((!opposedPosition && isOutside) || (opposedPosition && !isOutside)) ? height : -height;
                path += 'M ' + x + ' ' + y + ' L ' + x + ' ' + (y + height / 2) +
                    ' M ' + x + ' ' + (y + height / 2) + ' L ' + (value - 2) + ' ' + (y + height / 2) +
                    ' M ' + (value1) + ' ' + (y + height / 2) + ' L ' + (x + width) + ' ' + (y + height / 2) +
                    ' M ' + (x + width) + ' ' + (y + height / 2) + ' L ' + (x + width) + ' ' + (y);
                break;
            case 'CurlyBrace':
                if ((!opposedPosition && isOutside) || (opposedPosition && !isOutside)) {
                    padding = 10;
                    padding1 = 15;
                    padding2 = 5;
                }
                else {
                    padding = -10;
                    padding1 = -15;
                    padding2 = -5;
                }
                if (alignment === 'Center') {
                    path += 'M ' + x + ' ' + y + ' C ' + x + ' ' + y + ' ' + (x + 5) + ' ' + (y + padding) + ' ' + (x + 10) + ' ' +
                        (y + padding) + ' L ' + (x + width / 2 - 5) + ' ' + (y + padding) + ' L ' + (x + width / 2) + ' ' + (y + padding1) +
                        ' L ' + (x + width / 2 + 5) + ' ' + (y + padding) + ' L ' + (x + width - 10) + ' ' + (y + padding) + ' C ' +
                        (x + width - 10) + ' ' + (y + padding) + ' ' + (x + width) + ' ' + (y + padding2) + ' ' + (x + width) + ' ' + (y);
                }
                else if (alignment === 'Near') {
                    path += 'M ' + x + ' ' + y + ' C ' + x + ' ' + y + ' ' + (x + 5) + ' ' + (y + padding) + ' ' + (x + 10) + ' ' +
                        (y + padding) + ' L ' + (x + 15) + ' ' + (y + padding1) + ' L ' + (x + 20) + ' ' + (y + padding) + ' L ' +
                        (x + width - 10) + ' ' + (y + padding) + ' C ' + (x + width - 10) + ' ' + (y + padding) + ' ' + (x + width) + ' '
                        + (y + padding2) + ' ' + (x + width) + ' ' + (y);
                }
                else {
                    path += 'M ' + x + ' ' + y + ' C ' + x + ' ' + y + ' ' + (x + 5) + ' ' + (y + padding) + ' ' + (x + 10) + ' ' +
                        (y + padding) + ' L ' + (x + width - 20) + ' ' + (y + padding) + ' L ' + (x + width - 15) + ' ' + (y + padding1) +
                        ' L ' + (x + width - 10) + ' ' + (y + padding) + ' L ' + (x + width - 10) + ' ' + (y + padding) + ' C '
                        + (x + width - 10) + ' ' + (y + padding) + ' ' + (x + width) + ' ' + (y + padding2) + ' ' + (x + width) + ' ' + (y);
                }
                break;
        }
        return path;
    };
    /**
     * render y axis multi level labels
     *
     * @private
     * @returns {void}
     */
    MultiLevelLabel.prototype.renderYAxisMultiLevelLabels = function (axis, index, parent, rect) {
        var _this = this;
        var labelSize;
        var isOutside = axis.labelPosition === 'Outside';
        var x;
        var y;
        var padding = 10;
        var startX = (axis.tickPosition === axis.labelPosition ? axis.majorTickLines.height : 0) +
            (axis.maxLabelSize.width) + padding;
        var startY;
        var path = '';
        var endY;
        var argsData;
        var pointIndex;
        var isInversed = axis.isAxisInverse;
        var start;
        var end;
        var gap;
        var anchor = 'middle';
        var opposedPosition = axis.isAxisOpposedPosition;
        var scrollBarHeight = isOutside && isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight : 0;
        scrollBarHeight = scrollBarHeight * (opposedPosition ? 1 : -1);
        var clipX = ((opposedPosition && !isOutside) || (!opposedPosition && isOutside)) ?
            (rect.x - axis.multiLevelLabelHeight - startX - padding) : (rect.x + startX);
        this.createClipRect(clipX + scrollBarHeight, rect.y - axis.majorTickLines.width, rect.height + 2 * axis.majorTickLines.width, axis.multiLevelLabelHeight + padding, this.chart.element.id + '_YAxis_Clippath_' + index, this.chart.element.id
            + 'YAxisMultiLevelLabel' + index);
        axis.multiLevelLabels.map(function (multiLevel, level) {
            _this.labelElement = _this.chart.renderer.createGroup({ id: _this.chart.element.id + index + '_MultiLevelLabel' + level });
            pointIndex = 0;
            multiLevel.categories.map(function (categoryLabel, i) {
                path = '';
                end = typeof categoryLabel.end === 'string' ? Number(new Date(categoryLabel.end)) : categoryLabel.end;
                start = typeof categoryLabel.start === 'string' ? Number(new Date(categoryLabel.start)) : categoryLabel.start;
                startY = valueToCoefficient((start), axis) * (rect.height);
                endY = valueToCoefficient((end), axis) * (rect.height);
                endY = isInversed ? [startY, startY = endY][0] : endY;
                argsData = _this.triggerMultiLabelRender(axis, categoryLabel.text, multiLevel.textStyle, multiLevel.alignment, categoryLabel.customAttributes);
                if (!argsData.cancel) {
                    var maximumWidth = ((categoryLabel.maximumTextWidth === null ? (_this.yAxisMultiLabelHeight[level] / 2) : categoryLabel.maximumTextWidth / 2));
                    labelSize = measureText(argsData.text, argsData.textStyle, _this.chart.themeStyle.axisLabelFont);
                    gap = endY - startY;
                    x = rect.x - startX - _this.yAxisPrevHeight[level] -
                        (maximumWidth) - padding / 2;
                    y = rect.height + rect.y - startY - (gap / 2);
                    if (opposedPosition) {
                        x = isOutside ? rect.x + startX + padding / 2 + (maximumWidth) +
                            _this.yAxisPrevHeight[level] + scrollBarHeight : rect.x - startX - (maximumWidth) -
                            _this.yAxisPrevHeight[level] - padding / 2;
                    }
                    else {
                        x = isOutside ? x + scrollBarHeight : rect.x + startX + padding / 2 + (maximumWidth) +
                            _this.yAxisPrevHeight[level];
                    }
                    if (argsData.alignment === 'Center') {
                        y += labelSize.height / 4;
                    }
                    else if (argsData.alignment === 'Far') {
                        y += gap / 2 - labelSize.height / 2;
                    }
                    else {
                        y = y - gap / 2 + labelSize.height;
                    }
                    x = multiLevel.border.type === 'CurlyBrace' ? (((!opposedPosition && isOutside) ||
                        (opposedPosition && !isOutside)) ? x - padding : x + padding) : x;
                    var options = new TextOption(_this.chart.element.id + index + '_Axis_MultiLevelLabel_Level_' + level + '_Text_' + i, x, y, anchor, argsData.text);
                    options.text = (multiLevel.overflow === 'Trim') ?
                        textTrim((categoryLabel.maximumTextWidth === null ? _this.yAxisMultiLabelHeight[level] :
                            categoryLabel.maximumTextWidth), argsData.text, argsData.textStyle, _this.chart.enableRtl, _this.chart.themeStyle.axisLabelFont) : options.text;
                    options.text = (multiLevel.overflow === 'Wrap') ?
                        textWrap(argsData.text, (categoryLabel.maximumTextWidth === null ? _this.yAxisMultiLabelHeight[level] :
                            categoryLabel.maximumTextWidth), argsData.textStyle, _this.chart.enableRtl, null, null, _this.chart.themeStyle.axisLabelFont) : options.text;
                    if (typeof options.text !== 'string' && options.text.length > 1) {
                        options.y -= (padding * options.text.length / 2);
                    }
                    textElement$1(_this.chart.renderer, options, argsData.textStyle, argsData.textStyle.color || _this.chart.themeStyle.axisLabelFont.color, _this.labelElement, _this.chart.redraw, true, null, null, null, null, null, null, _this.chart.enableCanvas, null, _this.chart.themeStyle.axisLabelFont);
                    if (multiLevel.border.width > 0 && multiLevel.border.type !== 'WithoutBorder') {
                        path = _this.renderYAxisLabelBorder(level, gap, axis, endY, startX, startY, labelSize, options, rect, argsData.alignment, path, isOutside, opposedPosition, pointIndex);
                        if (path !== '') {
                            _this.createBorderElement(level, index, axis, path, pointIndex);
                            pointIndex++;
                        }
                    }
                    if (!_this.chart.enableCanvas) {
                        _this.multiElements.appendChild(_this.labelElement);
                    }
                }
            });
        });
        if (!this.chart.enableCanvas) {
            parent.appendChild(this.multiElements);
        }
    };
    /**
     * render y axis multi level labels border
     *
     * @private
     * @returns {void}
     */
    MultiLevelLabel.prototype.renderYAxisLabelBorder = function (labelIndex, gap, axis, endY, startX, startY, labelSize, textOptions, rect, alignment, path, isOutside, opposedPosition, categoryIndex) {
        var height = endY - startY;
        var padding = 10;
        var padding1;
        var padding2;
        var groupLabel = axis.multiLevelLabels[labelIndex];
        var categoryType = groupLabel.categories[categoryIndex].type;
        var y = rect.y + rect.height - endY;
        var scrollBarHeight = isOutside && isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight : 0;
        scrollBarHeight = scrollBarHeight * (opposedPosition ? 1 : -1);
        var width = (groupLabel.categories[categoryIndex].maximumTextWidth === null ? this.yAxisMultiLabelHeight[labelIndex] :
            (groupLabel.categories[categoryIndex].maximumTextWidth)) + padding;
        var x = (((!opposedPosition && isOutside) || (opposedPosition && !isOutside)) ? rect.x - startX -
            this.yAxisPrevHeight[labelIndex] : rect.x + startX + this.yAxisPrevHeight[labelIndex]) + scrollBarHeight;
        var borderType = categoryType ? categoryType : groupLabel.border.type;
        switch (borderType) {
            case 'WithoutTopandBottomBorder':
            case 'Rectangle':
            case 'WithoutTopBorder':
                width = ((!opposedPosition && isOutside) || (opposedPosition && !isOutside)) ? -width : width;
                path += 'M ' + x + ' ' + y + ' L ' + (x + width) + ' ' + y +
                    ' M ' + x + ' ' + (y + height) + ' L ' + (x + width) + ' ' + (y + height);
                path += (borderType !== 'WithoutTopandBottomBorder') ? (' L' + ' ' + (x + width) + ' ' + y + ' ') : ' ';
                path += (borderType === 'Rectangle') ? ('M ' + (x) + ' ' + (y + height) + 'L' + ' ' + (x) + ' ' + y + ' ') : ' ';
                break;
            case 'Brace':
                width = ((!opposedPosition && isOutside) || (opposedPosition && !isOutside)) ? width : -width;
                path += 'M ' + (x) + ' ' + y + ' L ' + (x - width / 2) + ' ' + y + ' L ' + (x - width / 2) + ' ' +
                    (textOptions.y - labelSize.height / 2 - 4) + ' M ' + (x - width / 2) + ' ' +
                    (textOptions.y + labelSize.height / 4 + 2) +
                    ' L ' + (x - width / 2) + ' ' + (y + height) + ' L ' + (x) + ' ' + (y + height);
                break;
            case 'CurlyBrace':
                if ((!opposedPosition && isOutside) || (opposedPosition && !isOutside)) {
                    padding = -10;
                    padding1 = -15;
                    padding2 = -5;
                }
                else {
                    padding = 10;
                    padding1 = 15;
                    padding2 = 5;
                }
                if (alignment === 'Center') {
                    path += 'M ' + x + ' ' + y + ' C ' + x + ' ' + y + ' ' + (x + padding) + ' ' + y + ' ' + (x + padding) + ' ' + (y + 10)
                        + ' L ' + (x + padding) + ' ' + (y + (height - 10) / 2) + ' L ' + (x + padding1) + ' ' + (y + (height - 10) / 2 + 5)
                        + ' L ' + (x + padding) + ' ' + (y + (height - 10) / 2 + 10) + ' L ' + (x + padding) + ' ' + (y + (height - 10)) +
                        ' C ' + (x + padding) + ' ' + (y + (height - 10)) + ' ' + (x + padding2) + ' ' + (y + height) + ' '
                        + x + ' ' + (y + height);
                }
                else if (alignment === 'Far') {
                    path += 'M ' + x + ' ' + y + ' C ' + x + ' ' + y + ' ' + (x + padding) + ' ' + y + ' ' + (x + padding) + ' ' + (y + 10)
                        + ' L ' + (x + padding) + ' ' + (y + height - 20) + ' ' + ' L ' + (x + padding1) + ' ' + (y + (height - 15)) +
                        ' L ' + (x + padding) + ' ' + (y + (height - 10)) + ' L ' + (x + padding) + ' ' + (y + (height - 10)) +
                        ' C ' + (x + padding) + ' ' + (y + (height - 10)) + ' ' + (x + padding) + ' ' + (y + height) + ' ' + x + ' '
                        + (y + height);
                }
                else {
                    path += 'M ' + x + ' ' + y + ' C ' + x + ' ' + y + ' ' + (x + padding) + ' ' + y + ' ' + (x + padding) + ' ' + (y + 10)
                        + ' L ' + (x + padding1) + ' ' + (y + 15) +
                        ' L ' + (x + padding) + ' ' + (y + 20) + ' L ' + (x + padding) + ' ' + (y + (height - 10)) +
                        ' C ' + (x + padding) + ' ' + (y + (height - 10)) + ' ' + (x + padding2) + ' ' + (y + height) + ' ' + x +
                        ' ' + (y + height);
                }
                break;
        }
        return path;
    };
    /**
     * create cliprect
     *
     * @returns {void}
     * @private
     */
    MultiLevelLabel.prototype.createClipRect = function (x, y, height, width, clipId, axisId) {
        this.multiElements = this.chart.renderer.createGroup({
            'id': axisId,
            'clip-path': 'url(#' + clipId + ')'
        });
        if (!this.chart.enableCanvas) {
            this.multiElements.appendChild(appendClipElement(this.chart.redraw, {
                'id': clipId,
                'x': x,
                'y': y,
                'width': width,
                'height': height,
                'fill': 'white',
                'stroke-width': 1, 'stroke': 'Gray'
            }, this.chart.renderer));
        }
    };
    /**
     * create borer element
     *
     * @returns {void}
     * @private
     */
    MultiLevelLabel.prototype.createBorderElement = function (borderIndex, axisIndex, axis, path, pointIndex) {
        var direction = path;
        var borderElement = this.chart.renderer.drawPath(new PathOption(this.chart.element.id + axisIndex + '_Axis_MultiLevelLabel_Rect_' + borderIndex + '_' + pointIndex, 'Transparent', axis.multiLevelLabels[borderIndex].border.width, axis.multiLevelLabels[borderIndex].border.color || this.chart.themeStyle.axisLine, 1, '', path));
        borderElement.style.pointerEvents = 'none';
        appendChildElement(this.chart.enableCanvas, this.labelElement, borderElement, this.chart.redraw, true, 'x', 'y', null, direction);
    };
    /**
     * Triggers the event.
     *
     * @returns {void}
     * @private
     */
    MultiLevelLabel.prototype.triggerMultiLabelRender = function (axis, text, textStyle, textAlignment, customAttributes) {
        var argsData = {
            cancel: false, name: axisMultiLabelRender, axis: axis,
            text: text, textStyle: textStyle, alignment: textAlignment, customAttributes: customAttributes
        };
        this.chart.trigger(axisMultiLabelRender, argsData);
        return argsData;
    };
    /**
     * Triggers the event.
     *
     * @returns {void}
     * @private
     */
    MultiLevelLabel.prototype.MultiLevelLabelClick = function (labelIndex, axisIndex) {
        var level = parseInt(labelIndex.substr(0, 1), 10);
        var textElement$$1 = parseInt(labelIndex.substr(7), 10);
        var chart = this.chart;
        var axis = chart.axisCollections[axisIndex];
        var categories = axis.multiLevelLabels[level].categories;
        var text = categories[textElement$$1].text;
        var start = categories[textElement$$1].start;
        var end = categories[textElement$$1].end;
        var customAttributes = categories[textElement$$1].customAttributes;
        var multilevelclickArgs = {
            axis: axis, level: level, text: text, customAttributes: customAttributes,
            start: start, end: end, name: multiLevelLabelClick, cancel: false
        };
        this.chart.trigger(multiLevelLabelClick, multilevelclickArgs);
        return multilevelclickArgs;
    };
    /**
     * To click the multi level label
     *
     * @returns {void}
     * @private
     */
    MultiLevelLabel.prototype.click = function (event) {
        var targetId = event.target.id;
        var multiLevelID = '_Axis_MultiLevelLabel_Level_';
        var textId;
        var elementId;
        var axisIndex;
        if (this.chart.enableCanvas) {
            for (var i = 0; i < this.multiLevelLabelRectXRegion.length; i++) {
                if (withInBounds(event['x'], event['y'], this.multiLevelLabelRectXRegion[i], this.multiLevelLabelRectXRegion[i].width, this.multiLevelLabelRectXRegion[i].height)) {
                    targetId = this.xLabelCollection[i].id;
                }
            }
        }
        if (targetId.indexOf(multiLevelID) > -1) {
            textId = targetId.split(multiLevelID)[1];
            elementId = targetId.split(multiLevelID)[0];
            axisIndex = parseInt(elementId.charAt(elementId.length - 1), 10);
            this.MultiLevelLabelClick(textId, axisIndex);
        }
    };
    /**
     * To get the module name for `MultiLevelLabel`.
     *
     * @private
     */
    MultiLevelLabel.prototype.getModuleName = function () {
        return 'MultiLevelLabel';
    };
    /**
     * To destroy the `MultiLevelLabel` module.
     *
     * @private
     */
    MultiLevelLabel.prototype.destroy = function () {
        // destroy peform here
    };
    return MultiLevelLabel;
}());

// eslint-disable-next-line jsdoc/require-param
/**
 * Create scrollbar svg.
 *
 * @returns {void}
 */
function createScrollSvg(scrollbar, renderer) {
    var rect = scrollbar.axis.rect;
    var isHorizontalAxis = scrollbar.axis.orientation === 'Horizontal';
    var enablePadding = false;
    var markerHeight = 0;
    var yMin;
    for (var _i = 0, _a = scrollbar.axis.series; _i < _a.length; _i++) {
        var tempSeries = _a[_i];
        if (tempSeries.marker.visible && tempSeries.marker.height > markerHeight) {
            markerHeight = tempSeries.marker.height;
        }
    }
    for (var _b = 0, _c = scrollbar.axis.series; _b < _c.length; _b++) {
        var tempSeries = _c[_b];
        if (tempSeries.visible) { // To avoid the console error, when the visibility of the series is false.
            yMin = tempSeries.yMin.toString();
            enablePadding = (tempSeries.yData).some(function (yData) {
                return yData === yMin;
            });
        }
        if (enablePadding) {
            break;
        }
    }
    scrollbar.svgObject = renderer.createSvg({
        id: scrollbar.component.element.id + '_' + 'scrollBar_svg' + scrollbar.axis.name,
        width: scrollbar.isVertical ? scrollbar.height : scrollbar.width,
        height: scrollbar.isVertical ? scrollbar.width : scrollbar.height,
        style: 'position: absolute;top: ' + ((scrollbar.axis.isAxisOpposedPosition && isHorizontalAxis ? -16 :
            (enablePadding ? markerHeight : 0)) + rect.y + Math.max(0.5, scrollbar.axis.lineStyle.width / 2)) + 'px;left: ' +
            (((scrollbar.axis.isAxisOpposedPosition && !isHorizontalAxis ? 16 : 0) + rect.x) -
                (scrollbar.isVertical ? scrollbar.height : 0))
            + 'px;cursor:auto;'
    });
    scrollbar.elements.push(scrollbar.svgObject);
}
/**
 * Scrollbar elements renderer
 */
var ScrollElements = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for scroll elements
     *
     * @param scrollObj
     * @param chart
     */
    function ScrollElements(chart) {
        this.chartId = chart.element.id + '_';
    }
    /**
     * Render scrollbar elements.
     *
     * @returns {void}
     * @private
     */
    ScrollElements.prototype.renderElements = function (scroll, renderer) {
        var isInverse = scroll.axis.isAxisInverse;
        var scrollBar = scroll.axis.scrollbarSettings;
        var scrollGroup = renderer.createGroup({
            id: this.chartId + 'scrollBar_' + scroll.axis.name,
            transform: 'translate(' + ((scroll.isVertical && isInverse) ? scroll.height : isInverse ?
                scroll.width : '0') + ',' + (scroll.isVertical && isInverse ? '0' : isInverse ?
                scroll.height : scroll.isVertical ? scroll.width : '0') + ') rotate(' + (scroll.isVertical && isInverse ?
                '90' : scroll.isVertical ? '270' : isInverse ? '180' : '0') + ')'
        });
        var backRectGroup = renderer.createGroup({
            id: this.chartId + 'scrollBar_backRect_' + scroll.axis.name
        });
        var thumbGroup = renderer.createGroup({
            id: this.chartId + 'scrollBar_thumb_' + scroll.axis.name,
            transform: 'translate(0,0)'
        });
        this.backRect(scroll, renderer, backRectGroup, scrollBar);
        this.thumb(scroll, renderer, thumbGroup, scrollBar);
        this.renderCircle(scroll, renderer, thumbGroup, scrollBar);
        this.arrows(scroll, renderer, thumbGroup, scrollBar);
        this.thumbGrip(scroll, renderer, thumbGroup, scrollBar);
        scrollGroup.appendChild(backRectGroup);
        scrollGroup.appendChild(thumbGroup);
        return scrollGroup;
    };
    /**
     * Method to render back rectangle of scrollbar
     *
     * @param scroll
     * @param renderer
     * @param parent
     * @param renderer
     * @param parent
     */
    ScrollElements.prototype.backRect = function (scroll, renderer, parent, scrollBar) {
        var style = scroll.scrollbarThemeStyle;
        var backRectEle = renderer.drawRectangle(new RectOption(this.chartId + 'scrollBarBackRect_' + scroll.axis.name, scrollBar.trackColor || style.backRect, { width: 1, color: scrollBar.trackColor || style.backRect }, 1, new Rect(0, 0, scroll.width, scroll.height), scrollBar.trackRadius, scrollBar.trackRadius));
        parent.appendChild(backRectEle);
    };
    /**
     * Method to render arrows
     *
     * @param scroll
     * @param renderer
     * @param parent
     * @param renderer
     * @param parent
     */
    ScrollElements.prototype.arrows = function (scroll, renderer, parent, scrollBar) {
        var style = scroll.scrollbarThemeStyle;
        var option = new PathOption(this.chartId + 'scrollBar_leftArrow_' + scroll.axis.name, style.arrow, 1, style.arrow, 1, '', '');
        this.leftArrowEle = renderer.drawPath(option);
        option.id = this.chartId + 'scrollBar_rightArrow_' + scroll.axis.name;
        this.rightArrowEle = renderer.drawPath(option);
        this.setArrowDirection(this.thumbRectX, this.thumbRectWidth, scroll.height);
        if (scrollBar.enableZoom) {
            parent.appendChild(this.leftArrowEle);
            parent.appendChild(this.rightArrowEle);
        }
    };
    /**
     * Methods to set the arrow width.
     *
     * @param thumbRectX
     * @param thumbRectWidth
     * @param height
     */
    ScrollElements.prototype.setArrowDirection = function (thumbRectX, thumbRectWidth, height) {
        var circleRadius = height / 2;
        var leftDirection = 'M ' + ((thumbRectX - circleRadius / 2)) + ' ' + (height / 2) + ' ' + 'L ' +
            (thumbRectX - circleRadius / 2 + (height / 2 - circleRadius / 4)) + ' ' + (height - circleRadius / 2) + ' ' + 'L ' + (thumbRectX - circleRadius / 2 + (height / 2 - circleRadius / 4)) + ' ' + (circleRadius / 2) + ' Z';
        var rightDirection = 'M ' + ((thumbRectX + thumbRectWidth + circleRadius / 2)) + ' ' + (height / 2)
            + ' ' + 'L ' + (thumbRectX + thumbRectWidth + circleRadius / 2 - (height / 2 - circleRadius / 4)) + ' ' + (height - circleRadius / 2) + ' ' + 'L ' + (thumbRectX +
            thumbRectWidth + circleRadius / 2 - (height / 2 - circleRadius / 4)) + ' ' + (circleRadius / 2) + ' Z';
        this.leftArrowEle.setAttribute('d', leftDirection);
        this.rightArrowEle.setAttribute('d', rightDirection);
    };
    /**
     * Method to render thumb.
     *
     * @param scroll
     * @param renderer
     * @param parent
     */
    ScrollElements.prototype.thumb = function (scroll, renderer, parent, scrollBar) {
        scroll.startX = this.thumbRectX;
        var style = scroll.scrollbarThemeStyle;
        this.slider = renderer.drawRectangle(new RectOption(this.chartId + 'scrollBarThumb_' + scroll.axis.name, scrollBar.scrollbarColor || style.thumb, { width: 1, color: scrollBar.scrollbarColor || style.thumb }, 1, new Rect(scrollBar.enableZoom ? this.thumbRectX : this.thumbRectX - scroll.height / 2, 0, scrollBar.enableZoom ? this.thumbRectWidth : this.thumbRectWidth + scroll.height / 2, scroll.height), scrollBar.scrollbarRadius, scrollBar.scrollbarRadius));
        parent.appendChild(this.slider);
    };
    /**
     *  Method to render circles
     *
     * @param scroll
     * @param renderer
     * @param parent
     */
    ScrollElements.prototype.renderCircle = function (scroll, renderer, parent, scrollBar) {
        var style = scroll.scrollbarThemeStyle;
        var option = new CircleOption(this.chartId + 'scrollBar_leftCircle_' + scroll.axis.name, style.circle, { width: 1, color: style.circle }, 1, this.thumbRectX, scroll.height / 2, scroll.height / 2);
        var scrollShadowEle = '<filter x="-25.0%" y="-20.0%" width="150.0%" height="150.0%" filterUnits="objectBoundingBox"' +
            'id="scrollbar_shadow"><feOffset dx="0" dy="1" in="SourceAlpha" result="shadowOffsetOuter1"></feOffset>' +
            '<feGaussianBlur stdDeviation="1.5" in="shadowOffsetOuter1" result="shadowBlurOuter1"></feGaussianBlur>' +
            '<feComposite in="shadowBlurOuter1" in2="SourceAlpha" operator="out" result="shadowBlurOuter1"></feComposite>' +
            '<feColorMatrix values="0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.16 0" type="matrix" in="shadowBlurOuter1">' +
            '</feColorMatrix></filter>';
        var defElement = renderer.createDefs();
        var shadowGroup = renderer.createGroup({
            id: this.chartId + scroll.axis.name + '_thumb_shadow'
        });
        defElement.innerText = scrollShadowEle;
        shadowGroup.innerText = '<use fill="black" fill-opacity="1" filter="url(#scrollbar_shadow)" xlink:href="#' +
            this.chartId + 'scrollBar_leftCircle_' +
            scroll.axis.name + '"></use><use fill="black" fill-opacity="1" filter="url(#scrollbar_shadow)" xlink:href="#' +
            this.chartId + 'scrollBar_rightCircle_' + scroll.axis.name + '"></use>';
        this.leftCircleEle = renderer.drawCircle(option);
        option.id = this.chartId + 'scrollBar_rightCircle_' + scroll.axis.name;
        option.cx = this.thumbRectX + this.thumbRectWidth;
        this.rightCircleEle = renderer.drawCircle(option);
        parent.appendChild(defElement);
        if (scrollBar.enableZoom) {
            parent.appendChild(this.leftCircleEle);
            parent.appendChild(this.rightCircleEle);
        }
        parent.appendChild(shadowGroup);
    };
    /**
     * Method to render grip elements
     *
     * @param scroll
     * @param renderer
     * @param parent
     */
    ScrollElements.prototype.thumbGrip = function (scroll, renderer, parent, scrollBar) {
        var sidePadding = 0;
        var topPadding = 0;
        var gripWidth = 14;
        var gripCircleDiameter = 2;
        var padding = gripWidth / 2 - gripCircleDiameter;
        var style = scroll.scrollbarThemeStyle;
        var option = new CircleOption(this.chartId + 'scrollBar_gripCircle0' + '_' + scroll.axis.name, scrollBar.gripColor || style.grip, { width: 1, color: scrollBar.gripColor || style.grip }, 1, 0, 0, 1);
        this.gripCircle = renderer.createGroup({
            id: this.chartId + 'scrollBar_gripCircle_' + scroll.axis.name,
            transform: 'translate(' + (!scrollBar.enableZoom ? ((this.thumbRectX + this.thumbRectWidth / 2) + ((scroll.isVertical ? 2 : 0) * padding) - scrollBar.height / 2) : (this.thumbRectX + this.thumbRectWidth / 2) + ((scroll.isVertical ? 1 : -1) * padding)) +
                ',' + (scroll.isVertical ? (scroll.height / 2 + padding / 2) - 0.5 : (scroll.height / 2 - padding / 2) - 0.5) + ') rotate(' + (scroll.isVertical ? '180' : '0') + ')'
        });
        for (var i = 1; i <= 6; i++) {
            option.id = this.chartId + 'scrollBar_gripCircle' + i + '_' + scroll.axis.name;
            option.cx = sidePadding;
            option.cy = topPadding;
            this.gripCircle.appendChild(renderer.drawCircle(option));
            sidePadding = i === 3 ? 0 : (sidePadding + 5);
            topPadding = i >= 3 ? 5 : 0;
        }
        if (scrollBar.height >= 12) {
            parent.appendChild(this.gripCircle);
        }
    };
    return ScrollElements;
}());

/* eslint-disable @typescript-eslint/ban-types */
/**
 * Scrollbar Base
 */
var ScrollBar = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for creating scrollbar
     *
     * @param component
     * @param axis
     */
    function ScrollBar(component, axis) {
        /** @private */
        this.scrollRange = { max: null, min: null, interval: null, delta: null };
        this.component = component;
        this.elements = [];
        this.scrollElements = new ScrollElements(component);
        this.axis = axis;
        this.mouseMoveListener = this.scrollMouseMove.bind(this);
        this.mouseUpListener = this.scrollMouseUp.bind(this);
        this.animateDuration = 500;
        this.isPointer = Browser.isPointer;
        this.browserName = Browser.info.name;
    }
    /**
     * To Mouse x and y position
     *
     * @param e
     */
    ScrollBar.prototype.getMouseXY = function (e) {
        var pageX;
        var pageY;
        var touchArg;
        if (e.type.indexOf('touch') > -1) {
            touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            pageY = touchArg.changedTouches[0].clientY;
        }
        else {
            pageX = e.clientX;
            pageY = e.clientY;
        }
        var svgRect = getElement$1(this.component.element.id + '_scrollBar_svg' + this.axis.name).getBoundingClientRect();
        this.mouseX = pageX - Math.max(svgRect.left, 0);
        this.mouseY = pageY - Math.max(svgRect.top, 0);
    };
    /**
     * Method to bind events for scrollbar svg object
     *
     * @param element
     * @returns {void}
     */
    ScrollBar.prototype.wireEvents = function (element) {
        EventHandler.add(element, Browser.touchStartEvent, this.scrollMouseDown, this);
        EventHandler.add(element, Browser.touchMoveEvent, this.scrollMouseMove, this);
        EventHandler.add(element, Browser.touchEndEvent, this.scrollMouseUp, this);
        EventHandler.add(element, 'mousewheel', this.scrollMouseWheel, this);
        window.addEventListener('mousemove', this.mouseMoveListener, false);
        window.addEventListener('mouseup', this.mouseUpListener, false);
    };
    /**
     * Method to remove events for srcollbar svg object
     *
     * @param element
     */
    ScrollBar.prototype.unWireEvents = function (element) {
        EventHandler.remove(element, Browser.touchStartEvent, this.scrollMouseDown);
        EventHandler.remove(element, Browser.touchMoveEvent, this.scrollMouseMove);
        EventHandler.remove(element, Browser.touchEndEvent, this.scrollMouseUp);
        EventHandler.remove(element, 'mousewheel', this.scrollMouseWheel);
        window.removeEventListener('mousemove', this.mouseMoveListener, false);
        window.removeEventListener('mouseup', this.mouseUpListener, false);
    };
    /**
     * Handles the mouse down on scrollbar.
     *
     * @param e
     */
    ScrollBar.prototype.scrollMouseDown = function (e) {
        var id = e.target.id;
        var elem = this.scrollElements;
        var isInverse = this.axis.isAxisInverse;
        this.getMouseXY(e);
        this.isResizeLeft = this.isExist(id, '_leftCircle_') || this.isExist(id, '_leftArrow_');
        this.isResizeRight = this.isExist(id, '_rightCircle_') || this.isExist(id, '_rightArrow_');
        //  this.previousXY = this.isVertical ? this.mouseY : this.mouseX;
        this.previousXY = (this.isVertical && isInverse) ? this.mouseY : this.isVertical ? this.width -
            this.mouseY : isInverse ? this.width - this.mouseX : this.mouseX;
        this.previousWidth = elem.thumbRectWidth;
        this.previousRectX = elem.thumbRectX;
        this.startZoomPosition = this.axis.zoomPosition;
        this.startZoomFactor = this.axis.zoomFactor;
        this.startRange = this.axis.visibleRange;
        this.scrollStarted = true;
        this.component.trigger(scrollStart, this.getArgs(scrollStart));
        if (this.isExist(id, 'scrollBarThumb_') || this.isExist(id, 'gripCircle')) {
            this.isThumbDrag = true;
            if (this.axis.scrollbarSettings.height >= 12) {
                this.svgObject.style.cursor = '-webkit-grabbing';
            }
        }
        else if (this.isExist(id, 'scrollBarBackRect_')) {
            var currentX = this.moveLength(this.previousXY, this.previousRectX);
            elem.thumbRectX = this.isWithIn(currentX) ? currentX : elem.thumbRectX;
            this.positionThumb(elem.thumbRectX, elem.thumbRectWidth);
            this.setZoomFactorPosition(elem.thumbRectX, elem.thumbRectWidth, false);
            this.axis.zoomPosition = this.zoomPosition < 0 ? 0 : this.zoomPosition > 0.9 ? 1 : this.zoomPosition;
            if (this.isLazyLoad) {
                var thumbMove = elem.thumbRectX > this.previousRectX ? 'RightMove' : 'LeftMove';
                var args = this.calculateLazyRange(elem.thumbRectX, elem.thumbRectWidth, thumbMove);
                if (args) {
                    this.component.trigger(scrollEnd, args);
                }
            }
        }
        /**
         * Customer issue
         * Task ID - EJ2-28898
         * Issue: While element's height is smaller than chart'height, html scroll bar presents. On that case while moving chart scrollbar,
         * html scrollbar goes up due to chart's svg removed from the dom when zoomFactor and zoomPosition chnaged
         * Fix: Only for scrolling purpose, height for element is set to chart's available height
         */
        if (this.component.element.style.height === '') {
            this.isCustomHeight = true;
            this.component.element.style.height = this.component.availableSize.height + 'px';
        }
    };
    /**
     * To check the matched string
     *
     * @param id
     * @param match
     */
    ScrollBar.prototype.isExist = function (id, match) {
        return id.indexOf(match) > -1;
    };
    /**
     * To check current poisition is within scrollbar region
     *
     * @param currentX
     */
    ScrollBar.prototype.isWithIn = function (currentX) {
        var circleRadius = this.axis.scrollbarSettings.height / 2;
        return (currentX - circleRadius >= 0 &&
            currentX + this.scrollElements.thumbRectWidth + circleRadius <= this.width);
    };
    /**
     * Method to find move length of thumb
     *
     * @param mouseXY
     * @param thumbX
     * @param circleRadius
     */
    ScrollBar.prototype.moveLength = function (mouseXY, thumbX, circleRadius) {
        if (circleRadius === void 0) { circleRadius = this.axis.scrollbarSettings.height / 2; }
        var moveLength = (10 / 100) * (this.width - circleRadius * 2);
        if (mouseXY < thumbX) {
            moveLength = thumbX - (thumbX - moveLength > circleRadius ? moveLength : circleRadius);
        }
        else {
            moveLength = thumbX + (thumbX + this.scrollElements.thumbRectWidth + moveLength < this.width - circleRadius ?
                moveLength : circleRadius);
        }
        return moveLength;
    };
    /**
     * Method to calculate zoom factor and position
     *
     * @param currentX
     * @param currentWidth
     */
    ScrollBar.prototype.setZoomFactorPosition = function (currentX, currentWidth, isRequire) {
        if (isRequire === void 0) { isRequire = true; }
        this.isScrollUI = true;
        var axis = this.axis;
        var circleRadius = this.axis.scrollbarSettings.height / 2;
        var circleWidth = 1;
        var currentScrollWidth = currentX + currentWidth + circleRadius + circleWidth;
        var currentZPWidth = circleRadius + (circleWidth / 2);
        var axisSize = this.isVertical ? axis.rect.height : this.width;
        this.zoomFactor = (currentWidth + (currentScrollWidth >= this.width ? circleRadius + circleWidth : 0)) / axisSize;
        this.zoomPosition = currentScrollWidth > axisSize ? (1 - axis.zoomFactor) : currentX < (circleRadius + circleWidth) ? 0 :
            (currentX - (currentX - currentZPWidth <= 0 ? currentZPWidth : 0)) / axisSize;
        this.zoomPosition = (this.component.enableRtl && !this.isVertical && !axis.isInversed) || (axis.isInversed && !(this.component.enableRtl && !this.isVertical)) ? 1 - (this.zoomPosition + axis.zoomFactor) : this.zoomPosition;
    };
    /**
     * Handles the mouse move on scrollbar.
     *
     * @param e
     */
    ScrollBar.prototype.scrollMouseMove = function (e) {
        var target = e.target;
        var elem = this.scrollElements;
        var isInverse = this.axis.isAxisInverse;
        if (!getElement$1(this.svgObject.id)) {
            return null;
        }
        this.getMouseXY(e);
        if (!isNullOrUndefined(target.id)) {
            this.setCursor(target);
            this.setTheme(target);
        }
        //let mouseXY: number = this.isVertical ? this.mouseY : this.mouseX;
        var mouseXY = (this.isVertical && isInverse) ? this.width - this.mouseY : this.isVertical ?
            this.mouseY : this.mouseX;
        var range = this.axis.visibleRange;
        var zoomPosition = this.zoomPosition;
        var zoomFactor = this.zoomFactor;
        var moveLength = this.previousRectX - elem.thumbRectX;
        var thumbMove = moveLength < 0 ? 'RightMove' : 'LeftMove';
        var args;
        if (this.isLazyLoad && (this.isThumbDrag || this.isResizeLeft || this.isResizeRight)) {
            args = this.calculateLazyRange(elem.thumbRectX, elem.thumbRectWidth, thumbMove);
        }
        var currentRange = args ? args.currentRange : null;
        if (this.isThumbDrag) {
            this.component.isScrolling = this.isThumbDrag;
            mouseXY = (this.isVertical || isInverse) ? this.width - mouseXY : mouseXY;
            var currentX = elem.thumbRectX + (mouseXY - this.previousXY);
            if (mouseXY >= currentX + elem.thumbRectWidth) {
                this.setCursor(target);
            }
            else {
                if (this.axis.scrollbarSettings.height >= 12) {
                    this.svgObject.style.cursor = '-webkit-grabbing';
                }
            }
            if (mouseXY >= 0 && mouseXY <= currentX + elem.thumbRectWidth) {
                elem.thumbRectX = this.isWithIn(currentX) ? currentX : elem.thumbRectX;
                this.positionThumb(elem.thumbRectX, elem.thumbRectWidth);
                this.previousXY = mouseXY;
                this.setZoomFactorPosition(currentX, elem.thumbRectWidth, false);
                this.axis.zoomPosition = this.zoomPosition < 0 ? 0 : this.zoomPosition > 0.9 ? 1 : this.zoomPosition;
            }
            this.component.trigger(scrollChanged, this.getArgs(scrollChanged, range, zoomPosition, zoomFactor, currentRange));
        }
        else if (this.isResizeLeft || this.isResizeRight) {
            this.resizeThumb();
        }
    };
    /**
     * Handles the mouse wheel on scrollbar.
     *
     * @param e
     */
    ScrollBar.prototype.scrollMouseWheel = function (e) {
        if (!this.axis.scrollbarSettings.enableZoom) {
            return null;
        }
        var svgRect = getElement$1(this.component.element.id + '_scrollBar_svg' + this.axis.name).getBoundingClientRect();
        this.mouseX = e.clientX - Math.max(svgRect.left, 0);
        this.mouseY = e.clientY - Math.max(svgRect.top, 0);
        var origin = 0.5;
        var elem = this.scrollElements;
        var axis = this.axis;
        var direction = (this.browserName === 'mozilla' && !this.isPointer) ?
            -(e.detail) / 3 > 0 ? 1 : -1 : (e['wheelDelta'] / 120) > 0 ? 1 : -1;
        var cumulative = Math.max(Math.max(1 / minMax(axis.zoomFactor, 0, 1), 1) + (0.25 * direction), 1);
        var range = this.axis.visibleRange;
        var zoomPosition = this.zoomPosition;
        var zoomFactor = this.zoomFactor;
        var args;
        if (cumulative >= 1) {
            origin = axis.orientation === 'Horizontal' ? this.mouseX / axis.rect.width : 1 - (this.mouseY / axis.rect.height);
            origin = origin > 1 ? 1 : origin < 0 ? 0 : origin;
            this.zoomFactor = (cumulative === 1) ? 1 : minMax(1 / cumulative, 0, 1);
            this.zoomPosition = (cumulative === 1) ? 0 : axis.zoomPosition + ((axis.zoomFactor - this.zoomFactor) * origin);
        }
        elem.thumbRectX = this.isWithIn(this.zoomPosition * this.width) ? this.zoomPosition * this.width : elem.thumbRectX;
        this.isScrollUI = true;
        this.positionThumb(elem.thumbRectX, elem.thumbRectWidth);
        if (this.isLazyLoad) {
            this.setZoomFactorPosition(elem.thumbRectX, elem.thumbRectWidth);
            this.axis.zoomFactor = this.zoomFactor;
            this.axis.zoomPosition = this.zoomPosition < 0 ? 0 : this.zoomPosition > 0.9 ? 1 : this.zoomPosition;
        }
        axis.zoomFactor = this.zoomFactor;
        axis.zoomPosition = this.zoomPosition;
        if (this.isLazyLoad) {
            args = this.calculateMouseWheelRange(elem.thumbRectX, elem.thumbRectWidth);
            if (args) {
                if ((args.currentRange.minimum !== args.previousAxisRange.minimum) && (args.currentRange.maximum !==
                    args.previousAxisRange.maximum)) {
                    this.component.trigger(scrollEnd, args);
                    this.isScrollEnd = false;
                }
            }
        }
        if (!this.isLazyLoad) {
            this.component.trigger(scrollChanged, this.getArgs(scrollChanged, range, zoomPosition, zoomFactor));
        }
    };
    /**
     * Handles the mouse up on scrollbar.
     *
     * @param e
     */
    ScrollBar.prototype.scrollMouseUp = function () {
        var args;
        this.startX = this.scrollElements.thumbRectX;
        var circleRadius = this.axis.scrollbarSettings.height / 2;
        var circleWidth = 1;
        var currentScrollWidth = this.startX + this.scrollElements.thumbRectWidth + circleRadius + circleWidth;
        var currentZPWidth = circleRadius + (circleWidth / 2);
        if ((this.isResizeLeft || this.isResizeRight) && !this.isLazyLoad) {
            this.axis.zoomFactor = (currentScrollWidth >= this.width - 1 && (this.startX - currentZPWidth) <= 0) ? 1 : this.zoomFactor;
        }
        if (this.isLazyLoad) {
            var moveLength = this.previousRectX - this.startX;
            if ((moveLength > 0 || moveLength < 0) && this.isThumbDrag) {
                var thumbMove = moveLength < 0 ? 'RightMove' : 'LeftMove';
                if (thumbMove === 'RightMove') {
                    this.startX = (this.startX + Math.abs(moveLength)) < this.width - circleRadius ? this.startX :
                        this.width - circleRadius - this.scrollElements.thumbRectWidth;
                }
                else {
                    this.startX = (this.startX + this.scrollElements.thumbRectWidth - Math.abs(moveLength)) > circleRadius ?
                        this.startX : circleRadius;
                }
                args = this.calculateLazyRange(this.startX, this.scrollElements.thumbRectWidth, thumbMove);
                if (args) {
                    this.component.trigger(scrollEnd, args);
                    this.scrollStarted = false;
                }
            }
            if (this.isResizeLeft || this.isResizeRight) {
                args = this.calculateLazyRange(this.startX, this.scrollElements.thumbRectWidth);
                if (args) {
                    this.component.trigger(scrollEnd, args);
                    this.scrollStarted = false;
                }
            }
        }
        this.isThumbDrag = false;
        this.isResizeLeft = false;
        this.isResizeRight = false;
        this.isScrollEnd = false;
        this.component.isScrolling = false;
        if (this.scrollStarted && !this.isLazyLoad) {
            this.component.trigger(scrollEnd, this.getArgs(scrollChanged, this.startRange, this.startZoomPosition, this.startZoomFactor));
            this.scrollStarted = false;
        }
        /**
         * Customer issue
         * Task ID - EJ2-28898
         * Chart's height setted is removed here.
         */
        if (this.isCustomHeight) {
            this.component.element.style.height = null;
        }
    };
    ScrollBar.prototype.calculateMouseWheelRange = function (scrollThumbX, scrollThumbWidth) {
        var zoomFactor;
        var zoomPosition;
        var args;
        var range = this.scrollRange;
        var previousRange = this.getStartEnd(this.previousStart, this.previousEnd, false);
        var circleRadius = this.axis.scrollbarSettings.height / 2;
        if ((scrollThumbX + scrollThumbWidth + circleRadius) <= this.width) {
            zoomPosition = (scrollThumbX - circleRadius) / this.width;
            zoomFactor = scrollThumbWidth / (this.width);
        }
        var currentStart = range.min + zoomPosition * range.delta;
        var currentEnd = currentStart + zoomFactor * range.delta;
        if (currentEnd) {
            args = { axis: this.axis, currentRange: this.getStartEnd(currentStart, currentEnd, true), previousAxisRange: previousRange };
        }
        return args;
    };
    /**
     * Range calculation for lazy loading.
     *
     * @param scrollThumbX
     * @param scrollThumbWidth
     * @param thumbMove
     * @param scrollThumbX
     * @param scrollThumbWidth
     * @param thumbMove
     * @param scrollThumbX
     * @param scrollThumbWidth
     * @param thumbMove
     */
    ScrollBar.prototype.calculateLazyRange = function (scrollThumbX, scrollThumbWidth, thumbMove) {
        var currentScrollWidth = scrollThumbWidth;
        var zoomFactor;
        var zoomPosition;
        var currentStart;
        var currentEnd;
        var args;
        var range = this.scrollRange;
        var previousRange = this.getStartEnd(this.previousStart, this.previousEnd, false);
        var circleRadius = this.axis.scrollbarSettings.height / 2;
        var circleWidth = 16;
        if (this.isResizeRight || thumbMove === 'RightMove') {
            currentScrollWidth = this.isResizeRight ? currentScrollWidth + circleWidth : currentScrollWidth;
            zoomFactor = (currentScrollWidth) / this.width;
            zoomPosition = thumbMove === 'RightMove' ? (scrollThumbX + circleRadius) / this.width : this.axis.zoomPosition;
            currentStart = thumbMove === 'RightMove' ? (range.min + zoomPosition * range.delta) : this.previousStart;
            currentEnd = currentStart + zoomFactor * range.delta;
        }
        else if (this.isResizeLeft || thumbMove === 'LeftMove') {
            zoomPosition = (scrollThumbX - circleRadius) / this.width;
            zoomFactor = currentScrollWidth / this.width;
            currentStart = range.min + zoomPosition * range.delta;
            currentStart = currentStart >= range.min ? currentStart : range.min;
            currentEnd = thumbMove === 'LeftMove' ? (currentStart + zoomFactor * range.delta) : this.previousEnd;
        }
        else if (this.isThumbDrag) {
            zoomPosition = thumbMove === 'RightMove' ? (scrollThumbX + circleRadius) / this.width : (scrollThumbX - circleRadius) / this.width;
            zoomFactor = (this.scrollElements.thumbRectWidth) / this.width;
            currentStart = range.min + zoomPosition * range.delta;
            currentStart = currentStart >= range.min ? currentStart : range.min;
            currentEnd = currentStart + zoomFactor * range.delta;
        }
        if (currentEnd) {
            args = { axis: (this.component.isBlazor ? {} : this.axis), currentRange: this.getStartEnd(currentStart, currentEnd, true),
                previousAxisRange: previousRange };
        }
        return args;
    };
    /**
     * Get start and end values
     *
     * @param start
     * @param end
     * @param isCurrentStartEnd
     * @param start
     * @param end
     * @param isCurrentStartEnd
     * @param start
     * @param end
     * @param isCurrentStartEnd
     */
    ScrollBar.prototype.getStartEnd = function (start, end, isCurrentStartEnd) {
        var valueType = this.valueType;
        if ((valueType === 'DateTime' || valueType === 'DateTimeCategory') && isCurrentStartEnd) {
            this.previousStart = start;
            this.previousEnd = end;
        }
        else if (isCurrentStartEnd) {
            var currentStart = Math.round(start);
            var currentEnd = Math.ceil(end);
            if (this.axis.valueType === 'Category') {
                currentEnd -= (!this.axis.scrollbarSettings.enableZoom && currentEnd - currentStart > this.previousEnd - this.previousStart) ? (currentEnd - currentStart) - (this.previousEnd - this.previousStart) : 0;
            }
            this.previousStart = start = currentStart;
            this.previousEnd = end = currentEnd;
        }
        switch (valueType) {
            case 'Double':
            case 'Category':
            case 'Logarithmic':
                start = Math.round(start);
                end = Math.ceil(end);
                break;
            case 'DateTime':
            case 'DateTimeCategory':
                start = new Date(start);
                end = new Date(end);
                break;
        }
        return { minimum: start, maximum: end };
    };
    /**
     * To render scroll bar
     *
     * @param isScrollExist
     * @private
     */
    ScrollBar.prototype.render = function (isScrollExist) {
        if (this.component.zoomModule || (isScrollExist && this.axis.scrollbarSettings.enable)) {
            this.getDefaults();
        }
        this.getTheme();
        this.removeScrollSvg();
        createScrollSvg(this, this.component.svgRenderer);
        this.wireEvents(this.svgObject);
        this.svgObject.appendChild(this.scrollElements.renderElements(this, this.component.svgRenderer));
        return this.svgObject;
    };
    /**
     * Theming for scrollabr
     *
     * @returns {void}
     */
    ScrollBar.prototype.getTheme = function () {
        this.scrollbarThemeStyle = getScrollbarThemeColor(this.component.theme);
    };
    /**
     * Method to remove existing scrollbar.
     *
     * @returns {void}
     */
    ScrollBar.prototype.removeScrollSvg = function () {
        if (document.getElementById(this.component.element.id + '_scrollBar_svg' + this.axis.name)) {
            remove(document.getElementById(this.component.element.id + '_scrollBar_svg' + this.axis.name));
        }
    };
    /**
     * Method to set cursor fpr scrollbar
     *
     * @param target
     */
    ScrollBar.prototype.setCursor = function (target) {
        var id = target.id;
        this.svgObject.style.cursor = ((id.indexOf('scrollBarThumb_') > -1 || id.indexOf('_gripCircle') > -1) && this.axis.scrollbarSettings.height >= 12) ?
            '-webkit-grab' : (id.indexOf('Circle_') > -1 || id.indexOf('Arrow_') > -1) ? this.isVertical ? 'ns-resize' :
            'ew-resize' : 'auto';
    };
    /**
     * Method to set theme for sollbar
     *
     * @param target
     */
    ScrollBar.prototype.setTheme = function (target) {
        var id = target.id;
        var isLeftHover = id.indexOf('_leftCircle_') > -1 || id.indexOf('_leftArrow_') > -1;
        var isRightHover = id.indexOf('_rightCircle_') > -1 || id.indexOf('_rightArrow_') > -1;
        var style = this.scrollbarThemeStyle;
        var leftArrowEle = this.scrollElements.leftArrowEle;
        var rightArrowEle = this.scrollElements.rightArrowEle;
        var leftCircleEle = this.scrollElements.leftCircleEle;
        var rightCircleEle = this.scrollElements.rightCircleEle;
        var isAxis = this.isCurrentAxis(target, leftArrowEle);
        leftCircleEle.style.fill = isLeftHover && isAxis ? style.circleHover : style.circle;
        rightCircleEle.style.fill = isRightHover && isAxis ? style.circleHover : style.circle;
        leftCircleEle.style.stroke = isLeftHover && isAxis ? style.circleHover : style.circle;
        rightCircleEle.style.stroke = isRightHover && isAxis ? style.circleHover : style.circle;
        if (this.component.theme === 'HighContrastLight') {
            leftArrowEle.style.fill = isLeftHover && isAxis ? style.arrowHover : style.arrow;
            leftArrowEle.style.stroke = isLeftHover && isAxis ? style.arrowHover : style.arrow;
            rightArrowEle.style.fill = isRightHover && isAxis ? style.arrowHover : style.arrow;
            rightArrowEle.style.stroke = isRightHover && isAxis ? style.arrowHover : style.arrow;
            leftCircleEle.style.stroke = isLeftHover && isAxis ? style.circleHover : style.circle;
            rightCircleEle.style.stroke = isRightHover && isAxis ? style.circleHover : style.circle;
        }
    };
    /**
     * To check current axis
     *
     * @param target
     * @param ele
     */
    ScrollBar.prototype.isCurrentAxis = function (target, ele) {
        return (target.id.split('_')[2] === ele.id.split('_')[2]);
    };
    /**
     * Method to resize thumb
     *
     * @param e
     */
    ScrollBar.prototype.resizeThumb = function () {
        var currentWidth;
        var circleRadius = this.axis.scrollbarSettings.height / 2;
        var padding = 5;
        var gripWidth = 14;
        var minThumbWidth = circleRadius * 2 + padding * 2 + gripWidth;
        var thumbX = this.previousRectX;
        var isInverse = this.axis.isAxisInverse;
        // let mouseXY: number = this.isVertical ? this.mouseY : this.mouseX;
        var mouseXY = (this.isVertical && isInverse) ? this.mouseY : this.isVertical ? this.width -
            this.mouseY : isInverse ? this.width - this.mouseX : this.mouseX;
        var diff = Math.abs(this.previousXY - mouseXY);
        if (this.isResizeLeft && mouseXY >= 0) {
            var currentX = thumbX + (mouseXY > this.previousXY ? diff : -diff);
            currentWidth = currentX - circleRadius >= 0 ? this.previousWidth + (mouseXY > this.previousXY ? -diff : diff) :
                this.previousWidth;
            currentX = currentX - circleRadius >= 0 ? currentX : thumbX;
            if (currentWidth >= minThumbWidth && mouseXY < currentX + currentWidth) {
                this.scrollElements.thumbRectX = this.previousRectX = currentX;
                this.scrollElements.thumbRectWidth = this.previousWidth = currentWidth;
                this.previousXY = mouseXY;
                this.setZoomFactorPosition(currentX, currentWidth);
                var argsData = {
                    axis: (this.component.isBlazor ? {} : this.axis),
                    name: scrollChanged,
                    range: this.axis.visibleRange,
                    zoomFactor: this.zoomFactor,
                    zoomPosition: this.zoomPosition,
                    previousRange: this.axis.visibleRange,
                    previousZoomFactor: this.axis.zoomFactor,
                    previousZoomPosition: this.axis.zoomPosition,
                    currentRange: null,
                    cancel: false
                };
                this.component.trigger(scrollChanged, argsData);
                if (!argsData.cancel) {
                    this.positionThumb(currentX, currentWidth);
                    this.axis.zoomFactor = argsData.zoomFactor;
                    this.axis.zoomPosition = argsData.zoomPosition;
                }
                else {
                    this.zoomFactor = argsData.previousZoomFactor;
                    this.zoomPosition = argsData.previousZoomPosition;
                }
            }
        }
        else if (this.isResizeRight) {
            currentWidth = mouseXY >= minThumbWidth + this.scrollElements.thumbRectX && mouseXY <= this.width - circleRadius ?
                mouseXY - this.scrollElements.thumbRectX : this.previousWidth;
            this.scrollElements.thumbRectWidth = this.previousWidth = currentWidth;
            this.previousXY = mouseXY;
            this.setZoomFactorPosition(this.startX, currentWidth);
            if (!this.isLazyLoad) {
                this.setZoomFactorPosition(this.startX, currentWidth);
            }
            var argsData = {
                axis: (this.component.isBlazor ? {} : this.axis),
                name: scrollChanged,
                range: this.axis.visibleRange,
                zoomFactor: this.zoomFactor,
                zoomPosition: this.zoomPosition,
                previousRange: this.axis.visibleRange,
                previousZoomFactor: this.axis.zoomFactor,
                previousZoomPosition: this.axis.zoomPosition,
                currentRange: null,
                cancel: false
            };
            this.component.trigger(scrollChanged, argsData);
            if (!argsData.cancel) {
                this.positionThumb(this.startX, currentWidth);
                this.axis.zoomFactor = argsData.zoomFactor;
                this.axis.zoomPosition = argsData.zoomPosition;
            }
            else {
                this.zoomFactor = argsData.previousZoomFactor;
                this.zoomPosition = argsData.previousZoomPosition;
            }
        }
    };
    /**
     * Method to position the scrollbar thumb
     *
     * @param currentX
     * @param currentWidth
     */
    ScrollBar.prototype.positionThumb = function (currentX, currentWidth) {
        var elem = this.scrollElements;
        var gripWidth = 14;
        var gripCircleDiameter = 2;
        var padding = gripWidth / 2 - gripCircleDiameter;
        elem.slider.setAttribute('x', this.axis.scrollbarSettings.enableZoom ? currentX.toString() : (currentX - this.axis.scrollbarSettings.height / 2).toString());
        elem.slider.setAttribute('width', this.axis.scrollbarSettings.enableZoom ? currentWidth.toString() : (currentWidth + this.axis.scrollbarSettings.height).toString());
        elem.leftCircleEle.setAttribute('cx', currentX.toString());
        elem.rightCircleEle.setAttribute('cx', (currentX + currentWidth).toString());
        elem.setArrowDirection(currentX, currentWidth, this.height);
        elem.gripCircle.setAttribute('transform', 'translate(' + (currentX + currentWidth / 2 + ((this.isVertical ? 1 : -1) * padding)) +
            ',' + (this.isVertical ? (this.axis.scrollbarSettings.height / 2 + padding / 2) - 0.5 : (this.axis.scrollbarSettings.height / 2 - padding / 2) - 0.5) + ') rotate(' + (this.isVertical ? '180' : '0') + ')');
    };
    /**
     * Method to get default values
     *
     * @returns {void}
     */
    ScrollBar.prototype.getDefaults = function () {
        var axis = this.axis;
        var circleRadius = this.axis.scrollbarSettings.height / 2;
        var padding = 5;
        var gripWidth = 14;
        var minThumbWidth = circleRadius * 2 + padding * 2 + gripWidth;
        if (this.axis.scrollbarSettings.enable) {
            this.isLazyLoad = true;
            this.getLazyDefaults(axis);
        }
        this.isVertical = axis.orientation === 'Vertical';
        var isRtlEnabled = (this.component.enableRtl && !this.isVertical && !axis.isInversed) || (axis.isInversed && !(this.component.enableRtl && !this.isVertical));
        this.zoomFactor = this.isLazyLoad ? this.zoomFactor : axis.zoomFactor;
        this.zoomPosition = this.isLazyLoad ? isRtlEnabled ? 1 - (this.zoomPosition + this.zoomFactor) : this.zoomPosition : isRtlEnabled ? 1 - (axis.zoomPosition + axis.zoomFactor) : axis.zoomPosition;
        var currentWidth = this.zoomFactor * (this.isVertical ? axis.rect.height : axis.rect.width);
        currentWidth = (this.isLazyLoad && !this.axis.scrollbarSettings.enableZoom) || currentWidth > minThumbWidth ? currentWidth : minThumbWidth;
        this.scrollX = axis.rect.x;
        this.scrollY = axis.rect.y;
        this.width = this.isVertical ? axis.rect.height : axis.rect.width;
        this.height = this.axis.scrollbarSettings.height;
        var currentX = this.zoomPosition * (this.isVertical ? axis.rect.height : this.width);
        var minThumbX = (this.width - minThumbWidth - circleRadius);
        this.scrollElements.thumbRectX = currentX > minThumbX ? minThumbX : currentX < circleRadius ? circleRadius : currentX;
        this.scrollElements.thumbRectWidth = this.isThumbDrag ? this.scrollElements.thumbRectWidth : ((currentWidth + this.scrollElements.thumbRectX) < this.width - (circleRadius * 2))
            ? currentWidth : this.width - this.scrollElements.thumbRectX - circleRadius;
    };
    /**
     * Lazy load default values.
     *
     * @param axis
     */
    ScrollBar.prototype.getLazyDefaults = function (axis) {
        var start;
        var end;
        var valueType = axis.valueType;
        var scrollbarSettings = axis.scrollbarSettings;
        var range = axis.scrollbarSettings.range;
        var visibleRange = axis.visibleRange;
        var pointsLength = axis.scrollbarSettings.pointsLength;
        this.valueType = valueType = (!scrollbarSettings.range.minimum || !scrollbarSettings.range.maximum) &&
            scrollbarSettings.pointsLength ? 'Double' : valueType;
        var option = {
            skeleton: 'full',
            type: 'dateTime'
        };
        var dateParser = this.component.intl.getDateParser(option);
        var dateFormatter = this.component.intl.getDateFormat(option);
        switch (valueType) {
            case 'Double':
            case 'Category':
            case 'Logarithmic':
                start = range.minimum ? range.minimum : pointsLength ? 0 : visibleRange.min;
                end = range.maximum ? range.maximum : pointsLength ? (pointsLength - 1) : visibleRange.max;
                break;
            case 'DateTime':
            case 'DateTimeCategory':
                start = range.minimum ? Date.parse(dateParser(dateFormatter(range.minimum))) : visibleRange.min;
                end = range.maximum ? Date.parse(dateParser(dateFormatter(range.maximum))) : visibleRange.max;
                break;
        }
        start = Math.min(start, visibleRange.min);
        end = Math.max(end, visibleRange.max);
        var zoomFactor = (visibleRange.max - visibleRange.min) / (end - start);
        var zoomPosition = (visibleRange.min - start) / (end - start);
        this.zoomFactor = range.minimum || range.maximum ? zoomFactor : (this.axis.maxPointLength / axis.scrollbarSettings.pointsLength);
        this.zoomPosition = range.minimum || range.maximum ? zoomPosition : axis.zoomPosition;
        this.zoomPosition = (this.component.enableRtl && axis.orientation === 'Horizontal' && !axis.isInversed) || (axis.isInversed && !(this.component.enableRtl && axis.orientation === 'Horizontal')) ? 1 - (this.zoomPosition + this.zoomFactor) : this.zoomPosition;
        this.scrollRange.min = start;
        this.scrollRange.max = end;
        this.scrollRange.delta = end - start;
        this.previousStart = visibleRange.min;
        this.previousEnd = visibleRange.max;
    };
    /**
     * Method to get log range
     *
     * @param axis
     */
    ScrollBar.prototype.getLogRange = function (axis) {
        var range = axis.scrollbarSettings.range;
        var start = logBase(range.minimum, axis.logBase);
        var end = logBase(range.maximum, axis.logBase);
        start = isFinite(start) ? start : range.minimum;
        end = isFinite(start) ? end : range.maximum;
        return { minimum: Math.floor(start / 1), maximum: Math.ceil(end / 1) };
    };
    /**
     * Method for injecting scrollbar module.
     *
     * @param axis
     * @param component
     */
    ScrollBar.prototype.injectTo = function (axis, component) {
        axis.zoomingScrollBar = new ScrollBar(component, axis);
    };
    /**
     * Method to destroy scrollbar.
     *
     * @returns {void}
     */
    ScrollBar.prototype.destroy = function () {
        var _this = this;
        if (this.axes) {
            this.axes.map(function (axis) {
                axis.zoomingScrollBar.destroy();
            });
        }
        else {
            this.elements.map(function (element) {
                _this.unWireEvents(element);
                remove(element.firstChild);
            });
            this.elements = [];
        }
    };
    /**
     * Method to get scrollbar module name.
     *
     * @returns {string}
     */
    ScrollBar.prototype.getModuleName = function () {
        return 'ScrollBar';
    };
    ScrollBar.prototype.getArgs = function (eventName, range, zoomPosition, zoomFactor, currentRanges) {
        var scrollArgs = {
            axis: (this.component.isBlazor ? {} : this.axis),
            name: eventName,
            range: this.axis.visibleRange,
            zoomFactor: this.axis.zoomFactor,
            zoomPosition: this.axis.zoomPosition,
            previousRange: range,
            previousZoomFactor: zoomFactor,
            previousZoomPosition: zoomPosition,
            currentRange: currentRanges
        };
        return scrollArgs;
    };
    return ScrollBar;
}());

var __extends$62 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * `Pareto series` module used to render the Pareto series.
 */
var ParetoSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$62(ParetoSeries, _super);
    function ParetoSeries() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.paretoAxes = [];
        return _this;
    }
    /**
     * Defines the Line initialization.
     */
    ParetoSeries.prototype.initSeries = function (targetSeries, chart) {
        var series = new Series(chart, 'series', targetSeries.properties, true);
        var colors = chart.palettes.length ? chart.palettes : getSeriesColor(chart.theme);
        var count = colors.length;
        series.name = 'Pareto';
        series.yAxisName = targetSeries.yAxisName + '_CumulativeAxis';
        series.category = 'Pareto';
        targetSeries.category = 'Pareto';
        series.index = targetSeries.index + chart.series.length;
        series.type = 'Line';
        series.interior = series.fill = series.paretoOptions.fill ? series.paretoOptions.fill : colors[series.index % count];
        series.width = series.paretoOptions.width;
        series.dashArray = series.paretoOptions.dashArray;
        series.marker = series.paretoOptions.marker;
        if (series.marker && series.marker.visible) {
            series.marker.shape = series.marker.shape ? series.marker.shape : markerShapes[chart.markerIndex % 10];
            chart.markerIndex++;
        }
        chart.visibleSeries.push(series);
        this.initAxis(targetSeries, series, chart);
    };
    /**
     * Defines the Axis initialization for Line.
     */
    ParetoSeries.prototype.initAxis = function (paretoSeries, targetSeries, chart) {
        var isExist = this.paretoAxes.some(function (currentAxis) {
            return currentAxis.name === targetSeries.yAxisName;
        });
        if (!isExist) {
            var secondaryAxis = (paretoSeries.yAxisName ? chart.axes.filter(function (axis) {
                return axis.name === paretoSeries.yAxisName;
            })[0] : chart.primaryYAxis);
            var newAxis = new Axis(chart, 'axes', {
                name: targetSeries.yAxisName,
                majorGridLines: {
                    width: 0
                },
                majorTickLines: secondaryAxis.majorTickLines,
                lineStyle: secondaryAxis.lineStyle,
                minimum: 0,
                maximum: 100,
                interval: 20,
                rowIndex: secondaryAxis.rowIndex,
                opposedPosition: true,
                labelFormat: '{value}%'
            });
            this.paretoAxes.push(newAxis);
        }
    };
    /**
     * Render Pareto series.
     *
     * @returns {void}
     * @private
     */
    ParetoSeries.prototype.render = function (series) {
        series.chart.columnSeriesModule.render(series);
    };
    /**
     * To perform the cumulative calculation for pareto series.
     */
    ParetoSeries.prototype.performCumulativeCalculation = function (json, series) {
        var data = json;
        var sum = 0;
        var count = 0;
        var length = data.length;
        for (var i = 0; i < length; i++) {
            sum += data[i][series.yName];
        }
        for (var i = 0; i < length; i++) {
            count = count + data[i][series.yName];
            data[i][series.yName] = Math.round((count / sum) * 100);
        }
        return data;
    };
    /**
     * Animates the series.
     *
     * @param  {Series} series - Defines the series to animate.
     * @returns {void}
     */
    ParetoSeries.prototype.doAnimation = function (series) {
        this.animate(series);
    };
    /**
     * Get module name.
     */
    ParetoSeries.prototype.getModuleName = function () {
        return 'ParetoSeries';
        /**
         * return the module name
         */
    };
    /**
     * To destroy the pareto series.
     *
     * @returns {void}
     * @private
     */
    ParetoSeries.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return ParetoSeries;
}(ColumnBase));

var ExportUtils = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for chart and accumulation annotation
     *
     * @param control
     */
    function ExportUtils(control) {
        this.control = control;
    }
    /**
     * To export the file as image/svg format.
     *
     * @param type
     * @param fileName
     */
    ExportUtils.prototype.export = function (type, fileName, orientation, controls, width, height, isVertical, header, footer, exportToMultiplePage) {
        var _this = this;
        var controlValue = this.getControlsValue(controls, isVertical, (exportToMultiplePage && type === 'PDF'), type);
        var canvasElements = [];
        var controlWidth = [];
        var controlHeight = [];
        var isDownload = !(Browser.userAgent.toString().indexOf('HeadlessChrome') > -1);
        orientation = isNullOrUndefined(orientation) ? PdfPageOrientation.Landscape : orientation;
        var _loop_1 = function (i) {
            controlWidth.push(width ? width : controlValue[i].width);
            controlHeight.push(height ? height : controlValue[i].height);
            var element = controls[i].svgObject;
            var isCanvas = controls[i].enableCanvas;
            var image = void 0;
            if (!isCanvas) {
                element = createElement('canvas', {
                    id: 'ej2-canvas',
                    attrs: {
                        'width': controlWidth[i].toString(),
                        'height': controlHeight[i].toString()
                    }
                });
            }
            var svgData = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' +
                controlValue[i].svg.outerHTML +
                '</svg>';
            var url = window.URL.createObjectURL(new Blob(type === 'SVG' ? [svgData] :
                [(new XMLSerializer()).serializeToString(controlValue[i].svg)], { type: 'image/svg+xml' }));
            if (type === 'SVG') {
                if (Browser.info.name === 'msie') {
                    var svg = new Blob([(new XMLSerializer()).serializeToString(controlValue[i].svg)], { type: 'application/octet-stream' });
                    window.navigator.msSaveOrOpenBlob(svg, fileName + '.' + type.toLocaleLowerCase());
                }
                else {
                    this_1.triggerDownload(fileName, type, url, isDownload);
                }
            }
            else if (Browser.info.name === 'msie') {
                var canvas = element;
                if (!isCanvas) {
                    canvas = this_1.createCanvas();
                }
                image = canvas.toDataURL();
                canvasElements.push(element);
                if (type === 'PDF') {
                    if (canvasElements.length === controlValue.length) {
                        this_1.exportPdf(canvasElements, orientation, controlWidth, controlHeight, isDownload, fileName, header, footer);
                    }
                }
                else {
                    this_1.doexport(type, image, fileName);
                }
            }
            else {
                var image_1 = new Image();
                var ctx_1 = element.getContext('2d');
                image_1.onload = (function () {
                    ctx_1.drawImage(image_1, 0, 0);
                    window.URL.revokeObjectURL(url);
                    canvasElements.push(element);
                    if (type === 'PDF') {
                        if (canvasElements.length === controlValue.length) {
                            _this.exportPdf(canvasElements, orientation, controlWidth, controlHeight, isDownload, fileName, header, footer);
                        }
                    }
                    else {
                        if (window.navigator.msSaveOrOpenBlob) {
                            window.navigator.msSaveOrOpenBlob(element.toBlob(null), fileName + '.' + type.toLocaleLowerCase());
                        }
                        else {
                            _this.triggerDownload(fileName, type, element.toDataURL('image/' + type.toLowerCase()), isDownload);
                        }
                    }
                });
                image_1.src = url;
            }
            if (!isCanvas) {
                removeElement$1(document.getElementById(controls[i].element.id + '_canvas'));
            }
        };
        var this_1 = this;
        for (var i = 0; i < controlValue.length; i++) {
            _loop_1(i);
        }
    };
    /**
     * To get data url for charts.
     *
     * @param chart
     */
    ExportUtils.prototype.getDataUrl = function (chart) {
        var controlValue = this.getControlsValue([chart]);
        var element = this.control.svgObject;
        var isCanvas = this.control.enableCanvas;
        if (!isCanvas) {
            element = createElement('canvas', {
                id: 'ej2-canvas',
                attrs: {
                    'width': controlValue[0].width.toString(),
                    'height': controlValue[0].height.toString()
                }
            });
        }
        var url = window.URL.createObjectURL(new Blob([(new XMLSerializer()).serializeToString(controlValue[0].svg)], { type: 'image/svg+xml' }));
        if (Browser.info.name === 'msie') {
            var canvas = element;
            if (!isCanvas) {
                canvas = this.createCanvas();
            }
            var argsData = {
                name: afterExport, cancel: false, dataUrl: element.toDataURL('image/png')
            };
            chart.trigger(afterExport, argsData);
            return { element: canvas, dataUrl: canvas.toDataURL() };
        }
        else {
            var image_2 = new Image();
            var ctx_2 = element.getContext('2d');
            image_2.onload = (function () {
                ctx_2.drawImage(image_2, 0, 0);
                window.URL.revokeObjectURL(url);
                var argsData = {
                    name: afterExport, cancel: false, dataUrl: element.toDataURL('image/png')
                };
                chart.trigger(afterExport, argsData);
                return argsData.dataUrl;
            });
            image_2.src = url;
            return { element: element, blobUrl: url };
        }
    };
    /**
     * To trigger the download element.
     *
     * @param fileName
     * @param type
     * @param url
     */
    ExportUtils.prototype.triggerDownload = function (fileName, type, url, isDownload) {
        createElement('a', {
            attrs: {
                'download': fileName + '.' + type.toLocaleLowerCase(),
                'href': url
            }
        }).dispatchEvent(new MouseEvent(isDownload ? 'click' : 'move', {
            view: window,
            bubbles: false,
            cancelable: true
        }));
    };
    /**
     * To get the maximum size value
     *
     * @param controls
     * @param name
     */
    // eslint-disable-next-line max-len
    ExportUtils.prototype.getControlsValue = function (controls, isVertical, isMultiPages, type) {
        var width = 0;
        var height = 0;
        var svgObject = new SvgRenderer('').createSvg({
            id: 'Svg_Export_Element',
            width: 200, height: 200
        });
        var controlValues = [];
        var backgroundColor;
        for (var i = 0; i < controls.length; i++) {
            var control = controls[i];
            var isCanvas = control.enableCanvas;
            var svg = control.svgObject.cloneNode(true);
            var groupEle = control.renderer.createGroup({
                style: (isNullOrUndefined(isVertical) || isVertical) ? 'transform: translateY(' + height + 'px)' :
                    'transform: translateX(' + width + 'px)'
            });
            backgroundColor = svg.childNodes[0] ? svg.childNodes[0].getAttribute('fill') : 'transparent';
            if (backgroundColor === 'transparent') {
                if (control.theme.indexOf('Dark') > -1 || control.theme === 'HighContrast') {
                    backgroundColor = 'rgba(0, 0, 0, 1)';
                }
                else {
                    backgroundColor = 'rgba(255, 255, 255, 1)';
                }
            }
            if (!isCanvas) {
                if (control.getModuleName() === 'stockChart') {
                    svg.childNodes[0].firstChild.setAttribute('fill', backgroundColor);
                    for (var index = 1; index < svg.childNodes.length; index++) {
                        svg.childNodes[index].childNodes[0].setAttribute('fill', backgroundColor);
                    }
                }
                else if (type === 'SVG') {
                    svg.childNodes[0].setAttribute('fill', backgroundColor);
                }
                groupEle.appendChild(svg);
            }
            var top_1 = 0;
            var left = 0;
            if (control.stockLegendModule && control.legendSettings.visible) {
                if (control.legendSettings.position === 'Bottom' || control.legendSettings.position === 'Top'
                    || control.legendSettings.position === 'Auto') {
                    top_1 += control.stockLegendModule.legendBounds.height;
                }
                else if (control.legendSettings.position === 'Left' || control.legendSettings.position === 'Right') {
                    left += control.stockLegendModule.legendBounds.width;
                }
            }
            width = (isNullOrUndefined(isVertical) || isVertical) ? Math.max(control.availableSize.width + left, width) :
                width + control.availableSize.width + left;
            height = (isNullOrUndefined(isVertical) || isVertical) ? height + control.availableSize.height + top_1 :
                Math.max(control.availableSize.height + top_1, height);
            if (!isCanvas) {
                svgObject.appendChild(groupEle);
            }
            if (isMultiPages || i === controls.length - 1) {
                if ((!isMultiPages && !(this.control.enableCanvas)) || (isMultiPages && !isCanvas)) {
                    svgObject.setAttribute('width', width + '');
                    svgObject.setAttribute('height', height + '');
                    svgObject.setAttribute('style', 'background-color: ' + backgroundColor + ';');
                }
                controlValues.push({
                    'width': width,
                    'height': height,
                    'svg': svgObject
                });
            }
            if (isMultiPages && (i < controls.length)) {
                width = 0;
                height = 0;
                svgObject = new SvgRenderer('').createSvg({
                    id: 'Svg_Export_Element',
                    width: 200, height: 200
                });
            }
        }
        return controlValues;
    };
    ExportUtils.prototype.createCanvas = function () {
        var chart = this.control;
        this.canvasRender(true, chart);
        var canvas = chart.svgObject;
        this.canvasRender(false, chart);
        return canvas;
    };
    /**
     * To convert svg chart into canvas chart to fix export issue in IE
     * We cant export svg to other formats in IE
     *
     * @param enableCanvas
     * @param chart
     * @param enableCanvas
     * @param chart
     */
    ExportUtils.prototype.canvasRender = function (enableCanvas, chart) {
        chart.enableCanvas = enableCanvas;
        chart['preRender']();
        chart['render']();
    };
    // eslint-disable-next-line max-len
    ExportUtils.prototype.exportPdf = function (element, orientation, width, height, isDownload, fileName, header, footer) {
        var document = new PdfDocument();
        var margin = document.pageSettings.margins;
        var pdfDefaultWidth = document.pageSettings.width;
        var pdfDefaultHeight = document.pageSettings.height;
        for (var i = 0; element.length > i; i++) {
            var imageString = element[i].toDataURL('image/jpeg').replace('image/jpeg', 'image/octet-stream');
            document.pageSettings.orientation = orientation;
            var exactWidth = (pdfDefaultWidth < width[i]) ? (width[i] + margin.left + margin.right) : pdfDefaultWidth;
            var exactHeight = (pdfDefaultHeight < height[i]) ? (height[i] + margin.top + margin.bottom) : pdfDefaultHeight;
            if (header !== undefined) {
                var font = new PdfStandardFont(1, header.fontSize || 15);
                var pdfHeader = new PdfPageTemplateElement(exactWidth, 40);
                pdfHeader.graphics.drawString(header.content + '', font, null, new PdfSolidBrush(new PdfColor(0, 0, 0)), header.x, header.y, null);
                document.template.top = pdfHeader;
            }
            if (footer !== undefined) {
                var font = new PdfStandardFont(1, footer.fontSize || 15);
                var pdfFooter = new PdfPageTemplateElement(exactWidth, 40);
                pdfFooter.graphics.drawString(footer.content + '', font, null, new PdfSolidBrush(new PdfColor(0, 0, 0)), footer.x, footer.y, null);
                document.template.bottom = pdfFooter;
            }
            document.pageSettings.size = new SizeF(exactWidth, exactHeight);
            imageString = imageString.slice(imageString.indexOf(',') + 1);
            document.pages.add().graphics.drawImage(new PdfBitmap(imageString), 0, 0, width[i], height[i]);
        }
        if (isDownload) {
            document.save(fileName + '.pdf');
            document.destroy();
        }
    };
    ExportUtils.prototype.doexport = function (type, image, fileName) {
        var images = [];
        var fileType = type || 'JPG';
        images = [image];
        this.exportImage(images, fileName, fileType, image);
    };
    ExportUtils.prototype.exportImage = function (images, fileName, fileType, image) {
        var buffers = [];
        var length = (!(images instanceof HTMLElement)) ? images.length : 0;
        for (var g = 0; g < length; g++) {
            image = images[g];
            image = image.replace(/^data:[a-z]*;,/, '');
            var image1 = image.split(',');
            var byteString = atob(image1[1]);
            var buffer = new ArrayBuffer(byteString.length);
            var intArray = new Uint8Array(buffer);
            for (var i = 0; i < byteString.length; i++) {
                intArray[i] = byteString.charCodeAt(i);
            }
            buffers.push(buffer);
        }
        for (var j = 0; j < buffers.length; j++) {
            var b = new Blob([buffers[j]], { type: 'application/octet-stream' });
            if (Browser.info.name === 'msie') {
                window.navigator.msSaveOrOpenBlob(b, fileName + '.' + fileType.toLocaleLowerCase());
            }
        }
    };
    return ExportUtils;
}());

/**
 * `ExportModule` module is used to print and export the rendered chart.
 */
var Export = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for export module.
     *
     * @private
     */
    function Export(chart) {
        this.actualRowCount = 0;
        this.series = [];
        this.axisCollection = [];
        this.requiredValuesLength = 0;
        this.histogramSeriesCount = 0;
        this.chart = chart;
    }
    /**
     * Handles the export method for chart control.
     */
    Export.prototype.export = function (type, fileName, orientation, controls, width, height, isVertical, header, footer, exportToMultiplePage) {
        var exportChart = new ExportUtils(this.chart);
        controls = controls ? controls : [this.chart];
        var argsData = {
            cancel: false, name: beforeExport, width: width, height: height
        };
        this.chart.trigger(beforeExport, argsData);
        if (!argsData.cancel) {
            if (type === 'CSV' || type === 'XLSX') {
                this.excelExport(controls, fileName, type);
            }
            else {
                exportChart.export(type, fileName, orientation, controls, width = argsData.width, height = argsData.height, isVertical, header, footer, exportToMultiplePage);
            }
        }
    };
    /**
     * To handle the export of XLSX and CSV files.
     */
    Export.prototype.excelExport = function (controls, fileName, type) {
        this.rows = [];
        this.actualRowCount = 1;
        var workSheets = [];
        var requiredValues = [];
        var headerStyle = { bold: true, hAlign: 'Center', vAlign: 'Center', wrapText: true };
        var xValues = [];
        var isRangeNavigator = controls[0].getModuleName() === 'rangeNavigator';
        var isAccumulation = controls[0].getModuleName() === 'accumulationchart';
        this.series = isRangeNavigator ? controls[0].series : controls[0].visibleSeries;
        if (isRangeNavigator && this.series.length === 0) {
            if (controls[0].dataSource) {
                //To create an Excel sheet when the Rangenavigator series is not given.
                this.createRangeNavigatorExcelSheet(controls[0], headerStyle, type);
            }
        }
        else {
            this.histogramSeriesCount = 0;
            this.requiredValuesLength = 0;
            this.axisCollection = [];
            if (isAccumulation || isRangeNavigator) {
                this.axisCollection.push(null);
            }
            else {
                this.axisCollection = controls[0].getModuleName() === 'stockChart' ? controls[0].chart.horizontalAxes : controls[0].horizontalAxes;
            }
            //To get the number of columns for the excel.
            requiredValues = this.getRequiredValues(isRangeNavigator);
            if (this.requiredValuesLength === 0 && this.series.length === this.histogramSeriesCount) {
                return;
            }
            //To get all x values in the series.
            xValues = this.getXValue(requiredValues, controls, isRangeNavigator, isAccumulation);
            //To get the the chart title and series name.
            this.getTitle(requiredValues, headerStyle, controls, isRangeNavigator, isAccumulation, type, xValues[0].length);
            //To create an Excel sheet.
            this.createExcelSheet(isRangeNavigator, isAccumulation, xValues, type, requiredValues, headerStyle, controls);
        }
        var columns = [];
        this.requiredValuesLength = this.requiredValuesLength === 0 ? 1 : this.requiredValuesLength;
        for (var columnCount = 0; columnCount < this.requiredValuesLength; columnCount++) {
            columns.push({ index: columnCount + 1, width: 100 });
        }
        workSheets.push({ columns: columns, rows: this.rows });
        var book = new Workbook({ worksheets: workSheets }, type === 'XLSX' ? 'xlsx' : 'csv');
        fileName = fileName ? fileName : type === 'XLSX' ? 'XLSX' : 'CSV';
        book.save(fileName + (type === 'XLSX' ? '.xlsx' : '.csv'));
    };
    /**
     * To create an Excel sheet when the Rangenavigator series is not given.
     */
    Export.prototype.createRangeNavigatorExcelSheet = function (controls, headerStyle, type) {
        var xName = controls.xName;
        var yName = controls.yName;
        this.rows.push({
            index: this.actualRowCount, cells: [{ index: 1, value: controls.valueType.indexOf('DateTime') > -1 ? controls.valueType : 'Category', colSpan: 1, rowSpan: 1,
                    style: headerStyle },
                { index: 2, value: yName, colSpan: 1, rowSpan: 1, style: headerStyle }]
        });
        this.actualRowCount++;
        var dataSource = controls.dataSource;
        for (var dataCount = 0; dataCount < dataSource.length; dataCount++) {
            this.rows.push({ index: this.actualRowCount, cells: [{ index: 1, value: (type === 'CSV' && dataSource[dataCount][xName] === null) ? '' :
                            dataSource[dataCount][xName], colSpan: 1, rowSpan: 1, style: headerStyle },
                    { index: 2, value: (type === 'CSV' && dataSource[dataCount][yName] === null) ? '' : dataSource[dataCount][yName], colSpan: 1, rowSpan: 1, style: {} }] });
            this.actualRowCount++;
        }
        this.requiredValuesLength = 2;
    };
    /**
     * To get the number of columns for the excel.
     */
    Export.prototype.getRequiredValues = function (isRangeNavigator) {
        var requiredValues = [];
        var _loop_1 = function (seriesCount) {
            var seriesType = this_1.series[seriesCount].type;
            if ((!isRangeNavigator && !this_1.series[seriesCount].visible) || this_1.series[seriesCount].category === 'TrendLine') {
                requiredValues.push([]);
                return "continue";
            }
            if (seriesType === 'Histogram') {
                requiredValues.push([]);
                this_1.histogramSeriesCount++;
            }
            else if (this_1.series[seriesCount].category === 'Pareto') {
                requiredValues.push([this_1.series[seriesCount]['xName'], 'y']);
            }
            else if (seriesType.indexOf('Range') !== -1 || seriesType === 'Hilo') {
                requiredValues.push([this_1.series[seriesCount]['xName'], this_1.series[seriesCount]['high'], this_1.series[seriesCount]['low']]);
            }
            else if (seriesType === 'HiloOpenClose' || seriesType === 'Candle') {
                requiredValues.push([this_1.series[seriesCount]['xName'], this_1.series[seriesCount]['high'], this_1.series[seriesCount]['low'], this_1.series[seriesCount]['open'], this_1.series[seriesCount]['close']]);
                if (seriesType === 'Candle' && this_1.series[seriesCount]['volume'] !== '') {
                    requiredValues[seriesCount].push(this_1.series[seriesCount]['volume']);
                }
            }
            else if (seriesType === 'BoxAndWhisker') {
                requiredValues.push([this_1.series[seriesCount]['xName'], 'maximum', 'upperQuartile', 'median', 'lowerQuartile', 'minimum', 'outliers']);
            }
            else if (seriesType === 'Bubble') {
                requiredValues.push([this_1.series[seriesCount]['xName'], this_1.series[seriesCount]['yName']]);
                if (this_1.series[seriesCount]['size'] !== '') {
                    requiredValues[seriesCount].push(this_1.series[seriesCount]['size']);
                }
            }
            else if (seriesType === 'Pie') {
                requiredValues.push([this_1.series[seriesCount]['xName'], this_1.series[seriesCount]['yName']]);
                if (this_1.series[seriesCount]['radius'].match(/[a-zA-Z]/)) {
                    requiredValues[seriesCount].push(this_1.series[seriesCount]['radius']);
                }
            }
            else {
                requiredValues.push([this_1.series[seriesCount]['xName'], this_1.series[seriesCount]['yName']]);
            }
            if (this_1.series[seriesCount].errorBar &&
                this_1.series[seriesCount].errorBar.visible) {
                var errorBar_1 = this_1.series[seriesCount].errorBar;
                var errorTypes = ['verticalError', 'horizontalError', 'verticalNegativeError', 'horizontalNegativeError', 'verticalPositiveError', 'horizontalPositiveError'];
                errorTypes.forEach(function (errorType) {
                    if (typeof errorBar_1[errorType] === 'string') {
                        requiredValues[seriesCount].push(errorBar_1[errorType]);
                    }
                });
            }
            this_1.requiredValuesLength += requiredValues[seriesCount].length;
        };
        var this_1 = this;
        for (var seriesCount = 0; seriesCount < this.series.length; seriesCount++) {
            _loop_1(seriesCount);
        }
        return requiredValues;
    };
    /**
     * To obtain the chart title and series name.
     */
    Export.prototype.getTitle = function (requiredValues, headerStyle, controls, isRangeNavigator, isAccumulation, type, xValueLength) {
        var cells = [];
        var additionalCells = [];
        var index = 1;
        var isTitle = false;
        if (!isRangeNavigator && type === 'XLSX' && controls[0].title) {
            this.rows.push({});
            this.actualRowCount++;
            isTitle = true;
        }
        for (var axisCount = 0; axisCount < this.axisCollection.length; axisCount++) {
            if (isAccumulation && xValueLength === 0) {
                break;
            }
            var isYName = false;
            var valueType = '';
            var currentIndex = index;
            var isXValue = false;
            var axisName = this.axisCollection[axisCount] !== null ? this.axisCollection[axisCount].name === 'primaryXAxis' ? null : this.axisCollection[axisCount].name : '';
            for (var seriesCount = 0; seriesCount < this.series.length; seriesCount++) {
                if (!isRangeNavigator && ((!isAccumulation && (axisName !==
                    this.series[seriesCount].xAxisName)) ||
                    !this.series[seriesCount].visible ||
                    this.series[seriesCount].category === 'TrendLine' || this.series[seriesCount].type === 'Histogram')) {
                    continue;
                }
                if (!isXValue) {
                    cells.push({});
                    index++;
                }
                isXValue = true;
                var seriesName = this.series[seriesCount].name;
                var requiredValuesLength = this.series[seriesCount].type === 'BoxAndWhisker' ? requiredValues[seriesCount].length - 1 : requiredValues[seriesCount].length;
                if (requiredValues[seriesCount][1] === this.series[seriesCount].yName) {
                    for (var requiredValuesCount = 1; requiredValuesCount < requiredValuesLength; requiredValuesCount++) {
                        cells.push({ index: index, value: (requiredValuesCount === 1 ? seriesName ? seriesName : 'Series-' + (seriesCount + 1) : requiredValues[seriesCount][requiredValuesCount]), colSpan: 1, rowSpan: 1, style: headerStyle });
                        index++;
                    }
                }
                else {
                    cells.push({ index: index, value: seriesName ? seriesName : 'Series-' + (seriesCount + 1), colSpan: requiredValuesLength - 1, rowSpan: 1, style: headerStyle });
                    var localIndex = index;
                    for (var requiredValuesCount = 1; requiredValuesCount < requiredValuesLength; requiredValuesCount++) {
                        additionalCells.push({
                            index: localIndex, value: requiredValues[seriesCount][requiredValuesCount],
                            colSpan: 1, rowSpan: 1, style: headerStyle
                        });
                        localIndex++;
                    }
                    if (this.series[seriesCount].type === 'BoxAndWhisker') {
                        cells.push({ index: localIndex, value: requiredValues[seriesCount][requiredValuesLength],
                            colSpan: 1, rowSpan: 2, style: headerStyle
                        });
                        localIndex++;
                    }
                    index = localIndex;
                    isYName = true;
                }
                valueType = isAccumulation ? requiredValues[0][0] : isRangeNavigator ? controls[0].valueType :
                    this.axisCollection[axisCount].valueType;
                valueType = (isAccumulation || valueType.indexOf('DateTime') > -1) ? valueType : 'Category';
            }
            if (isXValue) {
                cells[(currentIndex - 1)] = { index: currentIndex, value: valueType, colSpan: 1,
                    rowSpan: isYName ? 2 : 1, style: headerStyle };
            }
        }
        if (cells.length) {
            this.rows.push({ index: this.actualRowCount, cells: cells });
            this.actualRowCount++;
        }
        if (additionalCells.length) {
            this.rows.push({ index: this.actualRowCount, cells: additionalCells });
            this.actualRowCount++;
        }
        if (isTitle) {
            cells = [];
            cells.push({ index: 1, value: controls[0].title,
                colSpan: (index === 1 ? index : index - 1), rowSpan: 1, style: headerStyle });
            this.rows[0] = ({ index: 1, cells: cells });
        }
        this.requiredValuesLength = index - 1;
    };
    /**
     * To obtain all x values in the series.
     */
    Export.prototype.getXValue = function (requiredValues, controls, isRangeNavigator, isAccumulation) {
        var xValues = [];
        for (var axisCount = 0; axisCount < this.axisCollection.length; axisCount++) {
            var xValue = [];
            var axisName = this.axisCollection[axisCount] !== null ? this.axisCollection[axisCount].name === 'primaryXAxis' ? null : this.axisCollection[axisCount].name : '';
            var valueType = isAccumulation ? '' : isRangeNavigator ? controls[0].valueType : this.axisCollection[axisCount].valueType;
            for (var seriesCount = 0; seriesCount < this.series.length; seriesCount++) {
                if ((!isRangeNavigator && ((!isAccumulation && (axisName !==
                    this.series[seriesCount].xAxisName)) ||
                    !this.series[seriesCount].visible) ||
                    this.series[seriesCount].category === 'TrendLine' || this.series[seriesCount].type === 'Histogram')) {
                    continue;
                }
                for (var dataCount = 0; dataCount < this.series[seriesCount].dataSource.length; dataCount++) {
                    if (isAccumulation && !this.series[seriesCount].points[dataCount].visible) {
                        continue;
                    }
                    xValue.push((valueType.indexOf('DateTime') > -1) ? new Date(this.series[seriesCount].
                        dataSource[dataCount][requiredValues[seriesCount][0]]).getTime() :
                        this.series[seriesCount].dataSource[dataCount][requiredValues[seriesCount][0]]);
                }
            }
            xValues.push(xValue);
        }
        var _loop_2 = function (xValuesLength) {
            xValues[xValuesLength] = xValues[xValuesLength].filter(function (item, index) {
                return xValues[xValuesLength].indexOf(item) === index;
            });
        };
        for (var xValuesLength = 0; xValuesLength < xValues.length; xValuesLength++) {
            _loop_2(xValuesLength);
        }
        return (xValues);
    };
    /**
     * To create an Excel sheet.
     */
    Export.prototype.createExcelSheet = function (isRangeNavigator, isAccumulation, xValues, type, requiredValues, headerStyle, controls) {
        var startIndex = 0;
        var index = 0;
        for (var axisCount = 0; axisCount < this.axisCollection.length; axisCount++) {
            var axisName = this.axisCollection[axisCount] !== null ? this.axisCollection[axisCount].name === 'primaryXAxis' ? null : this.axisCollection[axisCount].name : '';
            var valueType = isAccumulation ? '' : isRangeNavigator ? controls[0].valueType : this.axisCollection[axisCount].valueType;
            for (var xValueLength = 0; xValueLength < xValues[axisCount].length; xValueLength++) {
                index = startIndex ? startIndex : 1;
                var cells = [];
                var isXValue = true;
                for (var seriesCount = 0; seriesCount < this.series.length; seriesCount++) {
                    if ((!isRangeNavigator && ((!isAccumulation &&
                        this.series[seriesCount].xAxisName !== axisName) ||
                        !this.series[seriesCount].visible) ||
                        this.series[seriesCount].category === 'TrendLine' || this.series[seriesCount].type === 'Histogram')) {
                        continue;
                    }
                    var isExist = false;
                    var dataSource = this.series[seriesCount].dataSource;
                    for (var dataCount = 0; dataCount < dataSource.length; dataCount++) {
                        var xValue = (valueType.indexOf('DateTime') > -1) ? this.series[seriesCount].category === 'Pareto' ? new Date(this.series[seriesCount].points[dataCount][requiredValues[seriesCount][0]]).getTime() :
                            new Date(dataSource[dataCount][requiredValues[seriesCount][0]]).getTime() :
                            this.series[seriesCount].category === 'Pareto' ? this.series[seriesCount].points[dataCount][requiredValues[seriesCount][0]] : dataSource[dataCount][requiredValues[seriesCount][0]];
                        if (xValues[axisCount][xValueLength] === xValue) {
                            var usedValueCount = isXValue ? 0 : 1;
                            var usedValueLength = this.series[seriesCount].type === 'BoxAndWhisker' ? requiredValues[seriesCount].length - 1 : requiredValues[seriesCount].length;
                            for (; usedValueCount < usedValueLength; usedValueCount++) {
                                var value = (usedValueCount !== 0 && (this.series[seriesCount].type === 'BoxAndWhisker' || this.series[seriesCount].category === 'Pareto')) ? this.series[seriesCount].points[dataCount][requiredValues[seriesCount][usedValueCount]] : dataSource[dataCount][requiredValues[seriesCount][usedValueCount]];
                                if (value === null && type === 'CSV') {
                                    value = '';
                                }
                                cells.push({
                                    index: (usedValueCount === 0 ? startIndex === 0 ? 1 : startIndex : index), value: value,
                                    colSpan: 1, rowSpan: 1, style: usedValueCount === 0 ? headerStyle : {}
                                });
                                index++;
                            }
                            if (this.series[seriesCount].type === 'BoxAndWhisker') {
                                cells.push({ index: index, value: this.series[seriesCount].points[dataCount]['outliers'][0], colSpan: 1, rowSpan: 1, style: {} });
                                index++;
                            }
                            isXValue = false;
                            isExist = true;
                            break;
                        }
                    }
                    if (!isExist) {
                        index += (requiredValues[seriesCount].length - 1);
                    }
                }
                this.rows.push({ index: this.actualRowCount, cells: cells });
                this.actualRowCount++;
            }
            startIndex = index;
        }
    };
    /**
     * To get data url for charts.
     */
    Export.prototype.getDataUrl = function (chart) {
        var exportUtil = new ExportUtils(chart);
        return exportUtil.getDataUrl(chart);
    };
    /**
     * Get module name.
     */
    Export.prototype.getModuleName = function () {
        // Returns the module name
        return 'Export';
    };
    /**
     * To destroy the chart.
     *
     * @returns {void}
     * @private
     */
    Export.prototype.destroy = function () {
        // Destroy method performed here
    };
    return Export;
}());

/**
 * Chart component exported items
 */

var __extends$64 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * AccumulationChart base file
 */
/**
 * Annotation for accumulation series
 */
var AccumulationAnnotationSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$64(AccumulationAnnotationSettings, _super);
    function AccumulationAnnotationSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$8([
        Property(null)
    ], AccumulationAnnotationSettings.prototype, "content", void 0);
    __decorate$8([
        Property('0')
    ], AccumulationAnnotationSettings.prototype, "x", void 0);
    __decorate$8([
        Property('0')
    ], AccumulationAnnotationSettings.prototype, "y", void 0);
    __decorate$8([
        Property('Pixel')
    ], AccumulationAnnotationSettings.prototype, "coordinateUnits", void 0);
    __decorate$8([
        Property('Chart')
    ], AccumulationAnnotationSettings.prototype, "region", void 0);
    __decorate$8([
        Property('Middle')
    ], AccumulationAnnotationSettings.prototype, "verticalAlignment", void 0);
    __decorate$8([
        Property('Center')
    ], AccumulationAnnotationSettings.prototype, "horizontalAlignment", void 0);
    __decorate$8([
        Property(null)
    ], AccumulationAnnotationSettings.prototype, "description", void 0);
    return AccumulationAnnotationSettings;
}(ChildProperty));
/**
 * Configures the dataLabel in accumulation chart.
 */
var AccumulationDataLabelSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$64(AccumulationDataLabelSettings, _super);
    function AccumulationDataLabelSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$8([
        Property(false)
    ], AccumulationDataLabelSettings.prototype, "visible", void 0);
    __decorate$8([
        Property(true)
    ], AccumulationDataLabelSettings.prototype, "showZero", void 0);
    __decorate$8([
        Property(null)
    ], AccumulationDataLabelSettings.prototype, "name", void 0);
    __decorate$8([
        Property('transparent')
    ], AccumulationDataLabelSettings.prototype, "fill", void 0);
    __decorate$8([
        Property('Inside')
    ], AccumulationDataLabelSettings.prototype, "position", void 0);
    __decorate$8([
        Property(5)
    ], AccumulationDataLabelSettings.prototype, "rx", void 0);
    __decorate$8([
        Property(5)
    ], AccumulationDataLabelSettings.prototype, "ry", void 0);
    __decorate$8([
        Property(0)
    ], AccumulationDataLabelSettings.prototype, "angle", void 0);
    __decorate$8([
        Property(false)
    ], AccumulationDataLabelSettings.prototype, "enableRotation", void 0);
    __decorate$8([
        Complex({ width: null, color: null }, Border)
    ], AccumulationDataLabelSettings.prototype, "border", void 0);
    __decorate$8([
        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, Font)
    ], AccumulationDataLabelSettings.prototype, "font", void 0);
    __decorate$8([
        Complex({}, Connector)
    ], AccumulationDataLabelSettings.prototype, "connectorStyle", void 0);
    __decorate$8([
        Property(null)
    ], AccumulationDataLabelSettings.prototype, "template", void 0);
    __decorate$8([
        Property('')
    ], AccumulationDataLabelSettings.prototype, "format", void 0);
    __decorate$8([
        Property(null)
    ], AccumulationDataLabelSettings.prototype, "maxWidth", void 0);
    __decorate$8([
        Property('Ellipsis')
    ], AccumulationDataLabelSettings.prototype, "textOverflow", void 0);
    __decorate$8([
        Property('Normal')
    ], AccumulationDataLabelSettings.prototype, "textWrap", void 0);
    return AccumulationDataLabelSettings;
}(ChildProperty));
/**
 * Center value of the Pie series.
 */
var PieCenter = /** @__PURE__ @class */ (function (_super) {
    __extends$64(PieCenter, _super);
    function PieCenter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$8([
        Property('50%')
    ], PieCenter.prototype, "x", void 0);
    __decorate$8([
        Property('50%')
    ], PieCenter.prototype, "y", void 0);
    return PieCenter;
}(ChildProperty));
/**
 * Points model for the series.
 *
 * @public
 */
var AccPoints = /** @__PURE__ @class */ (function () {
    function AccPoints() {
        /** accumulation point visibility. */
        this.visible = true;
        /** accumulation point symbol location. */
        this.symbolLocation = null;
        /** @private */
        this.region = null;
        /** @private */
        this.labelRegion = null;
        /** @private */
        this.labelVisible = true;
        this.regions = null;
        /** @private */
        this.isExplode = false;
        /** @private */
        this.isClubbed = false;
        /** @private */
        this.isSliced = false;
        /** @private  */
        this.argsData = null;
        /** @private */
        this.isLabelUpdated = null;
        /** @private */
        this.initialLabelRegion = null;
    }
    return AccPoints;
}());
/**
 *  Configures the series in accumulation chart.
 */
var AccumulationSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$64(AccumulationSeries, _super);
    function AccumulationSeries() {
        /**
         * Specifies the dataSource for the series. It can be an array of JSON objects or an instance of DataManager.
         * ```html
         * <div id='Pie'></div>
         * ```
         * ```typescript
         * let dataManager: DataManager = new DataManager({
         *         url: 'http://mvc.syncfusion.com/Services/Northwnd.svc/Tasks/'
         * });
         * let query: Query = new Query().take(50).where('Estimate', 'greaterThan', 0, false);
         * let pie: AccumulationChart = new AccumulationChart({
         * ...
         *     series: [{
         *        dataSource: dataManager,
         *        xName: 'Id',
         *        yName: 'Estimate',
         *        query: query
         *    }],
         * ...
         * });
         * pie.appendTo('#Pie');
         * ```
         *
         * @default ''
         */
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** @private */
        _this.points = [];
        /** @private */
        _this.clubbedPoints = [];
        /** @private */
        _this.sumOfPoints = 0;
        /** @private */
        _this.isRectSeries = true;
        /** @private */
        _this.clipRect = new Rect(0, 0, 0, 0);
        /** @private */
        _this.category = 'Series';
        /** @private */
        _this.rightSidePoints = [];
        /** @private */
        _this.leftSidePoints = [];
        return _this;
    }
    /**
     * To refresh the Datamanager for series
     *
     * @private
     */
    AccumulationSeries.prototype.refreshDataManager = function (accumulation, render) {
        var _this = this;
        this.radius = this.radius ? this.radius : (Browser.isDevice && this.dataLabel.position === 'Outside') ? '40%' : '80%';
        var dateSource = this.dataSource || accumulation.dataSource;
        if (!(dateSource instanceof DataManager) && isNullOrUndefined(this.query)) {
            this.dataManagerSuccess({ result: dateSource, count: dateSource.length }, accumulation, render);
            return;
        }
        var dataManager = this.dataModule.getData(this.dataModule.generateQuery().requiresCount());
        dataManager.then(function (e) { return _this.dataManagerSuccess(e, accumulation); });
    };
    /**
     * To get points on dataManager is success
     *
     * @private
     */
    AccumulationSeries.prototype.dataManagerSuccess = function (e, accumulation, render) {
        if (render === void 0) { render = true; }
        var argsData = {
            name: seriesRender, series: this, data: e.result
        };
        accumulation.allowServerDataBinding = false;
        accumulation.trigger(seriesRender, argsData);
        this.resultData = e.result !== '' ? e.result : [];
        if (!accumulation.isBlazor && !render) {
            this.getPoints(this.resultData, accumulation); // To update datasource using onPropertyChanged method. incident id: 290690
        }
        /* eslint-disable */
        if ((++accumulation.seriesCounts === accumulation.visibleSeries.length && render)
            // tslint:disable-next-line:no-string-literal
            || (window['Blazor'] && !render && accumulation.seriesCounts === 1)) {
            this.getPoints(this.resultData, accumulation);
            accumulation.refreshChart();
        }
    };
    /** @private To find points from result data */
    AccumulationSeries.prototype.getPoints = function (result, accumulation) {
        var length = Object.keys(result).length;
        this.sumOfPoints = 0;
        if (length === 0) {
            // fix for Pie datalabels are not removed for empty datasource
            this.points = [];
            return null;
        }
        this.findSumOfPoints(result);
        this.points = [];
        this.clubbedPoints = [];
        this.sumOfClub = 0;
        var point;
        var colors = this.palettes.length ? this.palettes : getSeriesColor(accumulation.theme);
        var clubValue = stringToNumber(this.groupTo, this.sumOfPoints);
        for (var i = 0; i < length; i++) {
            point = this.setPoints(result, i, colors, accumulation);
            var currentY = point.y;
            if (!this.isClub(point, clubValue, i)) {
                if (isNullOrUndefined(point.y)) {
                    point.visible = false;
                }
                this.pushPoints(point, colors);
            }
            else {
                point.index = this.clubbedPoints.length;
                point.isExplode = true;
                this.clubbedPoints.push(point);
                point.isSliced = true;
            }
        }
        this.lastGroupTo = this.groupTo;
        if (this.sumOfClub > 0) {
            var clubPoint_1 = this.generateClubPoint();
            this.pushPoints(clubPoint_1, colors);
            var pointsLength_1 = this.points.length - 1;
            this.clubbedPoints.map(function (point) {
                point.index += pointsLength_1;
                point.color = clubPoint_1.color;
            });
        }
        if (this.clubbedPoints.length && this.explode && this.type === 'Pie'
            && (this.explodeAll || this.points[this.points.length - 1].index === this.explodeIndex)) {
            this.points.splice(this.points.length - 1, 1);
            this.points = this.points.concat(this.clubbedPoints);
        }
    };
    AccumulationSeries.prototype.generateClubPoint = function () {
        var clubPoint = new AccPoints();
        clubPoint.isClubbed = true;
        clubPoint.x = 'Others';
        clubPoint.y = this.sumOfClub;
        clubPoint.text = clubPoint.originalText = clubPoint.x + ': ' + this.sumOfClub;
        clubPoint.sliceRadius = '80%';
        return clubPoint;
    };
    /**
     * Method to set point index and color
     */
    AccumulationSeries.prototype.pushPoints = function (point, colors) {
        point.index = this.points.length;
        point.isExplode = this.explodeAll || (point.index === this.explodeIndex);
        point.color = point.color || colors[point.index % colors.length];
        this.points.push(point);
    };
    /**
     * Method to find club point
     */
    AccumulationSeries.prototype.isClub = function (point, clubValue, index) {
        if (!isNullOrUndefined(clubValue)) {
            if (this.groupMode === 'Value' && Math.abs(point.y) <= clubValue) {
                this.sumOfClub += Math.abs(point.y);
                return true;
            }
            else if (this.groupMode === 'Point' && index >= clubValue) {
                this.sumOfClub += Math.abs(point.y);
                return true;
            }
        }
        return false;
    };
    /**
     * Method to find sum of points in the series
     */
    AccumulationSeries.prototype.findSumOfPoints = function (result) {
        var length = Object.keys(result).length;
        for (var i = 0; i < length; i++) {
            if (!isNullOrUndefined(result[i]) && !isNullOrUndefined(result[i][this.yName]) && !isNaN(result[i][this.yName])) {
                this.sumOfPoints += Math.abs(result[i][this.yName]);
            }
        }
    };
    /**
     * Method to set points x, y and text from data source
     */
    AccumulationSeries.prototype.setPoints = function (data, i, colors, accumulation) {
        var point = new AccPoints();
        point.x = getValue(this.xName, data[i]);
        point.y = getValue(this.yName, data[i]);
        point.percentage = (+(point.y / this.sumOfPoints * 100).toFixed(2));
        point.legendImageUrl = getValue(this.legendImageUrl, data[i]);
        point.color = getValue(this.pointColorMapping, data[i]);
        point.text = point.originalText = getValue(this.dataLabel.name || '', data[i]);
        point.tooltip = getValue(this.tooltipMappingName || '', data[i]);
        point.sliceRadius = getValue(this.radius, data[i]);
        point.sliceRadius = isNullOrUndefined(point.sliceRadius) ? '80%' : point.sliceRadius;
        point.separatorY = accumulation.intl.formatNumber(point.y, { useGrouping: accumulation.useGroupingSeparator });
        this.setAccEmptyPoint(point, i, data, colors);
        return point;
    };
    /**
     * Method render the series elements for accumulation chart
     * @private
     */
    AccumulationSeries.prototype.renderSeries = function (accumulation, redraw) {
        var seriesGroup = redraw ? getElement$1(accumulation.element.id + '_Series_' + this.index) :
            accumulation.renderer.createGroup({ id: accumulation.element.id + '_Series_' + this.index });
        this.renderPoints(accumulation, seriesGroup, redraw);
        var datalabelGroup;
        if (accumulation.accumulationDataLabelModule && this.dataLabel.visible) {
            datalabelGroup = accumulation.renderer.createGroup({ id: accumulation.element.id + '_datalabel_Series_' + this.index });
            datalabelGroup.style.visibility =
                (((this.animation.enable && animationMode != 'Disable') || animationMode === 'Enable') && accumulation.animateSeries && this.type === 'Pie') ? 'hidden' : 'visible';
            this.renderDataLabel(accumulation, datalabelGroup, redraw);
        }
        if (this.type === 'Pie') {
            this.findMaxBounds(this.labelBound, this.accumulationBound);
            accumulation.pieSeriesModule.animateSeries(accumulation, this.animation, this, seriesGroup);
        }
        if (accumulation.accumulationLegendModule) {
            this.labelBound.x -= accumulation.explodeDistance;
            this.labelBound.y -= accumulation.explodeDistance;
            this.labelBound.height += (accumulation.explodeDistance - this.labelBound.y);
            this.labelBound.width += (accumulation.explodeDistance - this.labelBound.x);
        }
    };
    /**
     * Method render the points elements for accumulation chart series.
     */
    AccumulationSeries.prototype.renderPoints = function (accumulation, seriesGroup, redraw) {
        var pointId = accumulation.element.id + '_Series_' + this.index + '_Point_';
        var option;
        for (var _i = 0, _a = this.points; _i < _a.length; _i++) {
            var point = _a[_i];
            var argsData = {
                cancel: false, name: pointRender, series: this, point: point, fill: point.color,
                border: this.isEmpty(point) ? { width: this.emptyPointSettings.border.width, color: this.emptyPointSettings.border.color } :
                    { width: this.border.width, color: this.border.color }
            };
            accumulation.trigger(pointRender, argsData);
            point.color = argsData.fill;
            option = new PathOption(pointId + point.index, point.color, argsData.border.width || 1, argsData.border.color || point.color, this.opacity, argsData.series.dashArray, '');
            accumulation[(firstToLowerCase(this.type) + 'SeriesModule')].
                renderPoint(point, this, accumulation, option, seriesGroup, redraw);
        }
        appendChildElement(false, accumulation.getSeriesElement(), seriesGroup, redraw);
    };
    /**
     * Method render the datalabel elements for accumulation chart.
     */
    AccumulationSeries.prototype.renderDataLabel = function (accumulation, datalabelGroup, redraw) {
        accumulation.accumulationDataLabelModule.findAreaRect();
        var element = createElement('div', {
            id: accumulation.element.id + '_Series_0' + '_DataLabelCollections'
        });
        this.leftSidePoints = [], this.rightSidePoints = [];
        var firstQuarter = [];
        var secondQuarter = [];
        for (var _i = 0, _a = this.points; _i < _a.length; _i++) {
            var point = _a[_i];
            if (point.visible) {
                if (this.dataLabel.showZero || (!this.dataLabel.showZero && ((point.y !== 0) || (point.y === 0 &&
                    this.emptyPointSettings.mode === 'Zero')))) {
                    accumulation.accumulationDataLabelModule.renderDataLabel(point, this.dataLabel, datalabelGroup, this.points, this.index, element, redraw);
                }
            }
            if (point.midAngle >= 90 && point.midAngle <= 270) {
                this.leftSidePoints.push(point);
            }
            else {
                if (point.midAngle >= 0 && point.midAngle <= 90) {
                    secondQuarter.push(point);
                }
                else {
                    firstQuarter.push(point);
                }
            }
        }
        firstQuarter.sort(function (a, b) { return a.midAngle - b.midAngle; });
        secondQuarter.sort(function (a, b) { return a.midAngle - b.midAngle; });
        this.leftSidePoints.sort(function (a, b) { return a.midAngle - b.midAngle; });
        this.rightSidePoints = firstQuarter.concat(secondQuarter);
        accumulation.accumulationDataLabelModule.drawDataLabels(this, this.dataLabel, datalabelGroup, element, redraw);
        if (this.dataLabel.template !== null && element.childElementCount) {
            var dataLabelCallBack = accumulation.accumulationDataLabelModule.drawDataLabels.bind(accumulation.accumulationDataLabelModule, this, this.dataLabel, datalabelGroup, element, redraw);
            // tslint:disable-next-line:no-any
            if (accumulation.isReact) {
                accumulation.renderReactTemplates(dataLabelCallBack);
            }
            appendChildElement(false, getElement$1(accumulation.element.id + '_Secondary_Element'), element, redraw);
        }
        appendChildElement(false, accumulation.getSeriesElement(), datalabelGroup, redraw);
    };
    /**
     * To find maximum bounds for smart legend placing
     *
     * @private
     */
    AccumulationSeries.prototype.findMaxBounds = function (totalbound, bound) {
        totalbound.x = bound.x < totalbound.x ? bound.x : totalbound.x;
        totalbound.y = bound.y < totalbound.y ? bound.y : totalbound.y;
        totalbound.height = (bound.y + bound.height) > totalbound.height ? (bound.y + bound.height) : totalbound.height;
        totalbound.width = (bound.x + bound.width) > totalbound.width ? (bound.x + bound.width) : totalbound.width;
    };
    /**
     * To set empty point value for null points
     * @private
     */
    AccumulationSeries.prototype.setAccEmptyPoint = function (point, i, data, colors) {
        if (!(isNullOrUndefined(point.y) || isNaN(point.y))) {
            return null;
        }
        point.color = this.emptyPointSettings.fill || point.color;
        switch (this.emptyPointSettings.mode) {
            case 'Zero':
                point.y = 0;
                point.visible = true;
                break;
            case 'Average':
                var previous = data[i - 1] ? (data[i - 1][this.yName] || 0) : 0;
                var next = data[i + 1] ? (data[i + 1][this.yName] || 0) : 0;
                point.y = (Math.abs(previous) + Math.abs(next)) / 2;
                this.sumOfPoints += point.y;
                point.visible = true;
                break;
            default:
                point.visible = false;
                break;
        }
    };
    /**
     * To find point is empty
     */
    AccumulationSeries.prototype.isEmpty = function (point) {
        return point.color === this.emptyPointSettings.fill;
    };
    __decorate$8([
        Property('')
    ], AccumulationSeries.prototype, "dataSource", void 0);
    __decorate$8([
        Property()
    ], AccumulationSeries.prototype, "query", void 0);
    __decorate$8([
        Property('')
    ], AccumulationSeries.prototype, "xName", void 0);
    __decorate$8([
        Property('')
    ], AccumulationSeries.prototype, "name", void 0);
    __decorate$8([
        Property('')
    ], AccumulationSeries.prototype, "tooltipMappingName", void 0);
    __decorate$8([
        Property('')
    ], AccumulationSeries.prototype, "yName", void 0);
    __decorate$8([
        Property(true)
    ], AccumulationSeries.prototype, "visible", void 0);
    __decorate$8([
        Complex({ color: null, width: 0 }, Border)
    ], AccumulationSeries.prototype, "border", void 0);
    __decorate$8([
        Complex(null, Animation$1)
    ], AccumulationSeries.prototype, "animation", void 0);
    __decorate$8([
        Property('SeriesType')
    ], AccumulationSeries.prototype, "legendShape", void 0);
    __decorate$8([
        Property('')
    ], AccumulationSeries.prototype, "legendImageUrl", void 0);
    __decorate$8([
        Property('')
    ], AccumulationSeries.prototype, "pointColorMapping", void 0);
    __decorate$8([
        Property(null)
    ], AccumulationSeries.prototype, "selectionStyle", void 0);
    __decorate$8([
        Property(null)
    ], AccumulationSeries.prototype, "groupTo", void 0);
    __decorate$8([
        Property('Value')
    ], AccumulationSeries.prototype, "groupMode", void 0);
    __decorate$8([
        Complex({}, AccumulationDataLabelSettings)
    ], AccumulationSeries.prototype, "dataLabel", void 0);
    __decorate$8([
        Property([])
    ], AccumulationSeries.prototype, "palettes", void 0);
    __decorate$8([
        Property(0)
    ], AccumulationSeries.prototype, "startAngle", void 0);
    __decorate$8([
        Property(null)
    ], AccumulationSeries.prototype, "endAngle", void 0);
    __decorate$8([
        Property(null)
    ], AccumulationSeries.prototype, "radius", void 0);
    __decorate$8([
        Property('0')
    ], AccumulationSeries.prototype, "innerRadius", void 0);
    __decorate$8([
        Property('Pie')
    ], AccumulationSeries.prototype, "type", void 0);
    __decorate$8([
        Property(true)
    ], AccumulationSeries.prototype, "enableTooltip", void 0);
    __decorate$8([
        Property(false)
    ], AccumulationSeries.prototype, "explode", void 0);
    __decorate$8([
        Property('30%')
    ], AccumulationSeries.prototype, "explodeOffset", void 0);
    __decorate$8([
        Property(false)
    ], AccumulationSeries.prototype, "explodeAll", void 0);
    __decorate$8([
        Property(null)
    ], AccumulationSeries.prototype, "explodeIndex", void 0);
    __decorate$8([
        Complex({ mode: 'Drop' }, EmptyPointSettings)
    ], AccumulationSeries.prototype, "emptyPointSettings", void 0);
    __decorate$8([
        Property(0)
    ], AccumulationSeries.prototype, "gapRatio", void 0);
    __decorate$8([
        Property('80%')
    ], AccumulationSeries.prototype, "width", void 0);
    __decorate$8([
        Property('80%')
    ], AccumulationSeries.prototype, "height", void 0);
    __decorate$8([
        Property('20%')
    ], AccumulationSeries.prototype, "neckWidth", void 0);
    __decorate$8([
        Property('20%')
    ], AccumulationSeries.prototype, "neckHeight", void 0);
    __decorate$8([
        Property('Linear')
    ], AccumulationSeries.prototype, "pyramidMode", void 0);
    __decorate$8([
        Property(1)
    ], AccumulationSeries.prototype, "opacity", void 0);
    __decorate$8([
        Property('0')
    ], AccumulationSeries.prototype, "dashArray", void 0);
    return AccumulationSeries;
}(ChildProperty));
/**
 * method to get series from index
 * @private
 */
function getSeriesFromIndex(index, visibleSeries) {
    for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
        var series = visibleSeries_1[_i];
        if (index === series.index) {
            return series;
        }
    }
    return visibleSeries[0];
}
/**
 * method to get point from index
 * @private
 */
function pointByIndex(index, points) {
    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
        var point = points_1[_i];
        if (point.index === index) {
            return point;
        }
    }
    return null;
}

/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * Defines the common functionalities of accumulation series
 */
/**
 * Accumulation Base used to do some base calculation for accumulation chart.
 */
var AccumulationBase = /** @__PURE__ @class */ (function () {
    /** @private */
    function AccumulationBase(accumulation) {
        this.accumulation = accumulation;
    }
    Object.defineProperty(AccumulationBase.prototype, "center", {
        /**
         * Gets the center of the pie
         *
         * @private
         */
        get: function () {
            return this.pieCenter || (this.accumulation.visibleSeries[0].type === 'Pie' ?
                this.accumulation.pieSeriesModule.pieBaseCenter : null);
        },
        /**
         * Sets the center of the pie
         *
         * @private
         */
        set: function (value) {
            this.pieCenter = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccumulationBase.prototype, "radius", {
        /**
         * Gets the radius of the pie
         *
         * @private
         */
        get: function () {
            return this.pieRadius !== undefined ? this.pieRadius :
                this.accumulation.pieSeriesModule.pieBaseRadius;
        },
        /**
         * Sets the radius of the pie
         *
         * @private
         */
        set: function (value) {
            this.pieRadius = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccumulationBase.prototype, "labelRadius", {
        /**
         * Gets the label radius of the pie
         *
         * @private
         */
        get: function () {
            return this.pieLabelRadius !== undefined ? this.pieLabelRadius :
                this.accumulation.pieSeriesModule.pieBaseLabelRadius;
        },
        /**
         * Sets the label radius of the pie
         *
         * @private
         */
        set: function (value) {
            this.pieLabelRadius = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks whether the series is circular or not
     *
     * @private
     */
    AccumulationBase.prototype.isCircular = function () {
        return this.accumulation.type === 'Pie';
    };
    /**
     * To check various radius pie
     *
     * @private
     */
    AccumulationBase.prototype.isVariousRadius = function () {
        return this.accumulation.pieSeriesModule.isRadiusMapped;
    };
    /**
     * To process the explode on accumulation chart loading
     *
     * @private
     */
    AccumulationBase.prototype.processExplode = function (event) {
        if (event.target.id.indexOf('_Series_') > -1 || event.target.id.indexOf('_datalabel_') > -1) {
            var pointIndex = indexFinder(event.target.id).point;
            if (isNaN(pointIndex) || (event.target.id.indexOf('_datalabel_') > -1 &&
                this.accumulation.visibleSeries[0].points[pointIndex].labelPosition === 'Outside')) {
                return null;
            }
            this.explodePoints(pointIndex, this.accumulation);
            this.deExplodeAll(pointIndex, this.accumulation.enableAnimation ? 300 : 0);
        }
    };
    /**
     * To invoke the explode on accumulation chart loading
     *
     * @private
     */
    AccumulationBase.prototype.invokeExplode = function () {
        var series = this.accumulation.visibleSeries[0];
        var duration = this.accumulation.enableAnimation ? 300 : 0;
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
            var point = _a[_i];
            if (point.isExplode && point.y !== 0) {
                this.pointExplode(point.index, point, duration);
            }
        }
        if (this.accumulation.accumulationSelectionModule && this.accumulation.selectionMode !== 'None' &&
            this.accumulation.accumulationSelectionModule.selectedDataIndexes.length) {
            for (var _b = 0, _c = this.accumulation.accumulationSelectionModule.selectedDataIndexes; _b < _c.length; _b++) {
                var index = _c[_b];
                this.explodePoints(index.point, this.accumulation, true);
                this.deExplodeAll(index.point, duration);
            }
        }
    };
    /**
     * To deExplode all points in the series
     *
     * @private
     */
    AccumulationBase.prototype.deExplodeAll = function (index, animationDuration) {
        var pointId = this.accumulation.element.id + '_Series_0_Point_';
        var points = this.accumulation.visibleSeries[0].points;
        for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
            var currentPoint = points_1[_i];
            if ((index !== currentPoint.index && !currentPoint.isSliced) || currentPoint.isClubbed) {
                currentPoint.isExplode = false;
                this.deExplodeSlice(currentPoint.index, pointId, animationDuration);
            }
        }
    };
    /**
     * To explode point by index
     *
     * @private
     */
    AccumulationBase.prototype.explodePoints = function (index, chart, explode) {
        if (explode === void 0) { explode = false; }
        var series = chart.visibleSeries[0];
        var points = series.points;
        var point = pointByIndex(index, points);
        var explodePoints = true;
        var duration = this.accumulation.enableAnimation ? 300 : 0;
        if (isNullOrUndefined(point)) {
            return null;
        }
        var clubPointsExploded = !explode &&
            (point.isSliced || (series.clubbedPoints.length &&
                points[points.length - 1].index === series.clubbedPoints[series.clubbedPoints.length - 1].index));
        if (series.type === 'Pie' && (clubPointsExploded || point.isClubbed)) {
            explodePoints = this.clubPointExplode(index, point, series, points, chart, duration, clubPointsExploded);
        }
        if (explodePoints && point.y !== 0) {
            this.pointExplode(index, point, duration, explode);
        }
    };
    AccumulationBase.prototype.getSum = function (points) {
        var total = 0;
        points.map(function (point) {
            total += point.visible ? point.y : 0;
        });
        return total;
    };
    AccumulationBase.prototype.clubPointExplode = function (index, point, series, points, chart, duration, clubPointsExploded) {
        if (clubPointsExploded === void 0) { clubPointsExploded = false; }
        if (point.isClubbed) {
            chart.animateSeries = false;
            points.splice(points.length - 1, 1);
            series.clubbedPoints.map(function (point) {
                point.visible = true;
                point.isExplode = true;
            });
            chart.visibleSeries[0].points = points.concat(series.clubbedPoints);
            this.deExplodeAll(index, duration);
            series.sumOfPoints = this.getSum(chart.visibleSeries[0].points);
            chart.refreshChart();
            return false;
        }
        else if (clubPointsExploded || point.isSliced) {
            chart.animateSeries = false;
            points.splice(points.length - series.clubbedPoints.length, series.clubbedPoints.length);
            var clubPoint = series.generateClubPoint();
            clubPoint.index = points.length;
            clubPoint.color = series.clubbedPoints[0].color;
            points.push(clubPoint);
            series.sumOfPoints = this.getSum(points);
            this.deExplodeAll(index, duration);
            clubPoint.isExplode = false;
            chart.visibleSeries[0].points = points;
            chart.refreshChart();
            this.pointExplode(clubPoint.index, points[clubPoint.index], 0, true);
            clubPoint.isExplode = false;
            this.deExplodeSlice(clubPoint.index, chart.element.id + '_Series_0_Point_', duration);
            if (point.isSliced) {
                return false;
            }
        }
        return true;
    };
    /**
     * To Explode points
     *
     * @param {number} index Index of a point.
     * @param {AccPoints} point To get the point of explode.
     * @param {number} duration Duration of the explode point.
     * @param {boolean} explode Either true or false.
     */
    AccumulationBase.prototype.pointExplode = function (index, point, duration, explode) {
        var translate;
        var pointId = this.accumulation.element.id + '_Series_0_Point_';
        var chart = this.accumulation;
        if (!this.isCircular()) {
            translate = {
                x: ((point.labelRegion && point.labelRegion.x < point.region.x) ? -chart.explodeDistance :
                    chart.explodeDistance), y: 0
            };
        }
        else {
            translate = degreeToLocation(point.midAngle, chart.explodeDistance, this.center);
        }
        if (this.isExplode(pointId + index) || explode) {
            point.isExplode = true;
            this.explodeSlice(index, translate, pointId, this.center || { x: 0, y: 0 }, duration);
        }
        else {
            point.isExplode = false;
            this.deExplodeSlice(index, pointId, duration);
        }
    };
    /**
     * To check point is exploded by id
     */
    AccumulationBase.prototype.isExplode = function (id) {
        var element = getElement$1(id);
        var transform = element ? element.getAttribute('transform') : null;
        return (element && (transform === 'translate(0, 0)' || transform === null || transform === 'translate(0)'));
    };
    /**
     * To deExplode the point by index
     */
    AccumulationBase.prototype.deExplodeSlice = function (index, sliceId, animationDuration) {
        var element = getElement$1(sliceId + index);
        var transform = element ? element.getAttribute('transform') : null;
        if (this.accumulation.enableAnimation && element && transform &&
            transform !== 'translate(0, 0)' && transform !== 'translate(0)') {
            // eslint-disable-next-line security/detect-unsafe-regex
            var result = /translate\((-?\d+\.?\d*),?\s*(-?\d+[.]?\d*)?\)/.exec(transform);
            this.performAnimation(index, sliceId, 0, 0, +result[1], +result[2] || 0, animationDuration, true);
        }
        else {
            this.performAnimation(index, sliceId, 0, 0, 0, 0, animationDuration, true);
        }
    };
    /**
     * To translate the point elements by index and position
     */
    AccumulationBase.prototype.setTranslate = function (index, sliceId, position, transform) {
        this.setElementTransform(sliceId + index, position);
        if (this.accumulation.visibleSeries[0].dataLabel.visible) {
            sliceId = this.accumulation.element.id + '_datalabel_Series_0_';
            this.setElementTransform(sliceId + 'shape_' + index, position);
            this.setElementTransform(sliceId + 'text_' + index, position + transform);
            this.setElementTransform(sliceId + 'connector_' + index, position);
        }
    };
    /**
     * To translate the point element by id and position
     */
    AccumulationBase.prototype.setElementTransform = function (id, position) {
        var element = getElement$1(id);
        if (element) {
            element.setAttribute('transform', position);
        }
    };
    /**
     * To translate the point elements by index position
     */
    AccumulationBase.prototype.explodeSlice = function (index, translate, sliceId, center, animationDuration) {
        this.performAnimation(index, sliceId, 0, 0, translate.x - center.x, translate.y - center.y, animationDuration);
    };
    /**
     * To Perform animation point explode
     *
     * @param {number} index Index of the series.
     * @param {string} sliceId ID of the series.
     * @param {number} startX X value of start.
     * @param {number} startY Y value of start.
     * @param {number} endX X value of end.
     * @param {number} endY Y value of end.
     * @param {number} duration Duration of the animation.
     */
    AccumulationBase.prototype.performAnimation = function (index, sliceId, startX, startY, endX, endY, duration, isReverse) {
        var _this = this;
        var chart = this.accumulation;
        var values = sliceId.split('_');
        var seriesIndex = parseInt(sliceId.split('_')[values.length - 3], 10);
        var point = chart.visibleSeries[seriesIndex].points[index];
        if (duration <= 0) {
            this.setTranslate(index, sliceId, 'translate(' + (endX) + ', ' + (endY) + ')', point.transform);
            return null;
        }
        var xValue;
        var yValue;
        new Animation({}).animate(createElement('div'), {
            duration: duration,
            progress: function (args) {
                xValue = linear(args.timeStamp, startX, endX, args.duration);
                yValue = linear(args.timeStamp, startY, endY, args.duration);
                _this.setTranslate(index, sliceId, 'translate(' + (isReverse ? endX - xValue : xValue) + ', ' + (isReverse ? endY - yValue : yValue) + ')', point.transform);
            },
            end: function () {
                _this.setTranslate(index, sliceId, 'translate(' + (isReverse ? startX : endX) + ', ' + (isReverse ? startX : endY) + ')', point.transform);
            }
        });
    };
    return AccumulationBase;
}());

var __extends$66 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * Accumulation charts base file
 */
/**
 * PieBase class used to do pie base calculations.
 */
var PieBase = /** @__PURE__ @class */ (function (_super) {
    __extends$66(PieBase, _super);
    function PieBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * To initialize the property values.
     *
     * @private
     */
    PieBase.prototype.initProperties = function (chart, series) {
        this.accumulation = chart;
        this.size = Math.min(chart.initialClipRect.width, chart.initialClipRect.height);
        this.initAngles(series);
        var r = parseInt(series.radius, 10);
        if ((series.radius.indexOf('%') !== -1 || typeof r === 'number') && !isNaN(r)) {
            this.isRadiusMapped = false;
            this.pieBaseRadius = stringToNumber(series.radius, this.size / 2);
            this.innerRadius = stringToNumber(series.innerRadius, this.pieBaseRadius);
            this.pieBaseLabelRadius = series.dataLabel.position === 'Inside' ? (((this.pieBaseRadius - this.innerRadius) / 2) + this.innerRadius) :
                (this.pieBaseRadius + stringToNumber(series.dataLabel.connectorStyle.length || '4%', this.size / 2));
        }
        else {
            var radiusCollection = [];
            this.isRadiusMapped = true;
            for (var i = 0; i < Object.keys(series.points).length; i++) {
                if (series.points[i].sliceRadius.indexOf('%') !== -1) {
                    radiusCollection[i] = stringToNumber(series.points[i].sliceRadius, this.size / 2);
                }
                else {
                    radiusCollection[i] = parseInt(series.points[i].sliceRadius, 10);
                }
            }
            var minRadius = Math.min.apply(null, radiusCollection);
            var maxRadius = Math.max.apply(null, radiusCollection);
            this.pieBaseRadius = this.seriesRadius = maxRadius;
            this.innerRadius = stringToNumber(series.innerRadius, this.seriesRadius);
            this.innerRadius = this.innerRadius > minRadius ? (this.innerRadius / 2) : this.innerRadius;
        }
        // this.radius = stringToNumber(series.radius, size / 2);
        // this.innerRadius = stringToNumber(series.innerRadius, this.radius);
        // this.labelRadius = series.dataLabel.position === 'Inside' ? (((this.radius - this.innerRadius) / 2) + this.innerRadius) :
        //     (this.radius + stringToNumber(series.dataLabel.connectorStyle.length || '4%', size / 2));
        this.radius = this.pieBaseRadius;
        this.labelRadius = this.pieBaseLabelRadius;
        chart.explodeDistance = series.explode ? stringToNumber(series.explodeOffset, this.pieBaseRadius) : 0;
        this.findCenter(chart, series);
        this.center = this.pieBaseCenter;
        this.defaultLabelBound(series, series.dataLabel.visible, series.dataLabel.position);
        this.totalAngle -= 0.001;
    };
    /*
     * To get label radius of the pie.
     * @private
     */
    PieBase.prototype.getLabelRadius = function (series, point) {
        return series.dataLabel.position === 'Inside' ?
            ((((stringToNumber(point.sliceRadius, this.pieBaseRadius) - this.innerRadius)) / 2) + this.innerRadius) :
            (stringToNumber(point.sliceRadius, this.seriesRadius) + stringToNumber(series.dataLabel.connectorStyle.length || '4%', this.size / 2));
    };
    /**
     * To find the center of the accumulation.
     *
     * @private
     */
    PieBase.prototype.findCenter = function (accumulation, series) {
        this.accumulation = accumulation;
        this.pieBaseCenter = {
            x: stringToNumber(accumulation.center.x, accumulation.initialClipRect.width) + (accumulation.initialClipRect.x),
            y: stringToNumber(accumulation.center.y, accumulation.initialClipRect.height) + (accumulation.initialClipRect.y)
        };
        var accumulationRect = this.getSeriesBound(series);
        var accumulationRectCenter = new ChartLocation(accumulationRect.x + accumulationRect.width / 2, accumulationRect.y + accumulationRect.height / 2);
        this.pieBaseCenter.x += (this.pieBaseCenter.x - accumulationRectCenter.x);
        this.pieBaseCenter.y += (this.pieBaseCenter.y - accumulationRectCenter.y);
        this.accumulation.origin = this.pieBaseCenter;
    };
    /**
     * To find angles from series.
     */
    PieBase.prototype.initAngles = function (series) {
        var endAngle = isNullOrUndefined(series.endAngle) ? series.startAngle : series.endAngle;
        this.totalAngle = (endAngle - series.startAngle) % 360;
        this.startAngle = series.startAngle - 90;
        this.totalAngle = this.totalAngle <= 0 ? (360 + this.totalAngle) : this.totalAngle;
        this.startAngle = (this.startAngle < 0 ? (this.startAngle + 360) : this.startAngle) % 360;
    };
    /**
     * To calculate data-label bound
     *
     * @private
     */
    PieBase.prototype.defaultLabelBound = function (series, visible, position) {
        var accumulationBound = this.getSeriesBound(series);
        series.accumulationBound = accumulationBound;
        series.labelBound = new Rect(accumulationBound.x, accumulationBound.y, accumulationBound.width + accumulationBound.x, accumulationBound.height + accumulationBound.y);
        if (visible && position === 'Outside') {
            series.labelBound = new Rect(Infinity, Infinity, -Infinity, -Infinity);
        }
    };
    /**
     * To calculate series bound
     *
     * @private
     */
    PieBase.prototype.getSeriesBound = function (series) {
        var rect = new Rect(Infinity, Infinity, -Infinity, -Infinity);
        this.initAngles(series);
        var start = this.startAngle;
        var total = this.totalAngle;
        var end = (this.startAngle + total) % 360;
        end = (end === 0) ? 360 : end;
        series.findMaxBounds(rect, this.getRectFromAngle(start));
        series.findMaxBounds(rect, this.getRectFromAngle(end));
        series.findMaxBounds(rect, new Rect(this.pieBaseCenter.x, this.pieBaseCenter.y, 0, 0));
        var nextQuandrant = (Math.floor(start / 90) * 90 + 90) % 360;
        var lastQuadrant = (Math.floor(end / 90) * 90) % 360;
        lastQuadrant = (lastQuadrant === 0) ? 360 : lastQuadrant;
        if (total >= 90 || lastQuadrant === nextQuandrant) {
            series.findMaxBounds(rect, this.getRectFromAngle(nextQuandrant));
            series.findMaxBounds(rect, this.getRectFromAngle(lastQuadrant));
        }
        if (start === 0 || (start + total >= 360)) {
            series.findMaxBounds(rect, this.getRectFromAngle(0));
        }
        var length = nextQuandrant === lastQuadrant ? 0 : Math.floor(total / 90);
        for (var i = 1; i < length; i++) {
            nextQuandrant = nextQuandrant + 90;
            if ((nextQuandrant < lastQuadrant || end < start) || total === 360) {
                series.findMaxBounds(rect, this.getRectFromAngle(nextQuandrant));
            }
        }
        rect.width -= rect.x;
        rect.height -= rect.y;
        return rect;
    };
    /**
     * To get rect location size from angle
     */
    PieBase.prototype.getRectFromAngle = function (angle) {
        var location = degreeToLocation(angle, this.pieBaseRadius, this.pieBaseCenter);
        return new Rect(location.x, location.y, 0, 0);
    };
    /**
     * To get path arc direction
     */
    PieBase.prototype.getPathArc = function (center, start, end, radius, innerRadius) {
        var degree = end - start;
        degree = degree < 0 ? (degree + 360) : degree;
        var flag = (degree < 180) ? 0 : 1;
        if (!innerRadius && innerRadius === 0) {
            return this.getPiePath(center, degreeToLocation(start, radius, center), degreeToLocation(end, radius, center), radius, flag);
        }
        else {
            return this.getDoughnutPath(center, degreeToLocation(start, radius, center), degreeToLocation(end, radius, center), radius, degreeToLocation(start, innerRadius, center), degreeToLocation(end, innerRadius, center), innerRadius, flag);
        }
    };
    /**
     * To get pie direction
     */
    PieBase.prototype.getPiePath = function (center, start, end, radius, clockWise) {
        return 'M ' + center.x + ' ' + center.y + ' L ' + start.x + ' ' + start.y + ' A ' + radius + ' ' +
            radius + ' 0 ' + clockWise + ' 1 ' + end.x + ' ' + end.y + ' Z';
    };
    /**
     * To get doughnut direction
     */
    PieBase.prototype.getDoughnutPath = function (center, start, end, radius, innerStart, innerEnd, innerRadius, clockWise) {
        return 'M ' + start.x + ' ' + start.y + ' A ' + radius + ' ' + radius + ' 0 ' + clockWise +
            ' 1 ' + end.x + ' ' + end.y + ' L ' + innerEnd.x + ' ' + innerEnd.y + ' A ' + innerRadius +
            ' ' + innerRadius + ' 0 ' + clockWise + ',0 ' + innerStart.x + ' ' + innerStart.y + ' Z';
    };
    /**
     * Method to start animation for pie series.
     */
    PieBase.prototype.doAnimation = function (slice, series) {
        var _this = this;
        var startAngle = series.startAngle - 90;
        var duration = this.accumulation.duration ? this.accumulation.duration : series.animation.duration;
        var value;
        this.pieBaseCenter.x += 1;
        var radius = Math.max(this.accumulation.availableSize.height, this.accumulation.availableSize.width) * 0.75;
        radius += radius * (0.414); // formula r + r / 2 * (1.414 -1)
        var effect = getAnimationFunction('Linear'); // need to check animation type
        new Animation({}).animate(slice, {
            duration: (duration === 0 && animationMode === 'Enable') ? 1000 : duration,
            delay: series.animation.delay,
            progress: function (args) {
                value = effect(args.timeStamp, startAngle, _this.totalAngle, args.duration);
                slice.setAttribute('d', _this.getPathArc(_this.pieBaseCenter, startAngle, value, radius, 0));
            },
            end: function () {
                _this.pieBaseCenter.x -= 1;
                slice.setAttribute('d', _this.getPathArc(_this.pieBaseCenter, 0, 359.99999, radius, 0));
                _this.accumulation.trigger(animationComplete, _this.accumulation.isBlazor ? {} :
                    { series: series, accumulation: _this.accumulation, chart: _this.accumulation });
                var datalabelGroup = getElement$1(_this.accumulation.element.id + '_datalabel_Series_' + series.index);
                if (datalabelGroup) {
                    datalabelGroup.style.visibility = _this.accumulation.isDestroyed ? 'hidden' : 'visible';
                }
            }
        });
    };
    return PieBase;
}(AccumulationBase));

var __extends$65 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * PieSeries module used to render `Pie` Series.
 */
var PieSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$65(PieSeries, _super);
    function PieSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * To get path option, degree, symbolLocation from the point.
     *
     * @private
     */
    PieSeries.prototype.renderPoint = function (point, series, chart, option, seriesGroup, redraw) {
        var sum$$1 = series.sumOfPoints;
        point.startAngle = this.startAngle;
        var yValue = point.visible ? point.y : 0;
        var degree = (sum$$1) ? ((Math.abs(yValue) / sum$$1) * (this.totalAngle)) : null;
        var start = Math.PI / 180 * ((90 - (360 - this.startAngle)) - 90);
        this.radius = this.isRadiusMapped ? stringToNumber(point.sliceRadius, this.seriesRadius) : this.radius;
        option.d = this.getPathOption(point, degree, this.startAngle % 360);
        point.midAngle = (this.startAngle - (degree / 2)) % 360;
        point.endAngle = this.startAngle % 360;
        point.symbolLocation = degreeToLocation(point.midAngle, (this.radius + this.innerRadius) / 2, this.center);
        if (!redraw) {
            var element = chart.renderer.drawPath(option);
            element.setAttribute('role', 'img');
            element.setAttribute('tabindex', point.index === 0 ? '0' : '-1');
            element.setAttribute('aria-label', (point.x + ': ' + point.y + '%. ' + series.name));
            seriesGroup.appendChild(element);
            point.degree = degree;
            point.start = start;
        }
        else {
            var element = chart.renderer.drawPath(option);
            element.setAttribute('role', 'img');
            element.setAttribute('tabindex', point.index === 0 ? '0' : '-1');
            element.setAttribute('aria-label', (point.x + ': ' + point.y + '%. ' + series.name));
            seriesGroup.appendChild(element);
            this.refresh(point, degree, start, chart, option);
        }
    };
    PieSeries.prototype.findSeries = function (e) {
        var borderGap = 3; // Gap between pie/doughnut chart and border
        var width = 2; // width of the border
        var radius = this.innerRadius === 0 ? this.radius + borderGap : this.innerRadius - borderGap;
        var innerRadius = this.innerRadius === 0 ? radius + width : radius - width;
        this.toggleInnerPoint(e, radius, innerRadius);
    };
    PieSeries.prototype.toggleInnerPoint = function (event, radius, innerRadius) {
        var target = event.target;
        var id = indexFinder(target.id, true);
        var accumulationId = event.target.id.substring(0, (event.target.id.indexOf('Series') - 1));
        var borderElement = document.getElementById(this.accumulation.element.id + 'PointHover_Border');
        var createBorderEle;
        var seriesIndex = id.series;
        var pointIndex = id.point;
        var srcElem = getElement$1(accumulationId + '_Series_' + seriesIndex + '_Point_' + pointIndex);
        if (!isNaN(id.series) && srcElem) {
            if (!isNullOrUndefined(seriesIndex) && !isNaN(seriesIndex) && !isNullOrUndefined(pointIndex) && !isNaN(pointIndex)) {
                var point = this.accumulation.visibleSeries[0].points[pointIndex];
                var opacity = srcElem.getAttribute('class') === accumulationId + '_ej2_deselected' ?
                    this.accumulation.tooltip.enable ? 0.5 : 0.3 : this.accumulation.tooltip.enable ? 0.5 : 1;
                var innerPie = this.getPathArc(this.accumulation.pieSeriesModule.center, point.startAngle % 360, (point.startAngle + point.degree) % 360, radius, innerRadius);
                // while using annotation as a chart border will appear in both chart.so changed checked the id with target id
                if ((borderElement) && (accumulationId === this.accumulation.element.id) &&
                    (borderElement.getAttribute('d') !== innerPie || point.isExplode)) {
                    borderElement.parentNode.removeChild(borderElement);
                    borderElement = null;
                }
                var seriousGroup = getElement$1(accumulationId + '_Series_' + seriesIndex);
                if (!borderElement && ((!point.isExplode) || (point.isExplode && event.type !== 'click'))) {
                    var path = new PathOption(accumulationId + 'PointHover_Border', point.color, 1, point.color, opacity, '', innerPie);
                    createBorderEle = this.accumulation.renderer.drawPath(path);
                    createBorderEle.removeAttribute('transform');
                    if (this.accumulation.selectionMode !== 'None' && event.target.hasAttribute('class')) {
                        this.accumulation.accumulationSelectionModule.addSvgClass(createBorderEle, event.target.getAttribute('class'));
                    }
                    seriousGroup.appendChild(createBorderEle);
                    if (point.isExplode && createBorderEle) {
                        var borderExplode = srcElem.getAttribute('transform');
                        if (borderExplode) {
                            createBorderEle.setAttribute('transform', borderExplode);
                        }
                    }
                }
            }
        }
        else if (borderElement) {
            this.removeBorder(borderElement, 1000);
            borderElement = null;
        }
    };
    PieSeries.prototype.removeBorder = function (borderElement, duration) {
        if (borderElement) {
            setTimeout(function () {
                if (borderElement.parentNode) {
                    borderElement.parentNode.removeChild(borderElement);
                }
            }, duration);
        }
    };
    PieSeries.prototype.refresh = function (point, degree, start, chart, option) {
        var _this = this;
        var seriesElement = getElement$1(option.id);
        var duration = chart.duration ? chart.duration : 300;
        new Animation({}).animate(createElement('div'), {
            duration: duration,
            delay: 0,
            progress: function (args) {
                var curentDegree = linear(args.timeStamp, point.degree, (degree - point.degree), args.duration);
                var currentStartAngle = linear(args.timeStamp, point.start, start - point.start, args.duration);
                currentStartAngle = ((currentStartAngle / (Math.PI / 180)) + 360) % 360;
                seriesElement.setAttribute('d', _this.getPathOption(point, curentDegree, currentStartAngle));
                if (point.isExplode) {
                    chart.accBaseModule.explodePoints(point.index, chart, true);
                }
                seriesElement.style.visibility = 'visible';
            },
            end: function () {
                seriesElement.style.visibility = point.visible ? 'visible' : 'hidden';
                seriesElement.setAttribute('d', option.d);
                point.degree = degree;
                point.start = start;
            }
        });
    };
    /**
     * To get path option from the point.
     */
    PieSeries.prototype.getPathOption = function (point, degree, startAngle) {
        if (!degree) {
            return '';
        }
        var path = this.getPathArc(this.center, startAngle % 360, (startAngle + degree) % 360, this.isRadiusMapped ? stringToNumber(point.sliceRadius, this.seriesRadius) : this.radius, this.innerRadius);
        //const path: string = this.getPathArc(this.center, startAngle % 360, (startAngle + degree) % 360, this.radius, this.innerRadius);
        this.startAngle += degree;
        return path;
    };
    /**
     * To animate the pie series.
     *
     * @private
     */
    PieSeries.prototype.animateSeries = function (accumulation, option, series, slice) {
        var groupId = accumulation.element.id + 'SeriesGroup' + series.index;
        if (((series.animation.enable && animationMode != 'Disable') || animationMode === 'Enable') && accumulation.animateSeries) {
            var clippath = accumulation.renderer.createClipPath({ id: groupId + '_clipPath' });
            var path = new PathOption(groupId + '_slice', 'transparent', 1, 'transparent', 1, '', '');
            var clipslice = accumulation.renderer.drawPath(path);
            clippath.appendChild(clipslice);
            accumulation.svgObject.appendChild(clippath);
            // I263828 pie chart animation issue fixed for safari browser
            slice.style.cssText = 'clip-path:url(#' + clippath.id + '); -webkit-clip-path:url(#' + clippath.id + ');';
            this.doAnimation(clipslice, series);
        }
    };
    /**
     * To get the module name of the Pie series.
     */
    PieSeries.prototype.getModuleName = function () {
        return 'PieSeries';
    };
    /**
     * To destroy the pie series.
     *
     * @returns {void}
     * @private
     */
    PieSeries.prototype.destroy = function () {
        /**
         * Destroy method calling here
         */
    };
    return PieSeries;
}(PieBase));

var __extends$63 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable radix */
/* eslint-disable curly */
/* eslint-disable jsdoc/valid-types */
/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * AccumulationChart file
 */
/**
 * Represents the AccumulationChart control.
 * ```html
 * <div id="accumulation"/>
 * <script>
 *   var accObj = new AccumulationChart({ });
 *   accObj.appendTo("#accumulation");
 * </script>
 * ```
 *
 * @public
 */
var AccumulationChart = /** @__PURE__ @class */ (function (_super) {
    __extends$63(AccumulationChart, _super);
    /**
     * Constructor for creating the AccumulationChart widget
     *
     * @private
     */
    function AccumulationChart(options, element) {
        var _this = _super.call(this, options, element) || this;
        /** @private */
        _this.animateselected = false;
        /** @private */
        _this.explodeDistance = 0;
        /** @private */
        _this.currentLegendIndex = 0;
        /** @private */
        _this.currentPointIndex = 0;
        /** @private */
        _this.previousTargetId = '';
        /** @private */
        _this.isLegendClicked = false;
        _this.chartid = 57724;
        return _this;
    }
    /**
     * Animate the series bounds on data change.
     *
     * @private
     */
    AccumulationChart.prototype.animate = function (duration) {
        this.duration = (duration === 0 && animationMode === 'Enable') ? 700 : duration;
        this.animateselected = true;
        this.animateSeries = false;
        var temIndex = 0;
        var tempcolor = [];
        var tempindex = [];
        var tempindex1 = [];
        var currentSeries = this.visibleSeries[0];
        var datasource = [];
        datasource = currentSeries.dataSource;
        currentSeries.sumOfPoints = 0;
        if (currentSeries.points.length < Object.keys(currentSeries.dataSource).length) {
            this.refresh();
        }
        else if (currentSeries.points.length > Object.keys(currentSeries.dataSource).length) {
            var currentSeries_1 = this.visibleSeries[0];
            currentSeries_1.points = currentSeries_1.points.filter(function (entry1) {
                entry1.visible = false;
                tempindex.push(entry1.index);
                tempcolor.push(entry1.color);
                return (datasource).some(function (entry2) {
                    var accPoint = entry2;
                    if (entry1.x === accPoint.x) {
                        entry1.visible = true;
                        tempindex1.push(entry1.index);
                        entry1.index = temIndex;
                        temIndex++;
                    }
                    return entry1.x === accPoint.x;
                });
            });
            var missing = tempindex.filter(function (item) { return tempindex1.indexOf(item) < 0; });
            var interval = tempindex.length - missing.length;
            for (var i = (tempindex.length - 1); i >= interval; i--) {
                removeElement$1('container_Series_0_Point_' + tempindex[i]);
            }
            for (var i = 0; i < currentSeries_1.points.length; i++) {
                currentSeries_1.points[i].y = currentSeries_1.dataSource[i].y;
                currentSeries_1.points[i].color = tempcolor[i];
                currentSeries_1.sumOfPoints += currentSeries_1.dataSource[i].y;
            }
            this.redraw = this.enableAnimation;
            this.animateSeries = false;
            this.calculateBounds();
            this.renderElements();
        }
        else {
            for (var i = 0; i < currentSeries.points.length; i++) {
                currentSeries.points[i].y = currentSeries.dataSource[i][currentSeries.yName];
                currentSeries.points[i].color = currentSeries.dataSource[i][currentSeries.pointColorMapping] != null
                    ? currentSeries.dataSource[i][currentSeries.pointColorMapping] : currentSeries.points[i].color;
                currentSeries.sumOfPoints += currentSeries.dataSource[i][currentSeries.yName];
            }
            this.redraw = this.enableAnimation;
            this.animateSeries = false;
            this.removeSvg();
            this.refreshPoints(currentSeries.points);
            this.renderElements();
        }
    };
    Object.defineProperty(AccumulationChart.prototype, "type", {
        /** @private */
        get: function () {
            if (this.series && this.series.length) {
                return this.series[0].type;
            }
            return 'Pie';
        },
        enumerable: true,
        configurable: true
    });
    // accumulation chart methods
    /**
     *  To create svg object, renderer and binding events for the container.
     */
    AccumulationChart.prototype.preRender = function () {
        var blazor = 'Blazor';
        this.isBlazor = window[blazor];
        this.allowServerDataBinding = false;
        this.unWireEvents();
        this.setCulture();
        this.animateSeries = true;
        if (this.element.id === '') {
            var collection = document.getElementsByClassName('e-accumulationchart').length;
            this.element.id = 'acc_chart_' + this.chartid + '_' + collection;
        }
        this.wireEvents();
        this.element.setAttribute('dir', this.enableRtl ? 'rtl' : '');
    };
    /**
     * Themeing for chart goes here
     */
    AccumulationChart.prototype.setTheme = function () {
        /*! Set theme for accumulation chart */
        this.themeStyle = getThemeColor(this.theme, false);
    };
    /**
     * To render the accumulation chart elements
     */
    AccumulationChart.prototype.render = function () {
        var _this = this;
        if (this.element.className.indexOf('e-accumulationchart') === -1) {
            this.element.classList.add('e-accumulationchart');
        }
        this.element.setAttribute('role', 'region');
        this.element.setAttribute('tabindex', '0');
        this.element.setAttribute('aria-label', this.title + '. Syncfusion interactive chart.');
        this.element.setAttribute('class', this.element.getAttribute('class') + ' e-accumulationchart-focused');
        var loadEventData = {
            chart: this.isBlazor ? {} : this,
            accumulation: this.isBlazor ? {} : this,
            theme: this.theme, name: load, cancel: false
        };
        this.trigger(load, loadEventData, function () {
            _this.theme = _this.isBlazor ? loadEventData.theme : _this.theme;
            _this.setTheme();
            _this.accBaseModule = new AccumulationBase(_this);
            _this.pieSeriesModule = new PieSeries(_this);
            _this.calculateVisibleSeries();
            _this.processData();
            _this.renderComplete();
            _this.allowServerDataBinding = true;
        });
    };
    /**
     * Method to unbind events for accumulation chart
     */
    AccumulationChart.prototype.unWireEvents = function () {
        /*! Find the Events type */
        var isIE11Pointer = Browser.isPointer;
        var start = Browser.touchStartEvent;
        var move = Browser.touchMoveEvent;
        var stop = Browser.touchEndEvent;
        var cancel = isIE11Pointer ? 'pointerleave' : 'mouseleave';
        /*! UnBind the Event handler */
        EventHandler.remove(this.element, move, this.accumulationMouseMove);
        EventHandler.remove(this.element, stop, this.accumulationMouseEnd);
        EventHandler.remove(this.element, start, this.accumulationMouseStart);
        EventHandler.remove(this.element, 'click', this.accumulationOnMouseClick);
        EventHandler.remove(this.element, 'dblclick', this.accumulationOnDoubleClick);
        EventHandler.remove(this.element, 'contextmenu', this.accumulationRightClick);
        EventHandler.remove(this.element, cancel, this.accumulationMouseLeave);
        EventHandler.remove(this.element, 'keydown', this.accumulationChartKeyDown);
        EventHandler.remove(document.body, 'keydown', this.documentKeyHandler);
        EventHandler.remove(this.element, 'keyup', this.accumulationChartKeyUp);
        window.removeEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.accumulationResizeBound);
    };
    /**
     * Method to bind events for the accumulation chart
     */
    AccumulationChart.prototype.wireEvents = function () {
        /**
         * To fix react timeout destroy issue.
         */
        if (!this.element) {
            return;
        }
        /*! Find the Events type */
        var isIE11Pointer = Browser.isPointer;
        var start = Browser.touchStartEvent;
        var stop = Browser.touchEndEvent;
        var move = Browser.touchMoveEvent;
        var cancel = isIE11Pointer ? 'pointerleave' : 'mouseleave';
        /*! Bind the Event handler */
        EventHandler.add(this.element, move, this.accumulationMouseMove, this);
        EventHandler.add(this.element, stop, this.accumulationMouseEnd, this);
        EventHandler.add(this.element, start, this.accumulationMouseStart, this);
        EventHandler.add(this.element, 'click', this.accumulationOnMouseClick, this);
        EventHandler.add(this.element, 'dblclick', this.accumulationOnDoubleClick, this);
        EventHandler.add(this.element, 'contextmenu', this.accumulationRightClick, this);
        EventHandler.add(this.element, cancel, this.accumulationMouseLeave, this);
        EventHandler.add(this.element, 'keydown', this.accumulationChartKeyDown, this);
        EventHandler.add(document.body, 'keydown', this.documentKeyHandler, this);
        EventHandler.add(this.element, 'keyup', this.accumulationChartKeyUp, this);
        this.accumulationResizeBound = this.accumulationResize.bind(this);
        window.addEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.accumulationResizeBound);
        new Touch(this.element); // To avoid geasture blocking for browser
        /*! Apply the style for chart */
        this.setStyle(this.element);
    };
    /**
     * Method to set mouse x, y from events
     */
    AccumulationChart.prototype.setMouseXY = function (e) {
        var pageX;
        var pageY;
        var svgRectElement = getElement$1(this.element.id + '_svg');
        if (svgRectElement && this.element) {
            var svgRect = svgRectElement.getBoundingClientRect();
            var rect = this.element.getBoundingClientRect();
            if (e.type.indexOf('touch') > -1) {
                this.isTouch = true;
                var touchArg = e;
                pageY = touchArg.changedTouches[0].clientY;
                pageX = touchArg.changedTouches[0].clientX;
            }
            else {
                this.isTouch = e.pointerType === 'touch' || e.pointerType === '2';
                pageX = e.clientX;
                pageY = e.clientY;
            }
            this.mouseY = (pageY - rect.top) - Math.max(svgRect.top - rect.top, 0);
            this.mouseX = (pageX - rect.left) - Math.max(svgRect.left - rect.left, 0);
        }
    };
    /**
     * Handles the mouse end.
     *
     * @returns {boolean} Mouse end of accumulation chart.
     * @private
     */
    AccumulationChart.prototype.accumulationMouseEnd = function (e) {
        this.setMouseXY(e);
        this.trigger(chartMouseUp, { target: e.target.id, x: this.mouseX, y: this.mouseY });
        if (this.isTouch) {
            this.titleTooltip(e, this.mouseX, this.mouseY, this.isTouch);
            if (this.accumulationDataLabelModule && this.visibleSeries[0].dataLabel.visible) {
                this.accumulationDataLabelModule.move(e, this.mouseX, this.mouseY, this.isTouch);
            }
            if (this.accumulationLegendModule && this.legendSettings.visible) {
                this.accumulationLegendModule.move(e);
            }
        }
        if (this.centerLabel.hoverTextFormat) {
            this.updateCenterLabel(e);
        }
        this.notify(Browser.touchEndEvent, e);
        return false;
    };
    /*public removeSvgOffset(x: number, y: number): ChartLocation {
        let rect: ClientRect = this.element.getBoundingClientRect();
        let svgRect: ClientRect = getElement(this.element.id + '_svg').getBoundingClientRect();
        return { x: (x - rect.left) - Math.max(svgRect.left - rect.left, 0), y: (y - rect.top) - Math.max(svgRect.top - rect.top, 0)};
    }*/
    /**
     * Handles the mouse start.
     *
     * @returns {boolean} Mouse start of accumulation chart.
     * @private
     */
    AccumulationChart.prototype.accumulationMouseStart = function (e) {
        this.setMouseXY(e);
        this.trigger(chartMouseDown, { target: e.target.id, x: this.mouseX, y: this.mouseY });
        return false;
    };
    /**
     * Handles the accumulation chart resize.
     *
     * @returns {boolean} Resize method of accumulation chart.
     * @private
     */
    AccumulationChart.prototype.accumulationResize = function () {
        var _this = this;
        this.animateSeries = false;
        var args = {
            accumulation: this.isBlazor ? {} : this,
            previousSize: new Size(this.availableSize.width, this.availableSize.height),
            name: resized,
            currentSize: new Size(0, 0),
            chart: this.isBlazor ? {} : this
        };
        var beforeResizeArgs = { name: 'beforeResize', cancelResizedEvent: false };
        if (this.resizeTo) {
            clearTimeout(this.resizeTo);
        }
        this.trigger(beforeResize, beforeResizeArgs);
        if (!beforeResizeArgs.cancelResizedEvent) {
            this.resizeTo = +setTimeout(function () {
                if (_this.isDestroyed) {
                    clearTimeout(_this.resizeTo);
                    return;
                }
                calculateSize(_this);
                args.currentSize = _this.availableSize;
                _this.trigger(resized, args);
                _this.refreshSeries();
                _this.refreshChart();
            }, 500);
        }
        return false;
    };
    /**
     * Handles the print method for accumulation chart control.
     */
    AccumulationChart.prototype.print = function (id) {
        // To handle the print funtion in IE and Edge browsers
        var clippath = document.getElementById(this.element.id + '_Series_0').style.clipPath;
        document.getElementById(this.element.id + '_Series_0').style.clipPath = '';
        var exportChart = new PrintUtils(this);
        exportChart.print(id);
        document.getElementById(this.element.id + '_Series_0').style.clipPath = clippath;
    };
    /**
     * Export method for the chart.
     */
    AccumulationChart.prototype.export = function (type, fileName) {
        if (this.exportModule) {
            this.exportModule.export(type, fileName);
            if (this.afterExport) {
                this.exportModule.getDataUrl(this);
            }
        }
    };
    /**
     * Applying styles for accumulation chart element
     */
    AccumulationChart.prototype.setStyle = function (element) {
        element.style.touchAction = 'element';
        element.style.msTouchAction = 'element';
        element.style.msContentZooming = 'none';
        element.style.msUserSelect = 'none';
        element.style.webkitUserSelect = 'none';
        element.style.position = 'relative';
        element.style.display = 'block';
        element.style.height = (element.style.height || (this.height && this.height.indexOf('%') === -1)) ? element.style.height : 'inherit';
        var tabColor = '';
        switch (this.theme) {
            case 'HighContrastLight':
            case 'HighContrast':
                tabColor = '#969696';
                break;
            case 'MaterialDark':
            case 'FabricDark':
            case 'Bootstrap':
            case 'Bootstrap4':
                tabColor = '#66afe9';
                break;
            case 'Tailwind':
            case 'TailwindDark':
                tabColor = '#4f46e5';
                break;
            case 'Bootstrap5':
            case 'Bootstrap5Dark':
                tabColor = '#0d6efd';
                break;
            case 'Fluent':
            case 'FluentDark':
                tabColor = '#9e9e9e';
                break;
            default:
                tabColor = '#9e9e9e';
                break;
        }
        var style = document.createElement('style');
        style.setAttribute('id', element.id + 'Keyboard_accumulationchart_focus');
        style.innerText = '.e-accumulationchart-focused:focus,path[id*=_Series_0_Point_]:focus, text[id*=_title]:focus' +
            '{outline: none} .e-accumulationchart-focused:focus-visible,path[id*=_Series_0_Point_]:focus-visible, text[id*=_title]:focus-visible' +
            '{outline: 1.5px ' + tabColor + ' solid}';
        document.body.appendChild(style);
    };
    /**
     * Method to set the annotation content dynamically for accumulation.
     */
    AccumulationChart.prototype.setAnnotationValue = function (annotationIndex, content) {
        var annotation = this.annotations[annotationIndex];
        var element;
        var parentNode = getElement$1(this.element.id + '_Annotation_Collections');
        if (content) {
            annotation.content = content;
            if (parentNode) {
                element = this.createElement('div');
                removeElement$1(this.element.id + '_Annotation_' + annotationIndex);
                this.annotationModule.processAnnotation(annotation, annotationIndex, element);
                parentNode.appendChild(element.children[0]);
            }
            else {
                this.annotationModule.renderAnnotations(getElement$1(this.element.id + '_Secondary_Element'));
            }
        }
    };
    /**
     * Handles the mouse move on accumulation chart.
     *
     * @returns {boolean} Mouse move of accumulation chart.
     * @private
     */
    AccumulationChart.prototype.accumulationMouseMove = function (e) {
        if (!getElement$1(this.element.id + '_svg')) {
            return false;
        }
        this.setMouseXY(e);
        this.trigger(chartMouseMove, { target: e.target.id, x: this.mouseX, y: this.mouseY });
        if (this.pointMove) {
            this.triggerPointEvent(pointMove, e.target, e);
        }
        if (this.accumulationLegendModule && this.legendSettings.visible) {
            this.accumulationLegendModule.move(e);
        }
        if (this.accumulationDataLabelModule && this.visibleSeries[0] && this.visibleSeries[0].dataLabel.visible) {
            this.accumulationDataLabelModule.move(e, this.mouseX, this.mouseY);
        }
        if (this.centerLabel.hoverTextFormat) {
            this.updateCenterLabel(e);
        }
        if (!this.isTouch) {
            this.titleTooltip(e, this.mouseX, this.mouseY);
        }
        if (this.enableBorderOnMouseMove && this.type === 'Pie' && this.pieSeriesModule &&
            withInBounds(this.mouseX, this.mouseY, this.initialClipRect)) {
            this.pieSeriesModule.findSeries(e);
        }
        this.notify(Browser.touchMoveEvent, e);
        return false;
    };
    AccumulationChart.prototype.titleTooltip = function (event, x, y, isTouch) {
        var targetId = event.target.id;
        var id = (targetId === (this.element.id + '_title') || targetId === (this.element.id + '_subTitle') ||
            targetId === (this.element.id + '_chart_legend_title'));
        if ((event.target.textContent.indexOf('...') > -1) && id) {
            var title = (targetId === (this.element.id + '_title')) ?
                this.title : (targetId === (this.element.id + '_subTitle')) ? this.subTitle : this.legendSettings.title;
            showTooltip(title, x, y, this.element.offsetWidth, this.element.id + '_EJ2_Title_Tooltip', getElement$1(this.element.id + '_Secondary_Element'), isTouch);
        }
        else {
            removeElement$1(this.element.id + '_EJ2_Title_Tooltip');
        }
    };
    /**
     * Handles the keyboard onkeydown on chart.
     *
     * @returns {boolean} false
     * @private
     */
    AccumulationChart.prototype.accumulationChartKeyDown = function (e) {
        var actionKey = '';
        if (this.tooltip.enable && ((e.code === 'Tab' && this.previousTargetId.indexOf('Series') > -1) || e.code === 'Escape')) {
            actionKey = 'ESC';
        }
        if (e.code.indexOf('Arrow') > -1) {
            e.preventDefault();
        }
        if (e.ctrlKey && (e.key === 'p')) {
            e.preventDefault();
            actionKey = 'CtrlP';
        }
        if (actionKey !== '')
            this.chartKeyboardNavigations(e, e.target.id, actionKey);
        return false;
    };
    /**
     * Handles the keyboard onkeydown on chart.
     *
     * @returns {boolean} false
     * @private
     */
    AccumulationChart.prototype.accumulationChartKeyUp = function (e) {
        var actionKey = '';
        var targetId = e.target['id'];
        var legendElement = getElement$1(this.element.id + '_chart_legend_translate_g');
        var pagingElement = getElement$1(this.element.id + '_chart_legend_pageup');
        if (legendElement) {
            var firstChild = legendElement.firstElementChild;
            var className = firstChild.getAttribute('class');
            if (className && className.indexOf('e-accumulationchart-focused') === -1) {
                className = className + ' e-accumulationchart-focused';
            }
            else if (!className) {
                className = 'e-accumulationchart-focused';
            }
            firstChild.setAttribute('class', className);
        }
        if (pagingElement) {
            pagingElement.setAttribute('class', 'e-accumulationchart-focused');
        }
        if (e.code === 'Tab') {
            if (this.previousTargetId !== '') {
                if (this.previousTargetId.indexOf('_Point_') > -1 && targetId.indexOf('_Point_') === -1) {
                    var groupElement = document.getElementById(this.previousTargetId).parentElement;
                    this.setTabIndex(groupElement.children[this.currentPointIndex], groupElement.firstElementChild);
                    this.currentPointIndex = 0;
                }
                else if (this.previousTargetId.indexOf('_chart_legend_page') > -1 && targetId.indexOf('_chart_legend_page') === -1 &&
                    targetId.indexOf('_chart_legend_g_') === -1) {
                    this.setTabIndex(e.target, pagingElement);
                }
                else if (this.previousTargetId.indexOf('_chart_legend_g_') > -1 && targetId.indexOf('chart_legend_g_') === -1) {
                    this.setTabIndex(legendElement.children[this.currentLegendIndex], legendElement.firstElementChild);
                }
            }
            this.previousTargetId = targetId;
            if (targetId.indexOf('_chart_legend_g_') > -1 && this.highlightMode !== 'None') {
                targetId = e.target['lastElementChild'].id;
                actionKey = 'Tab';
            }
            else if (targetId.indexOf('_Point_') > -1 && (this.highlightMode !== 'None' || this.tooltip.enable)) {
                actionKey = 'Tab';
            }
        }
        else if (e.code.indexOf('Arrow') > -1) {
            e.preventDefault();
            if (targetId.indexOf('_chart_legend_page') > -1) {
                e.target.removeAttribute('tabindex');
                this.previousTargetId = targetId = this.element.id + '_chart_legend_page' + (e.code === 'ArrowRight' ? 'up' : 'down');
                this.focusTarget(getElement$1(targetId));
            }
            else if ((targetId.indexOf('_chart_legend_') > -1)) {
                e.target.removeAttribute('tabindex');
                this.currentLegendIndex += (e.code === 'ArrowUp' || e.code === 'ArrowRight') ? +1 : -1;
                this.currentLegendIndex = this.getActualIndex(this.currentLegendIndex, legendElement.children.length);
                var currentLegend = legendElement.children[this.currentLegendIndex];
                this.focusTarget(currentLegend);
                this.previousTargetId = targetId = currentLegend.lastElementChild.id;
                actionKey = this.highlightMode !== 'None' ? 'ArrowMove' : '';
            }
            else if (targetId.indexOf('_Point_') > -1) {
                e.target.setAttribute('tabindex', '-1');
                this.currentPointIndex += (e.code === 'ArrowUp' || e.code === 'ArrowRight') ? +1 : -1;
                var totalLength = 0;
                for (var i = 0; i < e.target['parentElement'].children.length; i++) {
                    totalLength = e.target['parentElement'].children[i].id.indexOf('_Point_') > -1 ? totalLength + 1 : totalLength;
                }
                this.currentPointIndex = this.getActualIndex(this.currentPointIndex, totalLength);
                targetId = this.element.id + '_Series_0_Point_' + this.currentPointIndex;
                this.focusTarget(getElement$1(targetId));
                actionKey = this.tooltip.enable ? 'ArrowMove' : '';
            }
        }
        else if ((e.code === 'Enter' || e.code === 'Space') && ((targetId.indexOf('_chart_legend_') > -1) ||
            (targetId.indexOf('_Point_') > -1))) {
            targetId = (targetId.indexOf('_chart_legend_g') > -1) ? e.target['lastElementChild'].id : targetId;
            actionKey = 'Enter';
        }
        if (actionKey !== '') {
            this.chartKeyboardNavigations(e, targetId, actionKey);
        }
        return false;
    };
    AccumulationChart.prototype.setTabIndex = function (previousElement, currentElement) {
        if (previousElement) {
            previousElement.removeAttribute('tabindex');
        }
        if (currentElement) {
            currentElement.setAttribute('tabindex', '0');
        }
    };
    AccumulationChart.prototype.getActualIndex = function (index, totalLength) {
        return index > totalLength - 1 ? 0 : (index < 0 ? totalLength - 1 : index);
    };
    AccumulationChart.prototype.focusTarget = function (element) {
        var className = element.getAttribute('class');
        element.setAttribute('tabindex', '0');
        if (className && className.indexOf('e-accumulationchart-focused') === -1) {
            className = className + ' e-accumulationchart-focused';
        }
        else if (!className) {
            className = 'e-accumulationchart-focused';
        }
        element.setAttribute('tabindex', '0');
        element.setAttribute('class', className);
        element.focus();
        return element.id;
    };
    /**
     * Handles the document onkey.
     *
     * @private
     */
    AccumulationChart.prototype.documentKeyHandler = function (e) {
        // 74 - J
        if (e.altKey && e.keyCode === 74 && !isNullOrUndefined(this.element)) {
            this.element.focus();
        }
    };
    AccumulationChart.prototype.chartKeyboardNavigations = function (e, targetId, actionKey) {
        this.isLegendClicked = false;
        switch (actionKey) {
            case 'Tab':
            case 'ArrowMove':
                if (this.accumulationHighlightModule) {
                    //  this.accumulationHighlightModule.removeHighlightElements();
                }
                if (targetId.indexOf('_Point_') > -1) {
                    var seriesIndex = +(targetId.split('_Series_')[1].split('_Point_')[0]);
                    var pointIndex = +(targetId.split('_Series_')[1].replace('_Symbol', '').split('_Point_')[1]);
                    var pointRegion = this.visibleSeries[seriesIndex].points[pointIndex].symbolLocation;
                    this.mouseX = pointRegion.x + this.initialClipRect.x;
                    this.mouseY = pointRegion.y + this.initialClipRect.y;
                    if (this.accumulationHighlightModule) {
                        var targetElement = getElement$1(targetId);
                        if (!isNullOrUndefined(targetElement)) {
                            if (targetElement.id.indexOf('text') > 1) {
                                targetElement = getElement$1(targetElement.id.replace('text', 'shape'));
                            }
                            if ((targetElement).hasAttribute('class') && (targetElement).getAttribute('class').indexOf('highlight') > -1) {
                                return;
                            }
                            this.accumulationHighlightModule.calculateSelectedElements(this, targetElement, 'mousemove');
                            return;
                        }
                    }
                    if (this.accumulationTooltipModule) {
                        var series = this.visibleSeries[seriesIndex];
                        var data = void 0;
                        if (series.enableTooltip) {
                            data = new AccPointData(series.points[pointIndex], series);
                        }
                        this.accumulationTooltipModule.renderSeriesTooltip(this, data);
                    }
                }
                if (this.accumulationHighlightModule && this.highlightMode !== 'None') {
                    targetId = targetId.indexOf('_chart_legend_g_') > -1 ? document.getElementById(targetId).firstChild['id'] : targetId;
                    var legendID = this.element.id + '_chart_legend';
                    var legendItemsId = [legendID + '_text_', legendID + '_shape_marker_',
                        legendID + '_shape_'];
                    for (var i = 0; i < legendItemsId.length; i++) {
                        var id = legendItemsId[i];
                        if (targetId.indexOf(id) > -1) {
                            document.getElementById(targetId).setAttribute('class', '');
                            this.accumulationHighlightModule.legendSelection(this, 0, parseInt(targetId.split(id)[1], 10), getElement$1(targetId), 'mousemove');
                            break;
                        }
                    }
                }
                break;
            case 'Enter':
            case 'Space':
                if (targetId.indexOf('_chart_legend_') > -1 && this.accumulationLegendModule) {
                    this.isLegendClicked = true;
                    this.accumulationLegendModule.click(e);
                    this.focusChild(document.getElementById(targetId).parentElement);
                }
                else {
                    if (this.accumulationSelectionModule) {
                        this.accumulationSelectionModule.calculateSelectedElements(this, document.getElementById(targetId), 'click');
                    }
                }
                break;
            case 'CtrlP':
                this.print();
                break;
            case 'ESC':
                if (this.accumulationTooltipModule) {
                    this.accumulationTooltipModule.removeTooltip(1);
                }
                break;
        }
    };
    AccumulationChart.prototype.focusChild = function (element) {
        element.setAttribute('tabindex', '0');
        var className = element.getAttribute('class');
        element.setAttribute('tabindex', '0');
        if (className && className.indexOf('e-accumulationchart-focused') === -1) {
            className = 'e-accumulationchart-focused ' + className;
        }
        else if (!className) {
            className = 'e-accumulationchart-focused';
        }
        element.setAttribute('class', className);
        element.focus();
        return element.id;
    };
    /**
     * Handles the mouse double click on accumulation chart.
     *
     * @returns {boolean} Mouse double click of accumulation chart.
     * @private
     */
    AccumulationChart.prototype.accumulationOnDoubleClick = function (e) {
        this.trigger(chartDoubleClick, { target: e.target.id, x: this.mouseX, y: this.mouseY });
        return false;
    };
    /**
     * Handles the mouse click on accumulation chart.
     *
     * @returns {boolean} Mouse click of accumulation chart.
     * @private
     */
    AccumulationChart.prototype.accumulationOnMouseClick = function (e) {
        this.setMouseXY(e);
        if (this.accumulationLegendModule && this.legendSettings.visible) {
            this.accumulationLegendModule.click(e);
        }
        if (this.selectionMode !== 'None' && this.accumulationSelectionModule) {
            this.accumulationSelectionModule.calculateSelectedElements(this, e.target, e.type);
        }
        if (this.visibleSeries[0].explode) {
            this.accBaseModule.processExplode(e);
        }
        if (this.enableBorderOnMouseMove && this.pieSeriesModule && this.type === 'Pie') {
            this.pieSeriesModule.findSeries(e);
        }
        this.trigger(chartMouseClick, { target: e.target.id, x: this.mouseX, y: this.mouseY });
        if (this.pointClick) {
            this.triggerPointEvent(pointClick, e.target, e);
        }
        return false;
    };
    AccumulationChart.prototype.triggerPointEvent = function (event, element, e) {
        var evt = e;
        var indexes = indexFinder(element.id, true);
        if (indexes.series >= 0 && indexes.point >= 0) {
            this.trigger(event, {
                series: this.isBlazor ? {} : this.series[indexes.series],
                point: this.series[indexes.series].points[indexes.point],
                seriesIndex: indexes.series, pointIndex: indexes.point,
                x: this.mouseX, y: this.mouseY, pageX: evt.pageX, pageY: evt.pageY
            });
        }
    };
    /**
     * Handles the mouse right click on accumulation chart.
     *
     * @returns {boolean} Right click of accumulation chart.
     * @private
     */
    AccumulationChart.prototype.accumulationRightClick = function (event) {
        if (event.buttons === 2 || event.pointerType === 'touch') {
            event.preventDefault();
            event.stopPropagation();
            return false;
        }
        return true;
    };
    /**
     * Handles the mouse leave on accumulation chart.
     *
     * @returns {boolean} Mouse leave of accumulation chart.
     * @private
     */
    AccumulationChart.prototype.accumulationMouseLeave = function (e) {
        this.setMouseXY(e);
        this.trigger(chartMouseLeave, { target: e.target.id, x: this.mouseX, y: this.mouseY });
        this.notify(Browser.isPointer ? 'pointerleave' : 'mouseleave', e);
        var borderElement = document.getElementById(this.element.id + 'PointHover_Border');
        if (borderElement) {
            this.pieSeriesModule.removeBorder(borderElement, 1000);
            borderElement = null;
        }
        return false;
    };
    /**
     * Method to set culture for chart
     */
    AccumulationChart.prototype.setCulture = function () {
        this.intl = new Internationalization();
    };
    /**
     * Method to create SVG element for accumulation chart.
     */
    AccumulationChart.prototype.createPieSvg = function () {
        this.removeSvg();
        createSvg(this);
    };
    /**
     * To Remove the SVG from accumulation chart.
     *
     * @returns {boolean} Remove svg.
     * @private
     */
    AccumulationChart.prototype.removeSvg = function () {
        if (this.redraw) {
            return null;
        }
        blazorTemplatesReset(this);
        removeElement$1(this.element.id + '_Secondary_Element');
        if (this.svgObject) {
            while (this.svgObject.childNodes.length > 0) {
                this.svgObject.removeChild(this.svgObject.firstChild);
            }
            if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode) {
                remove(this.svgObject);
            }
        }
        removeElement$1('EJ2_legend_tooltip');
        removeElement$1('EJ2_datalabel_tooltip');
        removeElement$1(this.element.id + 'PointHover_Border');
    };
    /**
     * Method to create the secondary element for tooltip, datalabel and annotaitons.
     */
    AccumulationChart.prototype.createSecondaryElement = function () {
        var element = redrawElement(this.redraw, this.element.id + '_Secondary_Element') ||
            this.createElement('div', {
                id: this.element.id + '_Secondary_Element',
                styles: 'position: relative'
            });
        appendChildElement(false, this.element, element, this.redraw);
    };
    /**
     * Method to find visible series based on series types
     */
    AccumulationChart.prototype.calculateVisibleSeries = function () {
        this.visibleSeries = [];
        for (var i = 0, length_1 = this.series.length; i < length_1; i++) {
            this.series[i].index = i;
            if (this.series[i].type === this.type && this.visibleSeries.length === 0) {
                this.visibleSeries.push(this.series[i]);
                break;
            }
        }
    };
    /**
     * To find points from dataSource
     */
    AccumulationChart.prototype.processData = function (render) {
        if (render === void 0) { render = true; }
        this.seriesCounts = 0;
        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            series.dataModule = new Data(series.dataSource || this.dataSource, series.query);
            series.refreshDataManager(this, render);
        }
    };
    /**
     * To refresh the accumulation chart
     *
     * @private
     */
    AccumulationChart.prototype.refreshChart = function () {
        this.doGrouppingProcess();
        this.createPieSvg();
        this.calculateBounds();
        this.renderElements();
        removeElement$1('chartmeasuretext');
    };
    /**
     * Method to find groupped points
     */
    AccumulationChart.prototype.doGrouppingProcess = function () {
        var series = this.visibleSeries[0];
        if (!isNullOrUndefined(series.resultData) && ((!isNullOrUndefined(series.lastGroupTo) &&
            series.lastGroupTo !== series.groupTo))) {
            series.getPoints(series.resultData, this);
        }
    };
    /**
     * Method to calculate bounds for accumulation chart
     */
    AccumulationChart.prototype.calculateBounds = function () {
        this.initialClipRect = new Rect(this.margin.left, this.margin.top, this.availableSize.width, this.availableSize.height);
        this.titleCollection = [];
        this.subTitleCollection = [];
        var titleHeight = 0;
        var subTitleHeight = 0;
        var maxWidth = 0;
        var titleWidth = 0;
        if (this.title) {
            this.titleCollection = getTitle(this.title, this.titleStyle, this.initialClipRect.width, this.enableRtl, this.themeStyle.chartTitleFont);
        }
        titleHeight = this.title ? measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont).height * this.titleCollection.length : titleHeight;
        if (this.subTitle) {
            for (var _i = 0, _a = this.titleCollection; _i < _a.length; _i++) {
                var titleText = _a[_i];
                titleWidth = measureText(titleText, this.titleStyle, this.themeStyle.chartSubTitleFont).width;
                maxWidth = titleWidth > maxWidth ? titleWidth : maxWidth;
            }
            this.subTitleCollection = getTitle(this.subTitle, this.subTitleStyle, maxWidth, this.enableRtl, this.themeStyle.chartTitleFont);
            subTitleHeight = (measureText(this.subTitle, this.subTitleStyle, this.themeStyle.chartSubTitleFont).height * this.subTitleCollection.length);
        }
        subtractRect(this.initialClipRect, new Rect(0, (subTitleHeight + titleHeight), this.margin.right + this.margin.left, this.margin.bottom + this.margin.top));
        this.calculateLegendBounds();
    };
    /*
     * Method to calculate legend bounds for accumulation chart
     */
    AccumulationChart.prototype.calculateLegendBounds = function () {
        if (!this.accumulationLegendModule || !this.legendSettings.visible) {
            return null;
        }
        this.accumulationLegendModule.getLegendOptions(this, this.visibleSeries);
        this.accumulationLegendModule.calculateLegendBounds(this.initialClipRect, this.availableSize, null);
    };
    /**
     * To render elements for accumulation chart
     *
     * @private
     */
    AccumulationChart.prototype.renderElements = function () {
        this.renderBorder();
        this.createSecondaryElement();
        this.renderSeries();
        this.renderTitle();
        this.renderCenterLabel(true);
        this.renderLegend();
        appendChildElement(false, this.element, this.svgObject, this.redraw);
        this.processSelection();
        this.processExplode();
        this.renderAnnotation();
        this.setSecondaryElementPosition();
        updateBlazorTemplate(this.element.id + '_DataLabel', 'Template', this.series[0].dataLabel);
        this.trigger('loaded', { accumulation: this.isBlazor ? {} : this, chart: this.isBlazor ? {} : this });
        this.animateSeries = false;
    };
    /**
     * To set the left and top position for data label template for center aligned chart
     *
     * @private
     */
    AccumulationChart.prototype.setSecondaryElementPosition = function () {
        var tooltipParent = getElement$1(this.element.id + '_Secondary_Element');
        if (!tooltipParent) {
            return;
        }
        var rect = this.element.getBoundingClientRect();
        var svgRect = getElement$1(this.element.id + '_svg').getBoundingClientRect();
        tooltipParent.style.left = Math.max(svgRect.left - rect.left, 0) + 'px';
        tooltipParent.style.top = Math.max(svgRect.top - rect.top, 0) + 'px';
    };
    /**
     * To render the annotaitions for accumulation series.
     *
     * @private
     */
    AccumulationChart.prototype.renderAnnotation = function () {
        if (this.annotationModule) {
            this.annotationModule.renderAnnotations(getElement$1(this.element.id + '_Secondary_Element'));
        }
    };
    /**
     * Method to process the explode in accumulation chart
     *
     * @private
     */
    AccumulationChart.prototype.processExplode = function () {
        if (this.redraw) {
            return null;
        }
        if (!this.visibleSeries[0].explode) {
            return null;
        }
        this.accBaseModule.invokeExplode();
    };
    /**
     * Method to render series for accumulation chart
     */
    AccumulationChart.prototype.renderSeries = function () {
        if (!this.redraw) {
            this.svgObject.appendChild(this.renderer.createGroup({ id: this.element.id + '_SeriesCollection' }));
        }
        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            if (series.visible && this[(firstToLowerCase(series.type) + 'SeriesModule')]) {
                this[(firstToLowerCase(series.type) + 'SeriesModule')].initProperties(this, series);
                series.renderSeries(this, this.redraw);
            }
        }
    };
    /**
     * Method to render border for accumulation chart
     */
    AccumulationChart.prototype.renderBorder = function () {
        var padding = this.border.width;
        var rect = new RectOption(this.element.id + '_border', this.background || this.themeStyle.background, this.border, 1, new Rect(padding / 2, padding / 2, this.availableSize.width - padding, this.availableSize.height - padding));
        var htmlObject = this.renderer.drawRectangle(rect);
        htmlObject.setAttribute('aria-hidden', 'true');
        appendChildElement(false, this.svgObject, htmlObject, this.redraw);
        // to draw back ground image for accumulation chart
        var backGroundImage = this.backgroundImage;
        if (backGroundImage) {
            var image = new ImageOption(this.availableSize.height - padding, this.availableSize.width - padding, backGroundImage, 0, 0, this.element.id + '_background', 'visible', 'none');
            appendChildElement(false, this.svgObject, this.renderer.drawImage(image), this.redraw);
        }
    };
    /**
     * Method to render legend for accumulation chart
     */
    AccumulationChart.prototype.renderLegend = function () {
        if (!this.accumulationLegendModule || !this.legendSettings.visible) {
            return null;
        }
        if (this.accumulationLegendModule.legendCollections.length) {
            if (this.visibleSeries[0].type === 'Pie') {
                this.accumulationLegendModule.getSmartLegendLocation(this.visibleSeries[0].labelBound, this.accumulationLegendModule.legendBounds, this.margin);
            }
            this.accumulationLegendModule.renderLegend(this, this.legendSettings, this.accumulationLegendModule.legendBounds, this.redraw);
        }
    };
    /**
     * To process the selection in accumulation chart
     *
     * @private
     */
    AccumulationChart.prototype.processSelection = function () {
        var selectedDataIndexes = [];
        if (this.accumulationSelectionModule && this.selectionMode !== 'None') {
            selectedDataIndexes = extend([], this.accumulationSelectionModule.selectedDataIndexes, null, true);
            this.accumulationSelectionModule.invokeSelection(this);
        }
        if (this.accumulationHighlightModule && this.highlightMode !== 'None') {
            this.accumulationHighlightModule.invokeHighlight(this);
        }
        if (selectedDataIndexes.length > 0) {
            this.accumulationSelectionModule.selectedDataIndexes = selectedDataIndexes;
            this.accumulationSelectionModule.redrawSelection(this);
        }
    };
    /**
     * To render title for accumulation chart
     */
    AccumulationChart.prototype.renderTitle = function () {
        var margin = this.margin;
        if (!this.title) {
            return null;
        }
        var getAnchor = getTextAnchor(this.titleStyle.textAlignment, this.enableRtl);
        var titleSize = measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont);
        var padding = 20;
        var titleHeight = this.margin.top + (titleSize.height * 3 / 4);
        var legendHeight = this.accumulationLegendModule === undefined ? 0 : this.legendSettings.position === 'Top' ?
            this.accumulationLegendModule.legendBounds.height : 0;
        var explode = this.explodeDistance === 0 ? 0 : this.explodeDistance;
        var expodeValue = legendHeight !== 0 ? 0 : explode / 2;
        var rect = new Rect(margin.left, 0, this.availableSize.width - margin.left - margin.right, 0);
        var options = new TextOption(this.element.id + '_title', titlePositionX(rect, this.titleStyle), titleHeight, getAnchor, this.titleCollection, '', 'auto');
        var space = (this.series[0].type === 'Pie' && this.visibleSeries[0].dataLabel.position === 'Outside' && this.visibleSeries[0].dataLabel.connectorStyle.length) ? stringToNumber(this.visibleSeries[0].dataLabel.connectorStyle.length, this.accBaseModule.radius) : 0;
        if (!this.subTitle && (this.series[0].type !== 'Funnel' && this.series[0].type !== 'Pyramid')) {
            options.y = parseInt(this.series[0].radius) >= 80 ? options.y :
                (this.accBaseModule.center.y - this.accBaseModule.radius - padding
                    - titleHeight - legendHeight - expodeValue - space);
            if (this.series[0].type === 'Pie' && (parseInt(this.series[0].radius) < 80 || isNaN(parseInt(this.series[0].radius)))) {
                options.y = options.y < (this.initialClipRect.y - legendHeight) ? (this.initialClipRect.y - legendHeight) : options.y;
            }
        }
        var element = textElement$1(this.renderer, options, this.titleStyle, this.titleStyle.color || this.themeStyle.chartTitleFont.color, this.svgObject, false, this.redraw, null, null, null, null, null, null, null, null, this.themeStyle.chartTitleFont);
        if (element) {
            element.setAttribute('tabindex', '0');
            element.parentNode.insertBefore(element, this.svgObject.children && this.svgObject.children[1]);
        }
        if (this.subTitle) {
            this.renderSubTitle(options);
        }
    };
    /**
     * To update center label on mouse move.
     */
    AccumulationChart.prototype.updateCenterLabel = function (event) {
        var data = this.getPieData(event);
        this.format = (data.point == null) ? '' : this.parseFormat(data.point, this.visibleSeries[0], this.centerLabel.hoverTextFormat);
        this.renderCenterLabel();
    };
    /**
     * Function to get pie data on mouse move.
     */
    AccumulationChart.prototype.getPieData = function (e) {
        var dataIndex = indexFinder(e.target.id, true);
        if (!isNaN(dataIndex.series)) {
            return new AccPointData(this.visibleSeries[0].points[dataIndex.point], this.visibleSeries[0]);
        }
        return new AccPointData(null, null);
    };
    /**
     * Function to get format of pie data on mouse move.
     */
    AccumulationChart.prototype.parseFormat = function (point, series, format) {
        var value;
        var textValue;
        for (var _i = 0, _a = Object.keys(point); _i < _a.length; _i++) {
            var dataValue = _a[_i];
            // eslint-disable-next-line security/detect-non-literal-regexp
            value = new RegExp('${point' + '.' + dataValue + '}', 'gm');
            format = format.replace(value.source, point[dataValue]);
        }
        for (var _b = 0, _c = Object.keys(Object.getPrototypeOf(series)); _b < _c.length; _b++) {
            var dataValue = _c[_b];
            // eslint-disable-next-line security/detect-non-literal-regexp
            value = new RegExp('${series' + '.' + dataValue + '}', 'gm');
            textValue = series[dataValue];
            format = format.replace(value.source, textValue);
        }
        return format;
    };
    /**
     * To render center label for accumulation chart.
     */
    AccumulationChart.prototype.renderCenterLabel = function (isanimate) {
        if (!this.centerLabel.text) {
            return null;
        }
        var series = this.series[0];
        var ypos;
        var getAnchor = getTextAnchor(this.centerLabel.textStyle.textAlignment, this.enableRtl);
        var padding = 10;
        // To get side of square inside the circle , which is considered as maxwidth , d*sqrt(0.5)
        var maxwidth = this.pieSeriesModule.innerRadius ? ((2 * this.pieSeriesModule.innerRadius) * (0.7071067)) : ((2 * this.pieSeriesModule.radius) * (0.7071067));
        var labelCollection = (this.format || this.centerLabel.text).split('<br>');
        var centerLabelSize = measureText(labelCollection[0], this.centerLabel.textStyle, this.themeStyle.chartTitleFont);
        var collectionLength = labelCollection.length;
        for (var i = 0; i < collectionLength; i++) {
            var labelSize = measureText(labelCollection[i], this.centerLabel.textStyle, this.themeStyle.chartTitleFont);
            if (labelSize.width > maxwidth) {
                labelCollection.splice.apply(labelCollection, [i, 1].concat((textWrap(labelCollection[i], maxwidth, this.centerLabel.textStyle, this.enableRtl, null, null, this.themeStyle.chartTitleFont))));
            }
        }
        if (centerLabelSize.height * (labelCollection.length) > maxwidth) {
            ypos = this.accBaseModule.center.y + ((centerLabelSize.height + padding) / 2) - (maxwidth / 2);
        }
        else if (series.startAngle && series.endAngle) {
            ypos = this.accBaseModule.center.y - (centerLabelSize.height * labelCollection.length / 2) +
                ((centerLabelSize.height + padding) / 2) - this.pieSeriesModule.innerRadius / 2 + (this.pieSeriesModule.innerRadius ? padding : 0);
            if ((centerLabelSize.height * (labelCollection.length) + this.pieSeriesModule.innerRadius / 2 + padding > maxwidth)) {
                ypos = this.accBaseModule.center.y + ((centerLabelSize.height + padding) / 2) - (maxwidth / 2);
            }
        }
        else {
            ypos = labelCollection.length > 1 ? (this.accBaseModule.center.y - (centerLabelSize.height * labelCollection.length / 2) +
                ((centerLabelSize.height + padding) / 2)) : (this.accBaseModule.center.y + (centerLabelSize.height) / 4);
        }
        var options = new TextOption(this.element.id + '_centerLabel', (((this.series[0].animation.enable && animationMode != 'Disable') || animationMode === 'Enable') && isanimate) ? this.pieSeriesModule.center.x - 1 : this.pieSeriesModule.center.x, ypos, getAnchor, '', '', 'auto');
        var element = textElement$1(this.renderer, options, this.centerLabel.textStyle, this.centerLabel.textStyle.color ||
            this.themeStyle.chartTitleFont.color, this.svgObject, false, this.redraw, null, null, null, null, null, null, null, null, this.themeStyle.chartTitleFont);
        for (var i = 0; i < labelCollection.length; i++) {
            var tspanOption = { x: options.x, y: options.y + (i * centerLabelSize.height), fill: '', };
            var tspanElement = this.renderer.createTSpan(tspanOption, '');
            tspanElement.style.fontFamily = 'inherit';
            tspanElement.style.fontStyle = 'inherit';
            tspanElement.style.fontSize = 'inherit';
            tspanElement.style.fontWeight = (labelCollection[i].indexOf('<b>') > -1 || labelCollection[i].indexOf('</b>') > -1) ? 'bold' : 'inherit';
            tspanElement.textContent = labelCollection[i].replace(/<\/?b>/g, '');
            element.appendChild(tspanElement);
        }
        if (isanimate && ((this.series[0].animation.enable && animationMode != 'Disable') || animationMode === 'Enable') && this.animateSeries) {
            this.centerLabelDelay(element);
        }
    };
    /**
     * Function to delay Center label at initial stage of accumulation chart.
     */
    AccumulationChart.prototype.centerLabelDelay = function (element) {
        element.style.visibility = 'hidden';
        var animation = new Animation({});
        animation.animate(element, {
            delay: this.duration ? this.duration : this.series[0].animation.duration,
            progress: function (args) {
                args.element.style.visibility = 'visible';
            }
        });
    };
    AccumulationChart.prototype.renderSubTitle = function (options) {
        var maxWidth = 0;
        var titleWidth = 0;
        var padding = 10;
        var alignment = this.titleStyle.textAlignment;
        var subTitleElementSize = measureText(this.subTitle, this.subTitleStyle, this.themeStyle.chartSubTitleFont);
        for (var _i = 0, _a = this.titleCollection; _i < _a.length; _i++) {
            var titleText = _a[_i];
            titleWidth = measureText(titleText, this.titleStyle, this.themeStyle.chartSubTitleFont).width;
            maxWidth = titleWidth > maxWidth ? titleWidth : maxWidth;
        }
        var rect = new Rect(alignment === 'Center' ? (options.x - maxWidth / 2) : alignment === 'Far' ? options.x - maxWidth : options.x, 0, maxWidth, 0);
        var subTitleOption = new TextOption(this.element.id + '_subTitle', titlePositionX(rect, this.subTitleStyle), options.y * options.text.length + ((subTitleElementSize.height) * 3 / 4) + padding, getTextAnchor(this.subTitleStyle.textAlignment, this.enableRtl), this.subTitleCollection, '', 'auto');
        textElement$1(this.renderer, subTitleOption, this.subTitleStyle, this.subTitleStyle.color || this.themeStyle.chartSubTitleFont.color, this.svgObject, false, this.redraw, null, null, null, null, null, null, null, null, this.themeStyle.chartSubTitleFont);
    };
    /**
     * To get the series parent element
     *
     * @private
     */
    AccumulationChart.prototype.getSeriesElement = function () {
        return this.svgObject.getElementsByTagName('g')[0];
    };
    /**
     * To refresh the all visible series points
     *
     * @private
     */
    AccumulationChart.prototype.refreshSeries = function () {
        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            this.refreshPoints(series.points);
        }
    };
    /**
     * To refresh points label region and visible
     *
     * @private
     */
    AccumulationChart.prototype.refreshPoints = function (points) {
        for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
            var point = points_1[_i];
            point.labelPosition = null;
            point.labelRegion = null;
            point.labelVisible = true;
        }
    };
    /**
     * To get Module name
     *
     *  @private
     */
    AccumulationChart.prototype.getModuleName = function () {
        return 'accumulationchart';
    };
    /**
     * To destroy the accumulationcharts
     *
     * @private
     */
    AccumulationChart.prototype.destroy = function () {
        /**
         * To fix react timeout destroy issue.
         */
        if (this.element) {
            this.unWireEvents();
            _super.prototype.destroy.call(this);
            this.element.classList.remove('e-accumulationchart');
            this.element.classList.remove('e-accumulationchart-focused');
            var element = document.getElementById(this.element.id + 'Keyboard_accumulationchart_focus');
            if (element) {
                element.remove();
            }
            removeElement$1('chartmeasuretext');
            this.removeSvg();
            this.svgObject = null;
        }
    };
    /**
     * To provide the array of modules needed for control rendering
     *
     * @returns {ModuleDeclaration[]} required modules
     * @private
     */
    AccumulationChart.prototype.requiredModules = function () {
        var modules = [];
        var enableAnnotation = false;
        modules.push({
            member: this.type + 'Series',
            args: [this]
        });
        if (this.legendSettings.visible) {
            modules.push({
                member: 'AccumulationLegend',
                args: [this]
            });
        }
        if (this.findDatalabelVisibility()) {
            modules.push({
                member: 'AccumulationDataLabel',
                args: [this]
            });
        }
        if (this.tooltip.enable) {
            modules.push({
                member: 'AccumulationTooltip',
                args: [this]
            });
        }
        if (this.selectionMode !== 'None') {
            modules.push({
                member: 'AccumulationSelection',
                args: [this]
            });
        }
        if (this.highlightMode !== 'None') {
            modules.push({
                member: 'AccumulationHighlight',
                args: [this]
            });
        }
        if (this.enableExport || this.allowExport) {
            modules.push({
                member: 'Export',
                args: [this]
            });
        }
        enableAnnotation = this.annotations.some(function (value) {
            return (value.content !== null);
        });
        if (enableAnnotation) {
            modules.push({
                member: 'Annotation',
                args: [this]
            });
        }
        return modules;
    };
    /**
     * To find datalabel visibility in series
     */
    AccumulationChart.prototype.findDatalabelVisibility = function () {
        for (var _i = 0, _a = this.series; _i < _a.length; _i++) {
            var series = _a[_i];
            if (series.dataLabel.visible) {
                return true;
            }
        }
        return false;
    };
    /**
     * Get visible series for accumulation chart by index
     */
    AccumulationChart.prototype.changeVisibleSeries = function (visibleSeries, index) {
        for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
            var series = visibleSeries_1[_i];
            if (index === series.index) {
                return series;
            }
        }
        return null;
    };
    /**
     * Get the properties to be maintained in the persisted state.
     *
     * @private
     */
    AccumulationChart.prototype.getPersistData = function () {
        return '';
    };
    /**
     * Called internally if any of the property value changed.
     *
     * @private
     */
    // tslint:disable-next-line:max-func-body-length
    AccumulationChart.prototype.onPropertyChanged = function (newProp, oldProp) {
        var update = {
            refreshElements: false, refreshBounds: false
        };
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'theme':
                    this.animateSeries = true;
                    break;
                case 'title':
                case 'subTitle':
                case 'height':
                case 'width':
                case 'margin':
                    update.refreshBounds = true;
                    break;
                case 'titleStyle':
                    if (newProp.titleStyle && (newProp.titleStyle.size || newProp.titleStyle.textOverflow)) {
                        update.refreshBounds = true;
                    }
                    else {
                        update.refreshElements = true;
                    }
                    break;
                case 'subTitleStyle':
                    if (newProp.subTitleStyle && (newProp.subTitleStyle.size || newProp.subTitleStyle.textOverflow)) {
                        update.refreshBounds = true;
                    }
                    else {
                        update.refreshElements = true;
                    }
                    break;
                case 'legendSettings':
                    update.refreshBounds = true;
                    update.refreshElements = true;
                    break;
                case 'dataSource':
                    this.processData(false);
                    update.refreshBounds = true;
                    break;
                case 'series':
                    if (!this.animateselected) {
                        var len = this.series.length;
                        var seriesRefresh = false;
                        var series = void 0;
                        var blazorProp = void 0;
                        for (var i = 0; i < len; i++) {
                            series = newProp.series[i];
                            if (this.isBlazor && (series.startAngle || series.endAngle || series.explodeOffset || series.neckHeight ||
                                series.neckWidth || series.radius || series.innerRadius || series.groupMode || series.emptyPointSettings)) {
                                blazorProp = true;
                            }
                            if (newProp.series[i] && (newProp.series[i].dataSource || newProp.series[i].yName
                                || newProp.series[i].xName || series.type ||
                                newProp.series[i].dataLabel || blazorProp)) {
                                extend(this.changeVisibleSeries(this.visibleSeries, i), series, null, true);
                                seriesRefresh = true;
                            }
                            if (newProp.series[i] && !isNullOrUndefined(newProp.series[i].explodeIndex) &&
                                newProp.series[i].explodeIndex >= 0
                                && newProp.series[i].explodeIndex !== oldProp.series[i].explodeIndex) {
                                this.accBaseModule.explodePoints(newProp.series[i].explodeIndex, this);
                                this.accBaseModule.deExplodeAll(newProp.series[i].explodeIndex, this.enableAnimation ? 300 : 0);
                            }
                            else if (newProp.series[i].explodeIndex < 0) {
                                this.accBaseModule.deExplodeAll(newProp.series[i].explodeIndex, this.enableAnimation ? 300 : 0);
                            }
                            if (!this.pieSeriesModule) {
                                this.pieSeriesModule = new PieSeries(this);
                            }
                        }
                        if (seriesRefresh) {
                            this.processData(false);
                            update.refreshBounds = true;
                        }
                    }
                    this.animateselected = false;
                    this.redraw = false;
                    break;
                case 'enableRtl':
                case 'locale':
                case 'currencyCode':
                    _super.prototype.refresh.call(this);
                    break;
                case 'background':
                case 'border':
                case 'annotations':
                case 'enableSmartLabels':
                    update.refreshElements = true;
                    break;
                case 'isMultiSelect':
                case 'selectedDataIndexes':
                case 'selectionMode':
                    if (this.accumulationSelectionModule) {
                        if (isNullOrUndefined(this.accumulationSelectionModule.selectedDataIndexes)) {
                            this.accumulationSelectionModule.invokeSelection(this);
                        }
                        else {
                            this.accumulationSelectionModule.selectedDataIndexes = this.selectedDataIndexes;
                            this.accumulationSelectionModule.redrawSelection(this);
                        }
                    }
                    break;
                case 'tooltip':
                    if (this.accumulationTooltipModule) { // To check the tooltip enable is true.
                        this.accumulationTooltipModule.previousPoints = [];
                        if (this.tooltip.template) {
                            this.accumulationTooltipModule.template = this.tooltip.template;
                        }
                    }
                    break;
            }
        }
        if (!update.refreshBounds && update.refreshElements) {
            this.createPieSvg();
            this.renderElements();
        }
        else if (update.refreshBounds) {
            this.refreshSeries();
            this.createPieSvg();
            this.calculateBounds();
            this.renderElements();
        }
    };
    __decorate$7([
        Property(null)
    ], AccumulationChart.prototype, "width", void 0);
    __decorate$7([
        Property(null)
    ], AccumulationChart.prototype, "height", void 0);
    __decorate$7([
        Property(null)
    ], AccumulationChart.prototype, "title", void 0);
    __decorate$7([
        Property(null)
    ], AccumulationChart.prototype, "backgroundImage", void 0);
    __decorate$7([
        Complex({}, PieCenter)
    ], AccumulationChart.prototype, "center", void 0);
    __decorate$7([
        Property('')
    ], AccumulationChart.prototype, "dataSource", void 0);
    __decorate$7([
        Complex({ fontFamily: null, size: "16px", fontStyle: 'Normal', fontWeight: '600', color: null }, Font)
    ], AccumulationChart.prototype, "titleStyle", void 0);
    __decorate$7([
        Property(null)
    ], AccumulationChart.prototype, "subTitle", void 0);
    __decorate$7([
        Complex({ fontFamily: null, size: "14px", fontStyle: 'Normal', fontWeight: '400', color: null }, Font)
    ], AccumulationChart.prototype, "subTitleStyle", void 0);
    __decorate$7([
        Complex({}, LegendSettings)
    ], AccumulationChart.prototype, "legendSettings", void 0);
    __decorate$7([
        Complex({}, TooltipSettings)
    ], AccumulationChart.prototype, "tooltip", void 0);
    __decorate$7([
        Complex({}, CenterLabel)
    ], AccumulationChart.prototype, "centerLabel", void 0);
    __decorate$7([
        Property('None')
    ], AccumulationChart.prototype, "selectionMode", void 0);
    __decorate$7([
        Property('')
    ], AccumulationChart.prototype, "highlightColor", void 0);
    __decorate$7([
        Property('None')
    ], AccumulationChart.prototype, "highlightMode", void 0);
    __decorate$7([
        Property('None')
    ], AccumulationChart.prototype, "selectionPattern", void 0);
    __decorate$7([
        Property('None')
    ], AccumulationChart.prototype, "highlightPattern", void 0);
    __decorate$7([
        Property(true)
    ], AccumulationChart.prototype, "enableBorderOnMouseMove", void 0);
    __decorate$7([
        Property(false)
    ], AccumulationChart.prototype, "isMultiSelect", void 0);
    __decorate$7([
        Property(true)
    ], AccumulationChart.prototype, "enableAnimation", void 0);
    __decorate$7([
        Collection([], Indexes)
    ], AccumulationChart.prototype, "selectedDataIndexes", void 0);
    __decorate$7([
        Complex({}, Margin)
    ], AccumulationChart.prototype, "margin", void 0);
    __decorate$7([
        Property(true)
    ], AccumulationChart.prototype, "enableSmartLabels", void 0);
    __decorate$7([
        Complex({ color: '#DDDDDD', width: 0 }, Border)
    ], AccumulationChart.prototype, "border", void 0);
    __decorate$7([
        Property(null)
    ], AccumulationChart.prototype, "background", void 0);
    __decorate$7([
        Collection([{}], AccumulationSeries)
    ], AccumulationChart.prototype, "series", void 0);
    __decorate$7([
        Collection([{}], AccumulationAnnotationSettings)
    ], AccumulationChart.prototype, "annotations", void 0);
    __decorate$7([
        Property('Material')
    ], AccumulationChart.prototype, "theme", void 0);
    __decorate$7([
        Property(false)
    ], AccumulationChart.prototype, "useGroupingSeparator", void 0);
    __decorate$7([
        Property(true)
    ], AccumulationChart.prototype, "enableExport", void 0);
    __decorate$7([
        Property(false)
    ], AccumulationChart.prototype, "allowExport", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "loaded", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "legendClick", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "load", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "seriesRender", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "legendRender", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "textRender", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "tooltipRender", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "pointRender", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "annotationRender", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "beforePrint", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "chartMouseMove", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "chartMouseClick", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "chartDoubleClick", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "pointClick", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "pointMove", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "animationComplete", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "chartMouseDown", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "chartMouseLeave", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "chartMouseUp", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "beforeResize", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "resized", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "afterExport", void 0);
    __decorate$7([
        Event()
    ], AccumulationChart.prototype, "selectionComplete", void 0);
    __decorate$7([
        Property('USD')
    ], AccumulationChart.prototype, "currencyCode", void 0);
    AccumulationChart = __decorate$7([
        NotifyPropertyChanges
    ], AccumulationChart);
    return AccumulationChart;
}(Component));

/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * Defines the common behavior of funnel and pyramid series
 */
var __extends$68 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * TriangularBase is used to calculate base functions for funnel/pyramid series.
 */
var TriangularBase = /** @__PURE__ @class */ (function (_super) {
    __extends$68(TriangularBase, _super);
    function TriangularBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Initializes the properties of funnel/pyramid series
     *
     * @private
     */
    TriangularBase.prototype.initProperties = function (chart, series) {
        var actualChartArea = chart.initialClipRect;
        series.triangleSize = new Size(stringToNumber(series.width, actualChartArea.width), stringToNumber(series.height, actualChartArea.height));
        series.neckSize = new Size(stringToNumber(series.neckWidth, actualChartArea.width), stringToNumber(series.neckHeight, actualChartArea.height));
        this.defaultLabelBound(series, series.dataLabel.visible, series.dataLabel.position, chart);
        if (series.explodeOffset === '30%') {
            series.explodeOffset = '25px';
        }
        chart.explodeDistance = stringToNumber(series.explodeOffset, actualChartArea.width);
        var points = series.points;
        this.initializeSizeRatio(points, series);
    };
    /**
     * Initializes the size of the pyramid/funnel segments
     *
     * @private
     */
    TriangularBase.prototype.initializeSizeRatio = function (points, series, reverse) {
        if (reverse === void 0) { reverse = false; }
        var sumOfPoints = series.sumOfPoints;
        //Limiting the ratio within the range of 0 to 1
        var gapRatio = Math.min(Math.max(series.gapRatio, 0), 1);
        //% equivalence of a value 1
        var coEff = (sumOfPoints !== 0) ? 1 / (sumOfPoints * (1 + gapRatio / (1 - gapRatio))) : 0;
        var spacing = gapRatio / (points.length - 1);
        var y = 0;
        //starting from bottom
        for (var i = points.length - 1; i >= 0; i--) {
            var index = reverse ? points.length - 1 - i : i;
            if (points[index].visible) {
                var height = coEff * points[index].y;
                points[index].yRatio = y;
                points[index].heightRatio = height;
                y += height + spacing;
            }
        }
    };
    /**
     * Marks the label location from the set of points that forms a pyramid/funnel segment
     *
     * @private
     */
    TriangularBase.prototype.setLabelLocation = function (series, point, points) {
        var last = points.length - 1;
        var bottom = series.type === 'Funnel' ? points.length - 2 : points.length - 1;
        var x = (points[0].x + points[bottom].x) / 2;
        var right = (points[1].x + points[bottom - 1].x) / 2;
        point.region = new Rect(x, points[0].y, right - x, points[bottom].y - points[0].y);
        point.symbolLocation = {
            x: point.region.x + point.region.width / 2,
            y: point.region.y + point.region.height / 2
        };
        point.labelOffset = {
            x: point.symbolLocation.x - (points[0].x + points[last].x) / 2,
            y: point.symbolLocation.y - (points[0].y + points[last].y) / 2
        };
    };
    /**
     * Finds the path to connect the list of points
     *
     * @private
     */
    TriangularBase.prototype.findPath = function (locations) {
        var path = 'M';
        for (var i = 0; i < locations.length; i++) {
            path += locations[i].x + ' ' + locations[i].y;
            if (i !== locations.length - 1) {
                path += ' L';
            }
        }
        return path + ' Z';
    };
    /**
     * To calculate data-label bounds
     *
     * @private
     */
    TriangularBase.prototype.defaultLabelBound = function (series, visible, position, chart) {
        var x = (chart.initialClipRect.width - series.triangleSize.width) / 2;
        var y = (chart.initialClipRect.height - series.triangleSize.height) / 2;
        var accumulationBound = new Rect(x, y, series.triangleSize.width, series.triangleSize.height);
        series.labelBound = new Rect(accumulationBound.x, accumulationBound.y, accumulationBound.width + accumulationBound.x, accumulationBound.height + accumulationBound.y);
        series.accumulationBound = accumulationBound;
        if (visible && position === 'Outside') {
            series.labelBound = new Rect(Infinity, Infinity, -Infinity, -Infinity);
        }
    };
    return TriangularBase;
}(AccumulationBase));

/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * Defines the behavior of a funnel series
 */
var __extends$67 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * FunnelSeries module used to render `Funnel` Series.
 */
var FunnelSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$67(FunnelSeries, _super);
    function FunnelSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Defines the path of a funnel segment
     *
     * @private
     * @returns {string} Get segment data.
     */
    FunnelSeries.prototype.getSegmentData = function (point, series, chart) {
        var lineWidth;
        var topRadius;
        var bottomRadius;
        var endTop;
        var endBottom;
        var minRadius;
        var endMin;
        var bottomY;
        var area = series.triangleSize;
        var offset = 0;
        var extraSpace = (chart.initialClipRect.width - series.triangleSize.width) / 2;
        var emptySpaceAtLeft = extraSpace + chart.initialClipRect.x;
        var seriesTop = chart.initialClipRect.y + (chart.initialClipRect.height - area.height) / 2;
        //defines the top and bottom of a segment
        var top = point.yRatio * area.height;
        var bottom = top + point.heightRatio * area.height;
        var neckSize = series.neckSize;
        lineWidth = neckSize.width + (area.width - neckSize.width) * ((area.height - neckSize.height - top) /
            (area.height - neckSize.height));
        topRadius = (area.width / 2) - lineWidth / 2;
        //Calculating the middle slope change and bottom
        endTop = topRadius + lineWidth;
        if (bottom > area.height - neckSize.height || area.height === neckSize.height) {
            lineWidth = neckSize.width;
        }
        else {
            lineWidth = neckSize.width + (area.width - neckSize.width) *
                ((area.height - neckSize.height - bottom) / (area.height - neckSize.height));
        }
        bottomRadius = (area.width / 2) - (lineWidth / 2);
        endBottom = bottomRadius + lineWidth;
        if (top >= area.height - neckSize.height) {
            topRadius = bottomRadius = minRadius = (area.width / 2) - neckSize.width / 2;
            endTop = endBottom = endMin = (area.width / 2) + neckSize.width / 2;
        }
        else if (bottom > (area.height - neckSize.height)) {
            minRadius = bottomRadius = (area.width / 2) - lineWidth / 2;
            endMin = endBottom = minRadius + lineWidth;
            bottomY = area.height - neckSize.height;
        }
        top += seriesTop;
        bottom += seriesTop;
        bottomY += seriesTop;
        var line1 = { x: emptySpaceAtLeft + offset + topRadius, y: top };
        var line2 = { x: emptySpaceAtLeft + offset + endTop, y: top };
        var line4 = { x: emptySpaceAtLeft + offset + endBottom, y: bottom };
        var line5 = { x: emptySpaceAtLeft + offset + bottomRadius, y: bottom };
        var line3 = { x: emptySpaceAtLeft + offset + endBottom, y: bottom };
        var line6 = { x: emptySpaceAtLeft + offset + bottomRadius, y: bottom };
        if (bottomY) {
            line3 = { x: emptySpaceAtLeft + offset + endMin, y: bottomY };
            line6 = { x: emptySpaceAtLeft + offset + minRadius, y: bottomY };
        }
        var polygon = [line1, line2, line3, line4, line5, line6];
        this.setLabelLocation(series, point, polygon);
        var direction = this.findPath(polygon);
        return direction;
    };
    /**
     * Renders a funnel segment
     *
     * @private
     * @returns {void} Render point.
     */
    FunnelSeries.prototype.renderPoint = function (point, series, chart, options, seriesGroup, redraw) {
        if (!point.visible) {
            removeElement$1(options.id);
            return null;
        }
        var direction = this.getSegmentData(point, series, chart);
        point.midAngle = 0;
        options.d = direction;
        var element = chart.renderer.drawPath(options);
        element.setAttribute('role', 'img');
        element.setAttribute('tabindex', point.index === 0 ? '0' : '-1');
        element.setAttribute('aria-label', (point.x + ':' + point.y + '%. ' + series.name));
        appendChildElement(false, seriesGroup, element, redraw);
        if (point.isExplode) {
            chart.accBaseModule.explodePoints(point.index, chart, true);
        }
    };
    /**
     * To get the module name of the funnel series.
     *
     * @returns {string} Get module name.
     */
    FunnelSeries.prototype.getModuleName = function () {
        return 'FunnelSeries';
    };
    /**
     * To destroy the funnel series.
     *
     * @returns {void} Destroy method.
     * @private
     */
    FunnelSeries.prototype.destroy = function () {
        /**
         * Destroys the funnel series
         */
    };
    return FunnelSeries;
}(TriangularBase));

/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * Defines the behavior of a pyramid series
 */
var __extends$69 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * PyramidSeries module used to render `Pyramid` Series.
 */
var PyramidSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$69(PyramidSeries, _super);
    function PyramidSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Defines the path of a pyramid segment
     */
    PyramidSeries.prototype.getSegmentData = function (point, series, chart) {
        var area = series.triangleSize;
        //top of th series
        var seriesTop = chart.initialClipRect.y + (chart.initialClipRect.height - area.height) / 2;
        //consider, if the point is exploded
        var offset = 0;
        var extraSpace = (chart.initialClipRect.width - series.triangleSize.width) / 2;
        var emptySpaceAtLeft = extraSpace + chart.initialClipRect.x;
        //top and bottom
        var top = point.yRatio;
        var bottom = point.yRatio + point.heightRatio;
        //width of the top and bottom edge
        var topRadius = 0.5 * (1 - point.yRatio);
        var bottomRadius = 0.5 * (1 - bottom);
        top += seriesTop / area.height;
        bottom += seriesTop / area.height;
        var line1 = {
            x: emptySpaceAtLeft + offset + topRadius * area.width,
            y: top * area.height
        };
        var line2 = {
            x: emptySpaceAtLeft + offset + (1 - topRadius) * area.width,
            y: top * area.height
        };
        var line3 = {
            x: emptySpaceAtLeft + offset + (1 - bottomRadius) * area.width,
            y: bottom * area.height
        };
        var line4 = {
            x: emptySpaceAtLeft + offset + bottomRadius * area.width,
            y: bottom * area.height
        };
        var polygon = [line1, line2, line3, line4];
        this.setLabelLocation(series, point, polygon);
        var direction = this.findPath(polygon);
        return direction;
    };
    /**
     * Initializes the size of the pyramid segments
     *
     * @private
     */
    PyramidSeries.prototype.initializeSizeRatio = function (points, series) {
        if (series.pyramidMode === 'Linear') {
            _super.prototype.initializeSizeRatio.call(this, points, series, true);
        }
        else {
            this.calculateSurfaceSegments(series);
        }
    };
    /**
     * Defines the size of the pyramid segments, the surface of that will reflect the values
     */
    PyramidSeries.prototype.calculateSurfaceSegments = function (series) {
        var count = series.points.length;
        var sumOfValues = series.sumOfPoints;
        var y = [];
        var height = [];
        var gapRatio = Math.min(0, Math.max(series.gapRatio, 1));
        var gapHeight = gapRatio / (count - 1);
        var preSum = this.getSurfaceHeight(0, sumOfValues);
        var currY = 0;
        for (var i = 0; i < count; i++) {
            if (series.points[i].visible) {
                y[i] = currY;
                height[i] = this.getSurfaceHeight(currY, Math.abs(series.points[i].y));
                currY += height[i] + gapHeight * preSum;
            }
        }
        var coef = 1 / (currY - gapHeight * preSum);
        for (var i = 0; i < count; i++) {
            if (series.points[i].visible) {
                series.points[i].yRatio = coef * y[i];
                series.points[i].heightRatio = coef * height[i];
            }
        }
    };
    /**
     * Finds the height of pyramid segment
     */
    PyramidSeries.prototype.getSurfaceHeight = function (y, surface) {
        var result = this.solveQuadraticEquation(1, 2 * y, -surface);
        return result;
    };
    /**
     * Solves quadratic equation
     */
    PyramidSeries.prototype.solveQuadraticEquation = function (a, b, c) {
        var root1;
        var root2;
        var d = b * b - 4 * a * c;
        if (d >= 0) {
            var sd = Math.sqrt(d);
            root1 = (-b - sd) / (2 * a);
            root2 = (-b + sd) / (2 * a);
            return Math.max(root1, root2);
        }
        return 0;
    };
    /**
     * Renders a pyramid segment
     */
    PyramidSeries.prototype.renderPoint = function (point, series, chart, options, seriesGroup, redraw) {
        if (!point.visible) {
            removeElement(options.id);
            return null;
        }
        options.d = this.getSegmentData(point, series, chart);
        point.midAngle = 0;
        var element = chart.renderer.drawPath(options);
        element.setAttribute('role', 'img');
        element.setAttribute('tabindex', point.index === 0 ? '0' : '-1');
        element.setAttribute('aria-label', (point.x + ': ' + point.y + '%. ' + series.name));
        appendChildElement(false, seriesGroup, element, redraw);
        if (point.isExplode) {
            chart.accBaseModule.explodePoints(point.index, chart, true);
        }
    };
    /**
     * To get the module name of the Pyramid series.
     */
    PyramidSeries.prototype.getModuleName = function () {
        return 'PyramidSeries';
    };
    /**
     * To destroy the pyramid series
     *
     * @returns {void}
     * @private
     */
    PyramidSeries.prototype.destroy = function () {
        /**
         * Destroys the pyramid series
         */
    };
    return PyramidSeries;
}(TriangularBase));

var __extends$70 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable curly */
/* eslint-disable max-len */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * AccumulationChart legend
 */
/**
 * AccumulationLegend module used to render `Legend` for Accumulation chart.
 */
var AccumulationLegend = /** @__PURE__ @class */ (function (_super) {
    __extends$70(AccumulationLegend, _super);
    /**
     * Constructor for Accumulation Legend.
     *
     * @param {AccumulationChart} chart Get a chart as a parameter.
     */
    function AccumulationLegend(chart) {
        var _this = _super.call(this, chart) || this;
        _this.library = _this;
        _this.titleRect = new Rect(0, chart.margin.top, 0, 0);
        _this.addEventListener();
        return _this;
    }
    /**
     * Binding events for legend module.
     */
    AccumulationLegend.prototype.addEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
        this.chart.on(Browser.touchEndEvent, this.mouseEnd, this);
        this.chart.on('click', this.click, this);
    };
    /**
     * UnBinding events for legend module.
     */
    AccumulationLegend.prototype.removeEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.off(Browser.touchMoveEvent, this.mouseMove);
        this.chart.off('click', this.click);
        this.chart.off(Browser.touchEndEvent, this.mouseEnd);
    };
    /**
     * To handle mosue move for legend module
     */
    AccumulationLegend.prototype.mouseMove = function (e) {
        if (this.chart.legendSettings.visible && !this.chart.isTouch) {
            if (this.chart.accumulationHighlightModule && this.chart.highlightMode !== 'None') {
                this.click(e);
            }
        }
    };
    /**
     * To handle mosue end for legend module
     */
    AccumulationLegend.prototype.mouseEnd = function (e) {
        if (this.chart.legendSettings.visible && this.chart.isTouch) {
            this.move(e);
        }
    };
    /**
     * Get the legend options.
     *
     * @returns {void} Legend options.
     * @private
     */
    AccumulationLegend.prototype.getLegendOptions = function (chart, series) {
        this.legendCollections = [];
        this.isRtlEnable = chart.enableRtl;
        this.isReverse = !this.isRtlEnable && chart.legendSettings.reverse;
        for (var i = 0; i < 1; i++) {
            var seriesType = series[i].type;
            if (seriesType === 'Pie' || seriesType === 'Doughnut') {
                seriesType = (series[i].innerRadius !== '0' && series[i].innerRadius !== '0%') ?
                    'Doughnut' : 'Pie';
            }
            for (var _i = 0, _a = series[i].points; _i < _a.length; _i++) {
                var point = _a[_i];
                if (!isNullOrUndefined(point.x) && !isNullOrUndefined(point.y)) {
                    this.legendCollections.push(new LegendOptions(point.x.toString(), point.color, series[i].legendShape, point.visible, seriesType, point.legendImageUrl, null, null, point.index, series[i].index));
                }
            }
            if (this.isReverse) {
                this.legendCollections.reverse();
            }
        }
    };
    /**
     * To find legend bounds for accumulation chart.
     *
     * @private
     */
    AccumulationLegend.prototype.getLegendBounds = function (availableSize, legendBounds, legend) {
        this.calculateLegendTitle(legend, legendBounds);
        this.isTitle = legend.title ? true : false;
        var extraWidth = 0;
        var extraHeight = 0;
        var legendOption;
        this.chartRowCount = 1;
        this.rowHeights = [];
        this.columnHeights = [];
        this.pageHeights = [];
        var padding = legend.padding;
        var titlePosition = legend.titlePosition;
        var titlePlusArrowSpace = 0;
        var arrowWidth = this.arrowWidth;
        var arrowHeight = legend.enablePages ? 0 : this.arrowHeight;
        if (!this.isVertical) {
            extraHeight = !legend.height ? ((availableSize.height / 100) * 5) : 0;
        }
        else {
            extraWidth = !legend.width ? ((availableSize.width / 100) * 5) : 0;
        }
        legendBounds.width += extraWidth;
        legendBounds.height += extraHeight;
        var shapePadding = legend.shapePadding;
        var maximumWidth = legend.maximumLabelWidth ? legend.maximumLabelWidth : 0;
        var shapeWidth = legend.shapeWidth;
        var rowWidth = 0;
        var columnCount = 0;
        var rowCount = 0;
        var columnWidth = [];
        var pageWidth = [];
        var pageRowWidth = 0;
        var previousRowCount = 0;
        var columnHeight = 0;
        var legendWidth = 0;
        var titleHeight = 0;
        this.maxItemHeight = Math.max(measureText('MeasureText', legend.textStyle, this.chart.themeStyle.legendLabelFont).height, legend.shapeHeight);
        var legendEventArgs;
        var render = false;
        for (var i = 0; i < this.legendCollections.length; i++) {
            legendOption = this.legendCollections[i];
            legendEventArgs = { fill: legendOption.fill, text: legendOption.text, shape: legendOption.shape,
                name: 'legendRender', cancel: false };
            this.chart.trigger('legendRender', legendEventArgs);
            legendOption.render = !legendEventArgs.cancel;
            legendOption.text = ((legendEventArgs.text.indexOf('&') > -1) ?
                this.convertHtmlEntities(legendEventArgs.text) : legendEventArgs.text);
            legendOption.fill = legendEventArgs.fill;
            legendOption.shape = legendEventArgs.shape;
            legendOption.textSize = measureText(legendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont);
            if (legendOption.render && legendOption.text !== '') {
                render = true;
                legendWidth = shapeWidth + shapePadding + (legend.maximumLabelWidth ? legend.maximumLabelWidth :
                    legendOption.textSize.width) + (!this.isVertical ? (i === 0) ? padding : this.itemPadding : padding);
                this.getLegendHeight(legendOption, legend, legendBounds, rowWidth, this.maxItemHeight, padding);
                if (this.isVertical) {
                    columnHeight += legendOption.textSize.height + ((i === 0) ? padding : this.itemPadding);
                    if (columnHeight + this.itemPadding + (arrowHeight / this.pageButtonSize) > (legendBounds.height)) {
                        //columnHeight = Math.max(columnHeight, (rowCount * (this.maxItemHeight + padding)) + padding + arrowHeight);
                        rowWidth = rowWidth + maximumWidth;
                        pageRowWidth = this.getPageWidth(pageWidth);
                        this.totalPages = Math.max(rowCount, this.totalPages || 1);
                        if ((rowWidth - pageRowWidth + legendWidth) > legendBounds.width) {
                            pageWidth.push(rowWidth - pageRowWidth);
                            rowCount = this.rowHeights.length;
                            previousRowCount = rowCount;
                        }
                        else {
                            rowCount = previousRowCount;
                        }
                        columnWidth.push(maximumWidth);
                        maximumWidth = 0;
                        // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                        columnHeight = legendOption.textSize.height + padding;
                        legendOption.textSize.height + padding;
                        columnCount++;
                    }
                    this.columnHeights[columnCount] = (this.columnHeights[columnCount] ?
                        this.columnHeights[columnCount] : 0) + legendOption.textSize.height + ((i === 0) ? padding : this.itemPadding);
                    maximumWidth = Math.max(legendWidth, maximumWidth);
                    this.rowHeights[rowCount] = Math.max((this.rowHeights[rowCount] ? this.rowHeights[rowCount] : 0), legendOption.textSize.height);
                    rowCount++;
                }
                else {
                    if (!legend.enablePages) { // For new legend navigation support
                        titlePlusArrowSpace = this.isTitle && titlePosition !== 'Top' ? this.legendTitleSize.width + this.fivePixel : 0;
                        titlePlusArrowSpace += arrowWidth;
                    }
                    rowWidth = rowWidth + legendWidth;
                    if (legendBounds.width < (padding + rowWidth + titlePlusArrowSpace)) {
                        maximumWidth = Math.max(maximumWidth, (rowWidth + padding + titlePlusArrowSpace - legendWidth));
                        if (rowCount === 0 && (legendWidth !== rowWidth)) {
                            rowCount = 1;
                        }
                        rowWidth = legendWidth;
                        rowCount++;
                        columnCount = 0;
                        //  columnHeight = (rowCount * (this.maxItemHeight + padding)) + padding + this.legendTitleSize.height;
                    }
                    var len = rowCount ? (rowCount - 1) : rowCount;
                    this.rowHeights[len] = Math.max((this.rowHeights[len] ? this.rowHeights[len] : 0), legendOption.textSize.height);
                    this.columnHeights[columnCount] = (this.columnHeights[columnCount] ? this.columnHeights[columnCount] : 0) +
                        legendOption.textSize.height + padding;
                    columnCount++;
                }
            }
        }
        titleHeight = titlePosition === 'Top' ? this.legendTitleSize.height : 0;
        if (this.isVertical) {
            rowWidth = rowWidth + maximumWidth;
            this.isPaging = legendBounds.width < (rowWidth + padding);
            columnHeight = Math.max.apply(null, this.columnHeights) + padding + arrowHeight + titleHeight;
            columnHeight = Math.max(columnHeight, ((this.totalPages || 1) * (this.maxItemHeight + padding)) + padding + arrowHeight);
            this.isPaging = this.isPaging && (this.totalPages > 1);
            columnWidth.push(maximumWidth);
        }
        else {
            this.totalPages = this.totalRowCount = rowCount;
            columnHeight = Math.max.apply(null, this.columnHeights) + padding + arrowHeight + titleHeight;
            this.isPaging = legendBounds.height < columnHeight;
            columnHeight = !legend.enablePages && this.isPaging ? (this.maxItemHeight + padding) + padding + titleHeight : columnHeight;
            columnHeight = Math.max(columnHeight, (this.maxItemHeight + padding) + padding + titleHeight);
            if (!this.isPaging) { // For title left and right position
                rowWidth += this.isTitle && titlePosition !== 'Top' ? (this.fivePixel + this.legendTitleSize.width + this.fivePixel) : 0;
            }
        }
        this.maxColumns = 0; // initialization for max columns
        var width = this.isVertical ? this.getMaxColumn(columnWidth, legendBounds.width, padding, rowWidth + padding) :
            Math.max(rowWidth + padding, maximumWidth);
        if (render) { // if any legends not skipped in event check
            this.setBounds(width, columnHeight, legend, legendBounds);
        }
        else {
            this.setBounds(0, 0, legend, legendBounds);
        }
    };
    AccumulationLegend.prototype.getPageWidth = function (pageWidth) {
        var sum$$1 = 0;
        for (var i = 0; i < pageWidth.length; i++) {
            sum$$1 += pageWidth[i];
        }
        return sum$$1;
    };
    /** @private */
    AccumulationLegend.prototype.getLegendHeight = function (option, legend, bounds, rowWidth, legendHeight, padding) {
        var legendWidth = option.textSize.width;
        var textPadding = legend.shapePadding + (padding * 2) + legend.shapeWidth;
        switch (legend.textWrap) {
            case 'Wrap':
            case 'AnyWhere':
                if (legendWidth > legend.maximumLabelWidth || legendWidth + rowWidth > bounds.width) {
                    option.textCollection = textWrap(option.text, (legend.maximumLabelWidth ? Math.min(legend.maximumLabelWidth, (bounds.width - textPadding)) :
                        (bounds.width - textPadding)), legend.textStyle, this.chart.enableRtl, null, null, this.chart.themeStyle.legendLabelFont);
                }
                else {
                    option.textCollection.push(option.text);
                }
                option.textSize.height = (legendHeight * option.textCollection.length);
                break;
        }
    };
    /**
     * To find html entities value for legend.
     *
     * @returns {string} converts the entities to normal string.
     */
    AccumulationLegend.prototype.convertHtmlEntities = function (legendText) {
        var text = (legendText).replace('&amp;', '&').replace('&lt;', '<').replace('&gt;', '>').replace('&quot;', '"').replace('&nbsp;', ' ').replace('&cent;', '¢').replace('&pound;', '£').replace('&yen;', '¥').replace('&euro;', '€').replace('&copy;', '©').replace('&reg;', '®');
        text = (text).replace('&#38;', '&').replace('&#60;', '<').replace('&#62;', '>').replace('&#34;', '"').replace('&#160;', ' ').
            replace('&#162;', '¢').replace('&#163;', '£').replace('&#165;', '¥').replace('&#8364;', '€').replace('&#169;', '©').replace('&#174;', '®');
        return text;
    };
    /**
     * To find maximum column size for legend
     *
     * @returns {number} Get a maximum columns.
     */
    AccumulationLegend.prototype.getMaxColumn = function (columns, width, padding, rowWidth) {
        var maxPageColumn = padding;
        this.maxColumnWidth = Math.max.apply(null, columns);
        for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
            var column = columns_1[_i];
            maxPageColumn += this.maxColumnWidth;
            this.maxColumns++;
            if (maxPageColumn + padding > width) {
                maxPageColumn -= this.maxColumnWidth;
                this.maxColumns--;
                break;
            }
        }
        this.isPaging = (maxPageColumn < rowWidth) && (this.totalPages > 1);
        if (maxPageColumn === padding) {
            maxPageColumn = width;
        }
        this.maxColumns = Math.max(1, this.maxColumns);
        this.maxWidth = maxPageColumn;
        var columnWidth = this.maxColumnWidth + padding;
        var prevPage = 0;
        var columnCount = this.columnHeights.length;
        if (this.isPaging && this.isVertical) {
            for (var i = 1; i < columnCount; i++) {
                columnWidth += (this.maxColumnWidth + padding);
                if (columnWidth > width) {
                    this.pageHeights.push(((prevPage !== i - 1) ? Math.max.apply(null, this.columnHeights.slice(prevPage, i - 1)) :
                        this.columnHeights[prevPage]));
                    columnWidth = this.maxColumnWidth + padding;
                    prevPage = i;
                }
            }
            this.pageHeights.push(((prevPage !== columnCount - 1) ? Math.max.apply(null, this.columnHeights.slice(prevPage, columnCount - 1)) : this.columnHeights[prevPage]));
            this.totalPages = this.pageHeights.length;
        }
        return maxPageColumn;
    };
    /**
     * To find available width from legend x position.
     *
     * @returns {number} Get a available width.
     */
    AccumulationLegend.prototype.getAvailWidth = function (tx, width) {
        if (this.isVertical) {
            width = this.maxWidth;
        }
        else if (!this.isVertical && this.isPaging && !this.legend.enablePages) {
            return width - tx - this.fivePixel;
        }
        return width - ((this.legend.padding * 2) + this.legend.shapeWidth + this.legend.shapePadding);
    };
    /**
     * To find legend rendering locations from legend items.
     *
     * @private
     */
    AccumulationLegend.prototype.getRenderPoint = function (legendOption, start, textPadding, prevLegend, rect, count, firstLegend) {
        var padding = this.legend.padding;
        var previousLocation = prevLegend.location.y + this.maxItemHeight / 4 + (prevLegend.textCollection.length > 0 ?
            ((prevLegend.textCollection.length - 1) * this.maxItemHeight) : 0);
        if (this.isVertical) {
            if (count === firstLegend || (previousLocation + legendOption.textSize.height + padding > (rect.y + rect.height))) {
                legendOption.location.x = prevLegend.location.x + ((count === firstLegend) ? 0 : (!this.isRtlEnable) ?
                    this.maxColumnWidth : -this.maxColumnWidth);
                legendOption.location.y = start.y;
                var textStartLoc = (this.legend.shapeWidth / 2) + padding;
                this.pageXCollections.push(legendOption.location.x + ((!this.isRtlEnable) ? -textStartLoc : textStartLoc));
            }
            else {
                legendOption.location.x = prevLegend.location.x;
                legendOption.location.y = prevLegend.location.y + prevLegend.textSize.height + this.itemPadding;
            }
        }
        else {
            var textWidth = textPadding + (this.legend.maximumLabelWidth ?
                this.legend.maximumLabelWidth : prevLegend.textSize.width);
            var previousBound = prevLegend.location.x + ((!this.isRtlEnable) ? textWidth : -textWidth);
            if (this.isWithinBounds(previousBound, (this.legend.maximumLabelWidth ? this.legend.maximumLabelWidth :
                legendOption.textSize.width) + textPadding - this.itemPadding, rect, this.legend.shapeWidth / 2)) {
                if (count !== firstLegend)
                    this.chartRowCount++;
                legendOption.location.y = (count === firstLegend) ? prevLegend.location.y :
                    prevLegend.location.y + this.rowHeights[(this.chartRowCount - 2)] + padding;
                legendOption.location.x = start.x;
            }
            else {
                legendOption.location.y = prevLegend.location.y;
                legendOption.location.x = (count === firstLegend) ? prevLegend.location.x : previousBound;
            }
        }
        var availablewidth = this.getAvailWidth(legendOption.location.x, this.legendBounds.width);
        availablewidth = this.legend.maximumLabelWidth ? Math.min(this.legend.maximumLabelWidth, availablewidth) : availablewidth;
        if (this.legend.textOverflow === 'Ellipsis' && this.legend.textWrap === 'Normal') {
            legendOption.text = textTrim(+availablewidth.toFixed(4), legendOption.text, this.legend.textStyle, this.chart.enableRtl, this.chart.themeStyle.legendTitleFont);
        }
    };
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * check whether legend group within legend bounds or not.
     *
     */
    AccumulationLegend.prototype.isWithinBounds = function (previousBound, textWidth, legendBounds, shapeWidth) {
        if (!this.isRtlEnable) {
            return (previousBound + textWidth) > (legendBounds.x + legendBounds.width + shapeWidth);
        }
        else {
            return (previousBound - textWidth) < (legendBounds.x - shapeWidth);
        }
    };
    /**
     * finding the smart legend place according to positions.
     *
     * @returns {void}
     * @private
     */
    AccumulationLegend.prototype.getSmartLegendLocation = function (labelBound, legendBound, margin) {
        var space;
        switch (this.position) {
            case 'Left':
                space = ((labelBound.x - legendBound.width) - margin.left) / 2;
                legendBound.x = (labelBound.x - legendBound.width) < margin.left ? legendBound.x :
                    (labelBound.x - legendBound.width) - space;
                break;
            case 'Right':
                space = ((this.chart.availableSize.width - margin.right) - (labelBound.x + labelBound.width + legendBound.width)) / 2;
                legendBound.x = (labelBound.x + labelBound.width + legendBound.width) > (this.chart.availableSize.width - margin.right) ?
                    legendBound.x : (labelBound.x + labelBound.width + space);
                break;
            case 'Top':
                this.getTitleRect(this.chart);
                space = ((labelBound.y - legendBound.height) - (this.titleRect.y + this.titleRect.height)) / 2;
                legendBound.y = (labelBound.y - legendBound.height) < margin.top ? legendBound.y :
                    (labelBound.y - legendBound.height) - space;
                break;
            case 'Bottom':
                space = ((this.chart.availableSize.height - margin.bottom) - (labelBound.y + labelBound.height + legendBound.height)) / 2;
                legendBound.y = labelBound.y + labelBound.height + legendBound.height > (this.chart.availableSize.height - margin.bottom) ?
                    legendBound.y : (labelBound.y + labelBound.height) + space;
                break;
        }
    };
    /**
     * To get title rect.
     *
     * @returns {void} Get a title rect.
     */
    AccumulationLegend.prototype.getTitleRect = function (accumulation) {
        if (!accumulation.title) {
            return null;
        }
        var titleSize = measureText(accumulation.title, accumulation.titleStyle, this.chart.themeStyle.legendTitleFont);
        this.titleRect = new Rect(accumulation.availableSize.width / 2 - titleSize.width / 2, accumulation.margin.top, titleSize.width, titleSize.height);
    };
    /**
     * To get legend by index
     *
     * @returns {LegendOptions} Return legend index.
     */
    AccumulationLegend.prototype.legendByIndex = function (index, legendCollections) {
        for (var _i = 0, legendCollections_1 = legendCollections; _i < legendCollections_1.length; _i++) {
            var legend = legendCollections_1[_i];
            if (legend.pointIndex === index) {
                return legend;
            }
        }
        return null;
    };
    /**
     * To show or hide the legend on clicking the legend.
     *
     * @returns {void}
     */
    AccumulationLegend.prototype.click = function (event) {
        var targetId = event.target.id.indexOf('_chart_legend_g_') > -1 ?
            event.target.firstChild['id'] : event.target.id;
        var chart = this.chart;
        var legendItemsId = [this.legendID + '_text_', this.legendID + '_shape_', this.legendID + '_shape_marker_'];
        if (this.chart.accumulationSelectionModule) {
            var selectedDataIndexes = extend([], this.chart.accumulationSelectionModule.selectedDataIndexes, null, true);
        }
        this.chart.animateSeries = false;
        for (var _i = 0, legendItemsId_1 = legendItemsId; _i < legendItemsId_1.length; _i++) {
            var id = legendItemsId_1[_i];
            if (targetId.indexOf(id) > -1) {
                var pointIndex = parseInt(targetId.split(id)[1], 10);
                if (this.chart.legendSettings.toggleVisibility && !isNaN(pointIndex)) {
                    var currentSeries = this.chart.visibleSeries[0];
                    var point = pointByIndex(pointIndex, currentSeries.points);
                    var legendOption = this.legendByIndex(pointIndex, this.legendCollections);
                    var legendClickArgs = {
                        legendText: legendOption.text, legendShape: legendOption.shape,
                        chart: chart.isBlazor ? {} : chart, series: currentSeries, point: point,
                        name: legendClick, cancel: false
                    };
                    this.chart.trigger(legendClick, legendClickArgs);
                    if (!legendClickArgs.cancel) {
                        point.visible = !point.visible;
                        legendOption.visible = point.visible;
                        currentSeries.sumOfPoints += point.visible ? point.y : -point.y;
                        chart.redraw = chart.enableAnimation;
                        this.sliceVisibility(pointIndex, point.visible);
                        chart.removeSvg();
                        //To remove the blazor templates
                        blazorTemplatesReset(chart);
                        this.chart.refreshPoints(currentSeries.points);
                        this.chart.calculateBounds();
                        this.chart.renderElements();
                    }
                }
                else if (this.chart.accumulationSelectionModule && !isNaN(pointIndex)) {
                    this.chart.accumulationSelectionModule.legendSelection(this.chart, 0, pointIndex, event.target, event.type);
                }
                else if (this.chart.accumulationHighlightModule && !isNaN(pointIndex)) {
                    this.chart.accumulationHighlightModule.legendSelection(this.chart, 0, pointIndex, event.target, event.type);
                }
            }
        }
        if (targetId.indexOf(this.legendID + '_pageup') > -1) {
            this.changePage(event, true);
        }
        else if (targetId.indexOf(this.legendID + '_pagedown') > -1) {
            this.changePage(event, false);
        }
        chart.redraw = false;
    };
    /**
     * To translate the point elements by index and position
     */
    AccumulationLegend.prototype.sliceVisibility = function (index, isVisible) {
        var sliceId = this.chart.element.id + '_Series_0_Point_';
        if (this.chart.visibleSeries[0].dataLabel.visible) {
            sliceId = this.chart.element.id + '_datalabel_Series_0_';
            this.sliceAnimate(getElement$1(sliceId + 'g_' + index), isVisible);
        }
    };
    /**
     * Slice animation
     *
     * @param {Element} element slice element.
     * @param {boolean} isVisible boolean value of slice.
     * @returns {void} slice animation method.
     */
    AccumulationLegend.prototype.sliceAnimate = function (element, isVisible) {
        if (!element) {
            return null;
        }
        new Animation({}).animate(element, {
            duration: 300,
            delay: 0,
            name: isVisible ? 'FadeIn' : 'FadeOut',
            end: function (args) {
                args.element.style.visibility = isVisible ? 'visible' : 'hidden';
            }
        });
    };
    /**
     * Get module name
     *
     * @returns {string} Return module name.
     */
    AccumulationLegend.prototype.getModuleName = function () {
        return 'AccumulationLegend';
    };
    /**
     * To destroy the Legend.
     *
     * @returns {void}
     * @private
     */
    AccumulationLegend.prototype.destroy = function () {
        /**
         * Destroy method calling here
         */
        this.removeEventListener();
    };
    return AccumulationLegend;
}(BaseLegend));

var __extends$71 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable max-len */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * AccumulationChart DataLabel module file
 */
/**
 * AccumulationDataLabel module used to render `dataLabel`.
 */
var AccumulationDataLabel = /** @__PURE__ @class */ (function (_super) {
    __extends$71(AccumulationDataLabel, _super);
    function AccumulationDataLabel(accumulation) {
        var _this = _super.call(this, accumulation) || this;
        _this.rightSideRenderingPoints = [];
        _this.leftSideRenderingPoints = [];
        _this.id = accumulation.element.id + '_datalabel_Series_';
        return _this;
    }
    /**
     * Method to get datalabel text location.
     *
     * @private
     */
    AccumulationDataLabel.prototype.getDataLabelPosition = function (point, dataLabel, textSize, points) {
        var radius = this.isCircular() ? (!this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius :
            this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point)) :
            this.getLabelDistance(point, dataLabel);
        //let radius: number = this.isCircular() ? this.labelRadius : this.getLabelDistance(point, dataLabel);
        if (this.accumulation.title) {
            var titleSize = measureText(this.accumulation.title, this.accumulation.titleStyle, this.accumulation.themeStyle.datalabelFont);
            this.titleRect = new Rect(this.accumulation.availableSize.width / 2 - titleSize.width / 2, this.accumulation.margin.top, titleSize.width, titleSize.height);
        }
        this.getLabelRegion(point, dataLabel.position, textSize, radius, this.marginValue);
        point.labelAngle = point.midAngle;
        point.labelPosition = dataLabel.position;
        if (this.accumulation.enableSmartLabels) {
            this.getSmartLabel(point, dataLabel, textSize, points);
        }
    };
    /**
     * Method to get datalabel bound.
     */
    AccumulationDataLabel.prototype.getLabelRegion = function (point, position, textSize, labelRadius, margin, endAngle) {
        if (endAngle === void 0) { endAngle = 0; }
        var labelAngle = endAngle || point.midAngle;
        var space = 20;
        var location = degreeToLocation(labelAngle, labelRadius, this.isCircular() ? this.center :
            this.getLabelLocation(point, position));
        location.y = (position === 'Inside') ? (location.y - textSize.height / 2) : location.y;
        location.x = (position === 'Inside') ? (location.x - textSize.width / 2) : location.x;
        point.labelRegion = new Rect(location.x, location.y, textSize.width + (margin * 2), textSize.height + (margin * 2));
        if (position === 'Outside') {
            point.labelRegion.y -= point.labelRegion.height / 2;
            if (labelAngle >= 90 && labelAngle <= 270) {
                point.labelRegion.x -= (point.labelRegion.width + space);
            }
            else {
                point.labelRegion.x += space;
            }
        }
    };
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Method to get data label collection.
     */
    AccumulationDataLabel.prototype.calculateLabelCollection = function (point, dataLabel) {
        if (point.argsData.template !== null) {
            return null;
        }
        var position = point.labelPosition || dataLabel.position;
        var labelRadius = this.isCircular() ? (!this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius :
            this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point)) :
            this.getLabelDistance(point, dataLabel);
        var radius = (!this.isVariousRadius() ? (this.accumulation.pieSeriesModule.radius - this.accumulation.pieSeriesModule.innerRadius) :
            this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point));
        var location = degreeToLocation(point.midAngle, labelRadius, this.isCircular() ? this.center :
            this.getLabelLocation(point, position));
        var padding = 20;
        var maxWidth = dataLabel.maxWidth;
        if (!maxWidth) {
            if (position === 'Outside') {
                maxWidth = this.isCircular() ? (location.x >= this.center.x) ? (this.areaRect.x + this.areaRect.width - location.x) : (location.x - this.areaRect.x) :
                    (location.x >= point.region.x) ? (this.areaRect.x + this.areaRect.width - location.x) : (location.x - this.areaRect.x);
            }
            else {
                maxWidth = this.isCircular() ? (radius - padding) : point.region.width;
            }
        }
        if ((point.label.indexOf('<br>') !== -1)) {
            point.labelCollection = point.label.split('<br>');
        }
        else if (dataLabel.textWrap === 'Normal' && dataLabel.textOverflow === 'Ellipsis') {
            point.labelCollection[0] = textTrim(maxWidth, point.label, point.argsData.font, this.accumulation.enableRtl, this.accumulation.themeStyle.datalabelFont);
        }
        else if (dataLabel.textWrap === 'Wrap' || dataLabel.textWrap === 'AnyWhere') {
            point.labelCollection = textWrap(point.label, maxWidth, point.argsData.font, this.accumulation.enableRtl, dataLabel.textWrap === 'AnyWhere', dataLabel.textOverflow === 'Clip', this.accumulation.themeStyle.datalabelFont);
        }
        else {
            point.labelCollection[0] = point.label;
        }
    };
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * To calculate label collection text size.
     */
    AccumulationDataLabel.prototype.getTextSize = function (labelCollection, dataLabel) {
        var height = 0;
        var font = dataLabel.font;
        var width = dataLabel.maxWidth ? dataLabel.maxWidth : 0;
        var textSize;
        for (var i = 0; i < labelCollection.length; i++) {
            textSize = measureText(labelCollection[i], font, this.accumulation.themeStyle.datalabelFont);
            width = Math.max(textSize.width, width);
            height += textSize.height;
        }
        if (dataLabel.textOverflow === 'Clip' && dataLabel.textWrap !== 'Normal' && dataLabel.maxWidth) {
            width = dataLabel.maxWidth;
        }
        return (new Size(width, height));
    };
    /**
     * Method to get datalabel smart position.
     */
    AccumulationDataLabel.prototype.getSmartLabel = function (point, dataLabel, textSize, points) {
        var circular = this.isCircular();
        var labelRadius = circular ? this.radius : this.getLabelDistance(point, dataLabel);
        var connectorLength = circular ? (dataLabel.connectorStyle.length || '4%') :
            '0px';
        labelRadius += stringToNumber(connectorLength, labelRadius);
        var previousPoint = this.findPreviousPoint(points, point.index, point.labelPosition);
        if (dataLabel.position === 'Inside') {
            // `4` is padding adding to height and width of label region.
            point.labelRegion.height -= 4;
            point.labelRegion.width -= 4;
            if (previousPoint && previousPoint.labelRegion && !dataLabel.enableRotation && (isOverlap(point.labelRegion, previousPoint.labelRegion)
                || this.isOverlapping(point, points)) || !circular && !containsRect(point.region, point.labelRegion)) {
                point.labelPosition = 'Outside';
                if (!circular) {
                    labelRadius = this.getLabelDistance(point, dataLabel);
                }
                this.calculateLabelCollection(point, dataLabel);
                textSize = this.getTextSize(point.labelCollection, dataLabel);
                textSize.height += 4; // 4 for calculation with padding for smart label shape
                textSize.width += 4;
                this.getLabelRegion(point, point.labelPosition, textSize, labelRadius, this.marginValue);
                previousPoint = this.findPreviousPoint(points, point.index, point.labelPosition);
                if (previousPoint && (isOverlap(point.labelRegion, previousPoint.labelRegion) ||
                    this.isConnectorLineOverlapping(point, previousPoint))) {
                    this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius, textSize, this.marginValue);
                }
            }
        }
        else {
            if (previousPoint && previousPoint.labelRegion && (isOverlap(point.labelRegion, previousPoint.labelRegion)
                || this.isOverlapping(point, points) || this.isConnectorLineOverlapping(point, previousPoint))) {
                this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius, textSize, this.marginValue);
            }
        }
        if (this.isOverlapping(point, points) && (this.accumulation.type === 'Pyramid' || this.accumulation.type === 'Funnel')) {
            var position = 'OutsideLeft';
            var space = 20;
            var labelAngle = point.midAngle || 0;
            var labelRadius_1 = circular ? this.radius : this.getLabelDistance(point, dataLabel);
            var location_1 = degreeToLocation(labelAngle, -labelRadius_1, this.isCircular() ? this.center :
                this.getLabelLocation(point, position));
            point.labelRegion = new Rect(location_1.x, location_1.y, textSize.width + (this.marginValue * 2), textSize.height + (this.marginValue * 2));
            point.labelRegion.y -= point.labelRegion.height / 2;
            point.labelRegion.x = point.labelRegion.x - space - point.labelRegion.width;
            if (previousPoint && previousPoint.labelRegion && (isOverlap(point.labelRegion, previousPoint.labelRegion)
                || this.isOverlapping(point, points) || this.isConnectorLineOverlapping(point, previousPoint))) {
                this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius_1, textSize, this.marginValue);
            }
        }
    };
    /**
     * To find trimmed datalabel tooltip needed.
     *
     * @returns {void}
     * @private
     */
    AccumulationDataLabel.prototype.move = function (e, x, y, isTouch) {
        var _this = this;
        if (e.target.textContent.indexOf('...') > -1) {
            var targetId = e.target.id.split(this.id);
            if (targetId.length === 2) {
                var seriesIndex = parseInt(targetId[1].split('_text_')[0], 10);
                var pointIndex = parseInt(targetId[1].split('_text_')[1], 10);
                if (!isNaN(seriesIndex) && !isNaN(pointIndex)) {
                    if (isTouch) {
                        removeElement$1(this.accumulation.element.id + '_EJ2_Datalabel_Tooltip');
                    }
                    var point = getSeriesFromIndex(seriesIndex, (this.accumulation).visibleSeries).points[pointIndex];
                    showTooltip(point.text || point.y.toString(), x, y, this.areaRect.width, this.accumulation.element.id + '_EJ2_Datalabel_Tooltip', getElement$1(this.accumulation.element.id + '_Secondary_Element'));
                }
            }
        }
        else {
            removeElement$1(this.accumulation.element.id + '_EJ2_Datalabel_Tooltip');
        }
        if (isTouch) {
            clearTimeout(this.clearTooltip);
            this.clearTooltip = +setTimeout(function () { removeElement$1(_this.accumulation.element.id + '_EJ2_Datalabel_Tooltip'); }, 1000);
        }
    };
    /**
     * To find previous valid label point
     *
     * @returns {AccPoints} Find the previous value of accumulation point.
     */
    AccumulationDataLabel.prototype.findPreviousPoint = function (points, index, position) {
        var point = points[0];
        for (var i = index - 1; i >= 0; i--) {
            point = points[i];
            if (point.visible && point.labelVisible && point.labelRegion && point.labelPosition === position) {
                return point;
            }
        }
        return null;
    };
    /**
     * To find current point datalabel is overlapping with other points
     *
     * @returns {boolean} It returns boolean value of overlapping.
     */
    AccumulationDataLabel.prototype.isOverlapping = function (currentPoint, points) {
        for (var i = currentPoint.index - 1; i >= 0; i--) {
            if (points[i].visible && points[i].labelVisible &&
                points[i].labelRegion && currentPoint.labelRegion &&
                currentPoint.labelVisible && isOverlap(currentPoint.labelRegion, points[i].labelRegion)) {
                return true;
            }
        }
        return false;
    };
    /**
     * To get text trimmed while exceeds the accumulation chart area.
     */
    AccumulationDataLabel.prototype.textTrimming = function (point, rect, font, position, dataLabel) {
        if (isOverlap(point.labelRegion, rect)) {
            var size = point.labelRegion.width;
            if (position === 'Right') {
                size = rect.x - point.labelRegion.x;
            }
            else if (position === 'Left') {
                size = point.labelRegion.x - (rect.x + rect.width);
                if (size < 0) {
                    size += point.labelRegion.width;
                    point.labelRegion.x = rect.x + rect.width;
                }
            }
            else if (position === 'InsideRight') {
                size = (rect.x + rect.width) - point.labelRegion.x;
            }
            else if (position === 'InsideLeft') {
                size = (point.labelRegion.x + point.labelRegion.width) - rect.x;
                if (size < point.labelRegion.width) {
                    point.labelRegion.x = rect.x;
                }
            }
            else if (this.accumulation.enableSmartLabels) {
                this.setPointVisibileFalse(point);
            }
            if (point.labelVisible && point.labelRegion) {
                if ((point.label.indexOf('<br>') !== -1)) {
                    point.labelCollection = point.label.split('<br>');
                }
                else if (size < point.labelRegion.width) {
                    if (dataLabel.textWrap === 'Normal' && dataLabel.textOverflow === 'Ellipsis') {
                        point.labelCollection[0] = textTrim(size - (this.marginValue * 2), point.label, font, this.accumulation.enableRtl, this.accumulation.themeStyle.datalabelFont);
                    }
                    else if (dataLabel.textWrap === 'Wrap' || dataLabel.textWrap === 'AnyWhere') {
                        point.labelCollection = textWrap(point.label, size - (this.marginValue * 2), font, this.accumulation.enableRtl, dataLabel.textWrap === 'AnyWhere', dataLabel.textOverflow === 'Clip', this.accumulation.themeStyle.datalabelFont);
                    }
                    point.labelRegion.width = size;
                }
                for (var i = 0; i < point.labelCollection.length; i++) {
                    if (point.labelCollection[i].length === 3 && point.labelCollection[i].indexOf('...') > -1) {
                        this.setPointVisibileFalse(point);
                        break;
                    }
                }
            }
        }
    };
    /**
     * To set point label visible and region to disable.
     */
    AccumulationDataLabel.prototype.setPointVisibileFalse = function (point) {
        point.labelVisible = false;
        point.labelRegion = null;
    };
    /**
     * To set point label visible to enable.
     */
    AccumulationDataLabel.prototype.setPointVisibleTrue = function (point) {
        point.labelVisible = true;
    };
    /**
     * To set datalabel angle position for outside labels
     */
    AccumulationDataLabel.prototype.setOuterSmartLabel = function (previousPoint, point, border, labelRadius, textsize, margin) {
        if (!this.isCircular()) {
            this.setSmartLabelForSegments(point, previousPoint);
        }
        else {
            var labelAngle = this.getOverlappedAngle(previousPoint.labelRegion, point.labelRegion, point.midAngle, border * 2);
            this.getLabelRegion(point, 'Outside', textsize, labelRadius, margin, labelAngle);
            if (labelAngle > point.endAngle) {
                labelAngle = point.midAngle;
                //this.setPointVisibileFalse(point);
            }
            point.labelAngle = labelAngle;
            while (point.labelVisible && (isOverlap(previousPoint.labelRegion, point.labelRegion) || labelAngle <= previousPoint.labelAngle
                || labelAngle <= point.midAngle * 0.9 || this.isConnectorLineOverlapping(point, previousPoint))) {
                if (labelAngle > point.endAngle) {
                    //this.setPointVisibileFalse(point);
                    break;
                }
                point.labelAngle = labelAngle;
                this.getLabelRegion(point, 'Outside', textsize, labelRadius, margin, labelAngle);
                labelAngle += 0.1;
            }
        }
    };
    /**
     * Sets smart label positions for funnel and pyramid series
     *
     * @returns {void} setSmartLabelForSegments.
     */
    AccumulationDataLabel.prototype.setSmartLabelForSegments = function (point, prevPoint) {
        var textRegion = point.labelRegion;
        //let overlapWidth: number = prevPoint.labelRegion.x + prevPoint.labelRegion.width - textRegion.x;
        var overlapHeight = this.accumulation.type === 'Funnel' ?
            prevPoint.labelRegion.y - (textRegion.y + textRegion.height) :
            point.labelRegion.y - (prevPoint.labelRegion.y + prevPoint.labelRegion.height);
        if (overlapHeight < 0) {
            point.labelRegion.y += this.accumulation.type === 'Funnel' ? overlapHeight : -overlapHeight;
        }
    };
    /**
     * To find connector line overlapping.
     *
     * @returns {boolean} To find connector line overlapping or not.
     */
    AccumulationDataLabel.prototype.isConnectorLineOverlapping = function (point, previous) {
        var position;
        if (!this.isCircular() && point.labelRegion.x < point.region.x) {
            position = 'outsideLeft';
        }
        var start = this.getLabelLocation(point, position);
        var end = new ChartLocation(0, 0);
        this.getEdgeOfLabel(point.labelRegion, point.labelAngle, end, 0, point);
        var previousstart = this.getLabelLocation(previous);
        var previousend = new ChartLocation(0, 0);
        this.getEdgeOfLabel(previous.labelRegion, previous.labelAngle, previousend, 0, point);
        return this.isLineRectangleIntersect(start, end, point.labelRegion) ||
            this.isLineRectangleIntersect(start, end, previous.labelRegion) ||
            this.isLineRectangleIntersect(previousstart, previousend, point.labelRegion);
    };
    /**
     * To find two rectangle intersect
     *
     * @returns {boolean} To find line rectangle intersect value.
     */
    AccumulationDataLabel.prototype.isLineRectangleIntersect = function (line1, line2, rect) {
        var rectPoints = [
            new ChartLocation(Math.round(rect.x), Math.round(rect.y)),
            new ChartLocation(Math.round((rect.x + rect.width)), Math.round(rect.y)),
            new ChartLocation(Math.round((rect.x + rect.width)), Math.round((rect.y + rect.height))),
            new ChartLocation(Math.round(rect.x), Math.round((rect.y + rect.height)))
        ];
        line1.x = Math.round(line1.x);
        line1.y = Math.round(line1.y);
        line2.x = Math.round(line2.x);
        line2.y = Math.round(line2.y);
        for (var i = 0; i < rectPoints.length; i++) {
            if (this.isLinesIntersect(line1, line2, rectPoints[i], rectPoints[(i + 1) % rectPoints.length])) {
                return true;
            }
        }
        return false;
    };
    /**
     * To find two line intersect
     *
     * @returns {boolean} To find line intersect or not.
     */
    AccumulationDataLabel.prototype.isLinesIntersect = function (point1, point2, point11, point12) {
        var a1 = point2.y - point1.y;
        var b1 = point1.x - point2.x;
        var c1 = a1 * point1.x + b1 * point1.y;
        var a2 = point12.y - point11.y;
        var b2 = point11.x - point12.x;
        var c2 = a2 * point11.x + b2 * point11.y;
        var delta = a1 * b2 - a2 * b1;
        if (delta !== 0) {
            var x = (b2 * c1 - b1 * c2) / delta;
            var y = (a1 * c2 - a2 * c1) / delta;
            var lies = Math.min(point1.x, point2.x) <= x && x <= Math.max(point1.x, point2.x);
            lies = lies && Math.min(point1.y, point2.y) <= y && y <= Math.max(point1.y, point2.y);
            lies = lies && Math.min(point11.x, point12.x) <= x && x <= Math.max(point11.x, point12.x);
            lies = lies && Math.min(point11.y, point12.y) <= y && y <= Math.max(point11.y, point12.y);
            return lies;
        }
        return false;
    };
    /**
     * To get two rectangle overlapping angles.
     *
     * @returns {number} Get overlapped angle.
     */
    AccumulationDataLabel.prototype.getOverlappedAngle = function (first, second, angle, padding) {
        var x = first.x;
        if (angle >= 90 && angle <= 270) {
            second.y = first.y - (padding + second.height / 2);
            x = first.x + first.width;
        }
        else {
            second.y = first.y + first.height + padding;
        }
        return getAngle(this.center, new ChartLocation(x, second.y));
    };
    /**
     * To get connector line path
     *
     * @returns {string} Get connector line path.
     */
    AccumulationDataLabel.prototype.getConnectorPath = function (label, point, dataLabel, end) {
        if (end === void 0) { end = 0; }
        var connector = dataLabel.connectorStyle;
        var labelRadius = this.isCircular() ? (!this.isVariousRadius() ? this.labelRadius :
            this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point)) :
            this.getLabelDistance(point, dataLabel);
        //let labelRadius: number = this.isCircular() ? this.labelRadius : this.getLabelDistance(point, dataLabel);
        var start = this.getConnectorStartPoint(point, connector);
        var labelAngle = this.accumulation.enableSmartLabels ? point.midAngle : end || point.midAngle;
        var middle = new ChartLocation(0, 0);
        var endPoint = this.getEdgeOfLabel(label, labelAngle, middle, connector.width, point);
        if (connector.type === 'Curve') {
            if (this.isCircular()) {
                var r = labelRadius - (this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) :
                    this.radius);
                //let r: number = labelRadius - this.radius;
                if (point.isLabelUpdated) {
                    middle = this.getPerpendicularDistance(start, point);
                }
                else {
                    middle = degreeToLocation(labelAngle, labelRadius - (r / 2), this.center);
                    if (point.labelPosition === 'Outside' && dataLabel.position === 'Inside') {
                        middle = degreeToLocation(labelAngle, labelRadius - r * 1.25, this.center);
                    }
                }
                return 'M ' + start.x + ' ' + start.y + ' Q ' + middle.x + ' ' + middle.y + ' ' + endPoint.x + ' ' + endPoint.y;
            }
            else {
                return this.getPolyLinePath(start, endPoint);
            }
        }
        else {
            return 'M ' + start.x + ' ' + start.y + ' L ' + middle.x + ' ' + middle.y + ' L ' + endPoint.x + ' ' + endPoint.y;
        }
    };
    /**
     * Finds the curved path for funnel/pyramid data label connectors
     *
     * @returns {string} Get poly line path.
     */
    AccumulationDataLabel.prototype.getPolyLinePath = function (start, end) {
        var controlPoints = [start, end];
        if (start.y === end.y) {
            return 'M ' + start.x + ' ' + start.y + ' L ' + end.x + ' ' + end.y;
        }
        var path = 'M';
        for (var i = 0; i <= 16; i++) {
            var t = i / 16;
            var points = this.getBezierPoint(t, controlPoints, 0, 2);
            path += points.x + ',' + points.y;
            if (i !== 16) {
                path += ' L';
            }
        }
        return path;
    };
    /**
     * Finds the bezier point for funnel/pyramid data label connectors
     *
     * @returns {ChartLocation} Get bazier point.
     */
    AccumulationDataLabel.prototype.getBezierPoint = function (t, controlPoints, index, count) {
        if (count === 1) {
            return controlPoints[index];
        }
        var p0 = this.getBezierPoint(t, controlPoints, index, count - 1);
        var p1 = this.getBezierPoint(t, controlPoints, index + 1, count - 1);
        var x = (p0.x) ? p0.x : p0.x;
        var y = (p0.y) ? p0.y : p0.y;
        var x1 = (p1.x) ? p1.x : p1.x;
        var y1 = (p1.y) ? p1.y : p1.y;
        var x2 = (1 - t) * x + t * x1;
        var y2 = (1 - t) * y + t * y1;
        if (p0.x) {
            return { x: x2, y: y2 };
        }
        else {
            return { x: x2, y: y2 };
        }
    };
    /**
     * To get label edges based on the center and label rect position.
     *
     * @returns {ChartLocation} Get label edge value.
     */
    AccumulationDataLabel.prototype.getEdgeOfLabel = function (labelshape, angle, middle, border, point) {
        if (border === void 0) { border = 1; }
        var edge = new ChartLocation(labelshape.x, labelshape.y);
        var space = 10;
        if (angle >= 90 && angle <= 270) {
            edge.x += labelshape.width + border / 2 + space;
            edge.y += labelshape.height / 2;
            middle.x = edge.x + 10;
            middle.y = edge.y;
        }
        else if (point && point.region && point.region.x > point.labelRegion.x) {
            edge.x += border * 2 + labelshape.width + space;
            edge.y += labelshape.height / 2;
            middle.x = edge.x + 10;
            middle.y = edge.y;
        }
        else {
            edge.x -= space - border / 2;
            edge.y += labelshape.height / 2;
            middle.x = edge.x - 10;
            middle.y = edge.y;
        }
        return edge;
    };
    /**
     * Finds the distance between the label position and the edge/center of the funnel/pyramid
     *
     * @returns {number} Get label distance.
     */
    AccumulationDataLabel.prototype.getLabelDistance = function (point, dataLabel) {
        if (point.labelPosition && dataLabel.position !== point.labelPosition || (dataLabel.connectorStyle.length && dataLabel.position === 'Outside')) {
            var length_1 = stringToNumber(dataLabel.connectorStyle.length || '70px', this.accumulation.initialClipRect.width);
            if (length_1 < this.accumulation.initialClipRect.width) {
                return length_1;
            }
        }
        var position = point.labelPosition || dataLabel.position;
        var series = this.accumulation.visibleSeries[0];
        var extraSpace = (this.accumulation.initialClipRect.width - series.triangleSize.width) / 2;
        var labelLocation;
        switch (position) {
            case 'Inside':
                return 0;
            case 'Outside':
                labelLocation = point.symbolLocation.x + point.labelOffset.x;
                return this.accumulation.initialClipRect.width - labelLocation - extraSpace;
        }
    };
    /**
     * Finds the label position / beginning of the connector(ouside funnel labels)
     *
     * @returns {ChartLocation} Get label location.
     */
    AccumulationDataLabel.prototype.getLabelLocation = function (point, position) {
        if (position === void 0) { position = 'Outside'; }
        if (this.accumulation.type !== 'Pie') {
            position = position === 'OutsideLeft' ? 'OutsideLeft' : point.labelPosition || position;
            var location_2 = {
                x: point.symbolLocation.x,
                y: point.symbolLocation.y - point.labelOffset.y
            };
            switch (position) {
                case 'Inside':
                    location_2.y = point.region.y + point.region.height / 2;
                    break;
                case 'Outside':
                    location_2.x += point.labelOffset.x;
                    break;
                case 'OutsideLeft':
                    location_2.x -= point.labelOffset.x;
            }
            return location_2;
        }
        else {
            //return degreeToLocation(point.midAngle, this.radius, this.center);
            return degreeToLocation(point.midAngle, (this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) :
                this.radius), this.center);
        }
    };
    /**
     * Finds the beginning of connector line
     *
     * @returns {ChartLocation} Staring point of connector line.
     */
    AccumulationDataLabel.prototype.getConnectorStartPoint = function (point, connector) {
        // return this.isCircular() ? degreeToLocation(point.midAngle, this.radius - connector.width, this.center) :
        //     this.getLabelLocation(point);
        var position;
        if (!this.isCircular() && point.region.x > point.labelRegion.x) {
            position = 'OutsideLeft';
        }
        return this.isCircular() ? degreeToLocation(point.midAngle, (this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) :
            this.radius) - connector.width, this.center) : this.getLabelLocation(point, position);
    };
    /**
     * To find area rect based on margin, available size.
     *
     * @private
     */
    AccumulationDataLabel.prototype.findAreaRect = function () {
        this.areaRect = new Rect(0, 0, this.accumulation.availableSize.width, this.accumulation.availableSize.height);
        var margin = this.accumulation.margin;
        subtractThickness(this.areaRect, new Thickness(margin.left, margin.right, margin.top, margin.bottom));
    };
    /**
     * To render the data labels from series points.
     */
    AccumulationDataLabel.prototype.renderDataLabel = function (point, dataLabel, parent, points, series, templateElement, redraw) {
        var id = this.accumulation.element.id + '_datalabel_Series_' + series + '_';
        var datalabelGroup = this.accumulation.renderer.createGroup({ id: id + 'g_' + point.index });
        var border = { width: dataLabel.border.width, color: dataLabel.border.color };
        var argsFont = (extend({}, getValue('properties', dataLabel.font), null, true));
        point.label = this.getDatalabelText(dataLabel.format, this.accumulation, point.originalText || point.y.toString());
        var argsData = {
            cancel: false, name: textRender, series: this.accumulation.visibleSeries[0], point: point,
            text: point.label, border: border, color: dataLabel.fill, template: dataLabel.template, font: argsFont
        };
        this.accumulation.trigger(textRender, argsData);
        point.argsData = argsData;
        var isTemplate = argsData.template !== null;
        point.labelVisible = !argsData.cancel;
        point.text = point.label = argsData.text;
        point.labelCollection = [];
        this.marginValue = argsData.border.width ? (5 + argsData.border.width) : 1;
        var childElement = createElement('div', {
            id: this.accumulation.element.id + '_Series_' + 0 + '_DataLabel_' + point.index,
            styles: 'position: absolute;background-color:' + argsData.color + ';' +
                getFontStyle(dataLabel.font) + ';border:' + argsData.border.width + 'px solid ' + argsData.border.color + ';'
        });
        this.calculateLabelSize(isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw);
    };
    AccumulationDataLabel.prototype.getDatalabelText = function (labelFormat, chart, labelText) {
        if (Number(labelText)) {
            var customLabelFormat = labelFormat.match('{value}') !== null;
            var format = chart.intl.getNumberFormat({
                format: customLabelFormat ? '' : labelFormat,
                useGrouping: chart.useGroupingSeparator
            });
            labelText = customLabelFormat ? labelFormat.replace('{value}', format(parseFloat(labelText))) : format(parseFloat(labelText));
        }
        return labelText;
    };
    /**
     * To calculate label size
     */
    AccumulationDataLabel.prototype.calculateLabelSize = function (isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw, clientRect, isReactCallback) {
        this.calculateLabelCollection(point, dataLabel);
        var textSize = isTemplate ? (isReactCallback ? { width: clientRect.width, height: clientRect.height } :
            this.getTemplateSize(childElement, point, argsData, redraw, isTemplate, points, datalabelGroup, id, dataLabel)) : this.getTextSize(point.labelCollection, dataLabel);
        textSize.height += 4; // 4 for calculation with padding for smart label shape
        textSize.width += 4;
        point.textSize = textSize;
        point.templateElement = childElement;
        this.getDataLabelPosition(point, dataLabel, textSize, points);
        if (point.labelRegion) {
            this.correctLabelRegion(point.labelRegion, point.textSize);
        }
    };
    /**
     * @private
     */
    AccumulationDataLabel.prototype.drawDataLabels = function (series, dataLabel, parent, templateElement, redraw) {
        var angle;
        var degree;
        var modifiedPoints = series.leftSidePoints.concat(series.rightSidePoints);
        modifiedPoints.sort(function (a, b) { return a.index - b.index; });
        if (series.type === 'Pie' && this.accumulation.enableSmartLabels) {
            this.extendedLabelsCalculation();
        }
        for (var _i = 0, modifiedPoints_1 = modifiedPoints; _i < modifiedPoints_1.length; _i++) {
            var point = modifiedPoints_1[_i];
            if (!isNullOrUndefined(point.argsData) && !isNullOrUndefined(point.y)) {
                this.finalizeDatalabels(point, modifiedPoints, dataLabel);
                var id = this.accumulation.element.id + '_datalabel_Series_' + 0 + '_';
                var datalabelGroup = this.accumulation.renderer.createGroup({ id: id + 'g_' + point.index });
                datalabelGroup.setAttribute('aria-hidden', 'true');
                var dataLabelElement = void 0;
                var location_3 = void 0;
                var element = void 0;
                if (point.visible && point.labelVisible) {
                    angle = degree = dataLabel.angle;
                    if (point.argsData.template) {
                        this.setTemplateStyle(point.templateElement, point, templateElement, dataLabel.font.color, point.color, redraw);
                    }
                    else {
                        location_3 = new ChartLocation(point.labelRegion.x + this.marginValue, point.labelRegion.y
                            + (point.textSize.height * 3 / (point.labelCollection.length * 4)) + this.marginValue);
                        element = getElement$1(id + 'shape_' + point.index);
                        var startLocation = element ? new ChartLocation(+element.getAttribute('x'), +element.getAttribute('y')) : null;
                        var textWidth = point.textSize.width;
                        if (dataLabel.enableRotation) {
                            if (angle === 0) {
                                if (point.labelPosition === 'Outside') {
                                    degree = 0;
                                }
                                else if (point.midAngle >= 90 && point.midAngle <= 260) {
                                    degree = point.midAngle + 180;
                                }
                                else {
                                    degree = point.midAngle;
                                }
                            }
                            else {
                                degree = (angle > 360) ? angle - 360 : (angle < -360) ? angle + 360 : angle;
                            }
                        }
                        else {
                            degree = 0;
                        }
                        var rotate = 'rotate(' + degree + ',' + (location_3.x + (textWidth / 2)) + ',' + (location_3.y) + ')';
                        point.transform = rotate;
                        dataLabelElement = this.accumulation.renderer.drawRectangle(new RectOption(id + 'shape_' + point.index, point.argsData.color, point.argsData.border, 1, point.labelRegion, dataLabel.rx, dataLabel.ry, rotate));
                        appendChildElement(false, datalabelGroup, dataLabelElement, redraw, true, 'x', 'y', startLocation, null, false, false, null, this.accumulation.duration);
                        textElement$1(this.accumulation.renderer, new TextOption(id + 'text_' + point.index, location_3.x, location_3.y, this.accumulation.enableRtl ? 'end' : 'start', point.labelCollection, rotate, 'auto', degree), point.argsData.font, point.argsData.font.color || this.getSaturatedColor(point, point.argsData.color), datalabelGroup, false, redraw, true, false, this.accumulation.duration, null, null, null, null, true, this.accumulation.themeStyle.datalabelFont);
                        element = null;
                    }
                    if (this.accumulation.accumulationLegendModule && this.accumulation.legendSettings.visible && (dataLabel.position === 'Outside'
                        || this.accumulation.enableSmartLabels)) {
                        this.accumulation.visibleSeries[0].findMaxBounds(this.accumulation.visibleSeries[0].labelBound, point.labelRegion);
                    }
                    if (point.labelPosition === 'Outside') {
                        var element_1 = getElement$1(id + 'connector_' + point.index);
                        var previousDirection = element_1 ? element_1.getAttribute('d') : '';
                        var pathElement = this.accumulation.renderer.drawPath(new PathOption(id + 'connector_' + point.index, 'transparent', dataLabel.connectorStyle.width, dataLabel.connectorStyle.color || point.color, 1, dataLabel.connectorStyle.dashArray, this.getConnectorPath(extend({}, point.labelRegion, null, true), point, dataLabel, point.labelAngle)));
                        appendChildElement(false, datalabelGroup, pathElement, redraw, true, null, null, null, previousDirection, false, false, null, this.accumulation.duration);
                    }
                    appendChildElement(false, parent, datalabelGroup, redraw);
                }
            }
        }
        if (this.accumulation.type === 'Pie' && dataLabel.textWrap === 'Normal' && dataLabel.textOverflow === 'Clip') {
            this.dataLabelClipPath(dataLabel, parent);
        }
    };
    /**
     * To calculate data label clip path
     */
    AccumulationDataLabel.prototype.dataLabelClipPath = function (dataLabel, parent) {
        var id = this.accumulation.element.id + '_datalabel_Series_' + 0 + '_';
        var clippath = this.accumulation.renderer.createClipPath({ id: id + 'clipPath' });
        var clipRect;
        var radius = this.accumulation.pieSeriesModule.pieBaseRadius;
        if (dataLabel.position === 'Inside') {
            clipRect = this.accumulation.renderer.drawCircle(new CircleOption(id + 'clipPath_rect', 'transparent', { width: 0 }, 0, this.center.x, this.center.y, radius));
        }
        else if (dataLabel.maxWidth) {
            var x = this.center.x - radius - stringToNumber((dataLabel.connectorStyle.length || '4%'), radius) - dataLabel.maxWidth;
            var y = this.center.y - radius - stringToNumber((dataLabel.connectorStyle.length || '4%'), radius) - dataLabel.maxWidth;
            var height = (radius + stringToNumber((dataLabel.connectorStyle.length || '4%'), radius) + dataLabel.maxWidth) * 2;
            var width = height;
            if (this.accumulation.legendSettings.visible) {
                var legendModule = this.accumulation.accumulationLegendModule;
                if (legendModule.position === 'Left') {
                    width = (legendModule.legendBounds.x + legendModule.legendBounds.width - x) > 0 ? (width - (legendModule.legendBounds.width - x)) : width;
                    x = (legendModule.legendBounds.x + legendModule.legendBounds.width) < x ? x : (legendModule.legendBounds.x + legendModule.legendBounds.width);
                }
                else if (legendModule.position === 'Right') {
                    width = (x + width - legendModule.legendBounds.x) > 0 ? (width - (x + width - legendModule.legendBounds.x)) : width;
                }
            }
            clipRect = this.accumulation.renderer.drawRectangle(new RectOption(id + 'clipPath_rect', 'transparent', { width: 0 }, 0, new Rect(x, y, height, width), 0, 0));
        }
        if (dataLabel.position === 'Inside' || dataLabel.maxWidth) {
            clippath.appendChild(clipRect);
            appendChildElement(false, this.accumulation.svgObject, clippath);
            parent.style.cssText = 'clip-path:url(#' + clippath.id + ')';
        }
    };
    /**
     * In this method datalabels region checked with legebdBounds and areaBounds.
     * Trimming of datalabel and point's visibility again changed here.
     *
     * @param {AccPoints} point current point in which trimming and visibility to be checked
     * @param {AccPoints[]} points finalized points
     * @param {AccumulationDataLabelSettingsModel} dataLabel datalabel model
     */
    AccumulationDataLabel.prototype.finalizeDatalabels = function (point, points, dataLabel) {
        if (this.isOverlapping(point, points) ||
            (this.titleRect && point.labelRegion && isOverlap(point.labelRegion, this.titleRect))) {
            if (this.isCircular() && point.labelPosition === 'Outside' && this.accumulation.enableSmartLabels) {
                this.setPointVisibileFalse(point);
            }
        }
        if (this.accumulation.accumulationLegendModule && this.accumulation.legendSettings.visible &&
            point.labelVisible && point.labelRegion && (!dataLabel.maxWidth ? dataLabel.textOverflow === 'Clip' ? dataLabel.textWrap !== 'Normal' : true : false)) {
            var rect = this.accumulation.accumulationLegendModule.legendBounds;
            if (this.accumulation.visibleSeries[0].type !== 'Pie' && this.accumulation.legendSettings.position === 'Left'
                && dataLabel.position === 'Outside') {
                point.labelRegion.x = point.labelRegion.x + rect.width;
            }
            var padding = this.accumulation.legendSettings.border.width / 2;
            this.textTrimming(point, new Rect(rect.x - padding, rect.y - padding, rect.width + (2 * padding), rect.height + (2 * padding)), dataLabel.font, this.accumulation.accumulationLegendModule.position, dataLabel);
        }
        if (point.labelVisible && point.labelRegion && (!dataLabel.maxWidth ? dataLabel.textOverflow === 'Clip' ? dataLabel.textWrap !== 'Normal' : true : false)) {
            var position = this.isCircular() ? (point.labelRegion.x >= this.center.x) ? 'InsideRight' : 'InsideLeft' :
                (point.labelRegion.x >= point.region.x) ? 'InsideRight' : 'InsideLeft';
            this.textTrimming(point, this.areaRect, dataLabel.font, position, dataLabel);
        }
        if (point.labelVisible && point.labelRegion && !dataLabel.maxWidth && dataLabel.textOverflow !== 'Clip' && this.accumulation.enableSmartLabels && ((point.labelRegion.y + point.labelRegion.height / 2 >
            this.areaRect.y + this.areaRect.height || point.labelRegion.y < this.areaRect.y) || (point.labelRegion.x < this.areaRect.x ||
            point.labelRegion.x + point.labelRegion.width > this.areaRect.x + this.areaRect.width))) {
            this.setPointVisibileFalse(point);
        }
    };
    /**
     * To find the template element size
     *
     * @param {HTMLElement} element To get a template element.
     * @param {AccPoints} point Template of accumulation points.
     * @param {IAccTextRenderEventArgs} argsData Arguments of accumulation points.
     * @param {boolean} redraw redraw value.
     * @returns {Size} Size of a template.
     */
    AccumulationDataLabel.prototype.getTemplateSize = function (element, point, argsData, redraw, isTemplate, points, datalabelGroup, id, dataLabel) {
        element = createTemplate(element, point.index, argsData.template, this.accumulation, point, this.accumulation.visibleSeries[0], this.accumulation.element.id + '_DataLabel', 0, argsData, isTemplate, points, datalabelGroup, id, dataLabel, redraw);
        var clientRect = measureElementRect(element, redraw);
        return { width: clientRect.width, height: clientRect.height };
    };
    /**
     * To set the template element style
     *
     * @param {HTMLElement} childElement Set a child element of template.
     * @param {AccPoints} point Template point.
     * @param {parent} parent Parent element of template.
     * @param {labelColor} labelColor Template label color.
     * @param {string} fill Fill color of template.
     */
    AccumulationDataLabel.prototype.setTemplateStyle = function (childElement, point, parent, labelColor, fill, redraw) {
        childElement.style.left = (point.labelRegion.x) + 'px';
        childElement.style.top = (point.labelRegion.y) + 'px';
        childElement.style.color = labelColor || this.getSaturatedColor(point, point.labelPosition === 'Inside' ? fill : this.getLabelBackground(point));
        if (this.accumulation.isBlazor) {
            var position = this.isCircular() ? (point.labelRegion.x >= this.center.x) ? 'InsideRight' : 'InsideLeft' :
                (point.labelRegion.x >= point.region.x) ? 'InsideRight' : 'InsideLeft';
            if (position === 'InsideRight') {
                childElement.style.transform = 'translate(0%, -50%)';
            }
            else {
                childElement.style.transform = 'translate(-100%, -50%)';
            }
        }
        if (childElement.childElementCount) {
            appendChildElement(false, parent, childElement, redraw, true, 'left', 'top');
            this.doTemplateAnimation(this.accumulation, childElement);
        }
    };
    /**
     * To find saturated color for datalabel
     *
     * @returns {string} Get a saturated color.
     */
    AccumulationDataLabel.prototype.getSaturatedColor = function (point, color) {
        var saturatedColor;
        if (this.marginValue >= 1) {
            saturatedColor = color === 'transparent' ? this.getLabelBackground(point) : color;
        }
        else {
            saturatedColor = this.getLabelBackground(point);
        }
        saturatedColor = (saturatedColor === 'transparent') ? ((this.accumulation.theme.indexOf('Dark') > -1 || this.accumulation.theme === 'HighContrast') ? 'black' : 'white') : saturatedColor;
        var rgbValue = convertHexToColor(colorNameToHex(saturatedColor));
        var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);
        return contrast >= 128 ? 'black' : 'white';
    };
    /**
     * Animates the data label template.
     *
     * @returns {void}
     * @private
     */
    AccumulationDataLabel.prototype.doTemplateAnimation = function (accumulation, element) {
        var series = accumulation.visibleSeries[0];
        var delay = series.animation.delay + series.animation.duration;
        if (((series.animation.enable && animationMode != 'Disable') || animationMode === 'Enable') && accumulation.animateSeries) {
            element.style.visibility = 'hidden';
            templateAnimate(element, delay, 200, 'ZoomIn');
        }
    };
    /**
     * To find background color for the datalabel
     *
     * @returns {string} AccPoints
     */
    AccumulationDataLabel.prototype.getLabelBackground = function (point) {
        return point.labelPosition === 'Outside' ?
            this.accumulation.background || this.accumulation.themeStyle.background : !point.y ? this.accumulation.theme.indexOf('dark') ? 'white' : 'black' : point.color;
    };
    /**
     * To correct the padding between datalabel regions.
     */
    AccumulationDataLabel.prototype.correctLabelRegion = function (labelRegion, textSize, padding) {
        if (padding === void 0) { padding = 4; }
        labelRegion.height -= padding;
        labelRegion.width -= padding;
        labelRegion.x += padding / 2;
        labelRegion.y += padding / 2;
        textSize.height -= padding;
        textSize.width -= padding;
    };
    /**
     * To get the dataLabel module name
     *
     * @returns {string} module name
     */
    AccumulationDataLabel.prototype.getModuleName = function () {
        return 'AccumulationDataLabel';
    };
    /**
     * To destroy the data label.
     *
     * @returns {void}
     * @private
     */
    AccumulationDataLabel.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    //calculation for placing labels smartly
    AccumulationDataLabel.prototype.extendedLabelsCalculation = function () {
        var _this = this;
        var series = this.accumulation.series[0];
        series.rightSidePoints.forEach(function (point, index, halfSidePoints) {
            point.initialLabelRegion = point.labelRegion;
            point.isLabelUpdated = 0;
            _this.skipPoints(point, halfSidePoints, index);
        });
        series.leftSidePoints.forEach(function (point, index, halfSidePoints) {
            point.initialLabelRegion = point.labelRegion;
            point.isLabelUpdated = 0;
            _this.skipPoints(point, halfSidePoints, index);
        });
        this.arrangeLeftSidePoints(series);
        this.isIncreaseAngle = false;
        this.arrangeRightSidePoints(series);
    };
    /**
     * Rightside points alignments calculation
     *
     * @param {AccumulationSeries} series To get a proper series.
     */
    AccumulationDataLabel.prototype.arrangeRightSidePoints = function (series) {
        var startFresh;
        var angleChanged;
        var rightSideRenderPoints = series.rightSidePoints.filter(function (point) { return (point.labelVisible && point.labelPosition === 'Outside'); });
        this.rightSideRenderingPoints = rightSideRenderPoints;
        var checkAngle;
        var currentPoint;
        var lastPoint = rightSideRenderPoints[rightSideRenderPoints.length - 1];
        var nextPoint;
        if (lastPoint) {
            if (lastPoint.labelAngle > 90 && lastPoint.labelAngle < 270) {
                this.isIncreaseAngle = true;
                this.changeLabelAngle(lastPoint, 89);
            }
        }
        /**
         * Right side points arranged from last point.
         * A point checked with successive points for overlapping.
         * If that is overlapped, its label angle is decreased and placing in optimal position
         * If one point's angle is decreased, its previous points in the half side points also decreased until it reaced optimum position.
         * When decreasing angle falls beyond 270, label angle increased.
         * If one point's angle is increased, its successive points in that half point also increased until it reaced optimum position.
         */
        for (var i = rightSideRenderPoints.length - 1; i >= 0; i--) {
            currentPoint = rightSideRenderPoints[i];
            nextPoint = rightSideRenderPoints[i + 1];
            // A point checked for overlapping, label visibility
            if (this.isOverlapWithNext(currentPoint, rightSideRenderPoints, i) && currentPoint.labelVisible
                || !(currentPoint.labelAngle <= 90 || currentPoint.labelAngle >= 270)) {
                checkAngle = lastPoint.labelAngle + 10;
                angleChanged = true;
                //If last's point change angle in beyond the limit, stop the increasing angle and do decrease the angle.
                if (startFresh) {
                    this.isIncreaseAngle = false;
                }
                else if (checkAngle > 90 && checkAngle < 270 && nextPoint.isLabelUpdated) {
                    this.isIncreaseAngle = true;
                }
                if (!this.isIncreaseAngle) {
                    for (var k = i + 1; k < rightSideRenderPoints.length; k++) {
                        this.increaseAngle(rightSideRenderPoints[k - 1], rightSideRenderPoints[k], series, true);
                    }
                }
                else {
                    for (var k = i + 1; k > 0; k--) {
                        this.decreaseAngle(rightSideRenderPoints[k], rightSideRenderPoints[k - 1], series, true);
                    }
                }
            }
            else {
                //If a point did not overlapped with previous points, increase the angle always for right side points.
                if (angleChanged && nextPoint && !nextPoint.isLabelUpdated) {
                    startFresh = true;
                }
            }
        }
    };
    /**
     * Leftside points alignments calculation
     *
     * @param {AccumulationSeries} series To get a proper series.
     */
    AccumulationDataLabel.prototype.arrangeLeftSidePoints = function (series) {
        var _this = this;
        var leftSideRenderPoints = series.leftSidePoints.filter(function (point) { return (point.labelVisible && point.labelPosition === 'Outside'); });
        this.leftSideRenderingPoints = leftSideRenderPoints;
        var previousPoint;
        var currentPoint;
        var angleChanged;
        var startFresh;
        /**
         * Left side points arranged from first point.
         * A point checked with previous points for overlapping.
         * If that is overlapped, its label angle is decreased and placing in optimal position
         * If one point's angle is decreased, its previous points in the half side points also decreased until it reaced optimum position.
         * When decreasing angle falls beyond 90, label angle increased.
         * If one point's angle is increased, its successive points in that half point also increased until it reaced optimum position.
         */
        for (var i = 0; i < leftSideRenderPoints.length; i++) {
            currentPoint = leftSideRenderPoints[i];
            previousPoint = leftSideRenderPoints[i - 1];
            // A point checked
            if (this.isOverlapWithPrevious(currentPoint, leftSideRenderPoints, i) && currentPoint.labelVisible
                || !(currentPoint.labelAngle < 270)) {
                angleChanged = true;
                if (startFresh) {
                    this.isIncreaseAngle = false;
                }
                if (!this.isIncreaseAngle) {
                    for (var k = i; k > 0; k--) {
                        this.decreaseAngle(leftSideRenderPoints[k], leftSideRenderPoints[k - 1], series, false);
                        leftSideRenderPoints.filter(function (point, index) {
                            if (point.isLabelUpdated && leftSideRenderPoints[index].labelAngle - 10 < 100) {
                                _this.isIncreaseAngle = true;
                            }
                        });
                    }
                }
                else {
                    for (var k = i; k < leftSideRenderPoints.length; k++) {
                        this.increaseAngle(leftSideRenderPoints[k - 1], leftSideRenderPoints[k], series, false);
                    }
                }
            }
            else {
                if (angleChanged && previousPoint && previousPoint.isLabelUpdated) {
                    startFresh = true;
                }
            }
        }
    };
    AccumulationDataLabel.prototype.decreaseAngle = function (currentPoint, previousPoint, series, isRightSide) {
        if (isNullOrUndefined(currentPoint) || isNullOrUndefined(previousPoint)) {
            return null;
        }
        var count = 1;
        if (isRightSide) {
            while (isOverlap(currentPoint.labelRegion, previousPoint.labelRegion) || (!this.isVariousRadius() &&
                !((previousPoint.labelRegion.height + previousPoint.labelRegion.y) < currentPoint.labelRegion.y))) {
                var newAngle = previousPoint.midAngle - count;
                if (newAngle < 0) {
                    newAngle = 360 + newAngle;
                }
                if (newAngle <= 270 && newAngle >= 90) {
                    newAngle = 270;
                    this.isIncreaseAngle = true;
                    break;
                }
                this.changeLabelAngle(previousPoint, newAngle);
                count++;
            }
        }
        else {
            if (currentPoint.labelAngle > 270) {
                this.changeLabelAngle(currentPoint, 270);
                previousPoint.labelAngle = 270;
            }
            while (isOverlap(currentPoint.labelRegion, previousPoint.labelRegion) || (!this.isVariousRadius() &&
                ((currentPoint.labelRegion.y + currentPoint.labelRegion.height) > previousPoint.labelRegion.y))) {
                var newAngle = previousPoint.midAngle - count;
                if (!(newAngle <= 270 && newAngle >= 90)) {
                    newAngle = 90;
                    this.isIncreaseAngle = true;
                    break;
                }
                this.changeLabelAngle(previousPoint, newAngle);
                if (isOverlap(currentPoint.labelRegion, previousPoint.labelRegion) &&
                    !series.leftSidePoints.indexOf(previousPoint) && (newAngle - 1 < 90 && newAngle - 1 > 270)) {
                    this.changeLabelAngle(currentPoint, currentPoint.labelAngle + 1);
                    this.arrangeLeftSidePoints(series);
                    break;
                }
                count++;
            }
        }
    };
    AccumulationDataLabel.prototype.increaseAngle = function (currentPoint, nextPoint, series, isRightSide) {
        if (isNullOrUndefined(currentPoint) || isNullOrUndefined(nextPoint)) {
            return null;
        }
        var count = 1;
        if (isRightSide) {
            while (isOverlap(currentPoint.labelRegion, nextPoint.labelRegion) || (!this.isVariousRadius() &&
                !((currentPoint.labelRegion.y + currentPoint.labelRegion.height) < nextPoint.labelRegion.y))) {
                var newAngle = nextPoint.midAngle + count;
                if (newAngle < 270 && newAngle > 90) {
                    newAngle = 90;
                    this.isIncreaseAngle = true;
                    break;
                }
                this.changeLabelAngle(nextPoint, newAngle);
                if (isOverlap(currentPoint.labelRegion, nextPoint.labelRegion) && (newAngle + 1 > 90 && newAngle + 1 < 270) &&
                    this.rightSideRenderingPoints.indexOf(nextPoint) === this.rightSideRenderingPoints.length - 1) {
                    this.changeLabelAngle(currentPoint, currentPoint.labelAngle - 1);
                    nextPoint.labelRegion = nextPoint.initialLabelRegion;
                    this.arrangeRightSidePoints(series);
                    break;
                }
                if (count > 360) {
                    break;
                }
                count++;
            }
        }
        else {
            while (isOverlap(currentPoint.labelRegion, nextPoint.labelRegion) || (!this.isVariousRadius() &&
                (currentPoint.labelRegion.y < (nextPoint.labelRegion.y + nextPoint.labelRegion.height)))) {
                var newAngle = nextPoint.midAngle + count;
                if (!(newAngle < 270 && newAngle > 90)) {
                    newAngle = 270;
                    this.isIncreaseAngle = false;
                    break;
                }
                this.changeLabelAngle(nextPoint, newAngle);
                if (count > 360) {
                    break;
                }
                count++;
            }
        }
    };
    AccumulationDataLabel.prototype.changeLabelAngle = function (currentPoint, newAngle) {
        var dataLabel = this.accumulation.series[0].dataLabel;
        var variableR;
        if (this.isVariousRadius()) {
            variableR = this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], currentPoint);
        }
        //padding 10px is added to label radius for increasing the angle and avoid congestion.
        var labelRadius = (currentPoint.labelPosition === 'Outside' && this.accumulation.enableSmartLabels &&
            dataLabel.position === 'Inside') ?
            this.radius + stringToNumber(dataLabel.connectorStyle.length || '4%', this.accumulation.pieSeriesModule.size / 2) :
            (!this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius + 10 : variableR);
        var radius = (!this.isVariousRadius() ? labelRadius : variableR);
        this.getLabelRegion(currentPoint, 'Outside', currentPoint.textSize, radius, this.marginValue, newAngle);
        currentPoint.isLabelUpdated = 1;
        currentPoint.labelAngle = newAngle;
    };
    AccumulationDataLabel.prototype.isOverlapWithPrevious = function (currentPoint, points, currentPointIndex) {
        for (var i = 0; i < currentPointIndex; i++) {
            if (i !== points.indexOf(currentPoint) &&
                points[i].visible && points[i].labelVisible &&
                points[i].labelRegion && currentPoint.labelRegion &&
                currentPoint.labelVisible && isOverlap(currentPoint.labelRegion, points[i].labelRegion)) {
                return true;
            }
        }
        return false;
    };
    AccumulationDataLabel.prototype.isOverlapWithNext = function (point, points, pointIndex) {
        for (var i = pointIndex; i < points.length; i++) {
            if (i !== points.indexOf(point) && points[i].visible &&
                points[i].labelVisible && points[i].labelRegion &&
                point.labelRegion && point.labelVisible && isOverlap(point.labelRegion, points[i].labelRegion)) {
                return true;
            }
        }
        return false;
    };
    AccumulationDataLabel.prototype.skipPoints = function (currentPoint, halfsidePoints, pointIndex) {
        if (pointIndex > 0 && ((currentPoint.midAngle < 285 && currentPoint.midAngle > 255) ||
            (currentPoint.midAngle < 105 && currentPoint.midAngle > 75))) {
            var previousPoint = halfsidePoints[pointIndex - 1];
            var angleDiff = currentPoint.endAngle % 360 - currentPoint.startAngle % 360;
            var prevAngleDiff = previousPoint.endAngle % 360 - previousPoint.startAngle % 360;
            if (prevAngleDiff <= angleDiff && angleDiff < 5 && previousPoint.labelVisible) {
                this.setPointVisibleTrue(currentPoint);
            }
        }
        else if (pointIndex > 1 && ((currentPoint.midAngle < 300 && currentPoint.midAngle > 240) ||
            (currentPoint.midAngle < 120 && currentPoint.midAngle > 60))) {
            var prevPoint = halfsidePoints[pointIndex - 1];
            var secondPrevPoint = halfsidePoints[pointIndex - 2];
            var angleDiff = currentPoint.endAngle % 360 - currentPoint.startAngle % 360;
            var prevAngleDiff = prevPoint.endAngle % 360 - prevPoint.startAngle % 360;
            var thirdAngleDiff = secondPrevPoint.endAngle % 360 - secondPrevPoint.startAngle % 360;
            if (angleDiff < 3 && prevAngleDiff < 3 && thirdAngleDiff < 3 && prevPoint.labelVisible && currentPoint.labelVisible) {
                this.setPointVisibleTrue(currentPoint);
            }
        }
    };
    AccumulationDataLabel.prototype.getPerpendicularDistance = function (startPoint, point) {
        var increasedLocation;
        var add = 10;
        var height = add + 10 * Math.sin(point.midAngle * Math.PI / 360);
        if (point.midAngle > 270 && point.midAngle < 360) {
            increasedLocation = new ChartLocation(startPoint.x + height * (Math.cos((360 - point.midAngle) * Math.PI / 180)), startPoint.y - height * (Math.sin((360 - point.midAngle) * Math.PI / 180)));
        }
        else if (point.midAngle > 0 && point.midAngle < 90) {
            increasedLocation = new ChartLocation(startPoint.x + height * (Math.cos((point.midAngle) * Math.PI / 180)), startPoint.y + height * (Math.sin((point.midAngle) * Math.PI / 180)));
            // eslint-disable-next-line no-dupe-else-if
        }
        else if (point.midAngle > 0 && point.midAngle < 90) {
            increasedLocation = new ChartLocation(startPoint.x - height * (Math.cos((point.midAngle - 90) * Math.PI / 180)), startPoint.y + height * (Math.sin((point.midAngle - 90) * Math.PI / 180)));
        }
        else {
            increasedLocation = new ChartLocation(startPoint.x - height * (Math.cos((point.midAngle - 180) * Math.PI / 180)), startPoint.y - height * (Math.sin((point.midAngle - 180) * Math.PI / 180)));
        }
        return increasedLocation;
    };
    return AccumulationDataLabel;
}(AccumulationBase));

var __extends$72 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * AccumulationChart Tooltip file
 */
//import { Rect } from '@syncfusion/ej2-svg-base';
/**
 * `AccumulationTooltip` module is used to render tooltip for accumulation chart.
 */
var AccumulationTooltip = /** @__PURE__ @class */ (function (_super) {
    __extends$72(AccumulationTooltip, _super);
    function AccumulationTooltip(accumulation) {
        var _this = _super.call(this, accumulation) || this;
        _this.accumulation = accumulation;
        _this.addEventListener();
        _this.template = _this.accumulation.tooltip.template;
        return _this;
    }
    /**
     * @hidden
     */
    AccumulationTooltip.prototype.addEventListener = function () {
        if (this.accumulation.isDestroyed) {
            return;
        }
        this.accumulation.on(Browser.isPointer ? 'pointerleave' : 'mouseleave', this.mouseLeaveHandler, this);
        this.accumulation.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
        this.accumulation.on(Browser.touchEndEvent, this.mouseUpHandler, this);
    };
    AccumulationTooltip.prototype.mouseLeaveHandler = function (e) {
        this.removeTooltip(this.accumulation.tooltip.fadeOutDuration);
    };
    AccumulationTooltip.prototype.mouseUpHandler = function (e) {
        var control = this.accumulation;
        if (control.tooltip.enable && control.isTouch && withInBounds(control.mouseX, control.mouseY, control.initialClipRect)) {
            this.tooltip(e);
            this.removeTooltip(2000);
        }
    };
    AccumulationTooltip.prototype.mouseMoveHandler = function (e) {
        var control = this.accumulation;
        // Tooltip for chart series.
        if (control.tooltip.enable && withInBounds(control.mouseX, control.mouseY, control.initialClipRect)) {
            this.tooltip(e);
        }
    };
    /**
     * Renders the tooltip.
     *
     * @param  {PointerEvent} event - Mouse move event.
     * @return {void}
     */
    AccumulationTooltip.prototype.tooltip = function (event) {
        this.renderSeriesTooltip(this.accumulation, this.getPieData(event, this.accumulation, this.accumulation.mouseX, this.accumulation.mouseY));
    };
    /**
     * @private
     */
    AccumulationTooltip.prototype.renderSeriesTooltip = function (chart, data) {
        var svgElement = this.getElement(this.element.id + '_tooltip_svg');
        var isTooltip = svgElement && parseInt(svgElement.getAttribute('opacity'), 10) > 0;
        var tooltipDiv = this.getTooltipElement(isTooltip);
        var isFirst = !isTooltip;
        this.currentPoints = [];
        if (data.point && (!this.previousPoints[0] || (this.previousPoints[0].point !== data.point))) {
            if (this.previousPoints[0] && data.point.index === this.previousPoints[0].point.index
                && data.series.index === this.previousPoints[0].series.index) {
                return null;
            }
            if (this.pushData(data, isFirst, tooltipDiv, false)) {
                this.triggerTooltipRender(data, isFirst, this.getTooltipText(data, chart.tooltip), this.findHeader(data));
            }
        }
        else {
            if (!data.point && this.isRemove) {
                this.removeTooltip(this.accumulation.tooltip.fadeOutDuration);
                this.isRemove = false;
            }
        }
    };
    AccumulationTooltip.prototype.triggerTooltipRender = function (point, isFirst, textCollection, headerText, firstText) {
        var _this = this;
        if (firstText === void 0) { firstText = true; }
        //let template: string;
        var tooltip = this.chart.tooltip;
        var argsData = {
            cancel: false, name: tooltipRender, text: textCollection, point: point.point, textStyle: this.textStyle,
            series: this.accumulation.isBlazor ? {} : point.series, headerText: headerText,
            data: {
                pointX: point.point.x, pointY: point.point.y, seriesIndex: point.series.index,
                pointIndex: point.point.index, pointText: point.point.text, seriesName: point.series.name
            }
        };
        var tooltipSuccess = function (argsData) {
            if (!argsData.cancel) {
                _this.formattedText = _this.formattedText.concat(argsData.text);
                _this.text = _this.formattedText;
                _this.headerText = argsData.headerText;
                _this.createTooltip(_this.chart, isFirst, { x: (tooltip.location.x !== null) ? tooltip.location.x : point.point.symbolLocation.x, y: (tooltip.location.y !== null) ? tooltip.location.y : point.point.symbolLocation.y }, point.series.clipRect, point.point, !tooltip.enableMarker ? [] : ['Circle'], 0, _this.chart.initialClipRect, false, null, point.point, _this.template ? argsData.template : '');
            }
            else {
                _this.removeHighlight();
                remove(_this.getElement(_this.element.id + '_tooltip'));
            }
            _this.isRemove = true;
        };
        tooltipSuccess.bind(this, point);
        this.chart.trigger(tooltipRender, argsData, tooltipSuccess);
    };
    AccumulationTooltip.prototype.getPieData = function (e, chart, x, y) {
        var target = e.target;
        var id = indexFinder(target.id, true);
        if (!isNaN(id.series)) {
            var seriesIndex = id.series;
            var pointIndex = id.point;
            if (!isNullOrUndefined(seriesIndex) && !isNaN(seriesIndex) && !isNullOrUndefined(pointIndex) && !isNaN(pointIndex)) {
                var series = this.getSeriesFromIndex(seriesIndex, chart.visibleSeries);
                if (series.enableTooltip) {
                    return new AccPointData(series.points[pointIndex], series);
                }
            }
        }
        return new AccPointData(null, null);
    };
    /**
     * To get series from index
     */
    AccumulationTooltip.prototype.getSeriesFromIndex = function (index, visibleSeries) {
        return visibleSeries[0];
    };
    AccumulationTooltip.prototype.getTooltipText = function (data, tooltip) {
        var series = data.series;
        var format = tooltip.format ? tooltip.format : '${point.x} : <b>${point.y}</b>';
        format = this.accumulation.useGroupingSeparator ? format.replace('${point.y}', '${point.separatorY}') : format;
        return this.parseTemplate(data.point, series, format);
    };
    AccumulationTooltip.prototype.findHeader = function (data) {
        if (this.header === '') {
            return '';
        }
        this.header = this.parseTemplate(data.point, data.series, this.header);
        if (this.header.replace(/<b>/g, '').replace(/<\/b>/g, '').trim() !== '') {
            return this.header;
        }
        return '';
    };
    AccumulationTooltip.prototype.parseTemplate = function (point, series, format) {
        var value;
        var textValue;
        for (var _i = 0, _a = Object.keys(point); _i < _a.length; _i++) {
            var dataValue = _a[_i];
            // eslint-disable-next-line security/detect-non-literal-regexp
            value = new RegExp('${point' + '.' + dataValue + '}', 'gm');
            format = format.replace(value.source, point[dataValue]);
        }
        for (var _b = 0, _c = Object.keys(Object.getPrototypeOf(series)); _b < _c.length; _b++) {
            var dataValue = _c[_b];
            // eslint-disable-next-line security/detect-non-literal-regexp
            value = new RegExp('${series' + '.' + dataValue + '}', 'gm');
            textValue = series[dataValue];
            format = format.replace(value.source, textValue);
        }
        return format;
    };
    /**
     * Get module name
     */
    AccumulationTooltip.prototype.getModuleName = function () {
        return 'AccumulationTooltip';
    };
    /**
     * To destroy the Tooltip.
     *
     * @return {void}
     * @private
     */
    AccumulationTooltip.prototype.destroy = function (chart) {
        /**
         * Destroy method calling here
         */
    };
    return AccumulationTooltip;
}(BaseTooltip));

var __extends$73 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * AccumulationChart Selection src file
 */
/**
 * `AccumulationSelection` module handles the selection for accumulation chart.
 */
var AccumulationSelection = /** @__PURE__ @class */ (function (_super) {
    __extends$73(AccumulationSelection, _super);
    function AccumulationSelection(accumulation) {
        var _this = _super.call(this, accumulation) || this;
        _this.accumulation = accumulation;
        _this.renderer = accumulation.renderer;
        _this.addEventListener();
        return _this;
    }
    /**
     * Binding events for selection module.
     */
    AccumulationSelection.prototype.addEventListener = function () {
        if (this.accumulation.isDestroyed) {
            return;
        }
        //let cancelEvent: string = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        this.accumulation.on(Browser.touchMoveEvent, this.mouseMove, this);
        this.accumulation.on('click', this.mouseClick, this);
    };
    /**
     * UnBinding events for selection module.
     */
    AccumulationSelection.prototype.removeEventListener = function () {
        if (this.accumulation.isDestroyed) {
            return;
        }
        this.accumulation.off(Browser.touchMoveEvent, this.mouseMove);
        this.accumulation.off('click', this.mouseClick);
    };
    /**
     * To initialize the private variables
     */
    AccumulationSelection.prototype.initPrivateVariables = function (accumulation) {
        this.styleId = accumulation.element.id + '_ej2_chart_selection';
        this.unselected = accumulation.element.id + '_ej2_deselected';
        this.selectedDataIndexes = [];
        this.rectPoints = null;
    };
    /**
     * Invoke selection for rendered chart.
     *
     * @param {AccumulationChart} accumulation Define the chart to invoke the selection.
     * @returns {void}
     */
    AccumulationSelection.prototype.invokeSelection = function (accumulation) {
        this.initPrivateVariables(accumulation);
        this.series = extend({}, accumulation.visibleSeries, null, true);
        this.seriesStyles();
        this.currentMode = accumulation.selectionMode;
        this.selectDataIndex(this.concatIndexes(accumulation.selectedDataIndexes, this.selectedDataIndexes), accumulation);
    };
    /**
     * To get series selection style by series.
     */
    AccumulationSelection.prototype.generateStyle = function (series, point) {
        return (series.selectionStyle || this.styleId + '_series_' + series.index + '_point_' + point);
    };
    /**
     * To get series selection style while hovering legend
     */
    AccumulationSelection.prototype.generateLegendClickStyle = function (series, eventType) {
        if (eventType === 'mousemove') {
            this.styleId = this.accumulation.element.id + '_ej2_chart_highlight';
        }
        else if (eventType === 'click') {
            this.styleId = this.accumulation.element.id + '_ej2_chart_selection';
        }
        return (series.selectionStyle || this.styleId + '_series_' + series.index);
    };
    /**
     * To get elements by index, series
     */
    AccumulationSelection.prototype.findElements = function (accumulation, series, index) {
        return [this.getElementByIndex(index)];
    };
    /**
     * To get series point element by index
     */
    AccumulationSelection.prototype.getElementByIndex = function (index) {
        var elementId = this.control.element.id + '_Series_' + index.series + '_Point_' + index.point;
        return document.getElementById(elementId);
    };
    /**
     * To find the selected element.
     *
     * @return {void}
     * @private
     */
    AccumulationSelection.prototype.isAlreadySelected = function (targetElement, eventType) {
        if (eventType === 'mousemove') {
            this.currentMode = this.accumulation.highlightMode;
            this.highlightDataIndexes = [];
            this.styleId = this.accumulation.element.id + '_ej2_chart_highlight';
        }
        else if (eventType === 'click') {
            this.currentMode = this.accumulation.selectionMode;
            this.styleId = this.accumulation.element.id + '_ej2_chart_selection';
        }
        if (this.accumulation.highlightMode !== 'None' && this.accumulation.selectionMode === 'None') {
            if (eventType === 'click') {
                return false;
            }
        }
        if ((this.accumulation.highlightMode !== 'None' && this.previousSelectedElement && this.previousSelectedElement[0])) {
            var parentNodeId = targetElement.parentNode.id;
            var isValidElement = void 0;
            if (targetElement.parentNode) {
                isValidElement = (parentNodeId.indexOf('SeriesGroup') > 0 ||
                    parentNodeId.indexOf('SymbolGroup') > 0) ? true : false;
            }
            for (var i = 0; i < this.previousSelectedElement.length; i++) {
                if (this.previousSelectedElement[i].hasAttribute('class')) {
                    if (this.previousSelectedElement[i].getAttribute('class').indexOf('highlight') > -1 && (isValidElement || eventType === 'click')) {
                        this.previousSelectedElement[i].removeAttribute('class');
                        this.addOrRemoveIndex(this.highlightDataIndexes, indexFinder(this.previousSelectedElement[i].id));
                    }
                    else if (!isValidElement && this.previousSelectedElement[i].getAttribute('class').indexOf('highlight') > -1) {
                        this.performSelection(indexFinder(this.previousSelectedElement[i].id), this.accumulation, this.previousSelectedElement[i]);
                    }
                }
            }
        }
        return true;
    };
    /**
     * To calculate selected elements on mouse click or touch
     *
     * @private
     */
    AccumulationSelection.prototype.mouseClick = function (accumulation, event) {
        this.calculateSelectedElements(accumulation, event.target, event.type);
    };
    /**
     * To calculate selected elements on mouse click or touch
     *
     * @private
     */
    AccumulationSelection.prototype.calculateSelectedElements = function (accumulation, targetEle, eventType) {
        if (isNullOrUndefined(targetEle)) {
            return;
        }
        if ((accumulation.highlightMode === 'None' && accumulation.selectionMode === 'None') ||
            targetEle.id.indexOf(accumulation.element.id + '_') === -1) {
            return;
        }
        if (eventType === 'mousemove') {
            if (!isNullOrUndefined(targetEle.parentNode) && targetEle.parentNode.hasAttribute('class') &&
                (targetEle.parentNode.getAttribute('class').indexOf('highlight') > 0 ||
                    targetEle.parentNode.getAttribute('class').indexOf('selection') > 0)) {
                return;
            }
        }
        if (targetEle.getAttribute('id').indexOf('_connector_') > -1) {
            return;
        }
        else {
            this.isAlreadySelected(targetEle, eventType);
            if (targetEle.id.indexOf('_Series_') > -1 || targetEle.id.indexOf('_datalabel_') > -1) {
                this.performSelection(indexFinder(targetEle.id), accumulation, targetEle);
            }
        }
    };
    /**
     * To perform the selection process based on index and element.
     */
    AccumulationSelection.prototype.performSelection = function (index, accumulation, element) {
        element = element.id.indexOf('datalabel') > -1 ?
            accumulation.getSeriesElement().childNodes[index.series].childNodes[index.point]
            : element;
        switch (this.currentMode) {
            case 'Point':
                if (!isNaN(index.point)) {
                    this.selection(accumulation, index, [element]);
                    this.selectionComplete(accumulation, accumulation.series[0]);
                    this.blurEffect(accumulation.element.id, accumulation.visibleSeries);
                }
                break;
        }
    };
    /**
     *  Method to get the selected data index
     *
     * @private
     */
    AccumulationSelection.prototype.selectionComplete = function (accumulation, series) {
        var pointIndex;
        var selectedPointValues = [];
        for (var i = 0; i < this.selectedDataIndexes.length; i++) {
            pointIndex = this.selectedDataIndexes[i].point;
            if (!isNaN(pointIndex)) {
                selectedPointValues.push({
                    x: series.dataSource[pointIndex][series.xName], y: series.points[pointIndex].y,
                    seriesIndex: this.selectedDataIndexes[i].series, pointIndex: pointIndex
                });
            }
        }
        var args = {
            name: selectionComplete,
            selectedDataValues: selectedPointValues,
            cancel: false
        };
        accumulation.trigger(selectionComplete, args);
    };
    /**
     * To select the element by index. Adding or removing selection style class name.
     */
    AccumulationSelection.prototype.selection = function (accumulation, index, selectedElements) {
        if (!accumulation.isMultiSelect && this.styleId.indexOf('highlight') === -1 &&
            accumulation.selectionMode !== 'None') {
            this.removeMultiSelectEelments(accumulation, this.selectedDataIndexes, index, accumulation.series);
        }
        var className = selectedElements[0] && (selectedElements[0].getAttribute('class') || '');
        if (selectedElements[0] && className.indexOf(this.getSelectionClass(selectedElements[0].id, index.point)) > -1) {
            this.removeStyles(selectedElements, index);
            if (this.styleId.indexOf('highlight') > 0 && accumulation.highlightMode !== 'None') {
                this.addOrRemoveIndex(this.highlightDataIndexes, index);
            }
            else {
                this.addOrRemoveIndex(this.selectedDataIndexes, index);
            }
            if (accumulation.enableBorderOnMouseMove) {
                var borderElement = document.getElementById(selectedElements[0].id.split('_')[0] + 'PointHover_Border');
                if (!isNullOrUndefined(borderElement)) {
                    this.removeSvgClass(borderElement, borderElement.getAttribute('class'));
                }
            }
        }
        else {
            this.previousSelectedElement = accumulation.highlightMode !== 'None' ? selectedElements : [];
            if (className.indexOf('selection') < 0) {
                this.applyStyles(selectedElements, index);
            }
            if (accumulation.enableBorderOnMouseMove) {
                var borderElement = document.getElementById(selectedElements[0].id.split('_')[0] + 'PointHover_Border');
                if (!isNullOrUndefined(borderElement)) {
                    this.removeSvgClass(borderElement, borderElement.getAttribute('class'));
                    this.addSvgClass(borderElement, selectedElements[0].getAttribute('class'));
                }
            }
            if (this.styleId.indexOf('highlight') > 0 && accumulation.highlightMode !== 'None') {
                this.addOrRemoveIndex(this.highlightDataIndexes, index, true);
            }
            else {
                this.addOrRemoveIndex(this.selectedDataIndexes, index, true);
            }
        }
    };
    /**
     * To redraw the selection process on accumulation chart refresh.
     *
     * @private
     */
    AccumulationSelection.prototype.redrawSelection = function (accumulation) {
        var selectedDataIndexes = extend([], this.selectedDataIndexes, null, true);
        var highlightDataIndexes = extend([], this.highlightDataIndexes, null, true);
        if (this.styleId.indexOf('highlight') > 0 && highlightDataIndexes.length > 0) {
            this.removeSelectedElements(accumulation, this.highlightDataIndexes);
            selectedDataIndexes = highlightDataIndexes;
        }
        else {
            this.removeSelectedElements(accumulation, this.selectedDataIndexes);
        }
        this.blurEffect(accumulation.element.id, accumulation.visibleSeries);
        this.selectDataIndex(selectedDataIndexes, accumulation);
    };
    /**
     * To remove the selected elements style classes by indexes.
     */
    AccumulationSelection.prototype.removeSelectedElements = function (accumulation, indexes) {
        for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {
            var index = indexes_1[_i];
            this.removeStyles([this.getElementByIndex(index)], index);
        }
        var points = accumulation.visibleSeries[0].points;
        for (var i = 0; i < points.length; i++) {
            var index = new Index(0, points[i].index);
            this.removeStyles([this.getElementByIndex(index)], index);
        }
    };
    /**
     * To perform the selection for legend elements.
     *
     * @private
     */
    AccumulationSelection.prototype.legendSelection = function (accumulation, series, pointIndex, targetEle, eventType) {
        if (eventType === 'mousemove') {
            if (targetEle.id.indexOf('text') > 1) {
                targetEle = getElement$1(targetEle.id.replace('text', 'shape'));
            }
            if (targetEle.hasAttribute('class') && (targetEle.getAttribute('class').indexOf('highlight') > -1 ||
                targetEle.getAttribute('class').indexOf('selection') > -1)) {
                return;
            }
            this.currentMode = this.accumulation.highlightMode;
        }
        var isPreSelected = this.isAlreadySelected(targetEle, eventType);
        if (isPreSelected) {
            //let element: Element = <Element>accumulation.getSeriesElement().childNodes[series as number].childNodes[pointIndex as number];
            //let seriesStyle: string = this.generateLegendClickStyle(accumulation.visibleSeries[series as number], eventType);
            var seriesElements = accumulation.getSeriesElement().
                childNodes[series].childNodes[pointIndex];
            this.selection(accumulation, new Index(series, pointIndex), [seriesElements]);
            this.blurEffect(accumulation.element.id, accumulation.visibleSeries);
        }
    };
    /**
     * To select the element by selected data indexes.
     */
    AccumulationSelection.prototype.selectDataIndex = function (indexes, accumulation) {
        var element;
        for (var _i = 0, indexes_2 = indexes; _i < indexes_2.length; _i++) {
            var index = indexes_2[_i];
            element = this.getElementByIndex(index);
            if (element) {
                this.performSelection(index, accumulation, element);
            }
        }
    };
    /**
     * To remove the selection styles for multi selection process.
     */
    AccumulationSelection.prototype.removeMultiSelectEelments = function (accumulation, index, currentIndex, seriesCollection) {
        var series;
        for (var i = 0; i < index.length; i++) {
            series = seriesCollection[index[i].series];
            if (!this.checkEquals(index[i], currentIndex)) {
                this.removeStyles(this.findElements(accumulation, series, index[i]), index[i]);
                index.splice(i, 1);
                i--;
            }
        }
    };
    /**
     * To apply the opacity effect for accumulation chart series elements.
     */
    AccumulationSelection.prototype.blurEffect = function (pieId, visibleSeries) {
        var visibility = (this.checkVisibility(this.highlightDataIndexes) ||
            this.checkVisibility(this.selectedDataIndexes)); // legend click scenario
        for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
            var series = visibleSeries_1[_i];
            if (series.visible) {
                this.checkSelectionElements(document.getElementById(pieId + '_SeriesCollection'), this.generateStyle(series), visibility);
            }
        }
    };
    /**
     * To check selection elements by style class name.
     */
    AccumulationSelection.prototype.checkSelectionElements = function (element, className, visibility) {
        var children = element.childNodes[0].childNodes;
        var legendShape;
        var elementClass;
        var parentClass;
        //let selectElement: Element = element;
        for (var i = 0; i < children.length; i++) {
            elementClass = children[i].getAttribute('class') || '';
            parentClass = children[i].parentNode.getAttribute('class') || '';
            if (this.accumulation.selectionMode !== 'None' || this.accumulation.highlightMode !== 'None') {
                className = elementClass.indexOf('selection') > 0 ||
                    elementClass.indexOf('highlight') > 0 ? elementClass : className;
                className = (parentClass.indexOf('selection') > 0 ||
                    parentClass.indexOf('highlight') > 0) ? parentClass : className;
            }
            if (elementClass.indexOf(className) === -1 && parentClass.indexOf(className) === -1 && visibility) {
                this.addSvgClass(children[i], this.unselected);
            }
            else {
                this.removeSvgClass(children[i], this.unselected);
            }
            if (elementClass.indexOf(className) === -1 &&
                parentClass.indexOf(className) === -1 && visibility) {
                this.addSvgClass(children[i], this.unselected);
            }
            else {
                // selectElement = children[i as number] as HTMLElement;
                this.removeSvgClass(children[i], this.unselected);
                this.removeSvgClass(children[i].parentNode, this.unselected);
            }
            if (this.control.accumulationLegendModule && this.control.legendSettings.visible) {
                legendShape = document.getElementById(this.control.element.id + '_chart_legend_shape_' + i);
                if (legendShape) {
                    if (elementClass.indexOf(className) === -1 && parentClass.indexOf(className) === -1 && visibility) {
                        this.addSvgClass(legendShape, this.unselected);
                    }
                    else {
                        this.removeSvgClass(legendShape, this.unselected);
                    }
                }
            }
        }
    };
    /**
     * To apply selection style for elements.
     */
    AccumulationSelection.prototype.applyStyles = function (elements, index) {
        var accumulationTooltip = this.control.accumulationTooltipModule;
        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
            var element = elements_1[_i];
            var legendShape = void 0;
            if (element) {
                if (this.control.accumulationLegendModule && this.control.legendSettings.visible) {
                    legendShape = document.getElementById(this.control.element.id + '_chart_legend_shape_' + index.point);
                    this.removeSvgClass(legendShape, legendShape.getAttribute('class'));
                    this.addSvgClass(legendShape, this.getSelectionClass(legendShape.id, index.point));
                }
                this.removeSvgClass(element.parentNode, this.unselected);
                this.removeSvgClass(element, this.unselected);
                var opacity = accumulationTooltip && (accumulationTooltip.previousPoints.length > 0 &&
                    accumulationTooltip.previousPoints[0].point.index !== index.point) ?
                    accumulationTooltip.svgTooltip.opacity : this.series[index.series].opacity;
                element.setAttribute('opacity', opacity.toString());
                this.addSvgClass(element, this.getSelectionClass(element.id, index.point));
            }
        }
    };
    /**
     * To get selection style class name by id
     */
    AccumulationSelection.prototype.getSelectionClass = function (id, point) {
        return this.generateStyle(this.control.series[indexFinder(id).series], point);
    };
    /**
     * To remove selection style for elements.
     */
    AccumulationSelection.prototype.removeStyles = function (elements, index) {
        var accumulationTooltip = this.control.accumulationTooltipModule;
        var legendShape;
        for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {
            var element = elements_2[_i];
            if (element) {
                if (this.control.accumulationLegendModule && this.control.legendSettings.visible) {
                    legendShape = document.getElementById(this.control.element.id + '_chart_legend_shape_' + index.point);
                    this.removeSvgClass(legendShape, this.getSelectionClass(legendShape.id, index.point));
                }
                var opacity = accumulationTooltip && accumulationTooltip.previousPoints.length > 0
                    && (accumulationTooltip.previousPoints[0].point.index === index.point) ?
                    accumulationTooltip.svgTooltip.opacity : this.series[index.series].opacity;
                element.setAttribute('opacity', opacity.toString());
                this.removeSvgClass(element, this.getSelectionClass(element.id, index.point));
            }
        }
    };
    /**
     * To apply or remove selected elements index.
     */
    AccumulationSelection.prototype.addOrRemoveIndex = function (indexes, index, add) {
        for (var i = 0; i < indexes.length; i++) {
            if (this.checkEquals(indexes[i], index)) {
                indexes.splice(i, 1);
                i--;
            }
        }
        if (add) {
            indexes.push(index);
        }
    };
    /**
     * To check two index, point and series are equal
     */
    AccumulationSelection.prototype.checkEquals = function (first, second) {
        return ((first.point === second.point) && (first.series === second.series));
    };
    /** @private */
    AccumulationSelection.prototype.mouseMove = function (event) {
        var accumulation = this.accumulation;
        var targetElement = event.target;
        if (accumulation.highlightMode !== 'None') {
            if (!isNullOrUndefined(targetElement)) {
                if (event.target.id.indexOf('text') > 1) {
                    targetElement = getElement$1(event.target.id.replace('text', 'shape'));
                }
                if ((targetElement).hasAttribute('class') && (targetElement).getAttribute('class').indexOf('highlight') > -1) {
                    return;
                }
                this.calculateSelectedElements(accumulation, event.target, event.type);
                return;
            }
        }
        if (accumulation.selectionMode === 'None') {
            return;
        }
    };
    /**
     * To check selected points are visibility
     */
    AccumulationSelection.prototype.checkPointVisibility = function (selectedDataIndexes) {
        var visible = false;
        for (var _i = 0, selectedDataIndexes_1 = selectedDataIndexes; _i < selectedDataIndexes_1.length; _i++) {
            var data = selectedDataIndexes_1[_i];
            if (pointByIndex(data.point, this.control.visibleSeries[0].points).visible) {
                visible = true;
                break;
            }
        }
        return visible;
    };
    /**
     * Get module name.
     */
    AccumulationSelection.prototype.getModuleName = function () {
        return 'AccumulationSelection';
    };
    /**
     * To destroy the selection.
     *
     * @returns {void}
     * @private
     */
    AccumulationSelection.prototype.destroy = function () {
        // Destroy method performed here
        this.removeEventListener();
    };
    return AccumulationSelection;
}(BaseSelection));

var __extends$74 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * AccumulationChart highlight source file
 */
// tslint:disable:no-string-literal
/**
 * `AccumulationHighlight` module handles the selection for chart.
 *
 * @private
 */
var AccumulationHighlight = /** @__PURE__ @class */ (function (_super) {
    __extends$74(AccumulationHighlight, _super);
    /**
     * Constructor for selection module.
     *
     * @private.
     */
    function AccumulationHighlight(accumulation) {
        var _this = _super.call(this, accumulation) || this;
        _this.accumulation = accumulation;
        _this.renderer = accumulation.renderer;
        _this.wireEvents();
        return _this;
    }
    /**
     * Binding events for selection module.
     */
    AccumulationHighlight.prototype.wireEvents = function () {
        if (this.accumulation.isDestroyed) {
            return;
        }
        this.accumulation.on(Browser.touchMoveEvent, this.mouseMove, this);
    };
    /**
     * UnBinding events for selection module.
     */
    AccumulationHighlight.prototype.unWireEvents = function () {
        if (this.accumulation.isDestroyed) {
            return;
        }
        this.accumulation.off(Browser.touchMoveEvent, this.mouseMove);
    };
    /**
     * To find private variable values
     */
    AccumulationHighlight.prototype.declarePrivateVariables = function (accumulation) {
        this.styleId = accumulation.element.id + '_ej2_chart_highlight';
        this.unselected = accumulation.element.id + '_ej2_deselected';
        this.selectedDataIndexes = [];
        this.highlightDataIndexes = [];
    };
    /**
     * Method to select the point and series.
     *
     * @return {void}
     */
    AccumulationHighlight.prototype.invokeHighlight = function (accumulation) {
        this.declarePrivateVariables(accumulation);
        this.series = extend({}, accumulation.visibleSeries, null, true);
        this.seriesStyles();
        this.currentMode = accumulation.highlightMode;
    };
    /**
     * Get module name.
     *
     * @private
     */
    AccumulationHighlight.prototype.getModuleName = function () {
        return 'AccumulationHighlight';
    };
    /**
     * To destroy the highlight.
     *
     * @return {void}
     * @private
     */
    AccumulationHighlight.prototype.destroy = function () {
        this.unWireEvents();
        //Destroy method performed here
    };
    return AccumulationHighlight;
}(AccumulationSelection));

/* eslint-disable jsdoc/require-param */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/**
 * AccumulationChart annotation properties
 */
var __extends$75 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * `AccumulationAnnotation` module handles the annotation for accumulation chart.
 */
var AccumulationAnnotation = /** @__PURE__ @class */ (function (_super) {
    __extends$75(AccumulationAnnotation, _super);
    /**
     * Constructor for accumulation chart annotation.
     *
     * @private
     */
    function AccumulationAnnotation(control) {
        var _this = _super.call(this, control) || this;
        _this.pie = control;
        return _this;
    }
    /**
     * Method to render the annotation for accumulation chart.
     *
     * @param {Element} element Annotation element.
     */
    AccumulationAnnotation.prototype.renderAnnotations = function (element) {
        var _this = this;
        this.annotations = this.pie.annotations;
        var redraw = this.pie.redraw;
        this.parentElement = (redrawElement(redraw, this.pie.element.id + '_Annotation_Collections') ||
            createElement('div', {
                id: this.pie.element.id + '_Annotation_Collections'
            }));
        this.annotations.map(function (annotation, index) {
            _this.processAnnotation(annotation, index, _this.parentElement);
        });
        appendElement(this.parentElement, element, redraw);
    };
    /**
     * Get module name.
     */
    AccumulationAnnotation.prototype.getModuleName = function () {
        // Returns te module name
        return 'Annotation';
    };
    /**
     * To destroy the annotation.
     *
     * @returns {void}
     *
     * @private
     */
    AccumulationAnnotation.prototype.destroy = function () {
        // Destroy method performed here
    };
    return AccumulationAnnotation;
}(AnnotationBase));

/**
 * Pie Component items exported
 */

/**
 * Methods for calculating coefficient.
 */
/** @private */
function rangeValueToCoefficient(value, range, inversed) {
    var result = (value - range.min) / (range.delta);
    return inversed ? (1 - result) : result;
}
/** @private */
function getXLocation(x, range, size, inversed) {
    x = rangeValueToCoefficient(x, range, inversed);
    return x * size;
}
/** @private */
function getRangeValueXByPoint(value, size, range, inversed) {
    var actualValue = !inversed ? value / size : (1 - (value / size));
    return actualValue * (range.delta) + range.min;
}
/** @private */
function getExactData(points, start, end) {
    var selectedData = [];
    points.map(function (point) {
        if (point.xValue >= start && point.xValue <= end) {
            selectedData.push({
                'x': point.x,
                'y': point.y
            });
        }
    });
    return selectedData;
}
/** @private */
function getNearestValue(values, point) {
    return values.reduce(function (prev, curr) {
        return (Math.abs(curr - point) < Math.abs(prev - point) ? curr : prev);
    });
}
/**
 * Data point
 *
 * @public
 */
var DataPoint = /** @__PURE__ @class */ (function () {
    function DataPoint(x, y, xValue, yValue, visible) {
        if (visible === void 0) { visible = true; }
        this.x = x;
        this.y = y;
        this.xValue = xValue;
        this.visible = visible;
    }
    return DataPoint;
}());

var __extends$78 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * To render Chart series
 */
var RangeSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$78(RangeSeries, _super);
    function RangeSeries(range) {
        var _this = _super.call(this) || this;
        _this.dataSource = range.dataSource;
        _this.xName = range.xName;
        _this.yName = range.yName;
        _this.query = range.query;
        _this.xMin = Infinity;
        _this.xMax = -Infinity;
        _this.yMin = Infinity;
        _this.yMax = -Infinity;
        _this.labels = [];
        _this.indexLabels = {};
        return _this;
    }
    /**
     * To render light weight and data manager process
     *
     * @param {RangeNavigator} control RangeNavigator instance
     */
    RangeSeries.prototype.renderChart = function (control) {
        var _this = this;
        var dataSource;
        var query;
        this.seriesLength = 0;
        control.rangeSlider.points = [];
        if (control.series.length) {
            control.series.map(function (series) {
                dataSource = series.dataSource || control.dataSource;
                query = series.query || control.query;
                series.points = [];
                _this.processDataSource(dataSource, query, control, series);
            });
        }
        else {
            this.processDataSource(control.dataSource, control.query, control);
        }
    };
    RangeSeries.prototype.processDataSource = function (dataSource, query, control, series) {
        var _this = this;
        if (!(dataSource instanceof DataManager) && !isNullOrUndefined(dataSource) && isNullOrUndefined(query)) {
            this.dataManagerSuccess({ result: dataSource, count: dataSource.length }, control, series);
            return;
        }
        control.dataModule = new Data(dataSource, query);
        var dataManager = control.dataModule.getData(control.dataModule.generateQuery().requiresCount());
        dataManager.then(function (e) { return _this.dataManagerSuccess(e, control, series); });
    };
    /**
     * data manager process calculated here
     */
    RangeSeries.prototype.dataManagerSuccess = function (e, control, series) {
        var viewData = e.count ? e.result : [];
        control.allowServerDataBinding = false;
        this.processJsonData(viewData, control, Object.keys(viewData).length, series);
        this.seriesLength += series ? 1 : this.seriesLength;
        if (!series || this.seriesLength === control.series.length) {
            this.processXAxis(control);
            this.calculateGroupingBounds(control);
            this.processYAxis(control);
            control.renderChart();
        }
    };
    /**
     * Process JSON data from data source
     */
    RangeSeries.prototype.processJsonData = function (viewData, control, len, series) {
        var i = 0;
        var point;
        var xName = (series && series.xName) || control.xName;
        var yName = (series && series.yName) || control.yName;
        while (i < len) {
            point = new DataPoint(getValue(xName, viewData[i]), getValue(yName, viewData[i]));
            point.yValue = +point.y;
            if (control.valueType.indexOf('DateTime') > -1) {
                var dateParser = control.intl.getDateParser({ skeleton: 'full', type: 'dateTime' });
                var dateFormatter = control.intl.getDateFormat({ skeleton: 'full', type: 'dateTime' });
                point.x = new Date(DataUtil.parse.parseJson({ val: point.x }).val);
                point.xValue = Date.parse(dateParser(dateFormatter(point.x)));
                if (control.valueType === 'DateTimeCategory') {
                    if (this.indexLabels[point.xValue.toString()] === undefined) {
                        this.indexLabels[point.xValue.toString()] = this.labels.length;
                        this.labels.push(point.xValue.toString());
                    }
                    point.xValue = this.indexLabels[point.xValue];
                }
            }
            else {
                point.xValue = +point.x;
            }
            if (series) {
                series.points.push(point);
            }
            this.xMin = Math.min(this.xMin, point.xValue);
            this.yMin = Math.min(this.yMin, point.yValue);
            this.xMax = Math.max(this.xMax, point.xValue);
            this.yMax = Math.max(this.yMax, point.yValue);
            control.rangeSlider.points.push(point);
            i++;
        }
    };
    /**
     * Process x axis for range navigator.
     *
     * @private
     */
    RangeSeries.prototype.processXAxis = function (control) {
        var axis = {
            minimum: control.minimum, maximum: control.maximum,
            interval: control.interval, valueType: control.valueType,
            isInversed: control.enableRtl, labelFormat: control.labelFormat,
            logBase: control.logBase, skeleton: control.skeleton, skeletonType: control.skeletonType
        };
        this.xAxis = axis;
        this.xAxis.intervalType = control.intervalType;
        this.xAxis.maximumLabels = 3;
        this.xAxis.skeleton = control.skeleton;
        this.xAxis.intervalDivs = [10, 5, 2, 1];
        this.xAxis.rect = control.bounds;
        this.xAxis.visibleLabels = [];
        this.xAxis.orientation = 'Horizontal';
        this.xAxis.labels = this.labels;
        this.xAxis.indexLabels = this.indexLabels;
        var axisModule = control[firstToLowerCase(control.valueType) + 'Module'];
        axisModule.min = this.xMin;
        axisModule.max = this.xMax;
        axisModule.getActualRange(this.xAxis, control.bounds);
        if (this.xAxis.valueType === 'Double' || this.xAxis.valueType === 'DateTime' || this.xAxis.valueType === 'DateTimeCategory') {
            axisModule.updateActualRange(this.xAxis, this.xAxis.actualRange.min, this.xAxis.actualRange.max, this.xAxis.actualRange.interval);
        }
        this.xAxis.actualRange.delta = this.xAxis.actualRange.max - this.xAxis.actualRange.min;
        this.xAxis.visibleRange = this.xAxis.actualRange;
        axisModule.calculateVisibleLabels(this.xAxis, control);
        if (this.xAxis.valueType === 'DateTimeCategory' && control.periodSelectorModule) {
            control.periodSelectorModule.isDatetimeCategory = true;
            control.periodSelectorModule.sortedData = this.labels.map(function (label) { return parseInt(label, 10); });
        }
    };
    /**
     * Process yAxis for range navigator
     *
     * @param {RangeNavigator} control RangeNavigator instance
     * @private
     */
    RangeSeries.prototype.processYAxis = function (control) {
        var axis = {
            majorGridLines: { width: 0 }, rangePadding: 'None',
            majorTickLines: { width: 0 }, labelStyle: { size: '0' },
            visible: false, valueType: 'Double', minimum: null, maximum: null,
            interval: null
        };
        this.yAxis = axis;
        this.yAxis.rect = control.bounds;
        this.yAxis.maximumLabels = 3;
        this.yAxis.intervalDivs = [10, 5, 2, 1];
        this.yAxis.orientation = 'Vertical';
        control.doubleModule.min = this.yMin;
        control.doubleModule.max = this.yMax;
        control.doubleModule.getActualRange(this.yAxis, control.bounds);
        control.doubleModule.updateActualRange(this.yAxis, this.yAxis.actualRange.min, this.yAxis.actualRange.max, this.yAxis.actualRange.interval);
        this.yAxis.actualRange.delta = this.yAxis.actualRange.max - this.yAxis.actualRange.min;
        this.yAxis.visibleRange = this.yAxis.actualRange;
    };
    /**
     * Process Light weight control
     *
     * @param {RangeNavigator} control RangeNavigator instance
     * @private
     */
    RangeSeries.prototype.renderSeries = function (control) {
        var _this = this;
        this.chartGroup = control.renderer.createGroup({ id: control.element.id + '_chart' });
        var colors = getSeriesColor(control.theme);
        control.series.map(function (series, index) {
            var isSeriesVisible = control.stockChart ? control.stockChart.series[index].visible : true;
            if (isSeriesVisible) {
                series.xAxis = _this.xAxis;
                series.yAxis = _this.yAxis;
                series.chart = control;
                series.index = index;
                series.xAxis.isInversed = control.enableRtl;
                series.interior = series.fill || colors[index % colors.length];
                _this.createSeriesElement(control, series, index);
                if (series.xAxis.valueType === 'DateTimeCategory') {
                    for (var i = 0; i < series.points.length; i++) {
                        series.points[i].xValue =
                            _this.xAxis.labels.indexOf(Date.parse(series.points[i].x.toString()).toString());
                    }
                }
                if (control[firstToLowerCase(series.type) + 'SeriesModule']) {
                    control[firstToLowerCase(series.type) + 'SeriesModule'].render(series, _this.xAxis, _this.yAxis, false);
                }
                else {
                    control['line' + 'SeriesModule'].render(series, _this.xAxis, _this.yAxis, false);
                }
                _this.chartGroup.appendChild(series.seriesElement);
                if (((series.animation.enable && animationMode != 'Disable') || animationMode === 'Enable') && control.animateSeries) {
                    if (control[firstToLowerCase(series.type) + 'SeriesModule']) {
                        control[firstToLowerCase(series.type) + 'SeriesModule'].doAnimation(series);
                    }
                    else {
                        //control['line' + 'SeriesModule'].doAnimation(series);
                    }
                }
            }
        });
    };
    /**
     * Append series elements in element.
     */
    RangeSeries.prototype.appendSeriesElements = function (control) {
        control.svgObject.appendChild(this.chartGroup);
        if (control.series.length) {
            this.drawSeriesBorder(control);
        }
    };
    RangeSeries.prototype.createSeriesElement = function (control, series, index) {
        var elementId = control.element.id;
        series.clipRect = new Rect(this.xAxis.rect.x, this.yAxis.rect.y, this.xAxis.rect.width, this.yAxis.rect.height);
        series.clipRectElement = control.renderer.drawClipPath(new RectOption(elementId + '_RangeSeriesClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, {
            x: 0, y: 0,
            width: series.clipRect.width,
            height: series.clipRect.height
        }));
        series.seriesElement = control.renderer.createGroup({
            'id': elementId + 'SeriesGroup' + index,
            'transform': 'translate(' + series.clipRect.x + ',' + (series.clipRect.y) + ')',
            'clip-path': 'url(#' + elementId + '_RangeSeriesClipRect_' + index + ')'
        });
        series.seriesElement.appendChild(series.clipRectElement);
    };
    /**
     * Calculate grouping bounds for x axis.
     *
     * @private
     */
    RangeSeries.prototype.calculateGroupingBounds = function (control) {
        var padding = control.margin.bottom;
        var labelHeight = measureText('string', control.labelStyle, control.themeStyle.axisLabelFont).height;
        var xMin = control.valueType === 'DateTimeCategory' ? parseInt(this.xAxis.labels[this.xMin], 10) : this.xMin;
        var xMax = control.valueType === 'DateTimeCategory' ? parseInt(this.xAxis.labels[this.xMax], 10) : this.xMax;
        this.calculateDateTimeNiceInterval(this.xAxis, new Size(control.bounds.width, control.bounds.height), xMin, xMax, false);
        if (control.enableGrouping && (control.valueType === 'DateTime' || control.valueType === 'DateTimeCategory')
            && (this.xAxis.actualIntervalType !== 'Years' || !control.series.length)) {
            control.bounds.height -= (control.labelPosition === 'Outside' || control.series.length === 0) ? padding + labelHeight :
                (labelHeight + 2 * padding);
        }
        if (!control.series.length) {
            control.bounds.y += control.bounds.height / 4;
            control.bounds.height = control.bounds.height / 2;
        }
    };
    RangeSeries.prototype.drawSeriesBorder = function (control) {
        var start = control.stockChart ? 'M' : 'L';
        var close = control.stockChart ? '' : 'Z';
        var options = new PathOption(control.element.id + '_SeriesBorder', 'transparent', control.navigatorBorder.width, control.navigatorBorder.color || (control.theme.indexOf('Dark') > -1 ? '#49454F' : '#DDDDDD'), 1, '', ('M ' + (control.bounds.x) + ' ' + (control.bounds.y) +
            ' L ' + (control.bounds.x + control.bounds.width) + ' ' + control.bounds.y +
            start + (control.bounds.x + control.bounds.width) + ' ' + (control.bounds.y + control.bounds.height) +
            ' L ' + (control.bounds.x) + ' ' + (control.bounds.y + control.bounds.height) + close));
        var htmlObject = control.renderer.drawPath(options);
        control.svgObject.appendChild(htmlObject);
    };
    return RangeSeries;
}(NiceInterval));

var __extends$79 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * class for axis
 */
var RangeNavigatorAxis = /** @__PURE__ @class */ (function (_super) {
    __extends$79(RangeNavigatorAxis, _super);
    function RangeNavigatorAxis(range) {
        var _this = _super.call(this) || this;
        _this.firstLevelLabels = [];
        _this.secondLevelLabels = [];
        _this.rangeNavigator = range;
        return _this;
    }
    /**
     * To render grid lines of axis
     */
    RangeNavigatorAxis.prototype.renderGridLines = function () {
        var pointX = 0;
        var control = this.rangeNavigator;
        var majorGridLines = control.majorGridLines;
        var majorTickLines = control.majorTickLines;
        var majorGrid = '';
        var majorTick = '';
        var rect = control.bounds;
        var chartAxis = control.chartSeries.xAxis;
        var disabledColor = (control.disableRangeSelector) ? 'transparent' : null;
        this.gridLines = control.renderer.createGroup({ id: control.element.id + '_GridLines' });
        var tick = (control.tickPosition === 'Outside' || control.series.length === 0) ?
            rect.y + rect.height + majorTickLines.height : rect.y + rect.height - majorTickLines.height;
        //Gridlines
        this.firstLevelLabels = [];
        chartAxis.labelStyle = control.labelStyle;
        chartAxis.skeleton = control.skeleton;
        chartAxis.skeletonType = control.skeletonType;
        chartAxis.isChart = false;
        if (control.valueType.indexOf('DateTime') > -1) {
            var interval = this.calculateDateTimeNiceInterval(chartAxis, rect, chartAxis.doubleRange.start, chartAxis.doubleRange.end, chartAxis.isChart);
            if (control.valueType === 'DateTime') {
                this.findAxisLabels(chartAxis, interval);
            }
            this.actualIntervalType = chartAxis.actualIntervalType;
            if (control.valueType === 'DateTimeCategory' && (this.actualIntervalType === 'Quarter' || this.actualIntervalType === 'Weeks')) {
                this.findSecondaryAxisLabels(chartAxis);
            }
        }
        this.firstLevelLabels = chartAxis.visibleLabels;
        this.lowerValues = [];
        var labelLength = chartAxis.visibleLabels.length;
        for (var i = 0; i < labelLength; i++) {
            this.lowerValues.push(this.firstLevelLabels[i].value);
            pointX = (valueToCoefficient(this.firstLevelLabels[i].value, chartAxis) * rect.width) + rect.x;
            if (pointX >= rect.x && (rect.x + rect.width) >= pointX) {
                majorGrid = majorGrid.concat('M ' + pointX + ' ' + (control.bounds.y + control.bounds.height) +
                    ' L ' + pointX + ' ' + control.bounds.y + ' ');
                majorTick = majorTick.concat('M ' + (pointX) + ' ' + (rect.y + rect.height) +
                    ' L ' + (pointX) + ' ' + tick + ' ');
            }
        }
        var options = new PathOption(control.element.id + '_MajorGridLine', 'transparent', majorGridLines.width, control.series.length ? disabledColor || majorGridLines.color || control.themeStyle.gridLineColor : 'transparent', 1, majorGridLines.dashArray, majorGrid);
        this.gridLines.appendChild(control.renderer.drawPath(options));
        options = new PathOption(control.element.id + '_MajorTickLine', 'transparent', majorTickLines.width, disabledColor || majorTickLines.color || control.themeStyle.gridLineColor, 1, majorGridLines.dashArray, majorTick);
        this.gridLines.appendChild(control.renderer.drawPath(options));
    };
    /**
     * To render of axis labels
     */
    RangeNavigatorAxis.prototype.renderAxisLabels = function () {
        var axis = this.rangeNavigator.chartSeries.xAxis;
        var control = this.rangeNavigator;
        var pointY;
        var labelElement = control.renderer.createGroup({ id: control.element.id + '_AxisLabels' });
        var firstLevelElement = control.renderer.createGroup({ id: control.element.id + '_FirstLevelAxisLabels' });
        var secondLevelElement = control.renderer.createGroup({ id: control.element.id + '_SecondLevelAxisLabels' });
        var secondaryAxis = axis;
        pointY = this.findLabelY(control, false);
        this.placeAxisLabels(axis, pointY, '_AxisLabel_', control, firstLevelElement);
        secondaryAxis.intervalType = secondaryAxis.actualIntervalType = (control.groupBy ||
            this.getSecondaryLabelType(axis.actualIntervalType));
        secondaryAxis.labelFormat = '';
        if (control.enableGrouping && control.valueType.indexOf('DateTime') > -1 && this.actualIntervalType !== 'Years') {
            secondaryAxis.visibleRange.interval = 1;
            secondaryAxis.visibleLabels = [];
            var interval = this.calculateDateTimeNiceInterval(secondaryAxis, control.bounds, secondaryAxis.doubleRange.start, secondaryAxis.doubleRange.end, secondaryAxis.isChart);
            if (control.valueType === 'DateTime') {
                this.findAxisLabels(secondaryAxis, interval);
            }
            else {
                this.findSecondaryAxisLabels(secondaryAxis);
            }
            this.secondLevelLabels = secondaryAxis.visibleLabels;
            pointY = this.findLabelY(control, true);
            var border = this.placeAxisLabels(secondaryAxis, pointY, '_SecondaryLabel_', control, secondLevelElement);
            var path = new PathOption(control.element.id + '_SecondaryMajorLines', 'transparent', control.majorTickLines.width, control.majorTickLines.color || control.themeStyle.gridLineColor, 1, control.majorGridLines.dashArray, border);
            this.gridLines.appendChild(control.renderer.drawPath(path));
        }
        control.chartSeries.xAxis.visibleLabels = control.chartSeries.xAxis.visibleLabels.concat(secondaryAxis.visibleLabels);
        labelElement.style.cursor = axis.valueType.indexOf('DateTime') > -1 ? 'cursor: pointer' : 'cursor: default';
        labelElement.appendChild(firstLevelElement);
        labelElement.appendChild(secondLevelElement);
        //gridlines and axis label append to element
        control.svgObject.appendChild(this.gridLines);
        control.svgObject.appendChild(labelElement);
    };
    /**
     * To find secondary level label type
     *
     * @param {RangeIntervalType} type type of range interval
     */
    RangeNavigatorAxis.prototype.getSecondaryLabelType = function (type) {
        var types = ['Years', 'Quarter', 'Months', 'Weeks', 'Days', 'Hours', 'Minutes', 'Seconds'];
        return (type === 'Years' ? 'Years' : types[types.indexOf(type) - 1]);
    };
    /**
     * To find labels for date time category axis
     *
     * @param {Axis} axis range axis
     */
    RangeNavigatorAxis.prototype.findSecondaryAxisLabels = function (axis) {
        axis.visibleLabels = [];
        axis.visibleRange.interval = Math.max(axis.visibleRange.interval, 1);
        var previousIndex;
        this.rangeNavigator.format = this.rangeNavigator.intl.getDateFormat({
            format: axis.labelFormat || '',
            type: firstToLowerCase(axis.skeleton), skeleton: this.getSkeleton(axis, null, null)
        });
        for (var i = Math.ceil(axis.visibleRange.min); i <= axis.visibleRange.max; i += axis.visibleRange.interval) {
            if ((!this.rangeNavigator.dateTimeCategoryModule.sameInterval(axis.labels.map(Number)[i], axis.labels.map(Number)[i - axis.visibleRange.interval], axis.actualIntervalType, i) || axis.isIndexed)
                && withIn(i, axis.visibleRange)
                && this.rangeNavigator.dateTimeCategoryModule.isMaximum(i, previousIndex, axis)) {
                var currentLabel = new Date(axis.labels.map(Number)[i]);
                if (axis.actualIntervalType === 'Quarter') {
                    var quarterMonths = [0, 3, 6, 9];
                    var quarterIndex = Math.floor(currentLabel.getMonth() / 3);
                    currentLabel.setMonth(quarterMonths[quarterIndex]);
                }
                axis.visibleLabels.push(new VisibleLabels(this.dateFormats(this.rangeNavigator.format(currentLabel), axis, axis.visibleLabels.length), i, this.rangeNavigator.labelStyle, this.rangeNavigator.format(currentLabel)));
                previousIndex = i;
            }
        }
    };
    /**
     * To find labels for date time axis
     *
     * @param {Axis} axis range axis
     */
    RangeNavigatorAxis.prototype.findAxisLabels = function (axis, interval) {
        axis.visibleLabels = [];
        var start = new Date(axis.visibleRange.min);
        var nextInterval;
        var text;
        interval = this.rangeNavigator.interval ? this.rangeNavigator.interval : interval;
        switch (axis.actualIntervalType) {
            case 'Years':
                start = new Date(start.getFullYear(), 0, 1);
                break;
            case 'Quarter':
                if (start.getMonth() <= 2) {
                    start = new Date(start.getFullYear(), 0, 1);
                }
                else if (start.getMonth() <= 5) {
                    start = new Date(start.getFullYear(), 3, 1);
                }
                else if (start.getMonth() <= 8) {
                    start = new Date(start.getFullYear(), 6, 1);
                }
                else {
                    start = new Date(start.getFullYear(), 9, 1);
                }
                break;
            case 'Months':
                start = new Date(start.getFullYear(), start.getMonth());
                break;
            case 'Weeks':
                start = new Date(start.getFullYear(), start.getMonth(), start.getDate() - start.getDay());
                break;
            case 'Days':
                start = new Date(start.getFullYear(), start.getMonth(), start.getDate());
                break;
            case 'Hours':
                start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours());
                break;
            case 'Minutes':
                start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours(), start.getMinutes());
                break;
            case 'Seconds':
                start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours(), start.getMinutes(), start.getSeconds());
                break;
        }
        nextInterval = start.getTime();
        this.rangeNavigator.format = this.rangeNavigator.intl.getDateFormat({
            format: axis.labelFormat || '',
            type: firstToLowerCase(axis.skeletonType), skeleton: this.getSkeleton(axis, null, null)
        });
        while (nextInterval <= axis.visibleRange.max) {
            text = this.dateFormats(this.rangeNavigator.format(new Date(nextInterval)), axis, axis.visibleLabels.length);
            axis.visibleLabels.push(new VisibleLabels(text, nextInterval, this.rangeNavigator.labelStyle, text));
            nextInterval = this.increaseDateTimeInterval(axis, nextInterval, interval).getTime();
        }
    };
    /**
     * To find date time formats for Quarter and week interval type
     *
     * @param {string} text text
     * @param {Axis} axis axis
     * @param {number} index index
     */
    RangeNavigatorAxis.prototype.dateFormats = function (text, axis, index) {
        var changedText = text;
        var isFirstLevel = this.rangeNavigator.enableGrouping && this.firstLevelLabels.length === 0;
        switch (axis.actualIntervalType) {
            case 'Quarter':
                if (text.indexOf('Jan') > -1) {
                    changedText = !isFirstLevel ? text.replace('Jan', 'Quarter1') : 'Quarter1';
                }
                else if (text.indexOf('Apr') > -1) {
                    changedText = !isFirstLevel ? text.replace('Apr', 'Quarter2') : 'Quarter2';
                }
                else if (text.indexOf('Jul') > -1) {
                    changedText = !isFirstLevel ? text.replace('Jul', 'Quarter3') : 'Quarter3';
                }
                else if (text.indexOf('Oct') > -1) {
                    changedText = !isFirstLevel ? text.replace('Oct', 'Quarter4') : 'Quarter4';
                }
                break;
            case 'Weeks':
                changedText = 'Week' + ++index;
                break;
            default:
                changedText = text;
                break;
        }
        return changedText;
    };
    /**
     * To find the y co-ordinate for axis labels
     *
     * @param {RangeNavigator} control - rangeNavigator
     * @param {boolean} isSecondary sets true if the axis is secondary axis
     */
    RangeNavigatorAxis.prototype.findLabelY = function (control, isSecondary) {
        var pointY;
        var reference = control.bounds.y + control.bounds.height;
        var tickHeight = control.majorTickLines.height;
        var textHeight = measureText('Quarter1 2011', control.labelStyle, control.themeStyle.axisLabelFont).height;
        var padding = control.labelPosition === 'Inside' ? 3 : 8;
        if ((control.labelPosition === 'Outside' && control.tickPosition === 'Outside') || control.series.length === 0) {
            pointY = reference + tickHeight + padding + textHeight * 0.75;
        }
        else if (control.labelPosition === 'Inside' && control.tickPosition === 'Inside') {
            pointY = reference - tickHeight - padding;
        }
        else if (control.labelPosition === 'Inside' && control.tickPosition === 'Outside') {
            pointY = reference - padding;
        }
        else {
            pointY = reference + padding + (textHeight * 0.75);
        }
        if (isSecondary) {
            padding = 15;
            if (control.labelPosition === 'Outside' || control.series.length === 0) {
                pointY += padding + textHeight * 0.75;
            }
            else {
                pointY = (control.tickPosition === 'Outside' || control.series.length === 0) ?
                    reference + tickHeight + padding + textHeight * 0.75 : reference + padding + textHeight * 0.75;
            }
        }
        return pointY;
    };
    /**
     * It places the axis labels and returns border for secondary axis labels
     *
     * @param {Axis} axis axis for the lables placed
     * @param {number} pointY y co-ordinate for axis labels
     * @param {string} id id for the axis elements
     * @param {RangeNavigator} control range navigator
     * @param {Element} labelElement parent element in which axis labels appended
     */
    RangeNavigatorAxis.prototype.placeAxisLabels = function (axis, pointY, id, control, labelElement) {
        var maxLabels = axis.visibleLabels.length;
        var label;
        var prevLabel;
        var pointX;
        var padding = 2;
        var rect = control.bounds;
        var border = '';
        var pointXGrid;
        var disabledColor = (control.disableRangeSelector) ? 'transparent' : null;
        var prevX = control.enableRtl ? (rect.x + rect.width) : rect.x;
        var intervalType = axis.actualIntervalType;
        var intervalInTime = ((control.labelPlacement === 'Auto' && control.valueType === 'DateTime') || control.labelPlacement === 'BetweenTicks') ?
            maxLabels > 1 ? (axis.visibleLabels[1].value - axis.visibleLabels[0].value) :
                (axis.visibleRange.max - axis.visibleLabels[0].value) / 2 : 0;
        if (control.valueType.indexOf('DateTime') > -1 && (intervalType === 'Quarter' || intervalType === 'Weeks')) {
            this.findSuitableFormat(axis, control);
        }
        for (var i = 0, len = maxLabels; i < len; i++) {
            label = axis.visibleLabels[i];
            label.size = measureText(label.text, axis.labelStyle, control.themeStyle.axisLabelFont);
            if ((control.secondaryLabelAlignment === 'Middle' || id.indexOf('_AxisLabel_') > -1) && (control.labelPlacement === 'Auto' || control.labelPlacement === 'BetweenTicks')) {
                pointX = (valueToCoefficient((label.value + intervalInTime / 2), axis) * rect.width) + rect.x;
            }
            else if ((id.indexOf('Secondary') > -1)) {
                pointX = this.findAlignment(axis, i);
            }
            if (control.labelPlacement === 'OnTicks' && control.labelPosition === 'Inside') {
                pointX = (valueToCoefficient(label.value, axis) * rect.width) + rect.x + label.size.width / 2 + padding;
            }
            else if (control.labelPlacement === 'OnTicks' && control.labelPosition === 'Outside') {
                pointX = (valueToCoefficient(label.value, axis) * rect.width) + rect.x;
            }
            pointXGrid = (valueToCoefficient((label.value), axis) * rect.width) + rect.x;
            //edgelabelPlacements
            if ((i === 0 || (i === axis.visibleLabels.length - 1 && control.enableRtl)) && pointX < rect.x) {
                pointX = rect.x + label.size.width / 2;
            }
            if ((i === axis.visibleLabels.length - 1 || (i === 0 && control.enableRtl)) &&
                ((pointX + label.size.width) > (rect.x + rect.width))) {
                pointX = rect.x + rect.width - label.size.width / 2;
            }
            //secondary axis grid lines
            if (id.indexOf('_SecondaryLabel_') > -1) {
                if (pointX >= rect.x && (rect.x + rect.width) >= pointX) {
                    border = border.concat('M ' + pointXGrid + ' ' + pointY +
                        ' L ' + pointXGrid + ' ' + (pointY - label.size.height));
                }
            }
            //smart axis label position,
            if (control.labelIntersectAction === 'Hide' &&
                i !== 0 && this.isIntersect(axis, pointX, label.size.width, prevX, prevLabel.size.width)) {
                continue;
            }
            //label alignment for single visible label
            if (control.secondaryLabelAlignment === 'Middle' && axis.visibleLabels.length === 1) {
                pointX = valueToCoefficient(label.value, axis) + (rect.x + (rect.width / 2));
            }
            //labelrender event
            var labelStyle = control.labelStyle;
            var style = {
                size: labelStyle.size, color: disabledColor || labelStyle.color || control.themeStyle.axisLabelFont.color,
                fontFamily: labelStyle.fontFamily,
                fontStyle: labelStyle.fontStyle || control.labelStyle.fontStyle,
                fontWeight: labelStyle.fontWeight || control.labelStyle.fontWeight,
                opacity: labelStyle.opacity || control.labelStyle.opacity,
                textAlignment: labelStyle.textAlignment || control.labelStyle.textAlignment,
                textOverflow: labelStyle.textOverflow || control.labelStyle.textOverflow
            };
            var argsData = {
                cancel: false, name: 'labelRender',
                text: label.text, value: label.value, labelStyle: style,
                region: new Rect(pointX, pointY, label.size.width, label.size.height)
            };
            control.trigger('labelRender', argsData);
            if (!argsData.cancel) {
                control.labels.push(argsData);
            }
            else {
                continue;
            }
            textElement$1(this.rangeNavigator.renderer, new TextOption(this.rangeNavigator.element.id + id + i, pointX, pointY, 'middle', argsData.text), argsData.labelStyle, argsData.labelStyle.color || control.themeStyle.labelFontColor, labelElement, null, null, null, null, null, null, null, null, null, null, control.themeStyle.axisLabelFont).style.cursor = axis.valueType.indexOf('DateTime') > -1 ? 'cursor: pointer' : 'cursor: default';
            prevX = pointX;
            prevLabel = label;
        }
        return border;
    };
    /**
     * To check label is intersected with successive label or not
     */
    RangeNavigatorAxis.prototype.isIntersect = function (axis, currentX, currentWidth, prevX, prevWidth) {
        return (axis.isInversed) ? (currentX + currentWidth / 2 > prevX - prevWidth / 2) :
            (currentX - currentWidth / 2 < prevX + prevWidth / 2);
    };
    /**
     * To find suitable label format for Quarter and week Interval types
     *
     * @param {Axis} axis RangeNavigator axis
     * @param {RangeNavigator} control RangeNavigator instance
     */
    RangeNavigatorAxis.prototype.findSuitableFormat = function (axis, control) {
        var labels = axis.visibleLabels;
        var labelLength = labels.length;
        var bounds = control.bounds;
        var prevX;
        var currentX;
        var interval = control.valueType === 'DateTime' ?
            labelLength > 1 ? (labels[1].value - labels[0].value) : axis.visibleRange.interval
            : 0;
        for (var i = 0; i < labelLength; i++) {
            currentX = (valueToCoefficient((labels[i].value + interval / 2), axis) * bounds.width) + bounds.x;
            labels[i].size = measureText(labels[i].text, axis.labelStyle, control.themeStyle.axisLabelFont);
            //edgelabelPlacements
            if (i === 0 && currentX < bounds.x) {
                currentX = bounds.x + labels[i].size.width / 2;
            }
            if (axis.actualIntervalType === 'Quarter') {
                if (i !== 0) {
                    if ((labels[i].text.indexOf('Quarter') > -1) &&
                        (this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width))) {
                        labels.every(function (label) {
                            label.text = label.text.toString().replace('Quarter', 'QTR');
                            return true;
                        });
                        axis.visibleLabels = labels;
                        this.findSuitableFormat(axis, control);
                    }
                    else {
                        if (this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width)) {
                            labels.every(function (label) {
                                label.text = label.text.toString().replace('QTR', 'Q');
                                return true;
                            });
                            axis.visibleLabels = labels;
                        }
                    }
                }
            }
            else if (axis.actualIntervalType === 'Weeks') {
                if ((i !== 0) && ((labels[i].text.indexOf('Week') > -1) &&
                    (this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width)))) {
                    labels.every(function (label) {
                        label.text = label.text.toString().replace('Week', 'W');
                        return true;
                    });
                    axis.visibleLabels = labels;
                }
            }
            prevX = currentX;
        }
    };
    /**
     * Alignment position for secondary level labels in date time axis
     *
     * @param {Axis} axis axis
     * @param {number} index label index
     */
    RangeNavigatorAxis.prototype.findAlignment = function (axis, index) {
        var label = axis.visibleLabels[index];
        var nextLabel = axis.visibleLabels[index + 1];
        var bounds = this.rangeNavigator.bounds;
        return (this.rangeNavigator.secondaryLabelAlignment === 'Near' ?
            (valueToCoefficient((label.value), axis) * bounds.width) + bounds.x + label.size.width / 2 :
            (valueToCoefficient((nextLabel ? nextLabel.value : axis.visibleRange.max), axis) * bounds.width) + bounds.x - label.size.width);
    };
    return RangeNavigatorAxis;
}(DateTime));

var __extends$80 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$11 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Series class for the range navigator
 */
var RangeNavigatorSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$80(RangeNavigatorSeries, _super);
    function RangeNavigatorSeries() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** @private */
        _this.clipRect = new Rect(0, 0, 0, 0);
        return _this;
    }
    __decorate$11([
        Property(null)
    ], RangeNavigatorSeries.prototype, "dataSource", void 0);
    __decorate$11([
        Property(null)
    ], RangeNavigatorSeries.prototype, "xName", void 0);
    __decorate$11([
        Property(null)
    ], RangeNavigatorSeries.prototype, "yName", void 0);
    __decorate$11([
        Property()
    ], RangeNavigatorSeries.prototype, "query", void 0);
    __decorate$11([
        Property('Line')
    ], RangeNavigatorSeries.prototype, "type", void 0);
    __decorate$11([
        Complex({ enable: false }, Animation$1)
    ], RangeNavigatorSeries.prototype, "animation", void 0);
    __decorate$11([
        Complex({ color: 'transparent', width: 2 }, Border)
    ], RangeNavigatorSeries.prototype, "border", void 0);
    __decorate$11([
        Property(null)
    ], RangeNavigatorSeries.prototype, "fill", void 0);
    __decorate$11([
        Property(1)
    ], RangeNavigatorSeries.prototype, "width", void 0);
    __decorate$11([
        Property(1)
    ], RangeNavigatorSeries.prototype, "opacity", void 0);
    __decorate$11([
        Property('0')
    ], RangeNavigatorSeries.prototype, "dashArray", void 0);
    return RangeNavigatorSeries;
}(ChildProperty));
/**
 * Thumb settings
 */
var ThumbSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$80(ThumbSettings, _super);
    function ThumbSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$11([
        Property(null)
    ], ThumbSettings.prototype, "width", void 0);
    __decorate$11([
        Property(null)
    ], ThumbSettings.prototype, "height", void 0);
    __decorate$11([
        Complex({ width: 1, color: null }, Border)
    ], ThumbSettings.prototype, "border", void 0);
    __decorate$11([
        Property(null)
    ], ThumbSettings.prototype, "fill", void 0);
    __decorate$11([
        Property('Circle')
    ], ThumbSettings.prototype, "type", void 0);
    return ThumbSettings;
}(ChildProperty));
/**
 * Style settings
 */
var StyleSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$80(StyleSettings, _super);
    function StyleSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$11([
        Complex({}, ThumbSettings)
    ], StyleSettings.prototype, "thumb", void 0);
    __decorate$11([
        Property(null)
    ], StyleSettings.prototype, "selectedRegionColor", void 0);
    __decorate$11([
        Property(null)
    ], StyleSettings.prototype, "unselectedRegionColor", void 0);
    return StyleSettings;
}(ChildProperty));
/*
 * Configures the ToolTips in the chart.
 */
var RangeTooltipSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$80(RangeTooltipSettings, _super);
    function RangeTooltipSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$11([
        Property(false)
    ], RangeTooltipSettings.prototype, "enable", void 0);
    __decorate$11([
        Property(null)
    ], RangeTooltipSettings.prototype, "opacity", void 0);
    __decorate$11([
        Property(null)
    ], RangeTooltipSettings.prototype, "fill", void 0);
    __decorate$11([
        Property(null)
    ], RangeTooltipSettings.prototype, "format", void 0);
    __decorate$11([
        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, Font)
    ], RangeTooltipSettings.prototype, "textStyle", void 0);
    __decorate$11([
        Property(null)
    ], RangeTooltipSettings.prototype, "template", void 0);
    __decorate$11([
        Complex({ color: null, width: null }, Border)
    ], RangeTooltipSettings.prototype, "border", void 0);
    __decorate$11([
        Property('OnDemand')
    ], RangeTooltipSettings.prototype, "displayMode", void 0);
    return RangeTooltipSettings;
}(ChildProperty));

/**
 * Class for slider
 */
var RangeSlider = /** @__PURE__ @class */ (function () {
    function RangeSlider(range) {
        this.control = range;
        this.points = [];
        this.isIOS = Browser.isIos || Browser.isIos7;
        var thumb = range.navigatorStyleSettings.thumb;
        this.thumbVisible = (range.themeStyle.thumbWidth !== 0 && range.themeStyle.thumbHeight !== 0);
        this.elementId = range.element.id;
        this.thumpPadding = range.themeStyle.thumbWidth / 2;
        this.addEventListener();
        this.thumbColor = range.disableRangeSelector ? 'transparent' :
            (thumb.fill || range.themeStyle.thumbBackground);
    }
    /**
     * Render Slider elements for range navigator.
     *
     * @param {RangeNavigator} range RangeNavigator instance
     */
    RangeSlider.prototype.render = function (range) {
        var renderer = range.renderer;
        var style = range.navigatorStyleSettings;
        var disabledColor = (range.disableRangeSelector) ? 'transparent' : null;
        var sliderGroup = renderer.createGroup({
            'id': this.elementId + '_sliders',
            style: (range.disableRangeSelector) ? 'pointer-events:none;' : ''
        });
        var option = new RectOption(this.elementId + '_leftUnSelectedArea', disabledColor || style.unselectedRegionColor || range.themeStyle.unselectedRectColor, { width: 0 }, 1, {
            x: range.bounds.x, y: range.bounds.y,
            width: range.bounds.width / 3,
            height: range.bounds.height
        });
        this.leftUnSelectedElement = renderer.drawRectangle(option);
        option.id = this.elementId + '_rightUnSelectedArea';
        this.rightUnSelectedElement = renderer.drawRectangle(option);
        option.id = this.elementId + '_SelectedArea';
        option.fill = disabledColor || style.selectedRegionColor || range.themeStyle.selectedRegionColor;
        this.selectedElement = renderer.drawRectangle(option);
        this.selectedElement.setAttribute('role', 'region');
        this.selectedElement.setAttribute('aria-label', 'Range Slider with ' + range.rangeSlider.points.length + ' data points');
        this.selectedElement.style.cursor = '-webkit-grab';
        this.leftSlider = renderer.createGroup({
            'id': this.elementId + '_LeftSlider', 'style': 'cursor: ew-resize'
        });
        this.rightSlider = renderer.createGroup({
            'id': this.elementId + '_RightSlider', 'style': 'cursor: ew-resize'
        });
        this.createThump(renderer, range.bounds, this.leftSlider, this.elementId + '_LeftSlider', sliderGroup);
        this.createThump(renderer, range.bounds, this.rightSlider, this.elementId + '_RightSlider');
        sliderGroup.appendChild(this.leftUnSelectedElement);
        sliderGroup.appendChild(this.rightUnSelectedElement);
        sliderGroup.appendChild(this.selectedElement);
        sliderGroup.appendChild(this.leftSlider);
        sliderGroup.appendChild(this.rightSlider);
        range.svgObject.appendChild(sliderGroup);
    };
    /**
     * Thumb creation performed.
     *
     * @param {SvgRenderer} render SvgRenderer
     * @param {Rect} bounds bounds
     * @param {Element} parent parent element
     * @param {string} id id
     * @param {Element} sliderGroup sliderGroup
     */
    RangeSlider.prototype.createThump = function (render, bounds, parent, id, sliderGroup) {
        var control = this.control;
        var thump = control.navigatorStyleSettings.thumb;
        var style = control.themeStyle;
        var y = bounds.y + bounds.height / 2;
        var x = this.thumpPadding;
        var tickLength = (control.themeStyle.thumbHeight / 2) - 5;
        var disabledColor = control.disableRangeSelector ? 'transparent' : null;
        var lineColor = disabledColor || thump.border.color || style.thumpLineColor;
        var shadowElement;
        parent.appendChild(render.drawPath(new PathOption(id + '_ThumpLine', 'transparent', thump.border.width, control.series.length ? lineColor : 'transparent', 1, null, 'M' + ' ' + (x) + ' ' + (bounds.y) + ' ' + 'L' + ' ' + (x) + ' ' + (bounds.y + bounds.height) + ' ')));
        this.thumpY = y - (control.themeStyle.thumbHeight / 2);
        this.sliderY = bounds.y > this.thumpY ? this.thumpY : bounds.y;
        if (sliderGroup && !control.disableRangeSelector) {
            shadowElement = render.createDefs();
            shadowElement.innerText = '<rect xmlns="http://www.w3.org/2000/svg" id="' + this.control.element.id + '_shadow' + '" x="0" ' +
                'y="' + this.thumpY + '" width="' + control.themeStyle.thumbWidth + '" height="' + control.themeStyle.thumbHeight + '"' +
                ' rx="' + (thump.type === 'Circle' ? '50%' : '0%') + '"/>' +
                '<filter xmlns="http://www.w3.org/2000/svg" x="-25.0%" y="-20.0%" width="150.0%" height="150.0%"' +
                ' filterUnits="objectBoundingBox" id="ej2-range-shadow"><feOffset dx="0" dy="1" in="SourceAlpha"' +
                'result="shadowOffsetOuter1"/><feGaussianBlur stdDeviation="1.5" in="shadowOffsetOuter1" result="shadowBlurOuter1"/>' +
                '<feComposite in="shadowBlurOuter1" in2="SourceAlpha" operator="out" result="shadowBlurOuter1"/>' +
                '<feColorMatrix values="0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.16 0" type="matrix" in="shadowBlurOuter1"/>' +
                '</filter>';
            sliderGroup.appendChild(shadowElement);
        }
        parent.innerText += '<use xmlns="http://www.w3.org/2000/svg" fill="black" fill-opacity="1" filter="url(#ej2-range-shadow)"' +
            ' xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#path-1"/>';
        if (thump.type === 'Circle') {
            parent.appendChild(drawSymbol({ x: x, y: y }, 'Circle', { width: control.themeStyle.thumbWidth, height: control.themeStyle.thumbHeight }, '', new PathOption(id + '_ThumpSymbol', disabledColor || this.thumbColor, thump.border.width, lineColor, 1, null), 'Thumb'));
        }
        else {
            parent.appendChild(render.drawRectangle(new RectOption(id + '_ThumpSymbol', disabledColor || this.thumbColor, { width: thump.border.width, color: lineColor }, 1, {
                x: x - (control.themeStyle.thumbWidth / 2), y: y - (control.themeStyle.thumbHeight / 2),
                width: control.themeStyle.thumbWidth,
                height: control.themeStyle.thumbHeight
            }, 2, 2)));
        }
        if (this.thumbVisible) {
            parent.appendChild(render.drawPath(new PathOption(id + '_ThumpGrip', 'transparent', 1, disabledColor || control.themeStyle.gripColor, 1, null, 'M' + ' ' + (x + 2) + ' ' + (y + tickLength) + ' ' + 'L' + ' ' + (x + 2) + ' ' + (y - tickLength) + ' ' +
                'M' + ' ' + (x) + ' ' + (y + tickLength) + ' ' + 'L' + ' ' + (x) + ' ' + (y - tickLength) + ' ' +
                'M' + ' ' + (x - 2) + ' ' + (y + tickLength) + ' ' + 'L' + ' ' + (x - 2) + ' ' + (y - tickLength) + ' ')));
        }
    };
    /**
     * Set slider value for range navigator.
     */
    RangeSlider.prototype.setSlider = function (start, end, trigger, showTooltip$$1, resize) {
        if (resize === void 0) { resize = false; }
        var range = this.control;
        var padding = range.bounds.x;
        var axisRange = range.chartSeries.xAxis.actualRange;
        var isLeightWeight = range.series.length === 0;
        if (isNaN(start) && isNaN(end)) {
            start = 0;
            end = range.bounds.width;
        }
        if (!(end >= start)) {
            start = [end, end = start][0];
        }
        start = end >= start ? start : [end, end = start][0];
        start = Math.max(start, axisRange.min);
        end = Math.min(end, axisRange.max);
        this.startX = padding + getXLocation(start, axisRange, range.bounds.width, range.enableRtl);
        this.endX = padding + getXLocation(end, axisRange, range.bounds.width, range.enableRtl);
        var selectedX = range.enableRtl ? this.endX : this.startX;
        var rightPadding = range.enableRtl ? this.startX : this.endX;
        this.sliderWidth = Math.abs(this.endX - this.startX);
        this.selectedElement.setAttribute('x', (selectedX) + '');
        this.selectedElement.setAttribute('width', this.sliderWidth + '');
        this.leftUnSelectedElement.setAttribute('width', (selectedX - padding) + '');
        this.rightUnSelectedElement.setAttribute('x', rightPadding + '');
        this.rightUnSelectedElement.setAttribute('width', (range.bounds.width - (rightPadding - padding)) + '');
        this.leftSlider.setAttribute('transform', 'translate(' + (this.startX - this.thumpPadding) + ', 0)');
        this.rightSlider.setAttribute('transform', 'translate(' + (this.endX - this.thumpPadding) + ', 0)');
        var left = this.control.svgObject.getBoundingClientRect().left -
            this.control.element.getBoundingClientRect().left;
        var leftX = this.control.enableRtl ? this.endX : this.startX;
        var rightX = this.control.enableRtl ? this.startX : this.endX;
        this.leftRect = {
            x: isLeightWeight ? left + padding : padding,
            y: isLeightWeight ? 0 : range.bounds.y,
            width: isLeightWeight ? leftX - padding : leftX,
            height: isLeightWeight ? this.thumpY : range.bounds.height
        };
        this.rightRect = {
            x: isLeightWeight ? left + rightX : rightX,
            y: isLeightWeight ? 0 : range.bounds.y,
            width: (range.bounds.width - (rightPadding - padding)),
            height: isLeightWeight ? this.thumpY : range.bounds.height
        };
        this.midRect = {
            x: isLeightWeight ? leftX + left : 0,
            y: isLeightWeight ? 0 : range.bounds.y,
            width: isLeightWeight ? Math.abs(this.endX - this.startX) : rightX,
            height: isLeightWeight ? this.thumpY : range.bounds.height
        };
        this.currentStart = start;
        this.currentEnd = end;
        if (showTooltip$$1) {
            this.control.rangeTooltipModule.renderLeftTooltip(this);
            this.control.rangeTooltipModule.renderRightTooltip(this);
        }
        var periodSelectorModule = this.control.periodSelectorModule;
        if (periodSelectorModule && this.control.redraw && (this.control.getModuleName() === 'rangeNavigator')) {
            var selectedIndex = periodSelectorModule.findSelectedIndex(start, end, periodSelectorModule.control.periods);
            periodSelectorModule.setSelectedStyle(selectedIndex);
            this.control.redraw = false;
        }
        if (trigger && !resize) {
            this.triggerEvent(axisRange);
        }
    };
    /**
     * Trigger changed event.
     *
     * @param {VisibleRangeModel} range axis visible range
     */
    RangeSlider.prototype.triggerEvent = function (range) {
        var xAxis = this.control.chartSeries.xAxis;
        var valueType = xAxis.valueType;
        var argsData = {
            cancel: false,
            start: valueType === 'DateTime' ? new Date(this.currentStart) : valueType === 'DateTimeCategory' ? this.currentStart :
                (valueType === 'Logarithmic' ? Math.pow(xAxis.logBase, this.currentStart) : this.currentStart),
            end: valueType === 'DateTime' ? new Date(this.currentEnd) : valueType === 'DateTimeCategory' ? this.currentEnd :
                (valueType === 'Logarithmic' ? Math.pow(xAxis.logBase, this.currentEnd) : this.currentEnd),
            name: 'changed',
            selectedData: getExactData(this.points, this.currentStart, this.currentEnd),
            zoomPosition: (this.control.enableRtl ? range.max - this.currentEnd :
                this.currentStart - range.min) / range.delta,
            zoomFactor: (this.currentEnd - this.currentStart) / range.delta,
            selectedPeriod: this.selectedPeriod ? this.selectedPeriod : ''
        };
        this.control.trigger('changed', argsData);
    };
    /**
     * @hidden
     */
    RangeSlider.prototype.addEventListener = function () {
        if (this.control.isDestroyed) {
            return;
        }
        this.control.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
        this.control.on(Browser.touchStartEvent, this.mouseDownHandler, this);
        this.control.on(Browser.touchEndEvent, this.mouseUpHandler, this);
        this.control.on(Browser.isPointer ? 'pointerleave' : 'mouseleave', this.mouseCancelHandler, this);
    };
    /**
     * @hidden
     */
    RangeSlider.prototype.removeEventListener = function () {
        if (this.control.isDestroyed) {
            return;
        }
        this.control.off(Browser.touchMoveEvent, this.mouseMoveHandler);
        this.control.off(Browser.touchStartEvent, this.mouseDownHandler);
        this.control.off(Browser.touchEndEvent, this.mouseUpHandler);
        this.control.off(Browser.isPointer ? 'pointerleave' : 'mouseleave', this.mouseCancelHandler);
    };
    /**
     * Move move handler perfomed here
     *
     * @hidden
     * @param {PointerEvent} e mouse event argument
     */
    RangeSlider.prototype.mouseMoveHandler = function (e) {
        var control = this.control;
        var axisRange = control.chartSeries.xAxis.actualRange;
        var bounds = control.bounds;
        var start;
        var end;
        this.getCurrentSlider(e.target.id);
        if (this.isDrag && control.mouseX >= bounds.x) {
            switch (this.currentSlider) {
                case 'Left':
                    control.startValue = this.getRangeValue(Math.abs(control.mouseX - bounds.x));
                    break;
                case 'Right':
                    control.endValue = this.getRangeValue(Math.abs(control.mouseX - bounds.x));
                    break;
                case 'Middle':
                    start = Math.max(this.getRangeValue(Math.abs(this.startX - (this.previousMoveX - control.mouseX) - bounds.x)), axisRange.min);
                    end = Math.min(this.getRangeValue(Math.abs(this.endX - (this.previousMoveX - control.mouseX) - bounds.x)), axisRange.max);
                    // eslint-disable-next-line no-case-declarations
                    var currentWidth = Math.floor(Math.abs(getXLocation(end, axisRange, control.bounds.width, control.enableRtl) -
                        getXLocation(start, axisRange, control.bounds.width, control.enableRtl)));
                    if (currentWidth === Math.floor(this.sliderWidth)) {
                        control.startValue = start;
                        control.endValue = end;
                    }
                    else {
                        if (end === axisRange.max) {
                            control.endValue = axisRange.max;
                        }
                        if (Math.floor(this.startX) === bounds.x) {
                            control.startValue = axisRange.min;
                        }
                    }
                    break;
            }
            if (e.preventDefault && this.isIOS) {
                e.preventDefault();
            }
            if (this.currentSlider !== 'Middle') {
                var periodSelectorModule = this.control.periodSelectorModule;
                if (periodSelectorModule) {
                    var buttons = periodSelectorModule.control.periods;
                    buttons.map(function (period) {
                        period.selected = false;
                    });
                    periodSelectorModule.selectedIndex = undefined;
                    var selectedIndex = periodSelectorModule.findSelectedIndex(control.startValue, control.endValue, buttons);
                    periodSelectorModule.setSelectedStyle(selectedIndex);
                }
            }
            this.setSlider(control.startValue, control.endValue, !control.enableDeferredUpdate, (control.rangeTooltipModule && control.tooltip.enable));
            this.previousMoveX = control.mouseX;
        }
    };
    /**
     * To get the range value
     *
     * @param {number} x xValue
     */
    RangeSlider.prototype.getRangeValue = function (x) {
        var control = this.control;
        var axisRange = control.chartSeries.xAxis.actualRange;
        var bounds = control.bounds;
        return getRangeValueXByPoint(x, bounds.width, axisRange, control.enableRtl);
    };
    /**
     * Moused down handler for slider perform here
     *
     * @param {PointerEvent} e mouse event argument
     */
    RangeSlider.prototype.mouseDownHandler = function (e) {
        this.currentSlider = this.getCurrentSlider(e.target.id);
        this.selectedElement.style.cursor = '-webkit-grabbing';
        this.isDrag = !(this.currentSlider === 'UnSelectedArea' || !this.currentSlider);
        this.previousMoveX = this.control.mouseDownX;
    };
    /**
     * To get the current slider element
     *
     * @param {string} id slider element id
     */
    RangeSlider.prototype.getCurrentSlider = function (id) {
        var hoverColor = this.control.themeStyle.thumbHoverColor;
        if (id.indexOf(this.elementId + '_LeftSlider') > -1) {
            this.leftSlider.childNodes[2].setAttribute('fill', hoverColor);
            return 'Left';
        }
        else if (id.indexOf(this.elementId + '_RightSlider') > -1) {
            this.rightSlider.childNodes[2].setAttribute('fill', hoverColor);
            return 'Right';
        }
        else if (id.indexOf(this.elementId + '_SelectedArea') > -1) {
            return 'Middle';
        }
        else if (id.indexOf('UnSelectedArea') > -1) {
            this.leftSlider.childNodes[2].setAttribute('fill', this.thumbColor);
            this.rightSlider.childNodes[2].setAttribute('fill', this.thumbColor);
            return 'UnSelectedArea';
        }
        else if (id.indexOf(this.elementId + '_AxisLabel_') > -1 && (this.control.valueType === 'DateTime' || this.control.valueType === 'DateTimeCategory')) {
            this.labelIndex = +id.substring(id.lastIndexOf('_') + 1, id.length);
            return 'firstLevelLabels';
        }
        else if (id.indexOf(this.elementId + '_SecondaryLabel') > -1 && (this.control.valueType === 'DateTime' || this.control.valueType === 'DateTimeCategory')) {
            this.labelIndex = +id.substring(id.lastIndexOf('_') + 1, id.length);
            return 'secondLevelLabels';
        }
        else {
            this.leftSlider.childNodes[2].setAttribute('fill', this.thumbColor);
            this.rightSlider.childNodes[2].setAttribute('fill', this.thumbColor);
            if (this.control.periodSelectorModule) {
                this.control.periodSelectorModule.triggerChange = true;
            }
            return null;
        }
    };
    /**
     * Mouse up handler performed here
     */
    RangeSlider.prototype.mouseUpHandler = function () {
        var control = this.control;
        var range = control.chartSeries.xAxis.actualRange;
        var trigger = control.enableDeferredUpdate;
        var enabledTooltip = control.tooltip.enable;
        if (control.stockChart) {
            control.stockChart.zoomChange = false;
        }
        if (this.currentSlider === 'UnSelectedArea') {
            var value = void 0;
            var start = void 0;
            var end = void 0;
            var isRtl = control.enableRtl;
            var difference = control.endValue - control.startValue;
            if (control.mouseDownX < this.startX) {
                value = Math.max(this.getRangeValue((control.mouseDownX - (this.sliderWidth / 2) - control.bounds.x)), range.min);
                end = isRtl ? value : (value + difference);
                start = isRtl ? (value - difference) : value;
            }
            else {
                value = Math.min(this.getRangeValue((control.mouseDownX + (this.sliderWidth / 2) - control.bounds.x)), range.max);
                start = isRtl ? value : (value - difference);
                end = isRtl ? (value + difference) : value;
            }
            this.performAnimation(start, end, control);
            trigger = false;
        }
        else if (this.currentSlider === 'firstLevelLabels' || this.currentSlider === 'secondLevelLabels') {
            var secondLabel = control.rangeAxis[this.currentSlider][this.labelIndex + 1];
            if (this.selectedPeriod) {
                var periodSelectorModule = this.control.periodSelectorModule;
                if (periodSelectorModule) {
                    var buttons = periodSelectorModule.control.periods;
                    buttons.map(function (period) {
                        period.selected = false;
                    });
                    periodSelectorModule.selectedIndex = undefined;
                    var selectedIndex = periodSelectorModule.findSelectedIndex(control.rangeAxis[this.currentSlider][this.labelIndex].value, (secondLabel ? (control.allowIntervalData ? secondLabel.value - 1 : secondLabel.value) : range.max), buttons);
                    periodSelectorModule.setSelectedStyle(selectedIndex);
                }
            }
            /**
             * One millisecond is subtracted from the label to indicate the previous label value
             */
            this.performAnimation(control.rangeAxis[this.currentSlider][this.labelIndex].value, (secondLabel ? (control.allowIntervalData ? secondLabel.value - 1 : secondLabel.value) : range.max), control);
            trigger = false;
        }
        else if (this.currentSlider === null) {
            trigger = false;
        }
        if (this.isDrag && control.allowSnapping) {
            this.setAllowSnapping(control, this.currentStart, this.currentEnd, true, enabledTooltip);
            trigger = false;
        }
        if (trigger) {
            this.setSlider(this.currentStart, this.currentEnd, true, enabledTooltip);
        }
        if (this.currentSlider !== null) {
            if (this.control.periodSelectorSettings.periods.length > 0) {
                this.control.periodSelectorModule.triggerChange = false;
                this.control.periodSelectorModule.datePicker.startDate = this.control.periodSelectorModule.isDatetimeCategory ? new Date(this.control.periodSelectorModule.sortedData[Math.floor(this.currentStart)]) : new Date(this.currentStart);
                this.control.periodSelectorModule.datePicker.endDate = this.control.periodSelectorModule.isDatetimeCategory ? new Date(this.control.periodSelectorModule.sortedData[Math.floor(this.currentEnd)]) : new Date(this.currentEnd);
            }
        }
        this.selectedElement.style.cursor = '-webkit-grab';
        control.startValue = this.currentStart;
        control.endValue = this.currentEnd;
        this.isDrag = false;
        this.labelIndex = null;
        this.currentSlider = null;
    };
    /**
     * Allow Snapping perfomed here
     *
     * @param {RangeNavigator} control RangeNavigator instance
     * @param {number} start start
     * @param {number} end end
     * @param {boolean} trigger trigger
     * @param {boolean} tooltip tooltip
     * @private
     */
    RangeSlider.prototype.setAllowSnapping = function (control, start, end, trigger, tooltip) {
        var values = control.rangeAxis.lowerValues;
        values.push(control.chartSeries.xAxis.actualRange.max);
        this.setSlider(getNearestValue(values, start), getNearestValue(values, end), trigger, tooltip);
        control.startValue = this.currentStart;
        control.endValue = this.currentEnd;
    };
    /**
     * Animation Calculation for slider navigation.
     */
    RangeSlider.prototype.performAnimation = function (start, end, control, animationDuration) {
        var _this = this;
        var currentStart = this.currentStart;
        var currentEnd = this.currentEnd;
        var isDeffered = control.enableDeferredUpdate;
        var enableTooltip = control.tooltip.enable;
        new Animation({}).animate(createElement('div'), {
            duration: (this.control.animationDuration === 0 && animationMode === 'Enable') ? 1000 : this.control.animationDuration,
            progress: function (args) {
                _this.setSlider(linear(args.timeStamp, 0, start - currentStart, args.duration) + currentStart, linear(args.timeStamp, 0, end - currentEnd, args.duration) + currentEnd, !isDeffered, enableTooltip);
            },
            end: function () {
                if (control.allowSnapping) {
                    _this.setAllowSnapping(control, start, end, true, enableTooltip);
                }
                else {
                    _this.setSlider(start, end, true, enableTooltip);
                }
                _this.control.startValue = _this.currentStart;
                _this.control.endValue = _this.currentEnd;
                if (_this.control.periodSelectorSettings.periods.length > 0) {
                    _this.control.periodSelectorModule.triggerChange = false;
                    _this.control.periodSelectorModule.datePicker.startDate = _this.control.periodSelectorModule.isDatetimeCategory ? new Date(_this.control.periodSelectorModule.sortedData[Math.floor(_this.currentStart)]) : new Date(_this.currentStart);
                    _this.control.periodSelectorModule.datePicker.endDate = _this.control.periodSelectorModule.isDatetimeCategory ? new Date(_this.control.periodSelectorModule.sortedData[Math.floor(_this.currentEnd)]) : new Date(_this.currentEnd);
                }
            }
        });
    };
    /**
     * Mouse Cancel Handler
     */
    RangeSlider.prototype.mouseCancelHandler = function () {
        if (this.isDrag && this.control.allowSnapping) {
            this.setAllowSnapping(this.control, this.currentStart, this.currentEnd, false, this.control.tooltip.enable);
        }
        this.isDrag = false;
        this.currentSlider = null;
        this.control.startValue = this.currentStart;
        this.control.endValue = this.currentEnd;
    };
    /**
     * Destroy Method Calling here
     */
    RangeSlider.prototype.destroy = function () {
        this.removeEventListener();
    };
    return RangeSlider;
}());

/** @private */
// tslint:disable-next-line:max-func-body-length
function getRangeThemeColor(theme, range) {
    var thumbSize = range.navigatorStyleSettings.thumb;
    var thumbWidth = isNullOrUndefined(thumbSize.width) ? (Browser.isDevice ? 15 : 20) : thumbSize.width;
    var thumbHeight = isNullOrUndefined(thumbSize.height) ? (Browser.isDevice ? 15 : 20) : thumbSize.height;
    var darkAxisColor = (theme === 'HighContrast') ? '#969696' : '#6F6C6C';
    var darkGridlineColor = (theme === 'HighContrast') ? '#4A4848' : '#414040';
    var style = {
        gridLineColor: '#E0E0E0',
        axisLineColor: '#000000',
        labelFontColor: '#686868',
        unselectedRectColor: range.series.length ? 'rgba(255, 255, 255, 0.6)' : '#EEEEEE',
        thumpLineColor: 'rgba(189, 189, 189, 1)',
        thumbBackground: 'rgba(250, 250, 250, 1)',
        gripColor: '#757575',
        background: '#FFFFFF',
        thumbHoverColor: '#EEEEEE',
        selectedRegionColor: range.series.length ? 'transparent' : '#FF4081',
        tooltipBackground: theme === 'Material' ? '#000816' : theme === 'Fabric' ? '#FFFFFF' : '#212529',
        tooltipFontColor: '#dbdbdb',
        thumbWidth: thumbWidth,
        thumbHeight: thumbHeight,
        axisLabelFont: {
            color: theme === 'Material' ? 'rgba(97, 97, 97, 1)' : theme === 'Fabric' ? '#666666' : '#676767', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
        },
        tooltipLabelFont: {
            color: theme === 'Material' ? 'rgba(249, 250, 251, 1)' : theme === 'Fabric' ? '#333333' : '#F9FAFB', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
        }
    };
    switch (theme) {
        case 'Fabric':
            style.selectedRegionColor = range.series.length ? 'transparent' : '#007897';
            break;
        case 'Bootstrap':
            style.selectedRegionColor = range.series.length ? 'transparent' : '#428BCA';
            break;
        case 'HighContrastLight':
            style = {
                gridLineColor: '#bdbdbd',
                axisLineColor: '#969696',
                labelFontColor: '#ffffff',
                unselectedRectColor: range.series.length ? 'rgba(255, 255, 255, 0.3)' : '#EEEEEE',
                thumpLineColor: '#ffffff',
                thumbBackground: '#262626',
                gripColor: '#ffffff',
                background: 'transparent',
                thumbHoverColor: '#BFBFBF',
                selectedRegionColor: range.series.length ? 'transparent' : '#FFD939',
                tooltipBackground: '#ffffff',
                tooltipFontColor: '#000000',
                thumbWidth: thumbWidth,
                thumbHeight: thumbHeight,
                axisLabelFont: {
                    color: '#969696', fontFamily: 'Segoe UI'
                },
                tooltipLabelFont: {
                    color: '#000000', fontFamily: 'Segoe UI'
                }
            };
            break;
        case 'HighContrast':
            style = {
                gridLineColor: darkGridlineColor,
                axisLineColor: darkAxisColor,
                labelFontColor: '#DADADA',
                unselectedRectColor: range.series.length ? 'rgba(43, 43, 43, 0.6)' : '#514F4F',
                thumpLineColor: '#969696',
                thumbBackground: '#333232',
                gripColor: '#DADADA',
                background: 'transparent',
                thumbHoverColor: '#BFBFBF',
                selectedRegionColor: range.series.length ? 'rgba(22, 22, 22, 0.6)' : '#FFD939',
                tooltipBackground: '#FFFFFF',
                tooltipFontColor: '#282727',
                thumbWidth: thumbWidth,
                thumbHeight: thumbHeight,
                axisLabelFont: {
                    color: '#969696', fontFamily: 'Segoe UI'
                },
                tooltipLabelFont: {
                    color: '#000000', fontFamily: 'Segoe UI'
                }
            };
            break;
        case 'MaterialDark':
        case 'FabricDark':
        case 'BootstrapDark':
            style = {
                labelFontColor: '#DADADA',
                axisLineColor: ' #6F6C6C',
                gridLineColor: '#414040',
                tooltipBackground: theme === 'FabricDark' ? '#A19F9D' : theme === 'BootstrapDark' ? '#F0F0F0' : '#F4F4F4',
                tooltipFontColor: '#333232',
                unselectedRectColor: range.series.length ? 'rgba(43, 43, 43, 0.6)' : '#514F4F',
                thumpLineColor: '#969696',
                thumbBackground: '#333232',
                gripColor: '#DADADA',
                background: 'transparent',
                thumbHoverColor: '#BFBFBF',
                selectedRegionColor: range.series.length ? 'rgba(22, 22, 22, 0.6)' :
                    theme === 'FabricDark' ? '#007897' : theme === 'BootstrapDark' ? '#428BCA' : '#FF4081',
                thumbWidth: thumbWidth,
                thumbHeight: thumbHeight,
                axisLabelFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : theme === 'FabricDark' ? '#A19F9D' : '#CED4DA', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                tooltipLabelFont: {
                    color: theme === 'MaterialDark' ? 'rgba(18, 18, 18, 1)' : theme === 'FabricDark' ? '#DADADA' : '#1A1A1A', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                }
            };
            break;
        case 'Bootstrap4':
            style = {
                gridLineColor: '#E0E0E0',
                axisLineColor: '#CED4DA',
                labelFontColor: '#212529',
                unselectedRectColor: range.series.length ? 'rgba(255, 255, 255, 0.6)' : '#514F4F',
                thumpLineColor: 'rgba(189, 189, 189, 1)',
                thumbBackground: '#FFFFFF',
                gripColor: '#495057',
                background: 'transparent',
                thumbHoverColor: '#EEEEEE',
                selectedRegionColor: range.series.length ? 'transparent' : '#FFD939',
                tooltipBackground: '#212529',
                tooltipFontColor: 'rgba(255, 255, 255)',
                thumbWidth: thumbWidth,
                thumbHeight: thumbHeight,
                axisLabelFont: {
                    color: '#495057', fontFamily: 'Helvetica'
                },
                tooltipLabelFont: {
                    color: '#F9FAFB', fontFamily: 'Helvetica'
                }
            };
            break;
        case 'Tailwind':
            style = {
                gridLineColor: '#E5E7EB',
                axisLineColor: '#D1D5DB',
                labelFontColor: '#6B7280',
                unselectedRectColor: range.series.length ? 'transparent' : '#E5E7EB',
                thumpLineColor: '#9CA3AF',
                thumbBackground: '#FFFFFF',
                gripColor: '#6B7280',
                background: 'transparent',
                thumbHoverColor: '#374151',
                selectedRegionColor: range.series.length ? 'rgba(79, 70, 229, 0.3)' : '#4F46E5',
                tooltipBackground: '#111827',
                tooltipFontColor: '#F9FAFB',
                thumbWidth: thumbWidth,
                thumbHeight: thumbHeight,
                axisLabelFont: {
                    color: '#6B7280', fontFamily: 'Inter'
                },
                tooltipLabelFont: {
                    color: '#F9FAFB', fontFamily: 'Inter'
                }
            };
            break;
        case 'TailwindDark':
            style = {
                gridLineColor: '#374151',
                axisLineColor: '#4B5563',
                labelFontColor: '#9CA3AF',
                unselectedRectColor: range.series.length ? 'transparent' : '#4B5563',
                thumpLineColor: '#6B7280',
                thumbBackground: '#1F2937',
                gripColor: '#D1D5DB',
                background: 'transparent',
                thumbHoverColor: '#E5E7EB',
                selectedRegionColor: range.series.length ? 'rgba(255, 255, 255, 0.6)' : '#22D3EE',
                tooltipBackground: '#E9ECEF',
                tooltipFontColor: '#1F2937',
                thumbWidth: thumbWidth,
                thumbHeight: thumbHeight,
                axisLabelFont: {
                    color: '#9CA3AF', fontFamily: 'Inter'
                },
                tooltipLabelFont: {
                    color: '#1F2937', fontFamily: 'Inter'
                }
            };
            break;
        case 'Bootstrap5':
            style = {
                gridLineColor: '#E5E7EB',
                axisLineColor: '#E5E7EB',
                labelFontColor: '#495057',
                unselectedRectColor: range.series.length ? 'transparent' : '#E5E7EB',
                thumpLineColor: '#0D6EFD',
                thumbBackground: '#FFFFFF',
                gripColor: '#0D6EFD',
                background: 'transparent',
                thumbHoverColor: '#EEEEEE',
                selectedRegionColor: range.series.length ? 'rgba(13, 110, 253, 0.1)' : '#4F46E5',
                tooltipBackground: '#212529',
                tooltipFontColor: '#F9FAFB',
                thumbWidth: thumbWidth,
                thumbHeight: thumbHeight,
                axisLabelFont: {
                    color: '#495057', fontFamily: 'Helvetica'
                },
                tooltipLabelFont: {
                    color: '#F9FAFB', fontFamily: 'Helvetica'
                }
            };
            break;
        case 'Bootstrap5Dark':
            style = {
                gridLineColor: '#343A40',
                axisLineColor: '#343A40',
                labelFontColor: '#CED4DA',
                unselectedRectColor: range.series.length ? 'transparent' : '#E5E7EB',
                thumpLineColor: '#6C757D',
                thumbBackground: '#374151',
                gripColor: '#ADB5BD',
                background: 'transparent',
                thumbHoverColor: '#666666',
                selectedRegionColor: range.series.length ? 'rgba(173, 181, 189, 0.1)' : '#ADB5BD',
                tooltipBackground: '#E9ECEF',
                tooltipFontColor: '#212529',
                thumbWidth: thumbWidth,
                thumbHeight: thumbHeight,
                axisLabelFont: {
                    color: '#CED4DA', fontFamily: 'Helvetica'
                },
                tooltipLabelFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                }
            };
            break;
        case 'Fluent':
            style = {
                gridLineColor: '#EDEBE9',
                axisLineColor: '#D2D0CE',
                labelFontColor: '#3B3A39',
                unselectedRectColor: range.series.length ? 'transparent' : '#A19F9D',
                thumpLineColor: '#0078D4',
                thumbBackground: '#FFFFFF',
                gripColor: '#0078D4',
                background: 'transparent',
                thumbHoverColor: '#FFFFFF',
                selectedRegionColor: range.series.length ? 'rgba(0, 120, 212, 0.1)' : '#ADB5BD',
                tooltipBackground: '#FFFFFF',
                tooltipFontColor: '#323130',
                thumbWidth: thumbWidth,
                thumbHeight: thumbHeight,
                axisLabelFont: {
                    color: '#3B3A39', fontFamily: 'Segoe UI'
                },
                tooltipLabelFont: {
                    color: '#323130', fontFamily: 'Segoe UI'
                }
            };
            break;
        case 'FluentDark':
            style = {
                gridLineColor: '#414040',
                axisLineColor: '#3B3A39',
                labelFontColor: '#C8C6C4',
                unselectedRectColor: range.series.length ? 'transparent' : '#A19F9D',
                thumpLineColor: '#797775',
                thumbBackground: 'black',
                gripColor: '#797775',
                background: 'transparent',
                thumbHoverColor: 'black',
                selectedRegionColor: range.series.length ? 'rgba(121, 119, 117, 0.1)' : '#797775',
                tooltipBackground: '#323130',
                tooltipFontColor: '#F3F2F1',
                thumbWidth: thumbWidth,
                thumbHeight: thumbHeight,
                axisLabelFont: {
                    color: '#C8C6C4', fontFamily: 'Segoe UI'
                },
                tooltipLabelFont: {
                    color: '#F3F2F1', fontFamily: 'Segoe UI'
                }
            };
            break;
        case 'Material3':
            style = {
                gridLineColor: '#C4C7C5',
                axisLineColor: '#C4C7C5',
                labelFontColor: '#1E192B',
                unselectedRectColor: range.series.length ? 'transparent' : '#E5E5E5',
                thumpLineColor: '#49454E',
                thumbBackground: '#FFFFFF',
                gripColor: '#49454E',
                background: 'transparent',
                thumbHoverColor: '#FFFFFF',
                selectedRegionColor: range.series.length ? 'rgba(73, 69, 78, 0.1)' : '#49454E',
                tooltipBackground: '#313033',
                tooltipFontColor: '#F4EFF4',
                thumbWidth: thumbWidth,
                thumbHeight: thumbHeight,
                axisLabelFont: {
                    color: '#1E192B', fontFamily: 'Roboto'
                },
                tooltipLabelFont: {
                    color: '#F4EFF4', fontFamily: 'Roboto'
                }
            };
            break;
        case 'Material3Dark':
            style = {
                gridLineColor: '#444746',
                axisLineColor: '#444746',
                labelFontColor: '#E6E1E5',
                unselectedRectColor: range.series.length ? 'transparent' : '#E5E5E5',
                thumpLineColor: '#CAC4D0',
                thumbBackground: '#1C1B1F',
                gripColor: '#CAC4D0',
                background: 'transparent',
                thumbHoverColor: '#FFFFFF',
                selectedRegionColor: range.series.length ? 'rgba(202, 196, 208, 0.1)' : '#49454E',
                tooltipBackground: '#E6E1E5',
                tooltipFontColor: '#313033',
                thumbWidth: thumbWidth,
                thumbHeight: thumbHeight,
                axisLabelFont: {
                    color: '#CAC4D0', fontFamily: 'Roboto'
                },
                tooltipLabelFont: {
                    color: '#F4EFF4', fontFamily: 'Roboto'
                }
            };
            break;
        default:
            style.selectedRegionColor = range.series.length ? 'transparent' : '#FF4081';
            break;
    }
    return style;
}

/**
 * Period selector class
 */
var PeriodSelector = /** @__PURE__ @class */ (function () {
    //constructor for period selector
    function PeriodSelector(control) {
        this.control = {};
        this.isDatetimeCategory = false;
        this.sortedData = [];
        this.startValue = 0;
        this.endValue = 0;
        this.rootControl = control;
        if (this.rootControl.getModuleName() === 'stockChart') {
            this.sortedData = this.rootControl.sortedData;
            this.isDatetimeCategory = this.rootControl.isDateTimeCategory;
        }
    }
    /**
     * To set the control values
     *
     * @param control
     * @returns {void}
     */
    PeriodSelector.prototype.setControlValues = function (control) {
        if (control.getModuleName() === 'rangeNavigator') {
            this.control.periods = this.rootControl.periodSelectorSettings.periods;
            this.control.seriesXMax = control.chartSeries.xMax;
            this.control.seriesXMin = control.chartSeries.xMin;
            this.control.rangeSlider = control.rangeSlider;
            this.control.rangeNavigatorControl = control;
            this.control.endValue = control.endValue;
            this.control.startValue = control.startValue;
        }
        else {
            this.control.periods = this.rootControl.periods;
            this.control.endValue = this.control.seriesXMax = control.seriesXMax;
            this.control.startValue = this.control.seriesXMin = control.seriesXMin;
            this.control.rangeNavigatorControl = this.rootControl.rangeNavigator;
            if (this.control.rangeNavigatorControl) {
                this.control.rangeSlider = this.rootControl.rangeNavigator.rangeSlider;
            }
        }
        this.control.element = control.element;
        this.control.disableRangeSelector = control.disableRangeSelector;
    };
    /**
     * To initialize the period selector properties.
     *
     * @param options
     * @param x
     * @param options
     * @param x
     */
    PeriodSelector.prototype.appendSelector = function (options, x) {
        if (x === void 0) { x = 0; }
        this.renderSelectorElement(null, options, x);
        this.renderSelector();
    };
    /**
     * renderSelector div.
     *
     * @param control
     * @param options
     * @param x
     * @param options
     * @param x
     */
    PeriodSelector.prototype.renderSelectorElement = function (control, options, x) {
        //render border
        this.periodSelectorSize = control ? this.periodSelectorSize : new Rect(x, this.rootControl.titleSize.height ? this.rootControl.titleSize.height : 10, options.width, options.height);
        var thumbSize;
        var element;
        if (control) {
            thumbSize = control.themeStyle.thumbWidth;
            element = control.element;
        }
        else {
            thumbSize = options.thumbSize;
            element = options.element;
        }
        if (getElement$1(element.id + '_Secondary_Element')) {
            remove(getElement$1(element.id + '_Secondary_Element'));
        }
        this.periodSelectorDiv = createElement('div', {
            id: element.id + '_Secondary_Element',
            styles: 'width: ' + (this.periodSelectorSize.width - thumbSize) + 'px;height: ' +
                this.periodSelectorSize.height + 'px;top:' +
                this.periodSelectorSize.y + 'px;left:' +
                (this.periodSelectorSize.x + thumbSize / 2) + 'px; position: absolute'
        });
        element.appendChild(this.periodSelectorDiv);
    };
    /**
     * renderSelector elements.
     *
     * @returns {void}
     */
    PeriodSelector.prototype.renderSelector = function () {
        var _this = this;
        this.setControlValues(this.rootControl);
        var enableCustom = true;
        var controlId = this.control.element.id;
        var selectorElement = createElement('div', { id: controlId + '_selector' });
        var buttons = this.control.periods;
        var selector = this.updateCustomElement();
        var buttonStyles = 'text-transform: none; text-overflow: unset';
        var isStringTemplate = 'isStringTemplate';
        var dateRangeId = controlId + 'customRange';
        var selectedPeriod;
        this.periodSelectorDiv.appendChild(selectorElement);
        for (var i = 0; i < buttons.length; i++) {
            selector.push({ align: 'Left', text: buttons[i].text });
        }
        if (this.rootControl.getModuleName() === 'stockChart') {
            enableCustom = this.rootControl.enableCustomRange;
        }
        if (enableCustom) {
            this.calendarId = controlId + '_calendar';
            selector.push({ template: '<button id=' + this.calendarId + '></button>', align: 'Right' });
        }
        var selctorArgs = {
            selector: selector, name: 'RangeSelector', cancel: false, enableCustomFormat: true, content: 'Date Range'
        };
        if (this.rootControl.getModuleName() === 'stockChart') {
            if (this.rootControl.exportType.length) {
                var exportElement = createElement('button', { id: controlId + '_export', styles: buttonStyles,
                    className: 'e-dropdown-btn e-btn e-flat' });
                exportElement.innerText = 'Export';
                selector.push({ template: exportElement,
                    align: 'Right' });
            }
        }
        this.rootControl.trigger('selectorRender', selctorArgs);
        this.toolbar = new Toolbar({
            items: selctorArgs.selector, height: this.periodSelectorSize.height,
            clicked: function (args) {
                _this.buttonClick(args, _this.control);
            }, created: function () {
                _this.nodes = _this.toolbar.element.querySelectorAll('.e-toolbar-left')[0];
                if (isNullOrUndefined(_this.selectedIndex)) {
                    buttons.map(function (period, index) {
                        if (period.selected && _this.selectedPeriod !== null) {
                            selectedPeriod = period;
                            _this.control.startValue = _this.changedRange(period.intervalType, _this.control.endValue, period.interval).getTime();
                            if (_this.isDatetimeCategory) {
                                _this.control.startValue = _this.rootControl.getModuleName() !== 'stockChart' ? _this.findStartValue(_this.control.startValue, _this.control.endValue) : _this.rootControl.startValue;
                            }
                            _this.control.startValue = (period.text && period.text.toLowerCase() === 'all') ? _this.control.seriesXMin : _this.control.startValue;
                            _this.control.endValue = (period.text && period.text.toLowerCase() === 'all') ? _this.control.seriesXMax : _this.control.endValue;
                            _this.selectedIndex = (_this.nodes.childNodes.length - buttons.length) + index;
                            var slider = _this.control.rangeSlider;
                            if (slider) {
                                slider.selectedPeriod = period.text;
                            }
                        }
                    });
                }
                if (!selectedPeriod && _this.rootControl.getModuleName() !== 'stockChart') {
                    var selectedIndex = _this.findSelectedIndex(_this.control.startValue, _this.control.endValue, buttons);
                    _this.selectedIndex = selectedIndex ? selectedIndex : _this.selectedIndex;
                }
                _this.setSelectedStyle(_this.selectedIndex);
            }
        });
        this.toolbar[isStringTemplate] = true;
        this.toolbar.appendTo(selectorElement);
        this.triggerChange = true;
        if (enableCustom) {
            this.datePicker = new DateRangePicker({
                min: this.isDatetimeCategory ? new Date(this.sortedData[this.control.seriesXMin]) : new Date(this.control.seriesXMin),
                max: this.isDatetimeCategory ? new Date(this.sortedData[this.control.seriesXMax]) : new Date(this.control.seriesXMax),
                // eslint-disable-next-line no-useless-escape
                format: 'dd\'\/\'MM\'\/\'yyyy', placeholder: 'Select a range',
                showClearButton: false,
                startDate: this.isDatetimeCategory ? new Date(this.sortedData[Math.floor(this.control.startValue)]) :
                    new Date(this.control.startValue),
                endDate: this.isDatetimeCategory ? new Date(this.sortedData[Math.floor(this.control.endValue)]) :
                    new Date(this.control.endValue),
                created: function () {
                    if (selctorArgs.enableCustomFormat) {
                        var datePicker = document.getElementsByClassName('e-date-range-wrapper');
                        var datePickerElement = void 0;
                        for (var i = 0; i < datePicker.length; i++) {
                            if (datePicker[i].children[0].id.indexOf(controlId) !== -1) {
                                datePickerElement = datePicker[i];
                            }
                        }
                        datePickerElement.style.display = 'none';
                        var element = createElement('div', {
                            id: dateRangeId,
                            className: 'e-control e-btn e-dropdown-btn e-flat',
                            styles: 'font-size: 14px; font-weight: 500; text-transform: none '
                        });
                        element.innerText = selctorArgs.content;
                        datePickerElement.insertAdjacentElement('afterend', element);
                        getElement$1(dateRangeId).insertAdjacentElement('afterbegin', (createElement('span', {
                            id: controlId + 'dateIcon', className: 'e-input-group-icon e-range-icon e-btn-icon e-icons',
                            styles: 'font-size: 16px; min-height: 0px; margin: -3px 0 0 0; outline: none; min-width: 30px'
                            // fix for date range icon alignment issue.
                        })));
                        document.getElementById(dateRangeId).onclick = function () {
                            _this.datePicker.show(getElement$1(dateRangeId));
                        };
                    }
                },
                change: function (args) {
                    if (_this.triggerChange) {
                        if (_this.isDatetimeCategory) {
                            _this.startValue = args.startDate.getTime();
                            _this.endValue = args.endDate.getTime();
                            _this.findPeriodValue(_this.startValue, _this.endValue);
                        }
                        if (_this.control.rangeSlider && args.event) {
                            if (_this.rootControl.getModuleName() !== 'stockChart') {
                                _this.control.rangeNavigatorControl.startValue = _this.isDatetimeCategory ? _this.startValue :
                                    args.startDate.getTime();
                                _this.control.rangeNavigatorControl.endValue = _this.isDatetimeCategory ? _this.endValue :
                                    args.endDate.getTime();
                                _this.selectedIndex = undefined;
                                _this.selectedPeriod = null;
                                _this.control.rangeNavigatorControl.refresh();
                            }
                            _this.control.rangeSlider.performAnimation(_this.isDatetimeCategory ? _this.startValue : args.startDate.getTime(), _this.isDatetimeCategory ?
                                _this.endValue : args.endDate.getTime(), _this.control.rangeNavigatorControl);
                        }
                        else if (args.event) {
                            _this.rootControl.rangeChanged(_this.isDatetimeCategory ? _this.startValue :
                                args.startDate.getTime(), _this.isDatetimeCategory ? _this.endValue :
                                args.endDate.getTime());
                        }
                        _this.nodes = _this.toolbar.element.querySelectorAll('.e-toolbar-left')[0];
                        if (!_this.rootControl.resizeTo && _this.control.rangeSlider && _this.control.rangeSlider.isDrag) {
                            /**
                             * Issue: While disabling range navigator console error throws
                             * Fix:Check with rangeSlider present or not. Then checked with isDrag.
                             */
                            for (var i = 0, length_1 = _this.nodes.childNodes.length; i < length_1; i++) {
                                _this.nodes.childNodes[i].childNodes[0].classList.remove('e-active');
                                _this.nodes.childNodes[i].childNodes[0].classList.remove('e-active');
                            }
                        }
                    }
                }
            });
            this.datePicker.appendTo('#' + this.calendarId);
        }
    };
    /**
     * To find start and end value
     * @param startValue
     * @param endValue
     */
    PeriodSelector.prototype.findPeriodValue = function (startValue, endValue) {
        for (var index = 0; index < (this.sortedData).length; index++) {
            if ((this.sortedData[index]) >= startValue) {
                this.startValue = index;
                break;
            }
        }
        for (var index = this.sortedData.length - 1; index >= 0; index--) {
            if ((this.sortedData[index]) <= endValue) {
                this.endValue = index;
                break;
            }
        }
    };
    PeriodSelector.prototype.findSelectedIndex = function (startDate, endDate, buttons) {
        var daysDiffence = (endDate - startDate) / (1000 * 60 * 60 * 24);
        var selectedIndex;
        for (var i = 0; i < buttons.length; i++) {
            var period = buttons[i];
            if (period.intervalType === 'Years' && daysDiffence / 365 === period.interval) {
                selectedIndex = i;
            }
            else if (period.intervalType === 'Months' && (daysDiffence / 30 === period.interval || daysDiffence / 31 === period.interval)) {
                selectedIndex = i;
            }
            else if (period.intervalType === 'Days' && daysDiffence === period.interval) {
                selectedIndex = i;
            }
            else if (period.intervalType === 'Weeks' && daysDiffence / 7 === period.interval) {
                selectedIndex = i;
            }
            else if (period.intervalType === 'Hours' && daysDiffence * 24 === period.interval) {
                selectedIndex = i;
            }
            else if (period.intervalType === 'Seconds' && (daysDiffence * 24 * 3600) === period.interval) {
                selectedIndex = i;
            }
        }
        return selectedIndex;
    };
    PeriodSelector.prototype.updateCustomElement = function () {
        var selector = [];
        var controlId = this.rootControl.element.id;
        var buttonStyles = 'text-transform: none; text-overflow: unset';
        var className = 'e-dropdown-btn e-btn e-flat';
        if (this.rootControl.getModuleName() === 'stockChart') {
            if (this.rootControl.seriesType.length) {
                var SeriesElement = createElement('button', { id: controlId + '_seriesType',
                    styles: buttonStyles,
                    className: className });
                SeriesElement.innerText = 'Series';
                selector.push({ template: SeriesElement,
                    align: 'Left' });
            }
            if (this.rootControl.indicatorType.length) {
                var indicatorElement = createElement('button', {
                    id: controlId + '_indicatorType',
                    styles: buttonStyles,
                    className: className
                });
                indicatorElement.innerText = 'Indicators';
                selector.push({ template: indicatorElement,
                    align: 'Left' });
            }
            if (this.rootControl.trendlineType.length) {
                var trendlineElement = createElement('button', {
                    id: controlId + '_trendType',
                    styles: buttonStyles,
                    className: className
                });
                trendlineElement.innerText = 'Trendline';
                selector.push({ template: trendlineElement,
                    align: 'Left' });
            }
        }
        return selector;
    };
    /**
     * To set and remove the period style.
     *
     * @param buttons
     * @param selectedIndex
     * @returns {void}
     */
    PeriodSelector.prototype.setSelectedStyle = function (selectedIndex) {
        for (var i = 0, length_2 = this.nodes.childNodes.length; i < length_2; i++) {
            this.nodes.childNodes[i].childNodes[0].classList.remove('e-active');
        }
        if (!isNullOrUndefined(selectedIndex)) {
            this.nodes.childNodes[selectedIndex].childNodes[0].classList.add('e-flat');
            this.nodes.childNodes[selectedIndex].childNodes[0].classList.add('e-active');
        }
    };
    /**
     * Button click handling.
     *
     * @param args
     * @param control
     * @param args
     * @param control
     */
    PeriodSelector.prototype.buttonClick = function (args, control) {
        var _this = this;
        var clickedEle = args.item;
        var slider = this.control.rangeSlider;
        var buttons = this.control.periods;
        var button = buttons.filter(function (btn) { return (btn.text === clickedEle.text); });
        var updatedStart;
        var updatedEnd;
        buttons.map(function (period, index) {
            if (period.selected && _this.rootControl.getModuleName() !== 'stockChart') {
                period.selected = false;
            }
            if (period.text === args.item.text) {
                _this.selectedIndex = (_this.nodes.childNodes.length - buttons.length) + index;
                if (_this.rootControl.getModuleName() !== 'stockChart') {
                    period.selected = true;
                }
            }
        });
        if (args.item.text !== '') {
            this.setSelectedStyle(this.selectedIndex);
        }
        if (slider && clickedEle.text) {
            slider.selectedPeriod = clickedEle.text;
        }
        if (clickedEle.text.toLowerCase() === 'all') {
            updatedStart = control.seriesXMin;
            updatedEnd = control.seriesXMax;
            if (slider) {
                slider.performAnimation(updatedStart, updatedEnd, this.control.rangeNavigatorControl);
            }
            else {
                this.rootControl.rangeChanged(updatedStart, updatedEnd);
            }
        }
        else if (clickedEle.text.toLowerCase() === 'ytd') {
            if (slider) {
                updatedStart = this.isDatetimeCategory ?
                    new Date(new Date(this.sortedData[Math.floor(slider.currentEnd)]).getFullYear().toString()).getTime() :
                    new Date(new Date(slider.currentEnd).getFullYear().toString()).getTime();
                updatedStart = this.isDatetimeCategory ? this.findStartValue(updatedStart, slider.currentEnd) : updatedStart;
                updatedEnd = slider.currentEnd;
                slider.performAnimation(updatedStart, updatedEnd, this.control.rangeNavigatorControl);
            }
            else {
                updatedStart = this.isDatetimeCategory ? new Date(new Date(this.sortedData[Math.floor(this.rootControl.currentEnd)]).getFullYear().toString()).getTime() :
                    new Date(new Date(this.rootControl.currentEnd).getFullYear().toString()).getTime();
                updatedStart = this.isDatetimeCategory ? this.findStartValue(updatedStart, this.rootControl.currentEnd) :
                    updatedStart;
                updatedEnd = this.rootControl.currentEnd;
                this.rootControl.rangeChanged(updatedStart, updatedEnd);
            }
        }
        else if (clickedEle.text.toLowerCase() !== '') {
            if (slider) {
                updatedStart = this.changedRange(button[0].intervalType, slider.currentEnd, button[0].interval).getTime();
                updatedStart = this.isDatetimeCategory ? this.findStartValue(updatedStart, slider.currentEnd) : updatedStart;
                updatedEnd = slider.currentEnd;
                slider.performAnimation(updatedStart, updatedEnd, this.control.rangeNavigatorControl);
            }
            else {
                updatedStart = this.changedRange(button[0].intervalType, this.rootControl.currentEnd, button[0].interval).getTime();
                updatedStart = this.isDatetimeCategory ? this.findStartValue(updatedStart, this.rootControl.currentEnd) :
                    updatedStart;
                updatedEnd = this.rootControl.currentEnd;
                this.rootControl.rangeChanged(updatedStart, updatedEnd);
            }
        }
        if (this.rootControl.getModuleName() === 'stockChart') {
            this.rootControl.zoomChange = false;
        }
        if (getElement$1(this.calendarId + '_popup') && !Browser.isDevice) {
            var element = getElement$1(this.calendarId + '_popup');
            element.querySelectorAll('.e-range-header')[0].style.display = 'none';
        }
    };
    /**
     * To find the start value
     * @param startValue
     * @param endValue
     */
    PeriodSelector.prototype.findStartValue = function (startValue, endValue) {
        for (var index = Math.floor(endValue); index >= 0; index--) {
            if (this.sortedData[index] <= startValue) {
                return (index + 1);
            }
        }
        return 0;
    };
    /**
     *
     * @param type updatedRange for selector
     * @param end
     * @param interval
     */
    PeriodSelector.prototype.changedRange = function (type, end, interval) {
        var result = this.isDatetimeCategory ? new Date(this.sortedData[Math.floor(end)]) : new Date(end);
        switch (type) {
            case 'Quarter':
                result.setMonth(result.getMonth() - (3 * interval));
                break;
            case 'Months':
                result.setMonth(result.getMonth() - interval);
                break;
            case 'Weeks':
                result.setDate(result.getDate() - (interval * 7));
                break;
            case 'Days':
                result.setDate(result.getDate() - interval);
                break;
            case 'Hours':
                result.setHours(result.getHours() - interval);
                break;
            case 'Minutes':
                result.setMinutes(result.getMinutes() - interval);
                break;
            case 'Seconds':
                result.setSeconds(result.getSeconds() - interval);
                break;
            default:
                result.setFullYear(result.getFullYear() - interval);
                break;
        }
        return result;
    };
    /**
     * Get module name
     *
     * @returns {string}
     */
    PeriodSelector.prototype.getModuleName = function () {
        return 'PeriodSelector';
    };
    /**
     * To destroy the period selector.
     *
     * @returns {void}
     * @private
     */
    PeriodSelector.prototype.destroy = function () {
        /**
         * destroy method
         */
    };
    return PeriodSelector;
}());

var __extends$77 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$10 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable jsdoc/valid-types */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * Range Navigator
 */
var RangeNavigator = /** @__PURE__ @class */ (function (_super) {
    __extends$77(RangeNavigator, _super);
    /**
     * Constructor for creating the widget
     *
     * @hidden
     */
    function RangeNavigator(options, element) {
        var _this = _super.call(this, options, element) || this;
        /** @private */
        _this.animateSeries = true;
        _this.chartid = 57725;
        _this.redraw = false;
        return _this;
    }
    /**
     * Starting point of the control initialization
     */
    RangeNavigator.prototype.preRender = function () {
        this.unWireEvents();
        this.setCulture();
        this.allowServerDataBinding = false;
        if (this.periodSelectorModule) {
            this.periodSelectorModule.selectedIndex = null;
        }
        if (this.element.id === '') {
            var collection = document.getElementsByClassName('e-rangenavigator').length;
            this.element.id = 'rangenavigator_' + this.chartid + '_' + collection;
        }
        this.wireEvents();
    };
    /**
     * To initialize the private variables
     */
    RangeNavigator.prototype.initPrivateVariables = function () {
        this.doubleModule = new Double();
        this.labels = [];
        this.rangeSlider = new RangeSlider(this);
        this.chartSeries = new RangeSeries(this);
        this.lineSeriesModule = new LineSeries();
        this.rangeAxis = new RangeNavigatorAxis(this);
    };
    /**
     * Method to set culture for chart
     */
    RangeNavigator.prototype.setCulture = function () {
        this.intl = new Internationalization();
    };
    /**
     * to initialize the slider
     */
    RangeNavigator.prototype.setSliderValue = function () {
        var isDateTime = this.valueType === 'DateTime';
        var isDateTimeCategory = this.valueType === 'DateTimeCategory';
        var range = this.chartSeries.xAxis.actualRange;
        this.startValue = (this.startValue || (isDateTimeCategory && this.startValue === 0)) ? this.startValue : (!this.value[0] ?
            range.min : (isDateTime ? (new Date(this.value[0].toString())).getTime() : isDateTimeCategory ?
            this.getRangeValue(new Date(this.value[0].toString()).getTime(), true) : +this.value[0]));
        this.endValue = (this.endValue || (isDateTimeCategory && this.endValue === 0)) ? this.endValue : (!this.value[1] ? range.max :
            (isDateTime ? (new Date(this.value[1].toString())).getTime() : isDateTimeCategory ?
                this.getRangeValue(new Date(this.value[1].toString()).getTime(), false) : +this.value[1]));
    };
    /**
     * To find the start and end value in the date-time category.
     */
    RangeNavigator.prototype.getRangeValue = function (value, isStart) {
        var labels = this.chartSeries.xAxis.labels;
        var index = labels.length - 1;
        while (index >= 0 && parseInt(labels[index], 10) > value) {
            index--;
        }
        return isStart ? (index !== -1 ? index : this.chartSeries.xAxis.actualRange.min) :
            (index === 0 ? this.chartSeries.xAxis.actualRange.max : index);
    };
    /**
     * To render the range navigator
     */
    RangeNavigator.prototype.render = function () {
        var _this = this;
        var loadEventData = {
            name: 'load', rangeNavigator: this,
            theme: this.theme
        };
        this.trigger('load', loadEventData, function () {
            //this.theme = this.theme;
            _this.setTheme();
            _this.initPrivateVariables();
            _this.createRangeSvg();
            _this.calculateBounds();
            _this.chartSeries.renderChart(_this);
            removeElement$1('chartmeasuretext');
            _this.renderComplete();
            _this.allowServerDataBinding = true;
        });
        this.element.setAttribute('tabindex', '0');
        this.element.setAttribute('role', 'region');
        this.element.setAttribute('aria-label', 'Range navigator' + ' Syncfusion interactive chart.');
    };
    /**
     * Theming for rangeNavigator
     */
    RangeNavigator.prototype.setTheme = function () {
        /*! Set theme */
        this.themeStyle = getRangeThemeColor(this.theme, this);
    };
    /**
     * Method to create SVG for Range Navigator
     */
    RangeNavigator.prototype.createRangeSvg = function () {
        this.removeSvg();
        createSvg(this);
        this.renderChartBackground();
    };
    /**
     * Bounds calculation for widget performed.
     */
    RangeNavigator.prototype.calculateBounds = function () {
        var labelPadding = this.enableGrouping ? 15 : 8;
        var thumb = this.navigatorStyleSettings.thumb;
        var labelSize = measureText('tempString', this.labelStyle, this.themeStyle.axisLabelFont).height;
        var margin = this.margin;
        var isLeightWeight = !this.series.length;
        var tooltipSpace = (!this.disableRangeSelector) &&
            isLeightWeight && this.tooltip.enable ? 35 : 0;
        if (!this.periodSelectorModule && this.periodSelectorSettings.periods.length && !this.stockChart) {
            this.periodSelectorModule = new PeriodSelector(this);
        }
        var selector = this.periodSelectorModule;
        if (this.periodSelectorModule && this.periodSelectorSettings.periods.length > 0) {
            selector.periodSelectorSize = { x: 0, y: 0, height: 0, width: 0 };
            selector.periodSelectorSize.width = this.availableSize.width;
            selector.periodSelectorSize.height = this.periodSelectorSettings.height;
            selector.periodSelectorSize.y = this.periodSelectorSettings.position === 'Bottom' ?
                this.availableSize.height - selector.periodSelectorSize.height : 0;
        }
        var periodSelectorY = this.periodSelectorSettings.position === 'Top' && selector ?
            selector.periodSelectorSize.y + selector.periodSelectorSize.height : 0;
        var left = 0;
        var top = 0;
        if (this.stockChart && this.stockChart.stockLegendModule && this.stockChart.legendSettings.visible) {
            if (this.stockChart.legendSettings.position === 'Left') {
                left += this.stockChart.stockLegendModule.legendBounds.width;
            }
            else if (this.stockChart.legendSettings.position === 'Top') {
                top += this.stockChart.stockLegendModule.legendBounds.height;
            }
        }
        this.bounds = new Rect((this.themeStyle.thumbWidth / 2 + thumb.border.width + margin.left + left), margin.top + tooltipSpace + periodSelectorY + top, this.availableSize.width - this.themeStyle.thumbWidth - (thumb.border.width * 2) - margin.left - margin.right, this.availableSize.height - margin.top - margin.bottom - tooltipSpace - (selector ? selector.periodSelectorSize.height : 0));
        var deductHeight = ((this.labelPosition === 'Outside' || isLeightWeight) ?
            (labelSize + labelPadding) : 0) + ((this.tickPosition === 'Outside' || isLeightWeight) ?
            (this.majorTickLines.height) : 0);
        this.bounds.height -= deductHeight;
        if (isLeightWeight) {
            var height = this.enableGrouping ? this.bounds.height - ((labelSize) + labelPadding) : this.bounds.height;
            this.bounds.y += (this.themeStyle.thumbHeight > height ? (this.themeStyle.thumbHeight - height) / 2 : 0);
        }
        if (this.disableRangeSelector) {
            this.bounds.y = 0;
            this.bounds.height = this.periodSelectorSettings.periods.length > 0 ? this.periodSelectorSettings.height : 0;
        }
    };
    /**
     * Creating Chart for range navigator
     */
    RangeNavigator.prototype.renderChart = function (resize) {
        if (resize === void 0) { resize = false; }
        this.chartSeries.renderSeries(this);
        this.chartSeries.appendSeriesElements(this);
        this.rangeAxis.renderGridLines();
        this.rangeAxis.renderAxisLabels();
        this.createSecondaryElement();
        this.setSliderValue();
        this.renderPeriodSelector();
        this.renderSlider(resize);
        if (!this.stockChart) {
            this.element.appendChild(this.svgObject);
        }
        this.trigger('loaded', { rangeNavigator: this });
        this.rangeSlider.setSlider(this.startValue, this.endValue, false, this.tooltip.enable && this.tooltip.displayMode === 'Always', resize);
    };
    /**
     * To render period selector value
     */
    RangeNavigator.prototype.renderPeriodSelector = function () {
        if (this.periodSelectorModule) {
            this.periodSelectorModule.renderSelectorElement(this);
            this.periodSelectorModule.renderSelector();
        }
    };
    /**
     * Creating secondary range navigator
     */
    RangeNavigator.prototype.createSecondaryElement = function () {
        // For userInteraction
        if (this.tooltip.enable) {
            var tooltipDiv = this.createElement('div');
            tooltipDiv.id = this.element.id + '_Secondary_Element';
            tooltipDiv.style.position = 'relative';
            this.element.appendChild(tooltipDiv);
        }
    };
    /**
     * Slider Calculation ane rendering performed here
     */
    RangeNavigator.prototype.renderSlider = function (resize) {
        this.rangeSlider.render(this);
        if (this.periodSelectorModule) {
            this.startValue = this.periodSelectorModule.control.startValue;
            this.endValue = this.periodSelectorModule.control.endValue;
        }
        this.rangeSlider.setSlider(this.startValue, this.endValue, true, this.tooltip.enable && this.tooltip.displayMode === 'Always', resize);
    };
    /**
     * To Remove the SVG.
     *
     * @returns {void}
     * @private
     */
    RangeNavigator.prototype.removeSvg = function () {
        if (getElement$1(this.element.id + '_Secondary_Element')) {
            remove(getElement$1(this.element.id + '_Secondary_Element'));
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (this.isReact) {
                this.clearTemplate();
            }
        }
        var removeLength = 0;
        if (this.svgObject) {
            while (this.svgObject.childNodes.length > removeLength) {
                this.svgObject.removeChild(this.svgObject.firstChild);
            }
            if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode && !this.stockChart) {
                remove(this.svgObject);
            }
        }
    };
    /** Wire, UnWire and Event releated calculation Started here */
    /**
     * Method to un-bind events for range navigator
     */
    RangeNavigator.prototype.unWireEvents = function () {
        /*! Find the Events type */
        var startEvent = Browser.touchStartEvent;
        var moveEvent = Browser.touchMoveEvent;
        var stopEvent = Browser.touchEndEvent;
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        /*! UnBind the Event handler */
        EventHandler.remove(this.element, startEvent, this.rangeOnMouseDown);
        EventHandler.remove(this.element, moveEvent, this.mouseMove);
        EventHandler.remove(this.element, stopEvent, this.mouseEnd);
        EventHandler.remove(this.element, 'click', this.rangeOnMouseClick);
        //EventHandler.remove(this.element, 'contextmenu', this.rangeRightClick);
        EventHandler.remove(this.element, cancelEvent, this.mouseLeave);
        window.removeEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.rangeResize);
    };
    /**
     * Method to bind events for range navigator
     */
    RangeNavigator.prototype.wireEvents = function () {
        /*! Find the Events type */
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        /*! Bind the Event handler */
        EventHandler.add(this.element, Browser.touchStartEvent, this.rangeOnMouseDown, this);
        EventHandler.add(this.element, Browser.touchMoveEvent, this.mouseMove, this);
        EventHandler.add(this.element, Browser.touchEndEvent, this.mouseEnd, this);
        EventHandler.add(this.element, 'click', this.rangeOnMouseClick, this);
        //EventHandler.add(this.element, 'contextmenu', this.rangeRightClick, this);
        EventHandler.add(this.element, cancelEvent, this.mouseLeave, this);
        window.addEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.rangeResize.bind(this));
        var element = this.element;
        element.style.touchAction = 'none';
        element.style.msTouchAction = 'none';
        element.style.msContentZooming = 'none';
        element.style.msUserSelect = 'none';
        element.style.webkitUserSelect = 'none';
        element.style.position = 'relative';
        element.style.display = 'block';
    };
    /**
     * Handles the widget resize.
     *
     * @private
     */
    RangeNavigator.prototype.rangeResize = function () {
        var _this = this;
        // To avoid resize console error
        if (!document.getElementById(this.element.id)) {
            return false;
        }
        this.animateSeries = false;
        this.removeAllTooltip();
        var beforeResizeArgs = { name: 'beforeResize', cancelResizedEvent: false };
        if (this.resizeTo) {
            clearTimeout(this.resizeTo);
        }
        var arg = {
            rangeNavigator: this,
            name: 'resized',
            currentSize: new Size(0, 0),
            previousSize: new Size(this.availableSize.width, this.availableSize.height)
        };
        this.trigger(beforeResize, beforeResizeArgs);
        if (!beforeResizeArgs.cancelResizedEvent) {
            this.resizeTo = +setTimeout(function () {
                if (_this.isDestroyed) {
                    clearTimeout(_this.resizeTo);
                    return;
                }
                _this.createRangeSvg();
                arg.currentSize = _this.availableSize;
                _this.trigger('resized', arg);
                _this.calculateBounds();
                _this.chartSeries.processXAxis(_this);
                _this.chartSeries.calculateGroupingBounds(_this);
                _this.chartSeries.processYAxis(_this);
                _this.renderChart(true);
            }, 500);
        }
        return false;
    };
    /**
     * Bug task ID: EJ2-30797
     * while resizing tooltip shows in wrong position
     * Cause: Due to time lag in resize, tooltip did not remove until the component calculation
     * Fix: Removed the tooltip element on resize
     */
    RangeNavigator.prototype.removeAllTooltip = function () {
        if (this.tooltip.enable && this.tooltip.displayMode === 'Always') {
            if (getElement$1(this.element.id + '_leftTooltip')) {
                remove(getElement$1(this.element.id + '_leftTooltip'));
            }
            if (getElement$1(this.element.id + '_rightTooltip')) {
                remove(getElement$1(this.element.id + '_rightTooltip'));
            }
        }
    };
    /**
     * Handles the mouse move.
     *
     * @private
     */
    RangeNavigator.prototype.mouseMove = function (e) {
        if (this.stockChart) {
            return false;
        }
        if (getElement$1(!this.stockChart ? this.element.id + '_svg' : this.element.id)) {
            this.mouseX = this.setMouseX(e);
            this.notify(Browser.touchMoveEvent, e);
        }
        return false;
    };
    /**
     * Handles the mouse leave.
     *
     * @private
     */
    RangeNavigator.prototype.mouseLeave = function (e) {
        var rangeSlider = this.rangeSlider;
        if (rangeSlider.isDrag) {
            if (this.stockChart) {
                return false;
            }
            var enabledTooltip = rangeSlider.control.tooltip.enable;
            if (rangeSlider.control.allowSnapping) {
                rangeSlider.isDrag = false;
                rangeSlider.setAllowSnapping(rangeSlider.control, rangeSlider.currentStart, rangeSlider.currentEnd, false, enabledTooltip);
            }
            rangeSlider.triggerEvent(this.chartSeries.xAxis.actualRange);
        }
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        this.mouseX = this.setMouseX(e);
        this.notify(cancelEvent, e);
        return false;
    };
    /**
     * Handles the mouse click on range navigator.
     *
     * @private
     */
    RangeNavigator.prototype.rangeOnMouseClick = function (e) {
        this.notify('click', e);
        return false;
    };
    /**
     * Handles the print method for range navigator control.
     */
    RangeNavigator.prototype.print = function (id) {
        new PrintUtils(this).print(id);
    };
    /**
     * Handles the export method for range navigator control.
     */
    RangeNavigator.prototype.export = function (type, fileName, orientation, controls, width, height, isVertical) {
        controls = controls ? controls : [this];
        new ExportUtils(this).export(type, fileName, orientation, controls, width, height, isVertical);
    };
    /**
     * Creating a background element to the svg object
     */
    RangeNavigator.prototype.renderChartBackground = function () {
        var top = 0;
        var left = 0;
        if (this.stockChart && this.stockChart.legendSettings.visible && this.stockChart.stockLegendModule) {
            if (this.stockChart.legendSettings.position === 'Top') {
                top += this.stockChart.stockLegendModule.legendBounds.height;
            }
            else if (this.stockChart.legendSettings.position === 'Left') {
                left += this.stockChart.stockLegendModule.legendBounds.width;
            }
        }
        var rect = new RectOption(this.element.id + '_ChartBorder', this.background || this.themeStyle.background, { width: 0, color: 'transparent' }, 1, new Rect(left, top, this.availableSize.width, this.availableSize.height));
        this.svgObject.appendChild(this.renderer.drawRectangle(rect));
    };
    /**
     * Handles the mouse down on range navigator.
     *
     * @private
     */
    RangeNavigator.prototype.rangeOnMouseDown = function (e) {
        this.mouseDownX = this.setMouseX(e);
        this.notify(Browser.touchStartEvent, e);
        return false;
    };
    /**
     * Handles the mouse up.
     *
     * @private
     */
    RangeNavigator.prototype.mouseEnd = function (e) {
        this.mouseX = this.setMouseX(e);
        this.notify(Browser.touchEndEvent, e);
        return false;
    };
    // private rangeRightClick(event: MouseEvent | PointerEvent): boolean {
    //     if (event.buttons === 2 || event.which === 0 || (<PointerEvent>event).pointerType === 'touch') {
    //         event.preventDefault();
    //         event.stopPropagation();
    //         return false;
    //     }
    //     return true;
    // }
    /**
     * To find mouse x, y for aligned range navigator element svg position
     */
    RangeNavigator.prototype.setMouseX = function (e) {
        var pageX = e.type.indexOf('touch') > -1 ?
            e.changedTouches[0].clientX : e.clientX;
        var rect = this.element.getBoundingClientRect();
        var svgRect = !this.stockChart ? getElement$1(this.element.id + '_svg').getBoundingClientRect() :
            getElement$1(this.element.id).getBoundingClientRect();
        return (pageX - rect.left) - Math.max(svgRect.left - rect.left, 0);
    };
    /** Wire, UnWire and Event releated calculation End here */
    /**
     * Get the properties to be maintained in the persisted state.
     *
     * @private
     */
    RangeNavigator.prototype.getPersistData = function () {
        var keyEntity = ['loaded'];
        return this.addOnPersist(keyEntity);
    };
    /**
     * OnProperty change method calling here
     *
     * @param {RangeNavigatorModel} newProp new RangeNavigatorModel
     * @param {RangeNavigatorModel} oldProp old RangeNavigatorModel
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    RangeNavigator.prototype.onPropertyChanged = function (newProp, oldProp) {
        var renderer = false;
        var refreshBounds = false;
        var refreshRange = false;
        this.animateSeries = false;
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'width':
                case 'height':
                case 'navigatorBorder':
                case 'enableGrouping':
                case 'labelPosition':
                case 'tickPosition':
                case 'labelStyle':
                    refreshBounds = true;
                    break;
                case 'enableRtl':
                case 'xName':
                case 'yName':
                case 'query':
                case 'minimum':
                case 'maximum':
                case 'interval':
                case 'intervalType':
                case 'logBase':
                case 'valueType':
                case 'majorGridLines':
                case 'minorGridLines':
                case 'navigatorStyleSettings':
                case 'labelFormat':
                case 'skeleton':
                case 'skeletonType':
                case 'secondaryLabelAlignment':
                case 'background':
                    renderer = true;
                    break;
                case 'dataSource':
                case 'series':
                    renderer = true;
                    refreshBounds = true;
                    break;
                case 'theme':
                    this.animateSeries = true;
                    break;
                case 'locale':
                    _super.prototype.refresh.call(this);
                    break;
                case 'value':
                    this.startValue = null;
                    this.endValue = null;
                    refreshRange = true;
                    this.redraw = true;
                    break;
            }
        }
        if (!refreshBounds && renderer) {
            this.removeSvg();
            this.chartSeries.xMin = Infinity;
            this.chartSeries.xMax = -Infinity;
            this.chartSeries.renderChart(this);
        }
        // issue fix for Range Navigator size gets reduced when the data source is refreshed
        if (refreshBounds && renderer) {
            this.removeSvg();
            this.chartSeries.xMin = this.chartSeries.yMin = Infinity;
            this.chartSeries.xMax = this.chartSeries.yMax = -Infinity;
            this.calculateBounds();
            this.chartSeries.renderChart(this);
        }
        if (refreshBounds && !renderer) {
            this.removeSvg();
            this.calculateBounds();
            this.chartSeries.renderChart(this);
        }
        if (!refreshBounds && !renderer && refreshRange) {
            this.setSliderValue();
            this.rangeSlider.setSlider(this.startValue, this.endValue, true, this.tooltip.enable && this.tooltip.displayMode === 'Always');
        }
    };
    /**
     * To provide the array of modules needed for control rendering
     *
     * @returns {ModuleDeclaration[]} requiredModules
     * @private
     */
    RangeNavigator.prototype.requiredModules = function () {
        var _this = this;
        var modules = [];
        this.series.map(function (series) {
            modules.push({
                member: series.type + 'Series',
                args: [_this]
            });
        });
        if (this.periodSelectorSettings.periods.length > 0) {
            modules.push({
                member: 'PeriodSelector',
                args: [this]
            });
        }
        if (this.valueType !== 'Double') {
            modules.push({
                member: this.valueType,
                args: [this]
            });
        }
        if (this.tooltip.enable) {
            modules.push({
                member: 'RangeTooltip',
                args: [this]
            });
        }
        return modules;
    };
    /**
     * To get the module name of the widget
     */
    RangeNavigator.prototype.getModuleName = function () {
        return 'rangeNavigator';
    };
    /**
     * To destroy the widget
     *
     * @function destroy
     * @returns {void}.
     * @member of rangeNavigator
     */
    RangeNavigator.prototype.destroy = function () {
        this.unWireEvents();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (this.isReact) {
            this.clearTemplate();
        }
        this.rangeSlider.destroy();
        _super.prototype.destroy.call(this);
        this.element.innerText = '';
        this.element.classList.remove('e-rangenavigator');
    };
    __decorate$10([
        Property(null)
    ], RangeNavigator.prototype, "width", void 0);
    __decorate$10([
        Property(null)
    ], RangeNavigator.prototype, "height", void 0);
    __decorate$10([
        Property(null)
    ], RangeNavigator.prototype, "dataSource", void 0);
    __decorate$10([
        Property(null)
    ], RangeNavigator.prototype, "xName", void 0);
    __decorate$10([
        Property(null)
    ], RangeNavigator.prototype, "yName", void 0);
    __decorate$10([
        Property()
    ], RangeNavigator.prototype, "query", void 0);
    __decorate$10([
        Collection([], RangeNavigatorSeries)
    ], RangeNavigator.prototype, "series", void 0);
    __decorate$10([
        Complex({}, RangeTooltipSettings)
    ], RangeNavigator.prototype, "tooltip", void 0);
    __decorate$10([
        Property(null)
    ], RangeNavigator.prototype, "minimum", void 0);
    __decorate$10([
        Property(null)
    ], RangeNavigator.prototype, "maximum", void 0);
    __decorate$10([
        Property(null)
    ], RangeNavigator.prototype, "interval", void 0);
    __decorate$10([
        Property('Auto')
    ], RangeNavigator.prototype, "intervalType", void 0);
    __decorate$10([
        Property('Hide')
    ], RangeNavigator.prototype, "labelIntersectAction", void 0);
    __decorate$10([
        Property(10)
    ], RangeNavigator.prototype, "logBase", void 0);
    __decorate$10([
        Property('Double')
    ], RangeNavigator.prototype, "valueType", void 0);
    __decorate$10([
        Property('Outside')
    ], RangeNavigator.prototype, "labelPosition", void 0);
    __decorate$10([
        Property('Auto')
    ], RangeNavigator.prototype, "labelPlacement", void 0);
    __decorate$10([
        Property(500)
    ], RangeNavigator.prototype, "animationDuration", void 0);
    __decorate$10([
        Property(false)
    ], RangeNavigator.prototype, "enableGrouping", void 0);
    __decorate$10([
        Property(false)
    ], RangeNavigator.prototype, "enableDeferredUpdate", void 0);
    __decorate$10([
        Property(false)
    ], RangeNavigator.prototype, "disableRangeSelector", void 0);
    __decorate$10([
        Property(false)
    ], RangeNavigator.prototype, "allowSnapping", void 0);
    __decorate$10([
        Property(false)
    ], RangeNavigator.prototype, "allowIntervalData", void 0);
    __decorate$10([
        Property(false)
    ], RangeNavigator.prototype, "useGroupingSeparator", void 0);
    __decorate$10([
        Property()
    ], RangeNavigator.prototype, "groupBy", void 0);
    __decorate$10([
        Property('Outside')
    ], RangeNavigator.prototype, "tickPosition", void 0);
    __decorate$10([
        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, Font)
    ], RangeNavigator.prototype, "labelStyle", void 0);
    __decorate$10([
        Complex({}, MajorGridLines)
    ], RangeNavigator.prototype, "majorGridLines", void 0);
    __decorate$10([
        Complex({}, MajorTickLines)
    ], RangeNavigator.prototype, "majorTickLines", void 0);
    __decorate$10([
        Complex({}, StyleSettings)
    ], RangeNavigator.prototype, "navigatorStyleSettings", void 0);
    __decorate$10([
        Complex({}, PeriodSelectorSettings)
    ], RangeNavigator.prototype, "periodSelectorSettings", void 0);
    __decorate$10([
        Complex({ color: null, width: 1 }, Border)
    ], RangeNavigator.prototype, "navigatorBorder", void 0);
    __decorate$10([
        Property('Material')
    ], RangeNavigator.prototype, "theme", void 0);
    __decorate$10([
        Property([])
    ], RangeNavigator.prototype, "value", void 0);
    __decorate$10([
        Property(null)
    ], RangeNavigator.prototype, "background", void 0);
    __decorate$10([
        Property('')
    ], RangeNavigator.prototype, "labelFormat", void 0);
    __decorate$10([
        Property('')
    ], RangeNavigator.prototype, "skeleton", void 0);
    __decorate$10([
        Property('DateTime')
    ], RangeNavigator.prototype, "skeletonType", void 0);
    __decorate$10([
        Property('Middle')
    ], RangeNavigator.prototype, "secondaryLabelAlignment", void 0);
    __decorate$10([
        Complex({ top: 5, bottom: 5, right: 5, left: 5 }, Margin)
    ], RangeNavigator.prototype, "margin", void 0);
    __decorate$10([
        Event()
    ], RangeNavigator.prototype, "load", void 0);
    __decorate$10([
        Event()
    ], RangeNavigator.prototype, "loaded", void 0);
    __decorate$10([
        Event()
    ], RangeNavigator.prototype, "resized", void 0);
    __decorate$10([
        Event()
    ], RangeNavigator.prototype, "beforeResize", void 0);
    __decorate$10([
        Event()
    ], RangeNavigator.prototype, "labelRender", void 0);
    __decorate$10([
        Event()
    ], RangeNavigator.prototype, "changed", void 0);
    __decorate$10([
        Event()
    ], RangeNavigator.prototype, "tooltipRender", void 0);
    __decorate$10([
        Event()
    ], RangeNavigator.prototype, "selectorRender", void 0);
    __decorate$10([
        Event()
    ], RangeNavigator.prototype, "beforePrint", void 0);
    RangeNavigator = __decorate$10([
        NotifyPropertyChanges
    ], RangeNavigator);
    return RangeNavigator;
}(Component));

/**
 * Cartesian chart renderer for financial chart
 */
/** @private */
var CartesianChart = /** @__PURE__ @class */ (function () {
    function CartesianChart(chart) {
        this.stockChart = chart;
    }
    CartesianChart.prototype.initializeChart = function (chartArgsData) {
        var _this = this;
        var stockChart = this.stockChart;
        var isProtect = 'isProtectedOnChange';
        var startValue = null;
        var endValue = null;
        stockChart[isProtect] = true;
        if (!stockChart.chartObject) {
            stockChart.chartObject = stockChart.renderer.createGroup({
                id: stockChart.element.id + '_stockChart_chart'
            });
            stockChart.mainObject.appendChild(stockChart.chartObject);
        }
        else {
            var chartElement = document.getElementById(stockChart.chartObject.id);
            while (chartElement.firstChild) {
                chartElement.removeChild(chartElement.firstChild);
            }
            if (getElement$1(stockChart.chartObject + '_tooltip')) {
                remove(getElement$1(stockChart.chartObject + '_tooltip'));
            }
        }
        this.stockChart.isDateTimeCategory = this.stockChart.primaryXAxis.valueType === 'DateTimeCategory';
        if (this.stockChart.isDateTimeCategory && !this.stockChart.sortedData.length) {
            for (var _i = 0, _a = this.stockChart.series; _i < _a.length; _i++) {
                var series = _a[_i];
                var dataSource = series.dataSource;
                var xName = series.xName;
                for (var _b = 0, dataSource_1 = dataSource; _b < dataSource_1.length; _b++) {
                    var dataItem = dataSource_1[_b];
                    var currentData = Date.parse(new Date(DataUtil.parse.parseJson({ val: dataItem[xName] }).val).toString());
                    if (this.stockChart.sortedData.indexOf(currentData) === -1) {
                        this.stockChart.sortedData.push(currentData);
                    }
                }
            }
            this.stockChart.sortedData.sort(function (a, b) { return a - b; });
        }
        this.cartesianChartSize = this.calculateChartSize();
        stockChart.chart = new Chart({
            chartArea: stockChart.chartArea,
            margin: this.findMargin(stockChart),
            primaryXAxis: this.copyObject(stockChart.primaryXAxis),
            primaryYAxis: this.copyObject(stockChart.primaryYAxis),
            rows: stockChart.rows,
            indicators: stockChart.indicators,
            axes: stockChart.axes,
            tooltipRender: function (args) {
                _this.stockChart.trigger('tooltipRender', args);
            },
            axisLabelRender: function (args) {
                _this.stockChart.trigger('axisLabelRender', args);
            },
            seriesRender: function (args) {
                startValue = (_this.stockChart.startValue != null && _this.stockChart.isDateTimeCategory) ?
                    _this.stockChart.sortedData[Math.floor(_this.stockChart.startValue)] : _this.stockChart.startValue;
                endValue = (_this.stockChart.endValue != null && _this.stockChart.isDateTimeCategory) ?
                    _this.stockChart.sortedData[Math.floor(_this.stockChart.endValue)] : _this.stockChart.endValue;
                if (args.data && startValue && endValue) {
                    args.data = args.data
                        .filter(function (data) {
                        return (new Date(DataUtil.parse.parseJson({ val: (data[args.series.xName]) }).val).getTime() >= startValue &&
                            new Date(DataUtil.parse.parseJson({ val: (data[args.series.xName]) }).val).getTime() <= endValue);
                    });
                }
                args.data = chartArgsData ? chartArgsData : args.data;
                //args.data = this.stockChart.findCurrentData(args.data ,args.series.xName);
                _this.stockChart.trigger('seriesRender', args);
            },
            onZooming: function (args) { _this.stockChart.trigger(onZooming, args); },
            pointClick: function (args) {
                _this.stockChart.trigger('pointClick', args);
            },
            pointMove: function (args) {
                _this.stockChart.trigger('pointMove', args);
            },
            dataSource: stockChart.dataSource,
            series: this.findSeriesCollection(stockChart.series),
            zoomSettings: this.copyObject(stockChart.zoomSettings),
            tooltip: stockChart.tooltip,
            crosshair: stockChart.crosshair,
            height: this.cartesianChartSize.height.toString(),
            selectedDataIndexes: stockChart.selectedDataIndexes,
            selectionMode: stockChart.selectionMode,
            isMultiSelect: stockChart.isMultiSelect,
            annotations: stockChart.annotations,
            theme: stockChart.theme,
            legendSettings: { visible: false },
            enableRtl: stockChart.enableRtl,
            zoomComplete: function (args) {
                if (args.axis.valueType.indexOf('DateTime') !== -1 && stockChart.rangeNavigator) {
                    _this.stockChart.zoomChange = true;
                    var newRange = _this.calculateUpdatedRange(args.currentZoomFactor, args.currentZoomPosition, args.axis);
                    stockChart.rangeSelector.sliderChange(newRange.start, newRange.end);
                }
            }
        });
        if (stockChart.indicators.length !== 0) {
            if (stockChart.isSelect) {
                for (var i = 0; i < stockChart.indicators.length; i++) {
                    stockChart.chart.indicators[i].animation.enable = false;
                    stockChart.chart.indicators[i].dataSource = extend([], stockChart.chart.series[0].dataSource, null, true);
                }
            }
            stockChart.isSelect = true;
        }
        stockChart.chart.stockChart = stockChart;
        stockChart.chart.appendTo(stockChart.chartObject);
        stockChart[isProtect] = false;
        if (stockChart.onPanning) {
            getElement$1(this.stockChart.element.id + '_stockChart_chart').setAttribute('cursor', 'pointer');
            stockChart.chart.mouseMove(stockChart.mouseMoveEvent);
        }
    };
    CartesianChart.prototype.findMargin = function (stockChart) {
        var margin = {};
        margin.top = stockChart.stockLegendModule && stockChart.legendSettings.visible && stockChart.legendSettings.position === 'Top' ?
            stockChart.margin.top : stockChart.margin.top * 2;
        margin.left = stockChart.margin.left;
        margin.right = stockChart.margin.right;
        margin.bottom = stockChart.margin.bottom;
        return margin;
    };
    CartesianChart.prototype.findSeriesCollection = function (series) {
        var chartSeries = [];
        for (var i = 0, len = series.length; i < len; i++) {
            chartSeries.push(series[i]);
            chartSeries[i].high = series[i].high;
            chartSeries[i].low = series[i].low;
            chartSeries[i].open = series[i].open;
            chartSeries[i].close = series[i].close;
            chartSeries[i].xName = series[i].xName;
            chartSeries[i].volume = series[i].volume;
            chartSeries[i].animation = series[i].animation;
            if (series[i].localData) {
                chartSeries[i].dataSource = series[i].localData;
            }
            chartSeries[i].yName = series[i].yName === '' ? series[i].close : series[i].yName;
        }
        return chartSeries;
    };
    CartesianChart.prototype.calculateChartSize = function () {
        var stockChart = this.stockChart;
        return (new Size(stockChart.availableSize.width, (stockChart.enablePeriodSelector && stockChart.enableSelector) ?
            ((stockChart.availableSize.height - stockChart.toolbarHeight - 51)) :
            (stockChart.enableSelector && !stockChart.enablePeriodSelector) ? (stockChart.availableSize.height - 51) :
                (stockChart.enablePeriodSelector && !stockChart.enableSelector) ?
                    stockChart.availableSize.height - stockChart.toolbarHeight : stockChart.availableSize.height));
    };
    CartesianChart.prototype.calculateUpdatedRange = function (zoomFactor, zoomPosition, axis) {
        var start;
        var end;
        //if (zoomFactor < 1 || zoomPosition > 0) {
        var chartRange = axis.actualRange;
        var inversed = false;
        if (!inversed) {
            start = chartRange.min + zoomPosition * chartRange.delta;
            end = start + zoomFactor * chartRange.delta;
        }
        else {
            start = chartRange.max - (zoomPosition * chartRange.delta);
            end = start - (zoomFactor * chartRange.delta);
        }
        //}
        if (this.stockChart.isDateTimeCategory) {
            start = this.stockChart.sortedData.indexOf(parseInt(axis.labels[Math.floor(start)], 10));
            end = this.stockChart.sortedData.indexOf(parseInt(axis.labels[Math.floor(end)], 10));
        }
        var result = { start: start, end: end };
        return result;
    };
    /**
     * Cartesian chart refreshes based on start and end value
     *
     * @param {StockChart} stockChart stock chart instance
     * @param {Object[]} data stock chart data
     * @returns {void}
     */
    CartesianChart.prototype.cartesianChartRefresh = function (stockChart, data) {
        stockChart.cartesianChart.initializeChart(data);
    };
    CartesianChart.prototype.copyObject = function (originalObject) {
        return (extend({}, originalObject, {}, true));
    };
    return CartesianChart;
}());

/**
 * Render range navigator for financial chart
 */
/** @private */
var RangeSelector = /** @__PURE__ @class */ (function () {
    function RangeSelector(stockChart) {
        this.stockChart = stockChart;
    }
    RangeSelector.prototype.initializeRangeNavigator = function () {
        var _this = this;
        var stockChart = this.stockChart;
        if (!stockChart.selectorObject) {
            stockChart.selectorObject = stockChart.renderer.createGroup({
                id: stockChart.element.id + '_stockChart_rangeSelector',
                transform: 'translate(' + 0 + ',' + stockChart.cartesianChart.cartesianChartSize.height + ')'
            });
            stockChart.mainObject.appendChild(stockChart.selectorObject);
        }
        else {
            var chartElement = document.getElementById(stockChart.selectorObject.id);
            while (chartElement.firstChild) {
                chartElement.removeChild(chartElement.firstChild);
            }
            if (getElement$1(stockChart.selectorObject.id + '_leftTooltip')) {
                remove(getElement$1(stockChart.selectorObject.id + '_leftTooltip'));
            }
            if (getElement$1(stockChart.selectorObject.id + '_rightTooltip')) {
                remove(getElement$1(stockChart.selectorObject.id + '_rightTooltip'));
            }
        }
        stockChart.rangeNavigator = new RangeNavigator({
            locale: 'en',
            valueType: stockChart.primaryXAxis.valueType,
            theme: this.stockChart.theme,
            series: this.findSeriesCollection(stockChart.series),
            height: this.calculateChartSize().height.toString(),
            tickPosition: 'Inside',
            majorTickLines: { width: 0 },
            value: [stockChart.isDateTimeCategory ? new Date(stockChart.sortedData[Math.floor(stockChart.startValue)]) :
                    new Date(stockChart.startValue),
                stockChart.isDateTimeCategory ? new Date(stockChart.sortedData[Math.floor(stockChart.endValue)]) :
                    new Date(stockChart.endValue)],
            margin: this.findMargin(),
            tooltip: { enable: stockChart.tooltip.enable, displayMode: 'OnDemand' },
            labelPlacement: 'OnTicks',
            labelPosition: 'Inside',
            dataSource: stockChart.dataSource,
            intervalType: stockChart.primaryXAxis.intervalType,
            enableRtl: stockChart.enableRtl,
            changed: function (args) {
                var arg = {
                    name: 'rangeChange',
                    end: args.end,
                    selectedData: args.selectedData,
                    start: args.start,
                    zoomFactor: args.zoomFactor,
                    zoomPosition: args.zoomPosition,
                    data: undefined
                };
                _this.stockChart.trigger('rangeChange', arg);
                _this.stockChart.startValue = args.start;
                _this.stockChart.endValue = args.end;
                if (!_this.stockChart.zoomChange) {
                    _this.stockChart.cartesianChart.cartesianChartRefresh(_this.stockChart, arg.data);
                }
                if (stockChart.periodSelector && stockChart.periodSelector.datePicker) {
                    stockChart.periodSelector.datePicker.startDate = _this.stockChart.isDateTimeCategory ?
                        new Date(_this.stockChart.sortedData[Math.floor(args.start)]) : new Date(args.start);
                    stockChart.periodSelector.datePicker.endDate = _this.stockChart.isDateTimeCategory ?
                        new Date(_this.stockChart.sortedData[Math.floor(args.end)]) : new Date(args.end);
                    stockChart.periodSelector.datePicker.dataBind();
                }
            }
        });
        stockChart.rangeNavigator.stockChart = stockChart;
        stockChart.rangeNavigator.appendTo(stockChart.selectorObject);
    };
    RangeSelector.prototype.findMargin = function () {
        var margin = {};
        margin.top = 5;
        margin.left = 0;
        margin.right = 0;
        margin.bottom = 0;
        return margin;
    };
    RangeSelector.prototype.findSeriesCollection = function (series) {
        var chartSeries = [];
        for (var i = 0, len = series.length; i < len; i++) {
            chartSeries.push(series[i]);
            chartSeries[i].xName = series[i].xName;
            chartSeries[i].yName = series[i].yName === '' ? series[i].close : series[i].yName;
        }
        return chartSeries;
    };
    RangeSelector.prototype.calculateChartSize = function () {
        var stockChart = this.stockChart;
        return (new Size(stockChart.availableSize.width, (stockChart.enableSelector) ? 51 : 0));
    };
    /**
     * Performs slider change
     *
     * @param {number} start slider start value
     * @param {number} end slider end value
     * @returns {void}
     */
    RangeSelector.prototype.sliderChange = function (start, end) {
        this.stockChart.rangeNavigator.rangeSlider.performAnimation(start, end, this.stockChart.rangeNavigator, 0);
    };
    return RangeSelector;
}());

/**
 * Period selector for range navigator
 */
/** @private */
var ToolBarSelector = /** @__PURE__ @class */ (function () {
    function ToolBarSelector(chart) {
        this.selectedSeries = '';
        this.selectedIndicator = '';
        this.selectedTrendLine = '';
        this.indicators = [];
        this.secondayIndicators = [];
        this.stockChart = chart;
        this.selectedSeries = this.stockChart.series[0].type;
    }
    ToolBarSelector.prototype.initializePeriodSelector = function () {
        var periods = this.stockChart.tempPeriods;
        this.stockChart.periods = periods;
        this.stockChart.periodSelector.rootControl = this.stockChart;
        var rect = this.stockChart.chart.chartAxisLayoutPanel.seriesClipRect;
        var htmlElement = getElement$1(this.stockChart.element.id + '_Secondary_Element');
        var height = this.stockChart.toolbarHeight;
        this.stockChart.periodSelector.appendSelector({ thumbSize: 0, element: htmlElement, width: rect.width, height: height }, rect.x);
        if (this.stockChart.seriesType.length > 0) {
            this.initializeSeriesSelector();
        }
        this.initializeIndicatorSelector();
        if (this.stockChart.trendlineType.length > 0) {
            this.initializeTrendlineSelector();
        }
        this.exportButton();
    };
    /**
     * This method returns itemModel for dropdown button
     */
    ToolBarSelector.prototype.getDropDownItems = function (type) {
        var result = [];
        if (type === this.stockChart.seriesType) {
            for (var i = 0; i < type.length; i++) {
                result.push({ text: '&nbsp;&nbsp;&nbsp;' + type[i].toString() });
            }
            for (var i = 0; i < this.stockChart.series.length; i++) {
                for (var j = 0; j < result.length; j++) {
                    var text = result[j].text.replace('&nbsp;&nbsp;&nbsp;', '');
                    text = (text === 'OHLC') ? 'HiloOpenClose' : text;
                    if (text === this.stockChart.series[i].type) {
                        result[j].text = result[j].text.replace('&nbsp;&nbsp;&nbsp;', '&#10004&nbsp;');
                    }
                }
            }
        }
        else if (type === this.stockChart.exportType) {
            for (var i = 0; i < type.length; i++) {
                result.push({ text: type[i].toString() });
            }
        }
        else {
            for (var i = 0; i < type.length; i++) {
                if (type[i].toString() !== 'Print') {
                    result.push({ text: '&nbsp;&nbsp;&nbsp;' + type[i].toString() });
                }
            }
        }
        return result;
    };
    /**
     * This method changes the type of series while selectind series in dropdown button
     */
    ToolBarSelector.prototype.addedSeries = function (seriesType) {
        var series = this.stockChart.series;
        for (var i = 0; i < series.length; i++) {
            if (series[i].yName === 'volume') {
                continue;
            }
            series[i].type = (seriesType.indexOf('Candle') > -1 ? 'Candle' :
                (seriesType.indexOf('OHLC') > -1 ? 'HiloOpenClose' : seriesType));
            series[i].enableSolidCandles = seriesType === 'Candle';
            for (var index = 0; index < series[i].trendlines.length; index++) {
                var trendLine = series[i].trendlines[index];
                trendLine.animation.enable = false;
                trendLine.enableTooltip = false;
            }
        }
    };
    ToolBarSelector.prototype.initializeSeriesSelector = function () {
        var _this = this;
        if (this.stockChart.seriesType.indexOf('HiloOpenClose') > -1) {
            this.stockChart.seriesType[this.stockChart.seriesType.indexOf('HiloOpenClose')] = 'OHLC';
        }
        if (this.stockChart.seriesType.indexOf('Candle') > -1 && this.stockChart.seriesType.indexOf('Hollow Candle') === -1) {
            this.stockChart.seriesType[this.stockChart.seriesType.length] = 'Hollow Candle';
        }
        var seriesType = new DropDownButton({
            items: this.getDropDownItems(this.stockChart.seriesType),
            select: function (args) {
                _this.selectedSeries = args.item.text;
                var text = _this.tickMark(args);
                _this.addedSeries(text);
                _this.stockChart.cartesianChart.initializeChart();
                if (_this.stockChart.stockLegendModule && _this.stockChart.stockLegendModule.legendCollections.length
                    && _this.stockChart.legendSettings.visible) {
                    var bounds = _this.stockChart.stockLegendModule.legendBounds;
                    _this.stockChart.stockLegendModule.renderLegend(_this.stockChart, _this.stockChart.legendSettings, bounds);
                }
            }
        });
        seriesType.appendTo('#' + this.stockChart.element.id + '_seriesType');
    };
    ToolBarSelector.prototype.initializeTrendlineSelector = function () {
        var _this = this;
        this.trendlineDropDown = new DropDownButton({
            items: this.stockChart.resizeTo ? this.trendlineDropDown.items :
                this.getDropDownItems(this.stockChart.trendlineType),
            select: function (args) {
                var type = _this.tickMark(args);
                _this.selectedTrendLine = _this.selectedTrendLine === '' ? type : _this.selectedTrendLine + ',' + type;
                if (_this.trendline !== type) {
                    _this.trendline = type;
                    for (var i = 0; i < _this.stockChart.series.length; i++) {
                        if (_this.stockChart.series[i].yName === 'volume') {
                            continue;
                        }
                        if (_this.stockChart.series[0].trendlines.length === 0) {
                            var trendlines = void 0;
                            if (_this.stockChart.trendlinetriggered) {
                                trendlines = [{ type: type, width: 1, enableTooltip: false }];
                                _this.stockChart.trendlinetriggered = false;
                            }
                            _this.stockChart.series[0].trendlines = trendlines;
                        }
                        else {
                            _this.stockChart.series[0].trendlines[0].width = 1;
                            _this.stockChart.series[0].trendlines[0].type = type;
                            _this.stockChart.series[0].trendlines[0].animation.enable = _this.stockChart.trendlinetriggered ? true : false;
                        }
                    }
                    _this.stockChart.cartesianChart.initializeChart();
                }
                else {
                    args.item.text = '&nbsp;&nbsp;&nbsp;' + args.item.text.replace('&#10004&nbsp;', '');
                    _this.stockChart.series[0].trendlines[0].width = 0;
                    _this.trendline = null;
                    _this.stockChart.cartesianChart.initializeChart();
                }
            }
        });
        this.trendlineDropDown.appendTo('#' + this.stockChart.element.id + '_trendType');
    };
    ToolBarSelector.prototype.initializeIndicatorSelector = function () {
        var _this = this;
        this.indicatorDropDown = new DropDownButton({
            items: this.stockChart.resizeTo ? this.indicatorDropDown.items :
                this.getDropDownItems(this.stockChart.indicatorType),
            select: function (args) {
                for (var l = 0; l < _this.stockChart.series.length; l++) {
                    if (_this.stockChart.series[l].trendlines.length !== 0) {
                        _this.stockChart.series[l].trendlines[0].animation.enable = false;
                    }
                }
                args.item.text = args.item.text.indexOf('&#10004&nbsp;') >= 0 ? args.item.text.substr(args.item.text.indexOf(';') + 1) :
                    args.item.text;
                var text = args.item.text.replace('&nbsp;&nbsp;&nbsp;', '');
                text = text.split(' ')[0].toLocaleLowerCase() + (text.split(' ')[1] ? text.split(' ')[1] : '');
                text = text.substr(0, 1).toUpperCase() + text.substr(1);
                var type = text;
                _this.selectedIndicator = _this.selectedIndicator.indexOf(type) === -1 ? _this.selectedIndicator + ' ' + type :
                    _this.selectedIndicator.replace(type, '');
                if (type === 'Tma' || type === 'BollingerBands' || type === 'Sma' || type === 'Ema') {
                    if (_this.indicators.indexOf(type) === -1) {
                        args.item.text = '&#10004&nbsp;' + args.item.text.replace('&nbsp;&nbsp;&nbsp;', '');
                        var indicator = _this.getIndicator(type, _this.stockChart.series[0].yAxisName);
                        _this.indicators.push(type);
                        _this.stockChart.indicators = _this.stockChart.indicators.concat(indicator);
                        _this.stockChart.cartesianChart.initializeChart();
                    }
                    else {
                        args.item.text = '&nbsp;&nbsp;&nbsp;' + args.item.text;
                        for (var z = 0; z < _this.stockChart.indicators.length; z++) {
                            if (_this.stockChart.indicators[z].type === type) {
                                _this.stockChart.indicators.splice(z, 1);
                            }
                        }
                        _this.indicators.splice(_this.indicators.indexOf(type), 1);
                        _this.stockChart.cartesianChart.initializeChart();
                    }
                }
                else {
                    _this.createIndicatorAxes(type, args);
                }
            }
        });
        this.indicatorDropDown.appendTo('#' + this.stockChart.element.id + '_indicatorType');
    };
    ToolBarSelector.prototype.getIndicator = function (type, yAxisName) {
        var currentSeries = this.stockChart.series[0];
        var indicator = [{
                type: type, period: 3, yAxisName: yAxisName,
                dataSource: currentSeries.localData,
                xName: currentSeries.xName,
                open: currentSeries.open,
                close: currentSeries.close,
                high: currentSeries.high,
                low: currentSeries.low,
                volume: currentSeries.volume,
                fill: type === 'Sma' ? '#32CD32' : '#6063ff',
                animation: { enable: false }, upperLine: { color: '#FFE200', width: 1 },
                periodLine: { width: 2 }, lowerLine: { color: '#FAA512', width: 1 },
                fastPeriod: 8, slowPeriod: 5, macdType: 'Both', width: 1,
                macdPositiveColor: '#6EC992', macdNegativeColor: '#FF817F',
                bandColor: 'rgba(245, 203, 35, 0.12)'
            }];
        return indicator;
    };
    ToolBarSelector.prototype.createIndicatorAxes = function (type, args) {
        if (this.indicators.indexOf(type) === -1) {
            args.item.text = '&#10004&nbsp;' + args.item.text.replace('&nbsp;&nbsp;&nbsp;', '');
            this.indicators.push(type);
            var len = this.stockChart.rows.length;
            this.stockChart.rows[this.stockChart.rows.length - 1].height = '15%';
            var row = [{ height: '' + (100 - len * 15) + 'px' }];
            if (this.stockChart.rows.length === 1) {
                this.stockChart.isSingleAxis = true;
            }
            this.stockChart.rows = this.stockChart.rows.concat(row);
            if (!this.stockChart.isSingleAxis) {
                this.stockChart.axes[0].rowIndex += 1;
            }
            else {
                for (var i = 0; i < this.stockChart.axes.length; i++) {
                    this.stockChart.axes[i].rowIndex += 1;
                }
            }
            var axis = [{
                    plotOffset: 10, opposedPosition: true,
                    rowIndex: (!this.stockChart.isSingleAxis ? this.stockChart.axes.length : 0),
                    desiredIntervals: 1,
                    labelFormat: 'n2',
                    majorGridLines: this.stockChart.primaryYAxis.majorGridLines,
                    lineStyle: this.stockChart.primaryYAxis.lineStyle,
                    labelPosition: this.stockChart.primaryYAxis.labelPosition,
                    majorTickLines: this.stockChart.primaryYAxis.majorTickLines,
                    rangePadding: 'None', name: type.toString()
                }];
            this.stockChart.axes = this.stockChart.axes.concat(axis);
            this.stockChart.primaryYAxis.rowIndex = (!this.stockChart.isSingleAxis ? 0 : len + 1);
            var indicator = this.getIndicator(type, type.toString());
            this.stockChart.indicators = this.stockChart.indicators.concat(indicator);
            this.stockChart.cartesianChart.initializeChart();
        }
        else {
            args.item.text = '&nbsp;&nbsp;&nbsp;' + args.item.text;
            for (var i = 0; i < this.stockChart.indicators.length; i++) {
                if (this.stockChart.indicators[i].type === type) {
                    this.stockChart.indicators.splice(i, 1);
                }
            }
            this.indicators.splice(this.indicators.indexOf(type), 1);
            var removedIndex = 0;
            for (var z = 0; z < this.stockChart.axes.length; z++) {
                if (this.stockChart.axes[z].name === type) {
                    removedIndex = this.stockChart.axes[z].rowIndex;
                    this.stockChart.rows.splice(z, 1);
                    this.stockChart.axes.splice(z, 1);
                }
            }
            for (var z = 0; z < this.stockChart.axes.length; z++) {
                if (this.stockChart.axes[z].rowIndex !== 0 && this.stockChart.axes[z].rowIndex > removedIndex) {
                    this.stockChart.axes[z].rowIndex = this.stockChart.axes[z].rowIndex - 1;
                }
            }
            this.stockChart.cartesianChart.initializeChart();
        }
    };
    ToolBarSelector.prototype.tickMark = function (args) {
        var text;
        var items = args.item['parentObj'].items;
        for (var i = 0; i < items.length; i++) {
            items[i].text = items[i].text.indexOf('&#10004&nbsp;') >= 0 ?
                items[i].text.substr(items[i].text.indexOf(';') + 1) :
                items[i].text;
            if (!(items[i].text.indexOf('&nbsp;&nbsp;&nbsp;') >= 0)) {
                items[i].text = '&nbsp;&nbsp;&nbsp;' + items[i].text;
            }
        }
        if (args.item.text.indexOf('&nbsp;&nbsp;&nbsp;') >= 0) {
            text = args.item.text.replace('&nbsp;&nbsp;&nbsp;', '');
            args.item.text = args.item.text.replace('&nbsp;&nbsp;&nbsp;', '&#10004&nbsp;');
        }
        else {
            text = args.item.text.replace('&#10004&nbsp;', '');
        }
        return text;
    };
    ToolBarSelector.prototype.exportButton = function () {
        var _this = this;
        var exportChart = new DropDownButton({
            items: this.getDropDownItems(this.stockChart.exportType),
            select: function (args) {
                var type = args.item.text;
                if (_this.stockChart.chart.exportModule) {
                    var stockChart = _this.stockChart;
                    var stockID = stockChart.element.id + '_stockChart_';
                    var additionalRect = void 0;
                    var svgHeight = stockChart.svgObject.getBoundingClientRect();
                    _this.stockChart.svgObject.insertAdjacentElement('afterbegin', _this.addExportSettings(type === 'Print'));
                    additionalRect = stockChart.svgObject.firstElementChild.getBoundingClientRect();
                    var rect = new RectOption('additionalRect', 'transparent', { width: 0, color: 'transparent' }, 1, new Rect(0, 0, _this.stockChart.availableSize.width, additionalRect.height));
                    stockChart.svgObject.firstElementChild.insertAdjacentElement('afterbegin', _this.stockChart.renderer.drawRectangle(rect));
                    _this.stockChart.svgObject.setAttribute('height', (svgHeight.height + additionalRect.height).toString());
                    getElement$1(stockID + 'chart').style.transform = 'translateY(' + additionalRect.height + 'px)';
                    if (stockChart.enableSelector) {
                        getElement$1(stockID + 'rangeSelector').setAttribute('transform', 'translate(' + 0 + ',' + (stockChart.cartesianChart.cartesianChartSize.height + additionalRect.height) + ')');
                    }
                    if (_this.stockChart.legendSettings.visible && _this.stockChart.stockLegendModule) {
                        getElement$1(stockChart.element.id + '_chart_legend_g').style.transform = 'translateY(' + additionalRect.height + 'px)';
                    }
                    if (type === 'Print') {
                        _this.stockChart.chart.print(_this.stockChart.svgObject.id);
                    }
                    else {
                        stockChart.chart.exportModule.export(type, 'StockChart', null, [stockChart], null, stockChart.svgObject.clientHeight);
                    }
                    remove(getElement$1(_this.stockChart.element.id + '_additionalExport'));
                    getElement$1(stockID + 'chart').style.transform = '';
                    if (stockChart.enableSelector) {
                        getElement$1(stockID + 'rangeSelector').setAttribute('transform', 'translate(' + 0 + ',' + (stockChart.cartesianChart.cartesianChartSize.height) + ')');
                    }
                    if (_this.stockChart.legendSettings.visible && _this.stockChart.stockLegendModule) {
                        getElement$1(stockChart.element.id + '_chart_legend_g').style.transform = 'translateY(0px)';
                    }
                    _this.stockChart.svgObject.setAttribute('height', (svgHeight.height).toString());
                }
            }
        });
        exportChart.appendTo('#' + this.stockChart.element.id + '_export');
    };
    ToolBarSelector.prototype.calculateAutoPeriods = function () {
        var defaultPeriods = [];
        var min = this.stockChart.isDateTimeCategory ? this.stockChart.sortedData[this.stockChart.seriesXMin] :
            this.stockChart.seriesXMin;
        var max = this.stockChart.isDateTimeCategory ? this.stockChart.sortedData[this.stockChart.seriesXMax] :
            this.stockChart.seriesXMax;
        defaultPeriods = this.findRange(min, max);
        defaultPeriods.push({ text: 'YTD', selected: true }, { text: 'All' });
        return defaultPeriods;
    };
    ToolBarSelector.prototype.findRange = function (min, max) {
        var defaultPeriods = [];
        if (((max - min) / 3.154e+10) >= 1) {
            defaultPeriods.push({ text: '1M', interval: 1, intervalType: 'Months' }, { text: '3M', interval: 3, intervalType: 'Months' }, { text: '6M', interval: 6, intervalType: 'Months' }, { text: '1Y', interval: 1, intervalType: 'Years' });
        }
        else if ((max - min) / 1.577e+10 >= 1) {
            defaultPeriods.push({ text: '1M', interval: 1, intervalType: 'Months' }, { text: '3M', interval: 3, intervalType: 'Months' }, { text: '6M', interval: 6, intervalType: 'Months' });
        }
        else if ((max - min) / 2.628e+9 >= 1) {
            defaultPeriods.push({ text: '1D', interval: 1, intervalType: 'Days' }, { text: '3W', interval: 3, intervalType: 'Weeks' }, { text: '1M', interval: 1, intervalType: 'Months' });
        }
        else if ((max - min) / 8.64e+7 >= 1) {
            defaultPeriods.push({ text: '1H', interval: 1, intervalType: 'Hours' }, { text: '12H', interval: 12, intervalType: 'Hours' }, { text: '1D', interval: 1, intervalType: 'Days' });
        }
        return defaultPeriods;
    };
    /**
     * Text elements added to while export the chart
     * It details about the seriesTypes, indicatorTypes and Trendlines selected in chart.
     */
    ToolBarSelector.prototype.addExportSettings = function (isPrint) {
        var exportElement = this.stockChart.renderer.createGroup({
            id: this.stockChart.element.id + '_additionalExport',
            width: this.stockChart.availableSize.width,
            fill: this.stockChart.background ? this.stockChart.background : 'transparent'
        });
        var titleHeight = measureText(this.stockChart.title, this.stockChart.titleStyle, this.stockChart.themeStyle.chartTitleFont).height;
        var options = new TextOption(exportElement.id + '_Title', titlePositionX(new Rect(0, 0, this.stockChart.availableSize.width, 0), this.stockChart.titleStyle), 0, 'middle', this.stockChart.title, '', 'text-before-edge');
        textElement$1(this.stockChart.renderer, options, this.stockChart.titleStyle, this.stockChart.titleStyle.color || this.stockChart.themeStyle.chartTitleFont.color, exportElement, null, null, null, null, null, null, null, null, null, null, this.stockChart.themeStyle.chartTitleFont);
        if (isPrint) {
            return exportElement;
        }
        var style = { size: '16px', fontWeight: '600', color: this.stockChart.themeStyle.chartTitleFont.color, fontStyle: 'Normal', fontFamily: this.stockChart.themeStyle.chartTitleFont.fontFamily };
        var x = measureText('Series: ' + this.selectedSeries, style).width / 2;
        var y = titleHeight;
        this.textElementSpan(new TextOption(exportElement.id + '_Series', x, y, 'start', ['Series : ', this.selectedSeries], '', 'text-before-edge'), style, this.stockChart.themeStyle.chartTitleFont.color, exportElement);
        x += measureText('Series: ' + this.selectedSeries + ' Z', style).width;
        if (this.selectedIndicator !== '') {
            this.textElementSpan(new TextOption(exportElement.id + '_Indicator', x, y, 'start', ['Indicator :', this.selectedIndicator], '', 'text-before-edge'), style, this.stockChart.themeStyle.chartTitleFont.color, exportElement);
            x += measureText('Indicator: ' + this.selectedIndicator + ' Z', style).width;
        }
        if (this.selectedTrendLine !== '') {
            this.textElementSpan(new TextOption(exportElement.id + '_TrendLine', x, y, 'start', ['Trendline :', this.selectedTrendLine], '', 'text-before-edge'), style, this.stockChart.themeStyle.chartTitleFont.color, exportElement);
        }
        return exportElement;
    };
    /** @private */
    ToolBarSelector.prototype.textElementSpan = function (options, font, color, parent, isMinus, redraw, isAnimate, forceAnimate, animateDuration) {
        if (isMinus === void 0) { isMinus = false; }
        if (forceAnimate === void 0) { forceAnimate = false; }
        var renderer = new SvgRenderer('');
        var renderOptions = {};
        var tspanElement;
        renderOptions = {
            'id': options.id,
            'font-style': font.fontStyle,
            'font-family': font.fontFamily,
            'font-weight': font.fontWeight,
            'text-anchor': options.anchor,
            'x': options.x,
            'y': options.y,
            'fill': color,
            'font-size': font.size,
            'transform': options.transform,
            'opacity': font.opacity,
            'dominant-baseline': options.baseLine
        };
        var text = typeof options.text === 'string' ? options.text : isMinus ? options.text[options.text.length - 1] : options.text[0];
        var htmlObject = renderer.createText(renderOptions, text);
        if (typeof options.text !== 'string' && options.text.length > 1) {
            for (var i = 1, len = options.text.length; i < len; i++) {
                options.text[i] = ' ' + options.text[i];
                tspanElement = renderer.createTSpan({
                    'x': options.x + measureText(text, font).width + 5, 'id': options.id,
                    'y': (options.y), opacity: 0.5
                }, options.text[i]);
                htmlObject.appendChild(tspanElement);
            }
        }
        appendChildElement(false, parent, htmlObject, redraw, isAnimate, 'x', 'y', null, null, forceAnimate, false, null, animateDuration);
        return htmlObject;
    };
    return ToolBarSelector;
}());

var __extends$81 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$12 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var StockChartFont = /** @__PURE__ @class */ (function (_super) {
    __extends$81(StockChartFont, _super);
    function StockChartFont() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$12([
        Property('')
    ], StockChartFont.prototype, "color", void 0);
    __decorate$12([
        Property('16px')
    ], StockChartFont.prototype, "size", void 0);
    __decorate$12([
        Property('Segoe UI')
    ], StockChartFont.prototype, "fontFamily", void 0);
    __decorate$12([
        Property('Normal')
    ], StockChartFont.prototype, "fontStyle", void 0);
    __decorate$12([
        Property('Normal')
    ], StockChartFont.prototype, "fontWeight", void 0);
    __decorate$12([
        Property(1)
    ], StockChartFont.prototype, "opacity", void 0);
    __decorate$12([
        Property('Trim')
    ], StockChartFont.prototype, "textOverflow", void 0);
    __decorate$12([
        Property('Center')
    ], StockChartFont.prototype, "textAlignment", void 0);
    return StockChartFont;
}(ChildProperty));
/**
 * Border
 */
var StockChartBorder = /** @__PURE__ @class */ (function (_super) {
    __extends$81(StockChartBorder, _super);
    function StockChartBorder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$12([
        Property('')
    ], StockChartBorder.prototype, "color", void 0);
    __decorate$12([
        Property(1)
    ], StockChartBorder.prototype, "width", void 0);
    return StockChartBorder;
}(ChildProperty));
/**
 * Configures the chart area.
 */
var StockChartArea = /** @__PURE__ @class */ (function (_super) {
    __extends$81(StockChartArea, _super);
    function StockChartArea() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$12([
        Complex({}, StockChartBorder)
    ], StockChartArea.prototype, "border", void 0);
    __decorate$12([
        Property('transparent')
    ], StockChartArea.prototype, "background", void 0);
    __decorate$12([
        Property(1)
    ], StockChartArea.prototype, "opacity", void 0);
    return StockChartArea;
}(ChildProperty));
/**
 * Configures the chart margins.
 */
var StockMargin = /** @__PURE__ @class */ (function (_super) {
    __extends$81(StockMargin, _super);
    function StockMargin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$12([
        Property(Browser.isDevice ? 5 : 10)
    ], StockMargin.prototype, "left", void 0);
    __decorate$12([
        Property(Browser.isDevice ? 5 : 10)
    ], StockMargin.prototype, "right", void 0);
    __decorate$12([
        Property(Browser.isDevice ? 5 : 10)
    ], StockMargin.prototype, "top", void 0);
    __decorate$12([
        Property(Browser.isDevice ? 5 : 10)
    ], StockMargin.prototype, "bottom", void 0);
    return StockMargin;
}(ChildProperty));
/**
 * StockChart strip line settings
 */
var StockChartStripLineSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$81(StockChartStripLineSettings, _super);
    function StockChartStripLineSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$12([
        Property(false)
    ], StockChartStripLineSettings.prototype, "startFromAxis", void 0);
    __decorate$12([
        Property(true)
    ], StockChartStripLineSettings.prototype, "visible", void 0);
    __decorate$12([
        Property(null)
    ], StockChartStripLineSettings.prototype, "start", void 0);
    __decorate$12([
        Property('#808080')
    ], StockChartStripLineSettings.prototype, "color", void 0);
    __decorate$12([
        Property(null)
    ], StockChartStripLineSettings.prototype, "end", void 0);
    __decorate$12([
        Property(null)
    ], StockChartStripLineSettings.prototype, "size", void 0);
    __decorate$12([
        Property('Auto')
    ], StockChartStripLineSettings.prototype, "sizeType", void 0);
    __decorate$12([
        Property(null)
    ], StockChartStripLineSettings.prototype, "dashArray", void 0);
    __decorate$12([
        Property(false)
    ], StockChartStripLineSettings.prototype, "isRepeat", void 0);
    __decorate$12([
        Property(null)
    ], StockChartStripLineSettings.prototype, "repeatEvery", void 0);
    __decorate$12([
        Property(false)
    ], StockChartStripLineSettings.prototype, "isSegmented", void 0);
    __decorate$12([
        Property(null)
    ], StockChartStripLineSettings.prototype, "repeatUntil", void 0);
    __decorate$12([
        Property(null)
    ], StockChartStripLineSettings.prototype, "segmentStart", void 0);
    __decorate$12([
        Property(null)
    ], StockChartStripLineSettings.prototype, "segmentAxisName", void 0);
    __decorate$12([
        Property(null)
    ], StockChartStripLineSettings.prototype, "segmentEnd", void 0);
    __decorate$12([
        Property(1)
    ], StockChartStripLineSettings.prototype, "opacity", void 0);
    __decorate$12([
        Property('')
    ], StockChartStripLineSettings.prototype, "text", void 0);
    __decorate$12([
        Complex({ color: 'transparent', width: 1 }, StockChartBorder)
    ], StockChartStripLineSettings.prototype, "border", void 0);
    __decorate$12([
        Property(null)
    ], StockChartStripLineSettings.prototype, "rotation", void 0);
    __decorate$12([
        Property('Behind')
    ], StockChartStripLineSettings.prototype, "zIndex", void 0);
    __decorate$12([
        Property('Middle')
    ], StockChartStripLineSettings.prototype, "horizontalAlignment", void 0);
    __decorate$12([
        Property('Middle')
    ], StockChartStripLineSettings.prototype, "verticalAlignment", void 0);
    __decorate$12([
        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, StockChartFont)
    ], StockChartStripLineSettings.prototype, "textStyle", void 0);
    return StockChartStripLineSettings;
}(ChildProperty));
var StockEmptyPointSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$81(StockEmptyPointSettings, _super);
    function StockEmptyPointSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$12([
        Property(null)
    ], StockEmptyPointSettings.prototype, "fill", void 0);
    __decorate$12([
        Property('Gap')
    ], StockEmptyPointSettings.prototype, "mode", void 0);
    __decorate$12([
        Complex({ color: 'transparent', width: 0 }, StockChartBorder)
    ], StockEmptyPointSettings.prototype, "border", void 0);
    return StockEmptyPointSettings;
}(ChildProperty));
var StockChartConnector = /** @__PURE__ @class */ (function (_super) {
    __extends$81(StockChartConnector, _super);
    function StockChartConnector() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$12([
        Property('Line')
    ], StockChartConnector.prototype, "type", void 0);
    __decorate$12([
        Property(null)
    ], StockChartConnector.prototype, "length", void 0);
    __decorate$12([
        Property(null)
    ], StockChartConnector.prototype, "color", void 0);
    __decorate$12([
        Property('')
    ], StockChartConnector.prototype, "dashArray", void 0);
    __decorate$12([
        Property(1)
    ], StockChartConnector.prototype, "width", void 0);
    return StockChartConnector;
}(ChildProperty));
/**
 * Configures the Annotation for chart.
 */
var StockSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$81(StockSeries, _super);
    function StockSeries() {
        /**
         * The DataSource field that contains the x value.
         * It is applicable for series and technical indicators
         *
         * @default ''
         */
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** @private */
        _this.localData = undefined;
        return _this;
    }
    __decorate$12([
        Property('date')
    ], StockSeries.prototype, "xName", void 0);
    __decorate$12([
        Property('close')
    ], StockSeries.prototype, "yName", void 0);
    __decorate$12([
        Property('open')
    ], StockSeries.prototype, "open", void 0);
    __decorate$12([
        Property('close')
    ], StockSeries.prototype, "close", void 0);
    __decorate$12([
        Property('high')
    ], StockSeries.prototype, "high", void 0);
    __decorate$12([
        Property('low')
    ], StockSeries.prototype, "low", void 0);
    __decorate$12([
        Property('volume')
    ], StockSeries.prototype, "volume", void 0);
    __decorate$12([
        Property('')
    ], StockSeries.prototype, "pointColorMapping", void 0);
    __decorate$12([
        Property('SeriesType')
    ], StockSeries.prototype, "legendShape", void 0);
    __decorate$12([
        Property('')
    ], StockSeries.prototype, "legendImageUrl", void 0);
    __decorate$12([
        Complex(null, Animation$1)
    ], StockSeries.prototype, "animation", void 0);
    __decorate$12([
        Property(null)
    ], StockSeries.prototype, "xAxisName", void 0);
    __decorate$12([
        Property(null)
    ], StockSeries.prototype, "yAxisName", void 0);
    __decorate$12([
        Property(null)
    ], StockSeries.prototype, "fill", void 0);
    __decorate$12([
        Property('0')
    ], StockSeries.prototype, "dashArray", void 0);
    __decorate$12([
        Property(1)
    ], StockSeries.prototype, "width", void 0);
    __decorate$12([
        Property('')
    ], StockSeries.prototype, "name", void 0);
    __decorate$12([
        Property('')
    ], StockSeries.prototype, "dataSource", void 0);
    __decorate$12([
        Property()
    ], StockSeries.prototype, "query", void 0);
    __decorate$12([
        Property('#e74c3d')
    ], StockSeries.prototype, "bullFillColor", void 0);
    __decorate$12([
        Property('#2ecd71')
    ], StockSeries.prototype, "bearFillColor", void 0);
    __decorate$12([
        Property(false)
    ], StockSeries.prototype, "enableSolidCandles", void 0);
    __decorate$12([
        Property(true)
    ], StockSeries.prototype, "visible", void 0);
    __decorate$12([
        Complex({ color: 'transparent', width: 0 }, Border)
    ], StockSeries.prototype, "border", void 0);
    __decorate$12([
        Property(1)
    ], StockSeries.prototype, "opacity", void 0);
    __decorate$12([
        Property('Candle')
    ], StockSeries.prototype, "type", void 0);
    __decorate$12([
        Complex(null, MarkerSettings)
    ], StockSeries.prototype, "marker", void 0);
    __decorate$12([
        Collection([], Trendline)
    ], StockSeries.prototype, "trendlines", void 0);
    __decorate$12([
        Property(true)
    ], StockSeries.prototype, "enableTooltip", void 0);
    __decorate$12([
        Property('')
    ], StockSeries.prototype, "tooltipMappingName", void 0);
    __decorate$12([
        Property(null)
    ], StockSeries.prototype, "selectionStyle", void 0);
    __decorate$12([
        Property(0.5)
    ], StockSeries.prototype, "cardinalSplineTension", void 0);
    __decorate$12([
        Complex(null, CornerRadius)
    ], StockSeries.prototype, "cornerRadius", void 0);
    __decorate$12([
        Complex(null, StockEmptyPointSettings)
    ], StockSeries.prototype, "emptyPointSettings", void 0);
    __decorate$12([
        Property(null)
    ], StockSeries.prototype, "columnWidth", void 0);
    __decorate$12([
        Property(0)
    ], StockSeries.prototype, "columnSpacing", void 0);
    return StockSeries;
}(ChildProperty));
var StockChartIndicator = /** @__PURE__ @class */ (function (_super) {
    __extends$81(StockChartIndicator, _super);
    function StockChartIndicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$12([
        Property('Sma')
    ], StockChartIndicator.prototype, "type", void 0);
    __decorate$12([
        Property(14)
    ], StockChartIndicator.prototype, "period", void 0);
    __decorate$12([
        Property(3)
    ], StockChartIndicator.prototype, "dPeriod", void 0);
    __decorate$12([
        Property(14)
    ], StockChartIndicator.prototype, "kPeriod", void 0);
    __decorate$12([
        Property(80)
    ], StockChartIndicator.prototype, "overBought", void 0);
    __decorate$12([
        Property(20)
    ], StockChartIndicator.prototype, "overSold", void 0);
    __decorate$12([
        Property('Close')
    ], StockChartIndicator.prototype, "field", void 0);
    __decorate$12([
        Property(2)
    ], StockChartIndicator.prototype, "standardDeviation", void 0);
    __decorate$12([
        Property(12)
    ], StockChartIndicator.prototype, "slowPeriod", void 0);
    __decorate$12([
        Property(true)
    ], StockChartIndicator.prototype, "showZones", void 0);
    __decorate$12([
        Property(26)
    ], StockChartIndicator.prototype, "fastPeriod", void 0);
    __decorate$12([
        Complex({ color: '#ff9933', width: 2 }, StockChartConnector)
    ], StockChartIndicator.prototype, "macdLine", void 0);
    __decorate$12([
        Property('Both')
    ], StockChartIndicator.prototype, "macdType", void 0);
    __decorate$12([
        Property('#e74c3d')
    ], StockChartIndicator.prototype, "macdNegativeColor", void 0);
    __decorate$12([
        Property('#2ecd71')
    ], StockChartIndicator.prototype, "macdPositiveColor", void 0);
    __decorate$12([
        Property('rgba(211,211,211,0.25)')
    ], StockChartIndicator.prototype, "bandColor", void 0);
    __decorate$12([
        Complex({ color: '#ffb735', width: 1 }, StockChartConnector)
    ], StockChartIndicator.prototype, "upperLine", void 0);
    __decorate$12([
        Property('')
    ], StockChartIndicator.prototype, "seriesName", void 0);
    __decorate$12([
        Complex({ color: '#f2ec2f', width: 1 }, StockChartConnector)
    ], StockChartIndicator.prototype, "periodLine", void 0);
    __decorate$12([
        Complex({ color: '#f2ec2f', width: 1 }, StockChartConnector)
    ], StockChartIndicator.prototype, "lowerLine", void 0);
    __decorate$12([
        Property('')
    ], StockChartIndicator.prototype, "high", void 0);
    __decorate$12([
        Property('')
    ], StockChartIndicator.prototype, "open", void 0);
    __decorate$12([
        Property('')
    ], StockChartIndicator.prototype, "low", void 0);
    __decorate$12([
        Property('')
    ], StockChartIndicator.prototype, "xName", void 0);
    __decorate$12([
        Property('')
    ], StockChartIndicator.prototype, "close", void 0);
    __decorate$12([
        Property('')
    ], StockChartIndicator.prototype, "pointColorMapping", void 0);
    __decorate$12([
        Property('')
    ], StockChartIndicator.prototype, "volume", void 0);
    __decorate$12([
        Property(null)
    ], StockChartIndicator.prototype, "xAxisName", void 0);
    __decorate$12([
        Property(null)
    ], StockChartIndicator.prototype, "yAxisName", void 0);
    __decorate$12([
        Complex(null, Animation$1)
    ], StockChartIndicator.prototype, "animation", void 0);
    __decorate$12([
        Property(null)
    ], StockChartIndicator.prototype, "fill", void 0);
    __decorate$12([
        Property('0')
    ], StockChartIndicator.prototype, "dashArray", void 0);
    __decorate$12([
        Property(1)
    ], StockChartIndicator.prototype, "width", void 0);
    __decorate$12([
        Property()
    ], StockChartIndicator.prototype, "query", void 0);
    __decorate$12([
        Property('')
    ], StockChartIndicator.prototype, "dataSource", void 0);
    return StockChartIndicator;
}(ChildProperty));
var StockChartAxis = /** @__PURE__ @class */ (function (_super) {
    __extends$81(StockChartAxis, _super);
    function StockChartAxis() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$12([
        Complex({}, CrosshairTooltip)
    ], StockChartAxis.prototype, "crosshairTooltip", void 0);
    __decorate$12([
        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, Font)
    ], StockChartAxis.prototype, "labelStyle", void 0);
    __decorate$12([
        Property('')
    ], StockChartAxis.prototype, "title", void 0);
    __decorate$12([
        Complex({ fontFamily: null, size: "16px", fontStyle: 'Normal', fontWeight: '600', color: null }, StockChartFont)
    ], StockChartAxis.prototype, "titleStyle", void 0);
    __decorate$12([
        Property('')
    ], StockChartAxis.prototype, "labelFormat", void 0);
    __decorate$12([
        Property('DateTime')
    ], StockChartAxis.prototype, "skeletonType", void 0);
    __decorate$12([
        Property('')
    ], StockChartAxis.prototype, "skeleton", void 0);
    __decorate$12([
        Property(0)
    ], StockChartAxis.prototype, "plotOffset", void 0);
    __decorate$12([
        Property(10)
    ], StockChartAxis.prototype, "logBase", void 0);
    __decorate$12([
        Property(0)
    ], StockChartAxis.prototype, "rowIndex", void 0);
    __decorate$12([
        Property(1)
    ], StockChartAxis.prototype, "span", void 0);
    __decorate$12([
        Property(3)
    ], StockChartAxis.prototype, "maximumLabels", void 0);
    __decorate$12([
        Property(null)
    ], StockChartAxis.prototype, "desiredIntervals", void 0);
    __decorate$12([
        Property(1)
    ], StockChartAxis.prototype, "zoomFactor", void 0);
    __decorate$12([
        Property(0)
    ], StockChartAxis.prototype, "zoomPosition", void 0);
    __decorate$12([
        Property(false)
    ], StockChartAxis.prototype, "opposedPosition", void 0);
    __decorate$12([
        Property(true)
    ], StockChartAxis.prototype, "enableAutoIntervalOnZooming", void 0);
    __decorate$12([
        Property('Double')
    ], StockChartAxis.prototype, "valueType", void 0);
    __decorate$12([
        Property('Auto')
    ], StockChartAxis.prototype, "rangePadding", void 0);
    __decorate$12([
        Property('None')
    ], StockChartAxis.prototype, "edgeLabelPlacement", void 0);
    __decorate$12([
        Property('BetweenTicks')
    ], StockChartAxis.prototype, "labelPlacement", void 0);
    __decorate$12([
        Property('Auto')
    ], StockChartAxis.prototype, "intervalType", void 0);
    __decorate$12([
        Property('Outside')
    ], StockChartAxis.prototype, "tickPosition", void 0);
    __decorate$12([
        Property('')
    ], StockChartAxis.prototype, "name", void 0);
    __decorate$12([
        Property('Outside')
    ], StockChartAxis.prototype, "labelPosition", void 0);
    __decorate$12([
        Property(true)
    ], StockChartAxis.prototype, "visible", void 0);
    __decorate$12([
        Property(0)
    ], StockChartAxis.prototype, "labelRotation", void 0);
    __decorate$12([
        Property(0)
    ], StockChartAxis.prototype, "minorTicksPerInterval", void 0);
    __decorate$12([
        Property(null)
    ], StockChartAxis.prototype, "crossesAt", void 0);
    __decorate$12([
        Property(null)
    ], StockChartAxis.prototype, "crossesInAxis", void 0);
    __decorate$12([
        Property(true)
    ], StockChartAxis.prototype, "placeNextToAxisLine", void 0);
    __decorate$12([
        Property(null)
    ], StockChartAxis.prototype, "minimum", void 0);
    __decorate$12([
        Property(null)
    ], StockChartAxis.prototype, "interval", void 0);
    __decorate$12([
        Property(null)
    ], StockChartAxis.prototype, "maximum", void 0);
    __decorate$12([
        Property(34)
    ], StockChartAxis.prototype, "maximumLabelWidth", void 0);
    __decorate$12([
        Complex({}, MajorTickLines)
    ], StockChartAxis.prototype, "majorTickLines", void 0);
    __decorate$12([
        Property(false)
    ], StockChartAxis.prototype, "enableTrim", void 0);
    __decorate$12([
        Complex({}, MinorTickLines)
    ], StockChartAxis.prototype, "minorTickLines", void 0);
    __decorate$12([
        Complex({}, MinorGridLines)
    ], StockChartAxis.prototype, "minorGridLines", void 0);
    __decorate$12([
        Complex({}, MajorGridLines)
    ], StockChartAxis.prototype, "majorGridLines", void 0);
    __decorate$12([
        Complex({}, AxisLine)
    ], StockChartAxis.prototype, "lineStyle", void 0);
    __decorate$12([
        Property(false)
    ], StockChartAxis.prototype, "isInversed", void 0);
    __decorate$12([
        Property('Trim')
    ], StockChartAxis.prototype, "labelIntersectAction", void 0);
    __decorate$12([
        Property(100)
    ], StockChartAxis.prototype, "coefficient", void 0);
    __decorate$12([
        Property(0)
    ], StockChartAxis.prototype, "startAngle", void 0);
    __decorate$12([
        Property(2)
    ], StockChartAxis.prototype, "tabIndex", void 0);
    __decorate$12([
        Collection([], StockChartStripLineSettings)
    ], StockChartAxis.prototype, "stripLines", void 0);
    __decorate$12([
        Property(null)
    ], StockChartAxis.prototype, "description", void 0);
    return StockChartAxis;
}(ChildProperty));
/**
 * StockChart row
 */
var StockChartRow = /** @__PURE__ @class */ (function (_super) {
    __extends$81(StockChartRow, _super);
    function StockChartRow() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$12([
        Property('100%')
    ], StockChartRow.prototype, "height", void 0);
    __decorate$12([
        Complex({}, StockChartBorder)
    ], StockChartRow.prototype, "border", void 0);
    return StockChartRow;
}(ChildProperty));
var StockChartTrendline = /** @__PURE__ @class */ (function (_super) {
    __extends$81(StockChartTrendline, _super);
    function StockChartTrendline() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$12([
        Property(2)
    ], StockChartTrendline.prototype, "period", void 0);
    __decorate$12([
        Property('')
    ], StockChartTrendline.prototype, "name", void 0);
    __decorate$12([
        Property('Linear')
    ], StockChartTrendline.prototype, "type", void 0);
    __decorate$12([
        Property(2)
    ], StockChartTrendline.prototype, "polynomialOrder", void 0);
    __decorate$12([
        Property(0)
    ], StockChartTrendline.prototype, "forwardForecast", void 0);
    __decorate$12([
        Property(0)
    ], StockChartTrendline.prototype, "backwardForecast", void 0);
    __decorate$12([
        Complex({}, Animation$1)
    ], StockChartTrendline.prototype, "animation", void 0);
    __decorate$12([
        Property(true)
    ], StockChartTrendline.prototype, "enableTooltip", void 0);
    __decorate$12([
        Complex({}, MarkerSettings)
    ], StockChartTrendline.prototype, "marker", void 0);
    __decorate$12([
        Property(null)
    ], StockChartTrendline.prototype, "intercept", void 0);
    __decorate$12([
        Property('')
    ], StockChartTrendline.prototype, "fill", void 0);
    __decorate$12([
        Property('SeriesType')
    ], StockChartTrendline.prototype, "legendShape", void 0);
    __decorate$12([
        Property(1)
    ], StockChartTrendline.prototype, "width", void 0);
    return StockChartTrendline;
}(ChildProperty));
var StockChartAnnotationSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$81(StockChartAnnotationSettings, _super);
    function StockChartAnnotationSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$12([
        Property('0')
    ], StockChartAnnotationSettings.prototype, "y", void 0);
    __decorate$12([
        Property('0')
    ], StockChartAnnotationSettings.prototype, "x", void 0);
    __decorate$12([
        Property(null)
    ], StockChartAnnotationSettings.prototype, "content", void 0);
    __decorate$12([
        Property('Chart')
    ], StockChartAnnotationSettings.prototype, "region", void 0);
    __decorate$12([
        Property('Center')
    ], StockChartAnnotationSettings.prototype, "horizontalAlignment", void 0);
    __decorate$12([
        Property('Pixel')
    ], StockChartAnnotationSettings.prototype, "coordinateUnits", void 0);
    __decorate$12([
        Property('Middle')
    ], StockChartAnnotationSettings.prototype, "verticalAlignment", void 0);
    __decorate$12([
        Property(null)
    ], StockChartAnnotationSettings.prototype, "yAxisName", void 0);
    __decorate$12([
        Property(null)
    ], StockChartAnnotationSettings.prototype, "description", void 0);
    __decorate$12([
        Property(null)
    ], StockChartAnnotationSettings.prototype, "xAxisName", void 0);
    return StockChartAnnotationSettings;
}(ChildProperty));
var StockChartIndexes = /** @__PURE__ @class */ (function (_super) {
    __extends$81(StockChartIndexes, _super);
    function StockChartIndexes() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$12([
        Property(0)
    ], StockChartIndexes.prototype, "point", void 0);
    __decorate$12([
        Property(0)
    ], StockChartIndexes.prototype, "series", void 0);
    return StockChartIndexes;
}(ChildProperty));
/**
 * Configures the Stock events for stock chart.
 */
var StockEventsSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$81(StockEventsSettings, _super);
    function StockEventsSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$12([
        Property('Circle')
    ], StockEventsSettings.prototype, "type", void 0);
    __decorate$12([
        Property('')
    ], StockEventsSettings.prototype, "text", void 0);
    __decorate$12([
        Property('')
    ], StockEventsSettings.prototype, "description", void 0);
    __decorate$12([
        Property()
    ], StockEventsSettings.prototype, "date", void 0);
    __decorate$12([
        Complex({ color: 'black', width: 1 }, StockChartBorder)
    ], StockEventsSettings.prototype, "border", void 0);
    __decorate$12([
        Property('transparent')
    ], StockEventsSettings.prototype, "background", void 0);
    __decorate$12([
        Property(true)
    ], StockEventsSettings.prototype, "showOnSeries", void 0);
    __decorate$12([
        Property('close')
    ], StockEventsSettings.prototype, "placeAt", void 0);
    __decorate$12([
        Complex(Theme.stockEventFont, StockChartFont)
    ], StockEventsSettings.prototype, "textStyle", void 0);
    __decorate$12([
        Property([])
    ], StockEventsSettings.prototype, "seriesIndexes", void 0);
    return StockEventsSettings;
}(ChildProperty));

var __extends$82 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @private
 */
var StockEvents = /** @__PURE__ @class */ (function (_super) {
    __extends$82(StockEvents, _super);
    function StockEvents(stockChart) {
        var _this = _super.call(this, stockChart.chart) || this;
        /** @private */
        _this.symbolLocations = [];
        _this.stockChart = stockChart;
        _this.chartId = _this.stockChart.element.id;
        return _this;
    }
    /**
     * To render stock events in chart
     *
     * @returns {Element} Stock event element
     * @private
     */
    StockEvents.prototype.renderStockEvents = function () {
        var sChart = this.stockChart;
        var stockEvent;
        var stockEventElement;
        var textSize;
        // Creation of group elements for stock events
        var stockEventsElementGroup = sChart.renderer.createGroup({ id: this.chartId + '_StockEvents' });
        this.symbolLocations = initialArray(sChart.series.length, sChart.stockEvents.length, new ChartLocation(0, 0));
        for (var i = 0; i < sChart.stockEvents.length; i++) {
            stockEvent = this.stockChart.stockEvents[i];
            for (var _i = 0, _a = sChart.chart.series; _i < _a.length; _i++) {
                var series = _a[_i];
                var argsData = {
                    name: stockEventRender, stockChart: sChart, text: stockEvent.text,
                    type: stockEvent.type, cancel: false, series: series
                };
                sChart.trigger(stockEventRender, argsData);
                stockEvent.text = argsData.text;
                stockEvent.type = argsData.type;
                textSize = measureText(stockEvent.text + 'W', stockEvent.textStyle, this.stockChart.themeStyle.axisLabelFont);
                if (!argsData.cancel) {
                    stockEventElement = sChart.renderer.createGroup({ id: this.chartId + '_Series_' + series.index + '_StockEvents_' + i });
                    var stockEventDate = this.dateParse(stockEvent.date).getTime();
                    stockEventDate = this.stockChart.isDateTimeCategory ? series.xAxis.labels.indexOf(stockEventDate.toString()) :
                        stockEventDate;
                    if (withIn(stockEventDate, series.xAxis.visibleRange) && (stockEventDate >= series.xMin &&
                        stockEventDate <= series.xMax)) {
                        if (stockEvent.seriesIndexes.length > 0) {
                            for (var j = 0; j < stockEvent.seriesIndexes.length; j++) {
                                if (stockEvent.seriesIndexes[j] === series.index) {
                                    stockEventsElementGroup.appendChild(this.creatEventGroup(stockEventElement, series, stockEvent, i, textSize));
                                }
                            }
                        }
                        else {
                            stockEventsElementGroup.appendChild(this.creatEventGroup(stockEventElement, series, stockEvent, i, textSize));
                        }
                    }
                }
            }
        }
        return stockEventsElementGroup;
    };
    StockEvents.prototype.creatEventGroup = function (stockEventElement, series, stockEvent, i, textSize) {
        var symbolLocation = this.findClosePoint(series, stockEvent);
        if (!stockEvent.showOnSeries) {
            symbolLocation.y = series.yAxis.rect.y + series.yAxis.rect.height;
        }
        this.symbolLocations[series.index][i] = symbolLocation;
        this.createStockElements(stockEventElement, stockEvent, series, i, symbolLocation, textSize);
        return stockEventElement;
    };
    StockEvents.prototype.findClosePoint = function (series, sEvent) {
        var stockEventDate = this.dateParse(sEvent.date).getTime();
        stockEventDate = this.stockChart.isDateTimeCategory ? series.xAxis.labels.indexOf(stockEventDate.toString()) : stockEventDate;
        var closeIndex = this.getClosest(series, stockEventDate);
        var pointData;
        var point;
        var yPixel;
        for (var k = 0; k < series.points.length; k++) {
            point = series.points[k];
            if (closeIndex === point.xValue && point.visible) {
                pointData = new PointData(point, series);
            }
            else if (k !== 0 && k !== series.points.length - 1) {
                if (closeIndex > series.points[k - 1].xValue && closeIndex < series.points[k + 1].xValue) {
                    pointData = new PointData(point, series);
                }
            }
        }
        var xPixel = series.xAxis.rect.x + valueToCoefficient(pointData.point.xValue, series.xAxis) * series.xAxis.rect.width;
        yPixel = valueToCoefficient(pointData.point[sEvent.placeAt], series.yAxis) * series.yAxis.rect.height;
        yPixel = (yPixel * -1) + (series.yAxis.rect.y + series.yAxis.rect.height);
        return new ChartLocation(xPixel, yPixel);
    };
    StockEvents.prototype.createStockElements = function (stockEventElement, stockEve, series, i, symbolLocation, textSize) {
        var result = new Size(textSize.width > 20 ? textSize.width : 20, textSize.height > 20 ? textSize.height : 20);
        var pathString;
        var pathOption;
        var lx = symbolLocation.x;
        var ly = symbolLocation.y;
        var stockId = this.chartId + '_Series_' + series.index + '_StockEvents_' + i;
        var border = stockEve.border;
        switch (stockEve.type) {
            case 'Flag':
            case 'Circle':
            case 'Square':
                stockEventElement.appendChild(drawSymbol(new ChartLocation(lx, ly), 'Circle', new Size(2, 2), '', new PathOption(stockId + '_Circle', 'transparent', border.width, border.color), this.dateParse(stockEve.date).toISOString()));
                stockEventElement.appendChild(drawSymbol(new ChartLocation(lx, ly - 5), 'VerticalLine', new Size(9, 9), '', new PathOption(stockId + '_Path', border.color, border.width, border.color), this.dateParse(stockEve.date).toISOString()));
                stockEventElement.appendChild(drawSymbol(new ChartLocation(stockEve.type !== 'Flag' ? lx : lx + result.width / 2, ly - result.height), stockEve.type, result, '', new PathOption(stockId + '_Shape', stockEve.background, border.width, border.color), this.dateParse(stockEve.date).toISOString()));
                textElement$1(this.stockChart.renderer, new TextOption(stockId + '_Text', stockEve.type !== 'Flag' ? symbolLocation.x : symbolLocation.x + result.width / 2, (symbolLocation.y - result.height), 'middle', stockEve.text, '', 'middle'), stockEve.textStyle, stockEve.textStyle.color, stockEventElement);
                break;
            case 'ArrowUp':
            case 'ArrowDown':
            case 'ArrowRight':
            case 'ArrowLeft':
                pathString = 'M' + ' ' + lx + ' ' + ly + ' ' + this.findArrowpaths(stockEve.type);
                pathOption = new PathOption(stockId + '_Shape', stockEve.background, border.width, border.color, 1, '', pathString);
                stockEventElement.appendChild(this.stockChart.renderer.drawPath(pathOption));
                break;
            case 'Triangle':
            case 'InvertedTriangle':
                result.height = 3 * textSize.height;
                result.width = textSize.width + (1.5 * textSize.width);
                stockEventElement.appendChild(drawSymbol(new ChartLocation(symbolLocation.x, symbolLocation.y), stockEve.type, new Size(20, 20), '', new PathOption(stockId + '_Shape', stockEve.background, border.width, border.color), this.dateParse(stockEve.date).toISOString()));
                textElement$1(this.stockChart.renderer, new TextOption(stockId + '_Text', symbolLocation.x, symbolLocation.y, 'middle', stockEve.text, '', 'middle'), stockEve.textStyle, stockEve.textStyle.color, stockEventElement);
                break;
            case 'Text':
                textSize.height += 8; //padding for text height
                pathString = 'M' + ' ' + (lx) + ' ' + (ly) + ' ' +
                    'L' + ' ' + (lx - 5) + ' ' + (ly - 5) + ' ' +
                    'L' + ' ' + (lx - ((textSize.width) / 2)) + ' ' + (ly - 5) + ' ' +
                    'L' + ' ' + (lx - ((textSize.width) / 2)) + ' ' + (ly - textSize.height) + ' ' +
                    'L' + ' ' + (lx + ((textSize.width) / 2)) + ' ' + (ly - textSize.height) + ' ' +
                    'L' + ' ' + (lx + ((textSize.width) / 2)) + ' ' + (ly - 5) + ' ' +
                    'L' + ' ' + (lx + 5) + ' ' + (ly - 5) + ' ' + 'Z';
                pathOption = new PathOption(stockId + '_Shape', stockEve.background, border.width, border.color, 1, '', pathString);
                stockEventElement.appendChild(this.stockChart.renderer.drawPath(pathOption));
                textElement$1(this.stockChart.renderer, new TextOption(stockId + '_Text', lx, ly - (textSize.height / 2), 'middle', stockEve.text, '', 'middle'), stockEve.textStyle, stockEve.textStyle.color, stockEventElement);
                break;
            default:
                //pin type calculation.
                pathString = 'M' + ' ' + lx + ' ' + ly + ' ' +
                    'L' + ' ' + (lx - ((textSize.width) / 2)) + ' ' + (ly - textSize.height / 3) + ' ' +
                    'L' + ' ' + (lx - ((textSize.width) / 2)) + ' ' + (ly - textSize.height) + ' ' +
                    'L' + ' ' + (lx + ((textSize.width) / 2)) + ' ' + (ly - textSize.height) + ' ' +
                    'L' + ' ' + (lx + ((textSize.width) / 2)) + ' ' + (ly - textSize.height / 3) + ' ' + 'Z';
                pathOption = new PathOption(stockId + '_Shape', stockEve.background, border.width, border.color, 1, '', pathString);
                stockEventElement.appendChild(this.stockChart.renderer.drawPath(pathOption));
                //append text element
                textElement$1(this.stockChart.renderer, new TextOption(stockId + '_Text', lx, ly - (textSize.height / 2), 'middle', stockEve.text, '', 'middle'), stockEve.textStyle, stockEve.textStyle.color, stockEventElement);
        }
    };
    StockEvents.prototype.renderStockEventTooltip = function (targetId) {
        var seriesIndex = parseInt((targetId.split('_StockEvents_')[0]).split(this.chartId + '_Series_')[1], 10);
        var pointIndex = parseInt(targetId.split('_StockEvents_')[1].replace(/\D+/g, ''), 10);
        var updatedLocation = this.symbolLocations[seriesIndex][pointIndex];
        var pointLocation = new ChartLocation(updatedLocation.x, updatedLocation.y + this.stockChart.toolbarHeight + this.stockChart.titleSize.height);
        this.applyHighLights(pointIndex, seriesIndex);
        //title size and toolbar height is added location for placing tooltip
        var svgElement = this.getElement(this.chartId + '_StockEvents_Tooltip_svg');
        var isTooltip = (this.stockEventTooltip && svgElement && parseInt(svgElement.getAttribute('opacity'), 10) > 0);
        if (!isTooltip) {
            if (getElement$1(this.chartId + '_StockEvents_Tooltip_svg')) {
                remove(getElement$1(this.chartId + '_StockEvents_Tooltip'));
            }
            var tooltipElement = createElement('div', {
                id: this.chartId + '_StockEvents_Tooltip', className: 'ejSVGTooltip',
                attrs: { 'style': 'pointer-events:none; position:absolute;z-index: 1' }
            });
            getElement$1(this.chartId + '_Secondary_Element').appendChild(tooltipElement);
            this.stockEventTooltip = new Tooltip({
                opacity: 1,
                header: '', content: [(this.stockChart.stockEvents[pointIndex].description)],
                enableAnimation: true, location: pointLocation,
                theme: this.stockChart.theme,
                inverted: true,
                areaBounds: this.stockChart.chart.chartAxisLayoutPanel.seriesClipRect
            });
            this.stockEventTooltip.areaBounds.y += this.stockChart.toolbarHeight + this.stockChart.titleSize.height;
            this.stockEventTooltip.appendTo('#' + tooltipElement.id);
        }
        else {
            this.stockEventTooltip.content = [(this.stockChart.stockEvents[pointIndex].description)];
            this.stockEventTooltip.location = pointLocation;
            this.stockEventTooltip.dataBind();
        }
    };
    /**
     * Remove the stock event tooltip
     *
     * @param {number} duration tooltip timeout duration
     * @returns {void}
     */
    StockEvents.prototype.removeStockEventTooltip = function (duration) {
        var _this = this;
        var tooltipElement = this.getElement(this.chartId + '_StockEvents_Tooltip');
        this.stopAnimation();
        if (tooltipElement && this.stockEventTooltip) {
            this.toolTipInterval = +setTimeout(function () {
                _this.stockEventTooltip.fadeOut();
                _this.removeHighLights();
            }, duration);
        }
        else if (tooltipElement && this.stockChart.onPanning) {
            remove(tooltipElement);
        }
    };
    StockEvents.prototype.findArrowpaths = function (type) {
        var arrowString = '';
        switch (type) {
            case 'ArrowUp':
                arrowString = 'l -10 10 l 5 0 l 0 10 l 10 0 l 0 -10 l 5 0 z';
                break;
            case 'ArrowDown':
                arrowString = 'l -10 -10 l 5 0 l 0 -10 l 10 0 l 0 10 l 5 0 z';
                break;
            case 'ArrowLeft':
                arrowString = 'l -10 -10 l 0 5 l -10 0 l 0 10 l 10 0 l 0 5 z';
                break;
            case 'ArrowRight':
                arrowString = 'l 10 -10 l 0 5 l 10 0 l 0 10 l -10 0 l 0 5 z';
                break;
        }
        return arrowString;
    };
    StockEvents.prototype.applyHighLights = function (pointIndex, seriesIndex) {
        if (this.pointIndex !== pointIndex || this.seriesIndex !== seriesIndex) {
            this.removeHighLights();
        }
        this.pointIndex = pointIndex;
        this.seriesIndex = seriesIndex;
        var stockId = this.chartId + '_Series_' + seriesIndex + '_StockEvents_' + pointIndex;
        this.setOpacity(stockId + '_Shape', 0.5);
        this.setOpacity(stockId + '_Text', 0.5);
    };
    StockEvents.prototype.removeHighLights = function () {
        var stockId = this.chartId + '_Series_' + this.seriesIndex + '_StockEvents_' + this.pointIndex;
        this.setOpacity(stockId + '_Shape', 1);
        this.setOpacity(stockId + '_Text', 1);
    };
    StockEvents.prototype.setOpacity = function (elementId, opacity) {
        if (getElement$1(elementId)) {
            getElement$1(elementId).setAttribute('opacity', opacity.toString());
        }
    };
    /**
     * To convert the c# or javascript date formats into js format
     * refer chart control's dateTime processing.
     *
     * @param {Date | string} value date or string value
     * @returns {Date} date format value
     */
    StockEvents.prototype.dateParse = function (value) {
        var dateParser = this.chart.intl.getDateParser({ skeleton: 'full', type: 'dateTime' });
        var dateFormatter = this.chart.intl.getDateFormat({ skeleton: 'full', type: 'dateTime' });
        return new Date((Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({ val: value }).val))))));
    };
    return StockEvents;
}(BaseTooltip));
// eslint-disable-next-line valid-jsdoc
/**
 * To initialthe array
 *
 * @param {number} numrows numrows
 * @param {number} numcols numcols
 * @param {ChartLocation} initial initial
 * @returns {ChartLocation[][]} ChartLocation
 */
function initialArray(numrows, numcols, initial) {
    var arr = [];
    for (var i = 0; i < numrows; ++i) {
        var columns = [];
        for (var j = 0; j < numcols; ++j) {
            columns[j] = initial;
        }
        arr[i] = columns;
    }
    return arr;
}

var __extends$83 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$13 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable jsdoc/check-param-names */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable jsdoc/require-param-type */
/* eslint-disable jsdoc/require-param-description */
/* eslint-disable valid-jsdoc */
/**
 * Configures the legends in charts.
 */
var StockChartLegendSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$83(StockChartLegendSettings, _super);
    function StockChartLegendSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$13([
        Property(false)
    ], StockChartLegendSettings.prototype, "visible", void 0);
    __decorate$13([
        Property(null)
    ], StockChartLegendSettings.prototype, "height", void 0);
    __decorate$13([
        Property(null)
    ], StockChartLegendSettings.prototype, "width", void 0);
    __decorate$13([
        Complex({ x: 0, y: 0 }, Location)
    ], StockChartLegendSettings.prototype, "location", void 0);
    __decorate$13([
        Property('Auto')
    ], StockChartLegendSettings.prototype, "position", void 0);
    __decorate$13([
        Property('Series')
    ], StockChartLegendSettings.prototype, "mode", void 0);
    __decorate$13([
        Property(8)
    ], StockChartLegendSettings.prototype, "padding", void 0);
    __decorate$13([
        Property(null)
    ], StockChartLegendSettings.prototype, "itemPadding", void 0);
    __decorate$13([
        Property('Center')
    ], StockChartLegendSettings.prototype, "alignment", void 0);
    __decorate$13([
        Complex({ fontFamily: null, size: "14px", fontStyle: 'Normal', fontWeight: '400', color: null }, StockChartFont)
    ], StockChartLegendSettings.prototype, "textStyle", void 0);
    __decorate$13([
        Property(10)
    ], StockChartLegendSettings.prototype, "shapeHeight", void 0);
    __decorate$13([
        Property(10)
    ], StockChartLegendSettings.prototype, "shapeWidth", void 0);
    __decorate$13([
        Complex({}, StockChartBorder)
    ], StockChartLegendSettings.prototype, "border", void 0);
    __decorate$13([
        Complex({ left: 0, right: 0, top: 0, bottom: 0 }, StockMargin)
    ], StockChartLegendSettings.prototype, "margin", void 0);
    __decorate$13([
        Complex({ left: 0, right: 0, top: 0, bottom: 0 }, ContainerPadding)
    ], StockChartLegendSettings.prototype, "containerPadding", void 0);
    __decorate$13([
        Property(8)
    ], StockChartLegendSettings.prototype, "shapePadding", void 0);
    __decorate$13([
        Property('transparent')
    ], StockChartLegendSettings.prototype, "background", void 0);
    __decorate$13([
        Property(1)
    ], StockChartLegendSettings.prototype, "opacity", void 0);
    __decorate$13([
        Property(true)
    ], StockChartLegendSettings.prototype, "toggleVisibility", void 0);
    __decorate$13([
        Property(null)
    ], StockChartLegendSettings.prototype, "description", void 0);
    __decorate$13([
        Property(3)
    ], StockChartLegendSettings.prototype, "tabIndex", void 0);
    __decorate$13([
        Property(null)
    ], StockChartLegendSettings.prototype, "title", void 0);
    __decorate$13([
        Complex({ fontFamily: null, size: "14px", fontStyle: 'Normal', fontWeight: '600', color: null }, StockChartFont)
    ], StockChartLegendSettings.prototype, "titleStyle", void 0);
    __decorate$13([
        Property('Top')
    ], StockChartLegendSettings.prototype, "titlePosition", void 0);
    __decorate$13([
        Property(100)
    ], StockChartLegendSettings.prototype, "maximumTitleWidth", void 0);
    __decorate$13([
        Property(true)
    ], StockChartLegendSettings.prototype, "enablePages", void 0);
    __decorate$13([
        Property(false)
    ], StockChartLegendSettings.prototype, "isInversed", void 0);
    return StockChartLegendSettings;
}(ChildProperty));
/**
 * `Legend` module is used to render legend for the stockchart.
 */
var StockLegend = /** @__PURE__ @class */ (function (_super) {
    __extends$83(StockLegend, _super);
    function StockLegend(chart) {
        var _this = _super.call(this, chart) || this;
        _this.library = _this;
        _this.addEventListener();
        return _this;
    }
    /**
     * Binding events for Stocklegend module.
     */
    StockLegend.prototype.addEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.on('click', this.click, this);
        this.chart.on(Browser.touchEndEvent, this.mouseEnd, this);
        this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
    };
    /**
     * UnBinding events for Stocklegend module.
     */
    StockLegend.prototype.removeEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.off('click', this.click);
        this.chart.off(Browser.touchEndEvent, this.mouseEnd);
        this.chart.off(Browser.touchMoveEvent, this.mouseMove);
    };
    /**
     * To handle mosue move for Stocklegend module
     *
     * @param e
     */
    StockLegend.prototype.mouseMove = function (e) {
        if (this.chart.legendSettings.visible && !this.chart.isTouch) {
            this.move(e);
        }
    };
    /**
     * To handle mosue end for Stocklegend module
     *
     * @param e
     */
    StockLegend.prototype.mouseEnd = function (e) {
        if (this.chart.legendSettings.visible && this.chart.isTouch) {
            this.move(e);
        }
    };
    StockLegend.prototype.getLegendOptions = function (visibleSeriesCollection) {
        this.legendCollections = [];
        var seriesType;
        var fillColor;
        if (visibleSeriesCollection.length > 1) {
            this.legend.mode = 'Series';
        }
        for (var _i = 0, visibleSeriesCollection_1 = visibleSeriesCollection; _i < visibleSeriesCollection_1.length; _i++) {
            var series = visibleSeriesCollection_1[_i];
            if (this.legend.mode === 'Series') {
                if (series.category !== 'Indicator') {
                    seriesType = series.type;
                    fillColor = (series.pointColorMapping && series.points.length > 0) ?
                        (series.points[0].interior ? series.points[0].interior : series.interior) : series.interior;
                    this.legendCollections.push(new LegendOptions(series.name, fillColor, series.legendShape, (series.category === 'TrendLine' ?
                        this.chart.series[series.sourceIndex].trendlines[series.index].visible : series.visible), seriesType, series.legendImageUrl, series.marker.shape, series.marker.visible));
                }
            }
        }
    };
    /**
     * @param availableSize
     * @param legendBound
     * @param legend
     * @param availableSize
     * @param legendBound
     * @param legend
     * @param availableSize
     * @param legendBound
     * @param legend
     * @private
     */
    StockLegend.prototype.getLegendBounds = function (availableSize, legendBound, legend) {
        this.calculateLegendTitle(legend, legendBound);
        var padding = legend.padding;
        this.isTitle = legend.title ? true : false;
        var titlePosition = legend.titlePosition;
        var extraWidth = 0;
        var extraHeight = 0;
        var legendOption;
        var arrowHeight = this.arrowHeight;
        var arrowWidth = this.arrowWidth;
        var verticalArrowSpace = this.isVertical && !legend.enablePages ? arrowHeight : 0;
        var titleSpace = this.isTitle && titlePosition === 'Top' ? this.fivePixel + this.legendTitleSize.height : 0;
        titleSpace = this.isTitle && this.isVertical && titlePosition !== 'Top' ? this.fivePixel + this.legendTitleSize.height : titleSpace;
        if (!this.isVertical) {
            extraHeight = !legend.height ? ((availableSize.height / 100) * 5) : 0;
        }
        else {
            extraWidth = !legend.width ? ((availableSize.width / 100) * 5) : 0;
        }
        legendBound.height += (extraHeight);
        legendBound.width += extraWidth;
        var shapePadding = legend.shapePadding;
        var shapeWidth = legend.shapeWidth;
        var maximumWidth = 0;
        var rowWidth = 0;
        var legendWidth = 0;
        var columnHeight = 0;
        var rowCount = 0;
        var titlePlusArrowSpace = 0;
        var legendEventArgs;
        this.maxItemHeight = Math.max(measureText('MeasureText', legend.textStyle, this.chart.themeStyle.legendLabelFont).height, legend.shapeHeight);
        var render = false;
        for (var i = 0; i < this.legendCollections.length; i++) {
            legendOption = this.legendCollections[i];
            if (regSup.test(legendOption.text)) {
                legendOption.text = getUnicodeText(legendOption.text, regSup);
            }
            if (regSub.test(legendOption.text)) {
                legendOption.text = getUnicodeText(legendOption.text, regSub);
            }
            legendEventArgs = {
                fill: legendOption.fill, text: legendOption.text, shape: legendOption.shape,
                markerShape: legendOption.markerShape, name: legendRender, cancel: false
            };
            this.chart.trigger(legendRender, legendEventArgs);
            legendOption.text = legendEventArgs.text;
            legendOption.render = !legendEventArgs.cancel;
            legendOption.shape = legendEventArgs.shape;
            legendOption.fill = legendEventArgs.fill;
            legendOption.markerShape = legendEventArgs.markerShape;
            legendOption.textSize = measureText(legendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont);
            if (legendOption.render) {
                render = true;
                legendWidth = shapePadding + shapeWidth + legendOption.textSize.width + (!this.isVertical ? (i === 0) ? padding :
                    this.itemPadding : padding);
                rowWidth = rowWidth + legendWidth;
                if (!legend.enablePages && !this.isVertical) {
                    titlePlusArrowSpace = this.isTitle && titlePosition !== 'Top' ? this.legendTitleSize.width + this.fivePixel : 0;
                    titlePlusArrowSpace += arrowWidth;
                }
                if (legendBound.width < (padding + rowWidth + titlePlusArrowSpace) || this.isVertical) {
                    maximumWidth = Math.max(maximumWidth, (rowWidth + padding + titlePlusArrowSpace -
                        (this.isVertical ? 0 : legendWidth)));
                    if (rowCount === 0 && (legendWidth !== rowWidth)) {
                        rowCount = 1;
                    }
                    rowWidth = this.isVertical ? 0 : legendWidth;
                    rowCount++;
                    columnHeight = (rowCount * (this.maxItemHeight + (this.isVertical ? this.itemPadding : padding))) +
                        padding + titleSpace + verticalArrowSpace;
                }
            }
        }
        columnHeight = Math.max(columnHeight, (this.maxItemHeight + padding) + padding + titleSpace);
        this.isPaging = legendBound.height < columnHeight;
        if (this.isPaging && !legend.enablePages) {
            if (this.isVertical) {
                // eslint-disable-next-line no-self-assign
                columnHeight = columnHeight;
            }
            else {
                columnHeight = (this.maxItemHeight + padding) + padding + (titlePosition === 'Top' ? titleSpace : 0);
            }
        }
        this.totalPages = rowCount;
        if (!this.isPaging && !this.isVertical) {
            rowWidth += this.isTitle && titlePosition !== 'Top' ? (this.fivePixel + this.legendTitleSize.width + this.fivePixel) : 0;
        }
        if (render) {
            this.setBounds(Math.max((rowWidth + padding), maximumWidth), columnHeight, legend, legendBound);
        }
        else {
            this.setBounds(0, 0, legend, legendBound);
        }
    };
    /**
     * @param legendOptions
     * @param start
     * @param textPadding
     * @param prevLegend
     * @param rect
     * @param count
     * @param firstLegend
     * @param legendOptions
     * @param start
     * @param textPadding
     * @param prevLegend
     * @param rect
     * @param count
     * @param firstLegend
     * @param legendOptions
     * @param start
     * @param textPadding
     * @param prevLegend
     * @param rect
     * @param count
     * @param firstLegend
     * @param legendOptions
     * @param start
     * @param textPadding
     * @param prevLegend
     * @param rect
     * @param count
     * @param firstLegend
     * @param legendOptions
     * @param start
     * @param textPadding
     * @param prevLegend
     * @param rect
     * @param count
     * @param firstLegend
     * @param legendOptions
     * @param start
     * @param textPadding
     * @param prevLegend
     * @param rect
     * @param count
     * @param firstLegend
     * @param legendOptions
     * @param start
     * @param textPadding
     * @param prevLegend
     * @param rect
     * @param count
     * @param firstLegend
     * @private
     */
    StockLegend.prototype.getRenderPoint = function (legendOptions, start, textPadding, prevLegend, rect, count, firstLegend) {
        var previousBound = (prevLegend.location.x + textPadding + prevLegend.textSize.width);
        var padding = this.legend.padding;
        if ((previousBound + (legendOptions.textSize.width + textPadding - this.itemPadding)) >
            (rect.x + rect.width + this.legend.shapeWidth / 2) ||
            this.isVertical) {
            legendOptions.location.x = start.x;
            legendOptions.location.y = (count === firstLegend) ? prevLegend.location.y :
                prevLegend.location.y + this.maxItemHeight + (this.isVertical ? this.itemPadding : padding);
        }
        else {
            legendOptions.location.x = (count === firstLegend) ? prevLegend.location.x : previousBound;
            legendOptions.location.y = prevLegend.location.y;
        }
        var availwidth = (this.legendBounds.width + this.legendBounds.x) - (legendOptions.location.x +
            textPadding - this.itemPadding - this.legend.shapeWidth / 2);
        legendOptions.text = textTrim(+availwidth.toFixed(4), legendOptions.text, this.legend.textStyle, this.chart.enableRtl, this.chart.themeStyle.legendLabelFont);
    };
    /**
     * @param index
     * @param event
     * @param index
     * @param event
     * @private
     */
    StockLegend.prototype.legendClick = function (index, event) {
        var chart = this.chart;
        var seriesIndex = chart.legendSettings.mode === 'Series' ? index : 0;
        var targetSeries = chart.visibleSeries[seriesIndex];
        var targetLegend = this.legendCollections[index];
        var legendClickArgs = {
            legendText: targetLegend.text, legendShape: targetLegend.shape,
            chart: chart, series: targetSeries, name: legendClick, cancel: false
        };
        this.chart.trigger(legendClick, legendClickArgs);
        targetSeries.legendShape = legendClickArgs.legendShape;
        if (targetSeries.fill !== null) {
            chart.visibleSeries[index].interior = targetSeries.fill;
        }
        if (chart.legendSettings.toggleVisibility) {
            this.changeSeriesVisiblity(targetSeries, targetSeries.visible);
            targetLegend.visible = targetSeries.category === 'TrendLine' ? chart.series[targetSeries.sourceIndex].trendlines[targetSeries.index].visible :
                (targetSeries.visible);
            this.refreshLegendToggle(chart, targetSeries);
        }
    };
    StockLegend.prototype.refreshLegendToggle = function (chart, series) {
        var bounds = chart.stockLegendModule.legendBounds;
        chart.stockLegendModule.renderLegend(chart, chart.legendSettings, bounds);
        chart.cartesianChart.cartesianChartRefresh(chart);
    };
    StockLegend.prototype.changeSeriesVisiblity = function (series, visibility) {
        series.visible = !visibility;
        if (this.SecondaryAxis(series.yAxis)) {
            series.yAxis.internalVisibility = series.yAxis.series.some(function (value) { return (value.visible); });
        }
        if (this.SecondaryAxis(series.xAxis)) {
            series.xAxis.internalVisibility = series.xAxis.series.some(function (value) { return (value.visible); });
        }
    };
    StockLegend.prototype.SecondaryAxis = function (axis) {
        return (this.chart.axes.indexOf(axis) > -1);
    };
    /**
     * To show the tooltip for the trimmed text in legend.
     *
     * @param event
     * @returns {void}
     */
    StockLegend.prototype.click = function (event) {
        var _this = this;
        if (!this.chart.legendSettings.visible) {
            return;
        }
        var pageY = this.chart.mouseY;
        var pageX = this.chart.mouseX;
        var legendRegion = [];
        var legendItemsId = [this.legendID + '_text_', this.legendID + '_shape_marker_',
            this.legendID + '_shape_'];
        var targetId = event.target.id;
        var seriesIndex;
        for (var _i = 0, legendItemsId_1 = legendItemsId; _i < legendItemsId_1.length; _i++) {
            var id = legendItemsId_1[_i];
            if (targetId.indexOf(id) > -1) {
                seriesIndex = parseInt(targetId.split(id)[1], 10);
                this.legendClick(seriesIndex, event);
                break;
            }
        }
        if (targetId.indexOf(this.legendID + '_pagedown') > -1) {
            this.changePage(event, false);
        }
        else if (targetId.indexOf(this.legendID + '_pageup') > -1) {
            this.changePage(event, true);
        }
        legendRegion = this.legendRegions.filter(function (region) {
            return (withInBounds(pageX, (pageY + (_this.isPaging ? (_this.currentPageNumber - 1) *
                _this.translatePage(false, null, 1, 2) : 0)), region.rect));
        });
    };
    // eslint-disable-next-line jsdoc/require-returns
    /**
     *
     * Get module name
     */
    StockLegend.prototype.getModuleName = function () {
        return 'StockLegend';
    };
    /**
     * To destroy the Legend.
     *
     * @returns {void}
     * @private
     */
    StockLegend.prototype.destroy = function () {
        this.removeEventListener();
    };
    return StockLegend;
}(BaseLegend));

var __extends$76 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable jsdoc/valid-types */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable jsdoc/require-param */
/**
 * Stock Chart
 *
 * @public
 */
var StockChart = /** @__PURE__ @class */ (function (_super) {
    __extends$76(StockChart, _super);
    /**
     * Constructor for creating the widget
     *
     * @hidden
     */
    function StockChart(options, element) {
        var _this = _super.call(this, options, element) || this;
        /** @private */
        _this.isSingleAxis = false;
        _this.chartid = 57723;
        _this.tempSeriesType = [];
        /** private */
        _this.zoomChange = false;
        /** @private */
        _this.allowPan = false;
        /** @private  */
        _this.onPanning = false;
        /** @private */
        _this.trendlinetriggered = true;
        /** @private */
        _this.initialRender = true;
        /** @private */
        _this.rangeFound = false;
        /** @private */
        _this.tempPeriods = [];
        _this.isDateTimeCategory = false;
        _this.sortedData = [];
        _this.visibleRange = {
            min: 0, max: 0,
            delta: 0, interval: 0
        };
        _this.isStockChartRendered = false;
        _this.toolbarHeight = _this.enablePeriodSelector ? (Browser.isDevice ? 56 : 42) : 0;
        return _this;
    }
    /**
     * Called internally if any of the property value changed.
     *
     * @private
     */
    // eslint-disable-next-line
    StockChart.prototype.onPropertyChanged = function (newProp, oldProp) {
        // on property changes
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
            var property = _a[_i];
            switch (property) {
                case 'series':
                    this.storeDataSource();
                    this.chartRender();
                    this.stockChartDataManagerSuccess();
                    break;
            }
        }
    };
    /**
     * To change the range for chart
     */
    StockChart.prototype.rangeChanged = function (updatedStart, updatedEnd) {
        // manage chart refresh
        var chartElement = document.getElementById(this.chartObject.id);
        if (chartElement) {
            while (chartElement.firstChild) {
                chartElement.removeChild(chartElement.firstChild);
            }
        }
        this.startValue = updatedStart;
        this.endValue = updatedEnd;
        this.cartesianChart.initializeChart();
        this.periodSelector.datePicker.startDate = this.isDateTimeCategory ? new Date(this.sortedData[updatedStart]) :
            new Date(updatedStart);
        this.periodSelector.datePicker.endDate = this.isDateTimeCategory ? new Date(this.sortedData[updatedEnd]) :
            new Date(updatedEnd);
        this.periodSelector.datePicker.dataBind();
    };
    /**
     * Pre render for financial Chart
     */
    StockChart.prototype.preRender = function () {
        this.unWireEvents();
        this.initPrivateVariable();
        this.allowServerDataBinding = false;
        this.isProtectedOnChange = true;
        this.setCulture();
        this.wireEvents();
    };
    /**
     * Method to bind events for chart
     */
    StockChart.prototype.unWireEvents = function () {
        /*! Find the Events type */
        var startEvent = Browser.touchStartEvent;
        var moveEvent = Browser.touchMoveEvent;
        var stopEvent = Browser.touchEndEvent;
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        /*! UnBind the Event handler */
        EventHandler.remove(this.element, startEvent, this.stockChartOnMouseDown);
        EventHandler.remove(this.element, moveEvent, this.stockChartOnMouseMove);
        EventHandler.remove(this.element, stopEvent, this.stockChartMouseEnd);
        EventHandler.remove(this.element, 'click', this.stockChartOnMouseClick);
        EventHandler.remove(this.element, 'contextmenu', this.stockChartRightClick);
        EventHandler.remove(this.element, cancelEvent, this.stockChartOnMouseLeave);
        window.removeEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.stockChartResize);
    };
    StockChart.prototype.wireEvents = function () {
        /*! Find the Events type */
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        /*! Bind the Event handler */
        EventHandler.add(this.element, Browser.touchStartEvent, this.stockChartOnMouseDown, this);
        EventHandler.add(this.element, Browser.touchMoveEvent, this.stockChartOnMouseMove, this);
        EventHandler.add(this.element, Browser.touchEndEvent, this.stockChartMouseEnd, this);
        EventHandler.add(this.element, 'click', this.stockChartOnMouseClick, this);
        EventHandler.add(this.element, 'contextmenu', this.stockChartRightClick, this);
        EventHandler.add(this.element, cancelEvent, this.stockChartOnMouseLeave, this);
        window.addEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.stockChartResize.bind(this));
        this.setStyle(this.element);
    };
    StockChart.prototype.initPrivateVariable = function () {
        if (this.element.id === '') {
            var collection = document.getElementsByClassName('e-stockChart').length;
            this.element.id = 'stockChart_' + this.chartid + '_' + collection;
        }
        this.seriesXMax = null;
        this.seriesXMin = null;
        this.startValue = null;
        this.endValue = null;
        this.currentEnd = null;
        this.isStockChartRendered = false;
    };
    /**
     * Method to set culture for chart
     */
    StockChart.prototype.setCulture = function () {
        this.intl = new Internationalization();
    };
    StockChart.prototype.storeDataSource = function () {
        for (var i = 0; i < this.series.length; i++) {
            var series = this.series[i];
            this.tempSeriesType.push(series.type);
            series.localData = undefined;
        }
        if (this.series.length === 0) {
            this.series.push({});
        }
        this.initialRender = true;
        this.rangeFound = false;
        this.resizeTo = null;
        this.startValue = null;
        this.endValue = null;
    };
    /**
     * To Initialize the control rendering.
     */
    StockChart.prototype.render = function () {
        var _this = this;
        var loadEventData = { name: 'load', stockChart: this, theme: this.theme };
        this.trigger('load', loadEventData, function () {
            //this.theme = this.theme;
            _this.themeStyle = getThemeColor(_this.theme, false);
            _this.storeDataSource();
            _this.drawSVG();
            _this.renderTitle();
            _this.renderLegend();
            _this.chartModuleInjection();
            _this.chartRender();
            if (!(_this.dataSource instanceof DataManager) || !(_this.series[0].dataSource instanceof DataManager)) {
                _this.stockChartDataManagerSuccess();
                _this.initialRender = false;
            }
            _this.renderComplete();
            _this.allowServerDataBinding = true;
            _this.isStockChartRendered = true;
        });
        this.isProtectedOnChange = false;
    };
    /**
     * DataManager Success
     */
    StockChart.prototype.stockChartDataManagerSuccess = function () {
        this.findRange();
        this.renderRangeSelector();
        this.renderPeriodSelector();
        this.trigger('loaded', { stockChart: this });
    };
    /**
     * To set styles to resolve mvc width issue.
     *
     * @param {HTMLElement} element html element
     */
    StockChart.prototype.setStyle = function (element) {
        var zooming = this.zoomSettings;
        var disableScroll = zooming.enableSelectionZooming || zooming.enablePinchZooming ||
            this.selectionMode !== 'None' || this.crosshair.enable;
        element.style.msTouchAction = disableScroll ? 'none' : 'element';
        element.style.touchAction = disableScroll ? 'none' : 'element';
        element.style.msUserSelect = 'none';
        element.style.msContentZooming = 'none';
        element.style.position = 'relative';
        element.style.display = 'block';
        element.style.webkitUserSelect = 'none';
    };
    StockChart.prototype.drawSVG = function () {
        this.removeSvg();
        calculateSize(this);
        this.renderer = new SvgRenderer(this.element.id);
        this.renderBorder();
        this.createSecondaryElements();
        this.calculateVisibleSeries();
        this.calculateLegendBounds();
        //overall svg in which chart and selector appened
        this.mainObject = this.renderer.createSvg({
            id: this.element.id + '_stockChart_svg',
            width: this.availableSize.width,
            height: this.availableSize.height - (this.enablePeriodSelector ? this.toolbarHeight : 0) - this.titleSize.height
        });
        this.svgObject = this.mainObject;
        this.element.appendChild(this.mainObject);
    };
    StockChart.prototype.calculateVisibleSeries = function () {
        this.visibleSeries = [];
        var series;
        var color = getSeriesColor(this.theme);
        var count = color.length;
        var seriesCollections = this.series.sort(function (a, b) { return a.zOrder - b.zOrder; });
        for (var i = 0, len = seriesCollections.length; i < len; i++) {
            series = seriesCollections[i];
            series.category = 'Series';
            series.index = i;
            series.interior = series.fill || color[i % count];
            this.visibleSeries.push(series);
            seriesCollections[i] = series;
        }
    };
    StockChart.prototype.createSecondaryElements = function () {
        var tooltipDiv = redrawElement(false, this.element.id + '_Secondary_Element') ||
            this.createElement('div');
        tooltipDiv.id = this.element.id + '_Secondary_Element';
        if (this.title) {
            this.titleSize = measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont);
            this.titleSize.height += 15; // for title padding
        }
        else {
            this.titleSize = { height: null, width: null };
        }
        var height = (this.enablePeriodSelector ? this.toolbarHeight : 0) + this.titleSize.height;
        tooltipDiv.style.cssText = 'position: relative; height:' + height + 'px';
        appendChildElement(false, this.element, tooltipDiv, false);
    };
    /**
     * To provide the array of modules needed for control rendering
     *
     * @returns {ModuleDeclaration[]} required modules
     * @private
     */
    StockChart.prototype.requiredModules = function () {
        var modules = [];
        if (this.legendSettings.visible) {
            modules.push({
                member: 'StockLegend',
                args: [this]
            });
        }
        return modules;
    };
    StockChart.prototype.findCurrentData = function (totalData, xName) {
        var tempData = (!this.enablePeriodSelector && !this.enableSelector) ? totalData : undefined;
        var start = (this.isDateTimeCategory) ? new Date(this.sortedData[Math.floor(this.startValue)]).getTime() :
            this.startValue;
        var end = (this.isDateTimeCategory) ? new Date(this.sortedData[Math.floor(this.endValue)]).getTime() : this.endValue;
        if (totalData && start && end) {
            tempData = totalData
                .filter(function (data) {
                return (new Date(Date.parse(data[xName])).getTime() >= start &&
                    new Date(Date.parse(data[xName])).getTime() <= end);
            });
        }
        return tempData;
    };
    /**
     * Render period selector
     */
    StockChart.prototype.renderPeriodSelector = function () {
        if (this.enablePeriodSelector) {
            this.toolbarSelector.initializePeriodSelector();
            this.periodSelector.toolbar.refreshOverflow(); //to avoid overlapping toolbar elements
            if (!this.enableSelector) {
                this.cartesianChart.cartesianChartRefresh(this);
            }
        }
    };
    StockChart.prototype.chartRender = function () {
        this.sortedData = [];
        this.cartesianChart = new CartesianChart(this);
        this.cartesianChart.initializeChart();
    };
    /**
     * To render range Selector
     */
    StockChart.prototype.renderRangeSelector = function () {
        //SVG in which range navigator is going to append
        if (this.enableSelector) {
            this.rangeSelector = new RangeSelector(this);
            this.rangeSelector.initializeRangeNavigator();
        }
    };
    /**
     * Get component name
     */
    StockChart.prototype.getModuleName = function () {
        return 'stockChart';
    };
    /**
     * Get the properties to be maintained in the persisted state.
     *
     * @private
     */
    StockChart.prototype.getPersistData = function () {
        return '';
    };
    /**
     * To Remove the SVG.
     *
     * @returns {void}
     * @private
     */
    StockChart.prototype.removeSvg = function () {
        if (document.getElementById(this.element.id + '_Secondary_Element')) {
            remove(document.getElementById(this.element.id + '_Secondary_Element'));
        }
        var removeLength = 0;
        if (this.mainObject) {
            while (this.mainObject.childNodes.length > removeLength) {
                this.mainObject.removeChild(this.mainObject.firstChild);
            }
            if (!this.mainObject.hasChildNodes() && this.mainObject.parentNode) {
                remove(this.mainObject);
                this.mainObject = null;
                this.selectorObject = null;
                this.chartObject = null;
            }
        }
    };
    /**
     * Module Injection for components
     */
    StockChart.prototype.chartModuleInjection = function () {
        var moduleName;
        for (var _i = 0, _a = this.getInjectedModules(); _i < _a.length; _i++) {
            var modules = _a[_i];
            moduleName = modules.prototype.getModuleName().toLowerCase();
            if (moduleName.indexOf('rangetooltip') === -1) {
                Chart.Inject(modules);
            }
            else {
                RangeNavigator.Inject(modules);
            }
            if (moduleName === 'datetime' || moduleName === 'areaseries' || moduleName === 'steplineseries' || moduleName === 'datetimecategory') {
                RangeNavigator.Inject(modules);
            }
        }
    };
    /**
     * find range for financal chart
     */
    StockChart.prototype.findRange = function () {
        var _this = this;
        this.seriesXMin = Infinity;
        this.seriesXMax = -Infinity;
        for (var _i = 0, _a = this.chart.series; _i < _a.length; _i++) {
            var value = _a[_i];
            if (value.visible) {
                this.seriesXMin = Math.min(this.seriesXMin, value.xMin);
                this.seriesXMax = Math.max(this.seriesXMax, value.xMax);
            }
        }
        this.endValue = this.currentEnd = this.seriesXMax;
        if (this.enablePeriodSelector) {
            this.toolbarSelector = new ToolBarSelector(this);
            this.periodSelector = new PeriodSelector(this);
            this.tempPeriods = this.periods.length ? this.periods : this.toolbarSelector.calculateAutoPeriods();
            this.tempPeriods.map(function (period) {
                if (period.selected && period.text.toLowerCase() === 'ytd') {
                    if (_this.isDateTimeCategory) {
                        var currentYear = new Date(_this.sortedData[_this.currentEnd]).getFullYear();
                        var index = _this.currentEnd - 1;
                        for (; index >= 0; index--) {
                            if (new Date(_this.sortedData[index]).getFullYear() !== currentYear) {
                                _this.startValue = index + 1;
                                break;
                            }
                        }
                        _this.startValue = index === -1 ? 0 : _this.startValue;
                    }
                    else {
                        _this.startValue = new Date(new Date(_this.currentEnd).getFullYear().toString()).getTime();
                    }
                }
                else if (period.selected && period.text.toLowerCase() === 'all') {
                    _this.startValue = _this.seriesXMin;
                }
                else if (period.selected) {
                    _this.startValue = _this.periodSelector.changedRange(period.intervalType, _this.endValue, period.interval).getTime();
                    _this.startValue = _this.isDateTimeCategory ? _this.periodSelector.findStartValue(_this.startValue, _this.endValue) :
                        _this.startValue;
                }
            });
        }
        else {
            this.startValue = this.seriesXMin;
        }
        this.rangeFound = true;
    };
    /**
     * Handles the chart resize.
     *
     * @returns {boolean} false
     * @private
     */
    StockChart.prototype.stockChartResize = function () {
        var _this = this;
        // To avoid resize console error
        if (!document.getElementById(this.element.id)) {
            return false;
        }
        this.animateSeries = false;
        if (this.resizeTo) {
            clearTimeout(this.resizeTo);
        }
        this.resizeTo = +setTimeout(function () {
            calculateSize(_this);
            _this.renderBorder();
            _this.calculateLegendBounds();
            _this.renderTitle();
            _this.renderLegend();
            _this.cartesianChart.cartesianChartRefresh(_this);
            if (!_this.legendSettings.visible) {
                _this.mainObject.setAttribute('width', _this.availableSize.width.toString());
            }
            if (_this.enablePeriodSelector) {
                _this.renderPeriodSelector();
            }
        }, 500);
        return false;
    };
    /**
     * Handles the mouse down on chart.
     *
     * @returns {boolean} false
     * @private
     */
    StockChart.prototype.stockChartOnMouseDown = function (e) {
        var pageX;
        var pageY;
        var target;
        var touchArg;
        var rect = this.chart.element.getBoundingClientRect();
        var element = e.target;
        this.trigger('stockChartMouseDown', { target: element.id, x: this.mouseX, y: this.mouseY });
        if (e.type === 'touchstart') {
            this.isTouch = true;
            touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            target = touchArg.target;
            pageY = touchArg.changedTouches[0].clientY;
        }
        else {
            this.isTouch = e.pointerType === 'touch';
            pageX = e.clientX;
            pageY = e.clientY;
            target = e.target;
        }
        if (target.id.indexOf(this.element.id + '_stockChart_chart') > -1) {
            var svgRect = getElement$1(this.element.id + '_stockChart_chart').getBoundingClientRect();
            this.mouseDownY = this.previousMouseMoveY = (pageY - rect.top) - Math.max(svgRect.top - rect.top, 0);
            this.mouseDownX = this.previousMouseMoveX = (pageX - rect.left) - Math.max(svgRect.left - rect.left, 0);
            this.setMouseXY(pageX, pageY);
            this.referenceXAxis = this.chart.primaryXAxis;
            getElement$1(this.element.id + '_stockChart_chart').setAttribute('cursor', 'pointer');
            if (this.isDateTimeCategory) {
                this.visibleRange.min = this.sortedData.indexOf(parseInt(this.referenceXAxis.labels[this.referenceXAxis.visibleRange.min], 10));
                this.visibleRange.max = this.sortedData.indexOf(parseInt(this.referenceXAxis.labels[this.referenceXAxis.visibleRange.max], 10));
                this.visibleRange.delta = this.referenceXAxis.visibleRange.delta;
                this.visibleRange.interval = this.referenceXAxis.visibleRange.interval;
            }
            else {
                this.visibleRange = this.referenceXAxis.visibleRange;
            }
            this.mouseDownXPoint = getRangeValueXByPoint(this.mouseX - this.referenceXAxis.rect.x, this.referenceXAxis.rect.width, this.visibleRange, this.referenceXAxis.isInversed);
            this.allowPan = true;
            this.notify(Browser.touchStartEvent, e);
        }
        return false;
    };
    /**
     * Handles the mouse up.
     *
     * @returns {boolean} false
     * @private
     */
    StockChart.prototype.stockChartMouseEnd = function (e) {
        var pageY;
        var pageX;
        var touchArg;
        if (e.type === 'touchend') {
            touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            pageY = touchArg.changedTouches[0].clientY;
            this.isTouch = true;
        }
        else {
            pageY = e.clientY;
            pageX = e.clientX;
            this.isTouch = e.pointerType === 'touch' || e.pointerType === '2';
        }
        getElement$1(this.element.id + '_stockChart_chart').setAttribute('cursor', 'auto');
        this.onPanning = false;
        this.setMouseXY(pageX, pageY);
        this.stockChartOnMouseUp(e);
        return false;
    };
    /**
     * Handles the mouse up.
     *
     * @returns {boolean} false
     * @private
     */
    StockChart.prototype.stockChartOnMouseUp = function (e) {
        var element = e.target;
        this.trigger('stockChartMouseUp', { target: element.id, x: this.mouseX, y: this.mouseY });
        this.isChartDrag = false;
        this.allowPan = false;
        if (this.rangeNavigator) {
            this.rangeNavigator.rangeSlider.isDrag = false;
        }
        if (this.isTouch) {
            this.threshold = new Date().getTime() + 300;
        }
        this.notify(Browser.touchEndEvent, e);
        if (this.stockEvent) {
            this.stockEvent.removeStockEventTooltip(0);
        }
        return false;
    };
    /**
     * To find mouse x, y for aligned chart element svg position
     */
    StockChart.prototype.setMouseXY = function (pageX, pageY) {
        var svgRectElement = getElement$1(this.element.id + '_stockChart_chart');
        if (this.element && svgRectElement) {
            var stockRect = this.element.getBoundingClientRect();
            var svgRect = svgRectElement.getBoundingClientRect();
            this.mouseX = (pageX - stockRect.left) - Math.max(svgRect.left - stockRect.left, 0);
            this.mouseY = (pageY - stockRect.top) - Math.max(svgRect.top - stockRect.top, 0);
        }
    };
    /**
     * Handles the mouse move.
     *
     * @returns {boolean} false
     * @private
     */
    StockChart.prototype.stockChartOnMouseMove = function (e) {
        var pageX;
        var touchArg;
        var pageY;
        this.mouseMoveEvent = e;
        if (e.type === 'touchmove') {
            this.isTouch = true;
            touchArg = e;
            pageY = touchArg.changedTouches[0].clientY;
            pageX = touchArg.changedTouches[0].clientX;
        }
        else {
            this.isTouch = e.pointerType === 'touch' || e.pointerType === '2' || this.isTouch;
            pageX = e.clientX;
            pageY = e.clientY;
        }
        this.trigger('stockChartMouseMove', { target: e.target.id, x: this.mouseX, y: this.mouseY });
        if (getElement$1(this.element.id + '_stockChart_chart')) {
            this.setMouseXY(pageX, pageY);
            this.chartOnMouseMove(e);
        }
        return false;
    };
    /**
     * Handles the mouse move on chart.
     *
     * @returns {boolean} false
     * @private
     */
    StockChart.prototype.chartOnMouseMove = function (e) {
        if (this.rangeNavigator && this.rangeNavigator.rangeSlider.isDrag) {
            this.rangeNavigator.mouseX = this.mouseX;
            this.rangeNavigator.rangeSlider.mouseMoveHandler(e);
        }
        if (this.allowPan && !this.chart.startMove && this.mouseDownXPoint && this.mouseX !== this.previousMouseMoveX && this.zoomSettings.enablePan) {
            this.onPanning = true;
            this.zoomChange = false;
            getElement$1(this.element.id + '_stockChart_chart').setAttribute('cursor', 'pointer');
            this.mouseUpXPoint = getRangeValueXByPoint(this.mouseX - this.referenceXAxis.rect.x, this.referenceXAxis.rect.width, this.visibleRange, this.referenceXAxis.isInversed);
            var diff = Math.abs(this.mouseUpXPoint - this.mouseDownXPoint);
            if (this.mouseDownXPoint < this.mouseUpXPoint) {
                if (this.seriesXMin <= this.visibleRange.min - diff) {
                    this.startValue = this.visibleRange.min - diff;
                    this.endValue = this.visibleRange.max - diff;
                    if (this.enableSelector) {
                        this.rangeNavigator.rangeSlider.setSlider(this.visibleRange.min - diff, this.visibleRange.max - diff, !this.rangeNavigator.enableDeferredUpdate, (this.rangeNavigator.rangeTooltipModule
                            && this.rangeNavigator.tooltip.enable));
                    }
                    else {
                        this.cartesianChart.cartesianChartRefresh(this);
                    }
                }
            }
            else {
                if (this.seriesXMax >= this.visibleRange.max + diff) {
                    this.startValue = this.visibleRange.min + diff;
                    this.endValue = this.visibleRange.max + diff;
                    if (this.enableSelector) {
                        this.rangeNavigator.rangeSlider.setSlider(this.visibleRange.min + diff, this.visibleRange.max + diff, !this.rangeNavigator.enableDeferredUpdate, (this.rangeNavigator.rangeTooltipModule
                            && this.rangeNavigator.tooltip.enable));
                    }
                    else {
                        this.cartesianChart.cartesianChartRefresh(this);
                    }
                }
            }
        }
        this.notify(Browser.touchMoveEvent, e);
        if (e.target.id === '' && !this.onPanning === true) { //to remove the tooltip when hover on mouse move
            var element = void 0;
            if (this.chart.tooltip.enable || this.crosshair.enable) {
                element = document.getElementById(this.element.id + '_stockChart_chart_tooltip');
                if (element) {
                    remove(element);
                }
            }
            if (getElement$1(this.element.id + '_StockEvents_Tooltip')) {
                this.stockEvent.removeStockEventTooltip(0);
            }
        }
        if (e.target.id.indexOf('StockEvents') !== -1) {
            clearInterval(this.stockEvent.toolTipInterval);
            this.stockEvent.renderStockEventTooltip(e.target.id);
        }
        else {
            if (this.stockEvent) {
                this.stockEvent.removeStockEventTooltip(1000);
            }
        }
        this.isTouch = false;
        return false;
    };
    /**
     * Handles the mouse click on chart.
     *
     * @returns {boolean} false
     * @private
     */
    StockChart.prototype.stockChartOnMouseClick = function (e) {
        var element = e.target;
        this.trigger('stockChartMouseClick', { target: element.id, x: this.mouseX, y: this.mouseY });
        this.notify('click', e);
        return false;
    };
    StockChart.prototype.stockChartRightClick = function (event) {
        if (this.crosshair.enable &&
            (event.buttons === 2 || event.which === 0 || event.pointerType === 'touch')) {
            event.preventDefault();
            event.stopPropagation();
            return false;
        }
        return true;
    };
    /**
     * Handles the mouse leave.
     *
     * @returns {boolean} false
     * @private
     */
    StockChart.prototype.stockChartOnMouseLeave = function (e) {
        var touchArg;
        var pageX;
        var pageY;
        if (e.type === 'touchleave') {
            this.isTouch = true;
            touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            pageY = touchArg.changedTouches[0].clientY;
        }
        else {
            pageX = e.clientX;
            pageY = e.clientY;
            this.isTouch = e.pointerType === 'touch' || e.pointerType === '2';
        }
        this.setMouseXY(pageX, pageY);
        this.allowPan = false;
        this.stockChartOnMouseLeaveEvent(e);
        return false;
    };
    /**
     * Handles the mouse leave on chart.
     *
     * @returns {boolean} false
     * @private
     */
    StockChart.prototype.stockChartOnMouseLeaveEvent = function (e) {
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        //this.trigger(chartMouseLeave, { target: element.id, x: this.mouseX, y: this.mouseY });
        this.isChartDrag = false;
        this.notify(cancelEvent, e);
        if (this.stockEvent) {
            this.stockEvent.removeStockEventTooltip(1000);
        }
        if (this.rangeNavigator) {
            this.rangeNavigator.rangeSlider.isDrag = false;
        }
        if (this.onPanning) {
            this.onPanning = false;
            this.chart.mouseLeave(e);
            getElement$1(this.element.id + '_stockChart_chart').setAttribute('cursor', 'auto');
        }
        return false;
    };
    /**
     * Destroy method
     */
    StockChart.prototype.destroy = function () {
        this.cartesianChart = null;
        this.chart = null;
        this.periodSelector = null;
        this.rangeNavigator = null;
        this.rangeSelector = null;
        this.tempPeriods = [];
        this.toolbarSelector = null;
        this.visibleSeries = [];
        this.yAxisElements = null;
        var element = document.getElementById(this.element.id + '_stockChart_chartKeyboard_chart_focus');
        if (element) {
            element.remove();
        }
        var borderElement = document.getElementById(this.element.id + '_stock_border');
        if (borderElement) {
            borderElement.remove();
        }
        if (this.element) {
            this.unWireEvents();
            _super.prototype.destroy.call(this);
            this.removeSvg();
            this.svgObject = null;
        }
    };
    StockChart.prototype.renderBorder = function () {
        if (this.border.width) {
            var border = this.createElement('div');
            border.id = this.element.id + '_stock_border';
            border.style.width = (this.availableSize.width) + 'px';
            border.style.height = (this.availableSize.height) + 'px';
            border.style.position = 'absolute';
            border.style.border = this.border.width + 'px solid ' + this.border.color;
            border.style.pointerEvents = 'none';
            appendChildElement(false, getElement$1(this.element.id), border);
        }
    };
    /**
     * Render title for chart
     */
    StockChart.prototype.renderTitle = function () {
        var rect;
        if (this.title) {
            appendChildElement(false, getElement$1(this.element.id + '_Secondary_Element'), this.renderer.createSvg({
                id: this.element.id + '_stockChart_Title',
                width: this.availableSize.width,
                height: this.titleSize.height,
                fill: this.background || this.themeStyle.background
            }), false);
            var alignment = this.titleStyle.textAlignment;
            var getAnchor = alignment === 'Near' ? 'start' : alignment === 'Far' ? 'end' : 'middle';
            rect = new Rect(0, 0, this.availableSize.width, 0);
            var options = new TextOption(this.element.id + '_ChartTitle', titlePositionX(rect, this.titleStyle), ((this.titleSize.height - 10)), getAnchor, this.title, '', 'auto');
            textElement$1(this.renderer, options, this.titleStyle, this.titleStyle.color || this.themeStyle.chartTitleFont.color || this.findTitleColor(), getElement$1(this.element.id + '_stockChart_Title'), false, false, null, null, null, null, null, null, null, null, this.themeStyle.chartTitleFont);
            this.availableSize.height -= (this.titleSize.height + 5);
        }
    };
    /**
     * @private
     */
    StockChart.prototype.calculateLegendBounds = function () {
        if (this.stockLegendModule && this.legendSettings.visible) {
            this.stockLegendModule.getLegendOptions(this.visibleSeries);
        }
        var titleHeight = this.titleSize.height;
        var left = this.border.width;
        var width = this.availableSize.width - this.border.width - left;
        var top = this.chartArea.border.width * 0.5 + this.border.width;
        var height = this.availableSize.height - top - this.border.width -
            (this.enablePeriodSelector ? this.toolbarHeight : 0) - titleHeight;
        this.initialClipRect = new Rect(left, top, width, height);
        this.tempAvailableSize = new Size(this.availableSize.width, this.availableSize.height -
            (this.enablePeriodSelector ? this.toolbarHeight : 0) - titleHeight);
        if (this.stockLegendModule && this.legendSettings.visible) {
            this.stockLegendModule.calculateLegendBounds(this.initialClipRect, this.tempAvailableSize, null);
        }
    };
    /**
     * To render the legend
     *
     * @private
     */
    StockChart.prototype.renderLegend = function () {
        if (this.stockLegendModule && this.stockLegendModule.legendCollections.length && this.legendSettings.visible) {
            this.stockLegendModule.calTotalPage = true;
            var bounds = this.stockLegendModule.legendBounds;
            this.stockLegendModule.renderLegend(this, this.legendSettings, bounds);
            if (this.legendSettings.position === 'Auto' || this.legendSettings.position === 'Bottom' || this.legendSettings.position === 'Top') {
                this.availableSize.height -= this.stockLegendModule.legendBounds.height;
            }
            else if (this.legendSettings.position === 'Left' || this.legendSettings.position === 'Right') {
                this.availableSize.width -= this.stockLegendModule.legendBounds.width;
            }
        }
    };
    StockChart.prototype.findTitleColor = function () {
        if (this.theme.toLocaleLowerCase().indexOf('highcontrast') > -1 || this.theme.indexOf('Dark') > -1) {
            return '#ffffff';
        }
        return '#424242';
    };
    /**
     * @private
     */
    StockChart.prototype.calculateStockEvents = function () {
        if (this.stockEvents.length) {
            this.stockEvent = new StockEvents(this);
            appendChildElement(false, this.chartObject, this.stockEvent.renderStockEvents());
        }
    };
    __decorate$9([
        Property(null)
    ], StockChart.prototype, "width", void 0);
    __decorate$9([
        Property(null)
    ], StockChart.prototype, "height", void 0);
    __decorate$9([
        Property('')
    ], StockChart.prototype, "dataSource", void 0);
    __decorate$9([
        Complex({}, StockMargin)
    ], StockChart.prototype, "margin", void 0);
    __decorate$9([
        Complex({ color: '#DDDDDD', width: 1 }, StockChartBorder)
    ], StockChart.prototype, "border", void 0);
    __decorate$9([
        Property(null)
    ], StockChart.prototype, "background", void 0);
    __decorate$9([
        Property('Material')
    ], StockChart.prototype, "theme", void 0);
    __decorate$9([
        Complex({ name: 'primaryXAxis', valueType: 'DateTime' }, StockChartAxis)
    ], StockChart.prototype, "primaryXAxis", void 0);
    __decorate$9([
        Complex({ border: { color: null, width: 0.5 }, background: 'transparent' }, StockChartArea)
    ], StockChart.prototype, "chartArea", void 0);
    __decorate$9([
        Complex({ name: 'primaryYAxis', opposedPosition: true, labelPosition: 'Inside', tickPosition: 'Inside' }, StockChartAxis)
    ], StockChart.prototype, "primaryYAxis", void 0);
    __decorate$9([
        Collection([{}], StockChartRow)
    ], StockChart.prototype, "rows", void 0);
    __decorate$9([
        Collection([{ opposedPosition: true }], StockChartAxis)
    ], StockChart.prototype, "axes", void 0);
    __decorate$9([
        Collection([], StockSeries)
    ], StockChart.prototype, "series", void 0);
    __decorate$9([
        Collection([], StockEventsSettings)
    ], StockChart.prototype, "stockEvents", void 0);
    __decorate$9([
        Property(false)
    ], StockChart.prototype, "isTransposed", void 0);
    __decorate$9([
        Property('')
    ], StockChart.prototype, "title", void 0);
    __decorate$9([
        Complex({ size: '16px', fontWeight: '600', color: null, fontStyle: 'Normal', fontFamily: null }, StockChartFont)
    ], StockChart.prototype, "titleStyle", void 0);
    __decorate$9([
        Collection([], StockChartIndicator)
    ], StockChart.prototype, "indicators", void 0);
    __decorate$9([
        Complex({ shared: true, enableMarker: false }, StockTooltipSettings)
    ], StockChart.prototype, "tooltip", void 0);
    __decorate$9([
        Complex({ dashArray: '5', lineType: 'Vertical' }, CrosshairSettings)
    ], StockChart.prototype, "crosshair", void 0);
    __decorate$9([
        Complex({}, StockChartLegendSettings)
    ], StockChart.prototype, "legendSettings", void 0);
    __decorate$9([
        Complex({ enablePan: true }, ZoomSettings)
    ], StockChart.prototype, "zoomSettings", void 0);
    __decorate$9([
        Property(true)
    ], StockChart.prototype, "enablePeriodSelector", void 0);
    __decorate$9([
        Property(true)
    ], StockChart.prototype, "enableCustomRange", void 0);
    __decorate$9([
        Property(false)
    ], StockChart.prototype, "isSelect", void 0);
    __decorate$9([
        Property(true)
    ], StockChart.prototype, "enableSelector", void 0);
    __decorate$9([
        Collection([], Periods)
    ], StockChart.prototype, "periods", void 0);
    __decorate$9([
        Collection([{}], StockChartAnnotationSettings)
    ], StockChart.prototype, "annotations", void 0);
    __decorate$9([
        Event()
    ], StockChart.prototype, "selectorRender", void 0);
    __decorate$9([
        Event()
    ], StockChart.prototype, "stockChartMouseMove", void 0);
    __decorate$9([
        Event()
    ], StockChart.prototype, "stockChartMouseLeave", void 0);
    __decorate$9([
        Event()
    ], StockChart.prototype, "stockChartMouseDown", void 0);
    __decorate$9([
        Event()
    ], StockChart.prototype, "stockChartMouseUp", void 0);
    __decorate$9([
        Event()
    ], StockChart.prototype, "stockChartMouseClick", void 0);
    __decorate$9([
        Event()
    ], StockChart.prototype, "pointClick", void 0);
    __decorate$9([
        Event()
    ], StockChart.prototype, "pointMove", void 0);
    __decorate$9([
        Event()
    ], StockChart.prototype, "onZooming", void 0);
    __decorate$9([
        Event()
    ], StockChart.prototype, "legendRender", void 0);
    __decorate$9([
        Event()
    ], StockChart.prototype, "legendClick", void 0);
    __decorate$9([
        Property('None')
    ], StockChart.prototype, "selectionMode", void 0);
    __decorate$9([
        Property(false)
    ], StockChart.prototype, "isMultiSelect", void 0);
    __decorate$9([
        Event()
    ], StockChart.prototype, "load", void 0);
    __decorate$9([
        Event()
    ], StockChart.prototype, "loaded", void 0);
    __decorate$9([
        Event()
    ], StockChart.prototype, "rangeChange", void 0);
    __decorate$9([
        Event()
    ], StockChart.prototype, "axisLabelRender", void 0);
    __decorate$9([
        Event()
    ], StockChart.prototype, "tooltipRender", void 0);
    __decorate$9([
        Event()
    ], StockChart.prototype, "seriesRender", void 0);
    __decorate$9([
        Event()
    ], StockChart.prototype, "stockEventRender", void 0);
    __decorate$9([
        Collection([], StockChartIndexes)
    ], StockChart.prototype, "selectedDataIndexes", void 0);
    __decorate$9([
        Property([])
    ], StockChart.prototype, "seriesType", void 0);
    __decorate$9([
        Property(['EMA', 'TMA', 'SMA', 'Momentum', 'ATR', 'Accumulation Distribution', 'Bollinger Bands', 'MACD', 'Stochastic', 'RSI'])
    ], StockChart.prototype, "indicatorType", void 0);
    __decorate$9([
        Property(['PNG', 'JPEG', 'SVG', 'PDF', 'XLSX', 'CSV', 'Print'])
    ], StockChart.prototype, "exportType", void 0);
    __decorate$9([
        Property([])
    ], StockChart.prototype, "trendlineType", void 0);
    StockChart = __decorate$9([
        NotifyPropertyChanges
    ], StockChart);
    return StockChart;
}(Component));

/**
 * Financial chart exports
 */

/**
 * Chart and accumulation common files
 */

/**
 * `Tooltip` module is used to render the tooltip for chart series.
 */
var RangeTooltip = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for tooltip module.
     *
     * @private
     */
    function RangeTooltip(range) {
        this.control = range;
        this.elementId = range.element.id;
    }
    /**
     * Left tooltip method called here.
     *
     * @param {RangeSlider} rangeSlider RangeSlider
     */
    RangeTooltip.prototype.renderLeftTooltip = function (rangeSlider) {
        this.fadeOutTooltip();
        var content = this.getTooltipContent(rangeSlider.currentStart);
        var contentWidth = this.getContentSize(content);
        var rect = this.control.enableRtl ? rangeSlider.rightRect : rangeSlider.leftRect;
        if (contentWidth > rect.width) {
            rect = rangeSlider.midRect;
        }
        this.leftTooltip = this.renderTooltip(rect, this.createElement('_leftTooltip'), rangeSlider.startX, content);
    };
    /**
     * get the content size
     *
     * @param {string[]} value value
     */
    RangeTooltip.prototype.getContentSize = function (value) {
        var width;
        var font = this.control.tooltip.textStyle;
        if (this.control.tooltip.template) {
            width = createTemplate(createElement('div', {
                id: 'measureElement',
                styles: 'position: absolute;'
            }), 0, this.control.tooltip.template, this.control).getBoundingClientRect().width;
        }
        else {
            // 20 for tooltip padding
            width = measureText(value[0], font, this.control.themeStyle.tooltipLabelFont).width + 20;
        }
        return width;
    };
    /**
     * Right tooltip method called here.
     *
     * @param {RangeSlider} rangeSlider RangeSlider
     */
    RangeTooltip.prototype.renderRightTooltip = function (rangeSlider) {
        this.fadeOutTooltip();
        var content = this.getTooltipContent(rangeSlider.currentEnd);
        var contentWidth = this.getContentSize(content);
        var rect = this.control.enableRtl ? rangeSlider.leftRect : rangeSlider.rightRect;
        if (contentWidth > rect.width) {
            rect = rangeSlider.midRect;
            rect.x = !this.control.series.length ? rect.x : 0;
        }
        this.rightTooltip = this.renderTooltip(rect, this.createElement('_rightTooltip'), rangeSlider.endX, content);
    };
    /**
     * Tooltip element creation
     *
     * @param {string} id element id
     */
    RangeTooltip.prototype.createElement = function (id) {
        if (getElement$1(this.elementId + id)) {
            return getElement$1(this.elementId + id);
        }
        else {
            var element = document.createElement('div');
            element.id = this.elementId + id;
            element.className = 'ejSVGTooltip';
            element.style.cssText = 'pointer-events:none; position:absolute;z-index: 1';
            if (!this.control.stockChart) {
                getElement$1(this.elementId + '_Secondary_Element').appendChild(element);
            }
            else {
                var stockChart = this.control.stockChart;
                getElement$1(stockChart.element.id + '_Secondary_Element').appendChild(element);
                element.style.transform = 'translateY(' + (((stockChart.availableSize.height - stockChart.toolbarHeight - 51) +
                    stockChart.toolbarHeight) + stockChart.titleSize.height) + 'px)';
            }
            return element;
        }
    };
    /**
     * Tooltip render called here
     *
     * @param {Rect} bounds bounds
     * @param {Element} parent parent
     * @param {number} pointX pointX
     * @param {string[]} content content
     */
    RangeTooltip.prototype.renderTooltip = function (bounds, parent, pointX, content) {
        var control = this.control;
        var tooltip = control.tooltip;
        var argsData = {
            cancel: false, name: 'tooltipRender', text: content,
            textStyle: tooltip.textStyle
        };
        this.control.trigger('tooltipRender', argsData);
        var left = control.svgObject.getBoundingClientRect().left -
            control.element.getBoundingClientRect().left;
        if (!argsData.cancel) {
            return new Tooltip({
                location: { x: pointX, y: control.rangeSlider.sliderY },
                content: argsData.text, marginX: 2,
                enableShadow: false,
                marginY: 2, arrowPadding: 8, rx: 4, ry: 4,
                inverted: control.series.length > 0,
                areaBounds: bounds, fill: tooltip.fill ? tooltip.fill : this.control.themeStyle.tooltipBackground,
                theme: this.control.theme,
                clipBounds: { x: left },
                border: tooltip.border, opacity: tooltip.opacity ? tooltip.opacity : ((this.control.theme === 'Material3' || this.control.theme === 'Material3Dark') ? 1 : 0.75),
                template: tooltip.template,
                textStyle: argsData.textStyle,
                availableSize: control.availableSize,
                controlName: 'RangeNavigator',
                data: {
                    'start': this.getTooltipContent(this.control.startValue)[0],
                    'end': this.getTooltipContent(this.control.endValue)[0],
                    'value': content[0]
                }
            }, parent);
        }
        else {
            return null;
        }
    };
    /**
     * Tooltip content processed here
     *
     * @param {number} value tooltip value
     */
    RangeTooltip.prototype.getTooltipContent = function (value) {
        var control = this.control;
        var tooltip = control.tooltip;
        var xAxis = control.chartSeries.xAxis;
        var text;
        var format = tooltip.format || xAxis.labelFormat;
        var isCustom = format.match('{value}') !== null;
        var valueType = xAxis.valueType;
        value = (valueType === 'DateTimeCategory' ? parseInt(xAxis.labels[Math.floor(value)], 10) : value);
        if (valueType.indexOf('DateTime') > -1) {
            text = (control.intl.getDateFormat({
                format: format || 'MM/dd/yyyy',
                type: firstToLowerCase(control.skeletonType),
                skeleton: valueType === 'DateTime' ? control.dateTimeModule.getSkeleton(xAxis, null, null) : control.dateTimeCategoryModule.getSkeleton(xAxis, null, null)
            }))(new Date(value));
        }
        else {
            xAxis.format = control.intl.getNumberFormat({
                format: isCustom ? '' : format,
                useGrouping: control.useGroupingSeparator
            });
            text = control.doubleModule.formatValue(xAxis, isCustom, format, valueType === 'Logarithmic' ? Math.pow(xAxis.logBase, value) : value);
        }
        return [text];
    };
    /**
     * Fadeout animation performed here
     */
    RangeTooltip.prototype.fadeOutTooltip = function () {
        var _this = this;
        var tooltip = this.control.tooltip;
        if (tooltip.displayMode === 'OnDemand') {
            stopTimer(this.toolTipInterval);
            if (this.rightTooltip) {
                this.toolTipInterval = +setTimeout(function () {
                    _this.leftTooltip.fadeOut();
                    _this.rightTooltip.fadeOut();
                }, 1000);
            }
        }
    };
    /**
     * Get module name.
     */
    RangeTooltip.prototype.getModuleName = function () {
        return 'RangeTooltip';
    };
    /**
     * To destroy the tooltip.
     *
     * @returns {void}
     * @private
     */
    RangeTooltip.prototype.destroy = function () {
        // Destroy method called here
    };
    return RangeTooltip;
}());

/**
 * Range Navigator component export methods
 */

/**
 * Class for Bullet chart axis
 */
var BulletChartAxis = /** @__PURE__ @class */ (function () {
    function BulletChartAxis(bullet) {
        //super();
        this.bulletChart = bullet;
        this.isVertical = (bullet.orientation === 'Vertical');
        this.isLabelsInside = (bullet.labelPosition === 'Inside');
        this.isHorizontal = (bullet.orientation === 'Horizontal');
        this.isLeft = bullet.titlePosition === 'Left';
        this.isRight = bullet.titlePosition === 'Right';
        this.isTop = bullet.titlePosition === 'Top';
        this.majorTickSize = bullet.majorTickLines.height;
        this.location = 10;
        this.labelOffset = 15;
        this.labelSize = parseFloat(bullet.labelStyle.size);
        this.isLabelBelow = !this.bulletChart.opposedPosition;
    }
    BulletChartAxis.prototype.renderMajorTickLines = function (intervalValue, scale) {
        if (this.bulletChart.orientation === 'Horizontal') {
            this.renderXMajorTickLines(intervalValue, scale);
        }
        else {
            this.renderYMajorTickLines(intervalValue, scale);
        }
    };
    BulletChartAxis.prototype.renderMinorTickLines = function (intervalValue, scale) {
        if (this.bulletChart.orientation === 'Horizontal') {
            this.renderXMinorTickLines(intervalValue, scale);
        }
        else {
            this.renderYMinorTickLines(intervalValue, scale);
        }
    };
    BulletChartAxis.prototype.renderAxisLabels = function (intervalValue, scale) {
        if (this.bulletChart.orientation === 'Horizontal') {
            this.renderXAxisLabels(intervalValue, scale);
        }
        else {
            this.renderYAxisLabels(intervalValue, scale);
        }
    };
    /**
     * To render grid lines of bullet chart axis.
     */
    BulletChartAxis.prototype.renderXMajorTickLines = function (intervalValue, scale) {
        var bullet = this.bulletChart;
        var tickGroup = bullet.renderer.createGroup({ 'id': bullet.svgObject.id + '_majorTickGroup' });
        var min = bullet.minimum;
        var max = bullet.maximum;
        var interval = bullet.interval;
        var enableRtl = bullet.enableRtl;
        var y1 = bullet.initialClipRect.y + ((bullet.opposedPosition) ? 0 : bullet.initialClipRect.height);
        var y2 = y1 + ((!bullet.opposedPosition) ? ((bullet.tickPosition !== 'Inside' ?
            this.majorTickSize : -this.majorTickSize)) : ((bullet.tickPosition !== 'Inside' ? -this.majorTickSize : this.majorTickSize)));
        var majorTick = bullet.majorTickLines;
        var strokeColor = majorTick.color || bullet.themeStyle.majorTickLineColor;
        var options;
        var condition;
        var size = bullet.initialClipRect.x + ((bullet.enableRtl) ? bullet.initialClipRect.width : 0);
        var majorPointX = bullet.initialClipRect.x + majorTick.width / 2 + ((enableRtl) ? bullet.initialClipRect.width : 0);
        for (var i = min; i <= max; i += interval) {
            condition = (!bullet.enableRtl) ? (i === max) : (i === min);
            if (condition) {
                majorPointX -= majorTick.width / 2;
            }
            condition = (!bullet.enableRtl) ? (i === max) : (i === min);
            if (bullet.majorTickLines.useRangeColor) {
                strokeColor = this.bindingRangeStrokes(majorPointX - ((condition) ? this.bulletChart.majorTickLines.width / 2 : 0), size, this.bulletChart.orientation, bullet.enableRtl);
            }
            options = this.majorTicks(majorPointX, majorPointX, y1, y2, strokeColor, i);
            var majorTicks = bullet.renderer.drawLine(options);
            majorPointX = majorPointX + ((enableRtl ? -intervalValue : intervalValue));
            tickGroup.appendChild(majorTicks);
            scale.appendChild(tickGroup);
        }
    };
    /**
     * To render grid lines of bullet chart axis.
     */
    BulletChartAxis.prototype.renderYMajorTickLines = function (intervalValue, scale) {
        var bulletChart = this.bulletChart;
        var tickGroup = bulletChart.renderer.createGroup({ 'id': bulletChart.svgObject.id + '_majorTickGroup' });
        var min = bulletChart.minimum;
        var max = bulletChart.maximum;
        var interval = bulletChart.interval;
        var enableRtl = bulletChart.enableRtl;
        var rect = bulletChart.initialClipRect;
        var x1 = rect.x + ((!bulletChart.opposedPosition) ? 0 : rect.width);
        var x2 = x1 - ((!bulletChart.opposedPosition) ? ((bulletChart.tickPosition !== 'Inside' ?
            this.majorTickSize : -this.majorTickSize)) : ((bulletChart.tickPosition !== 'Inside'
            ? -this.majorTickSize : this.majorTickSize)));
        var majorTick = bulletChart.majorTickLines;
        var strokeColor = majorTick.color || bulletChart.themeStyle.majorTickLineColor;
        var condition;
        var options;
        var size = rect.y + ((!bulletChart.enableRtl) ? rect.height : 0);
        var majorPointY = rect.y + majorTick.width / 2 + ((!enableRtl) ? rect.height : 0);
        for (var i = min; i <= max; i += interval) {
            condition = (bulletChart.enableRtl) ? (i === max) : (i === min);
            if (condition) {
                majorPointY -= majorTick.width / 2;
            }
            condition = (!bulletChart.enableRtl) ? (i === max) : (i === min);
            if (bulletChart.majorTickLines.useRangeColor) {
                strokeColor = this.bindingRangeStrokes(majorPointY - ((condition) ? this.bulletChart.majorTickLines.width / 2 : 0), size, this.bulletChart.orientation, bulletChart.enableRtl);
            }
            options = this.majorTicks(x1, x2, majorPointY, majorPointY, strokeColor, i);
            var majorTicks = bulletChart.renderer.drawLine(options);
            majorPointY = majorPointY + ((!enableRtl ? -intervalValue : intervalValue));
            tickGroup.appendChild(majorTicks);
            scale.appendChild(tickGroup);
        }
    };
    BulletChartAxis.prototype.majorTicks = function (x1, x2, y1, y2, strokeColor, i) {
        var options = {
            'id': this.bulletChart.svgObject.id + '_MajorTickLine_' + i,
            'x1': x1,
            'y1': y1,
            'x2': x2,
            'y2': y2,
            'stroke-width': this.bulletChart.majorTickLines.width,
            'stroke': (this.bulletChart.majorTickLines.useRangeColor && strokeColor) ? strokeColor :
                this.bulletChart.majorTickLines.color || strokeColor
        };
        return options;
    };
    BulletChartAxis.prototype.bindingRangeStrokes = function (majorPointX, size, orientation, rtl) {
        if ((orientation === 'Vertical' && !rtl) || (rtl && orientation === 'Horizontal')) {
            return this.backwardStrokeBinding(majorPointX, size);
        }
        else {
            return this.forwardStrokeBinding(majorPointX, size);
        }
    };
    /**
     * To render minor tick lines of bullet chart.
     */
    BulletChartAxis.prototype.renderXMinorTickLines = function (intervalValue, scaleGroup) {
        var minorTickGroup = this.bulletChart.renderer.createGroup({ 'id': this.bulletChart.svgObject.id + '_minorTickGroup' });
        var bullet = this.bulletChart;
        var max = bullet.maximum;
        var min = bullet.minimum;
        var interval = bullet.interval;
        var minorTick = bullet.minorTickLines.height;
        var minorTicksPerInterval = this.bulletChart.minorTicksPerInterval;
        var minorPointX;
        var x;
        var majorPointX = bullet.initialClipRect.x;
        var y1 = bullet.initialClipRect.y + ((bullet.opposedPosition) ? 0 : bullet.initialClipRect.height);
        var y2 = y1 + ((!bullet.opposedPosition) ? ((bullet.tickPosition !== 'Inside' ? minorTick : -minorTick)) :
            ((bullet.tickPosition !== 'Inside' ? -minorTick : minorTick)));
        var strokeColor = bullet.minorTickLines.color || bullet.themeStyle.minorTickLineColor;
        var options;
        var minorTicks;
        var size = bullet.initialClipRect.x + ((bullet.enableRtl) ? bullet.initialClipRect.width : 0);
        for (var i = min; i < max; i += interval) {
            minorPointX = intervalValue / minorTicksPerInterval;
            for (var j = 1; j <= minorTicksPerInterval; j++) {
                x = majorPointX + minorPointX - (minorPointX / (minorTicksPerInterval + 1));
                if (bullet.minorTickLines.useRangeColor) {
                    strokeColor = this.bindingRangeStrokes(x, size, this.bulletChart.orientation, bullet.enableRtl);
                }
                options = this.minorXTicks(x, x, y1, y2, strokeColor, i.toString() + j.toString());
                minorTicks = this.bulletChart.renderer.drawLine(options);
                minorTickGroup.appendChild(minorTicks);
                scaleGroup.appendChild(minorTickGroup);
                minorPointX = (intervalValue / minorTicksPerInterval) * (j + 1);
            }
            majorPointX += intervalValue;
        }
    };
    /**
     * To render minor tick lines of bullet chart.
     */
    BulletChartAxis.prototype.renderYMinorTickLines = function (intervalValue, scaleGroup) {
        var minorTickGroup = this.bulletChart.renderer.createGroup({ 'id': this.bulletChart.svgObject.id + '_minorTickGroup' });
        var bulletChart = this.bulletChart;
        var max = bulletChart.maximum;
        var min = bulletChart.minimum;
        var interval = bulletChart.interval;
        var minorTick = bulletChart.minorTickLines.height;
        var minorTicksPerInterval = this.bulletChart.minorTicksPerInterval;
        var minorPointY;
        var y;
        var majorPointY = bulletChart.initialClipRect.y + ((!bulletChart.enableRtl) ? bulletChart.initialClipRect.height : 0);
        var x1 = bulletChart.initialClipRect.x + ((!bulletChart.opposedPosition) ? 0 : bulletChart.initialClipRect.width);
        var x2 = x1 - ((!bulletChart.opposedPosition) ? ((bulletChart.tickPosition !== 'Inside' ? minorTick : -minorTick)) :
            ((bulletChart.tickPosition !== 'Inside' ? -minorTick : minorTick)));
        var strokeColor = bulletChart.minorTickLines.color || bulletChart.themeStyle.minorTickLineColor;
        var options;
        var minorTicks;
        var size = bulletChart.initialClipRect.y + ((!bulletChart.enableRtl) ? bulletChart.initialClipRect.height : 0);
        for (var i = min; i < max; i += interval) {
            minorPointY = intervalValue / minorTicksPerInterval;
            for (var j = 1; j <= minorTicksPerInterval; j++) {
                if (!this.bulletChart.enableRtl) {
                    y = majorPointY - minorPointY + (minorPointY / (minorTicksPerInterval + 1));
                }
                else {
                    y = majorPointY + minorPointY - (minorPointY / (minorTicksPerInterval + 1));
                }
                if (bulletChart.minorTickLines.useRangeColor) {
                    strokeColor = this.bindingRangeStrokes(y, size, this.bulletChart.orientation, bulletChart.enableRtl);
                }
                options = this.minorXTicks(x1, x2, y, y, strokeColor, i.toString() + j.toString());
                minorTicks = this.bulletChart.renderer.drawLine(options);
                minorTickGroup.appendChild(minorTicks);
                scaleGroup.appendChild(minorTickGroup);
                minorPointY = (intervalValue / minorTicksPerInterval) * (j + 1);
            }
            majorPointY -= (this.bulletChart.enableRtl) ? -intervalValue : intervalValue;
        }
    };
    BulletChartAxis.prototype.minorXTicks = function (x1, x2, y1, y2, strokeColor, i) {
        var options = {
            'id': this.bulletChart.svgObject.id + '_MajorTickLine_' + i,
            'x1': x1,
            'x2': x2,
            'y1': y1,
            'y2': y2,
            'stroke-width': this.bulletChart.minorTickLines.width,
            'stroke': (this.bulletChart.minorTickLines.useRangeColor && strokeColor) ? strokeColor :
                this.bulletChart.minorTickLines.color || strokeColor
        };
        return options;
    };
    BulletChartAxis.prototype.forwardStrokeBinding = function (position, size) {
        var bullet = this.bulletChart;
        var previous = size;
        // (bullet.orientation === 'Horizontal') ? bullet.initialClipRect.x :
        // (bullet.initialClipRect.y + bullet.initialClipRect.height);
        for (var k = 0; k <= bullet.rangeCollection.length - 1; k++) {
            previous += (!k) ? 0 : bullet.rangeCollection[k - 1];
            if (position >= previous && position < previous + bullet.rangeCollection[k]) {
                return bullet.ranges[k].color;
            }
        }
        return null;
    };
    BulletChartAxis.prototype.backwardStrokeBinding = function (position, size) {
        var bullet = this.bulletChart;
        var previous = size;
        for (var k = 0; k <= bullet.rangeCollection.length - 1; k++) {
            previous -= (!k) ? 0 : bullet.rangeCollection[k - 1];
            if (Math.round(position) >= Math.round(previous - bullet.rangeCollection[k]) && position <= previous) {
                return bullet.ranges[k].color;
            }
        }
        return null;
    };
    /**
     * To render axis labels of bullet chart.
     */
    BulletChartAxis.prototype.renderXAxisLabels = function (intervalValue, scaleGroup) {
        var axisLabelGroup = this.bulletChart.renderer.createGroup({ 'id': this.bulletChart.svgObject.id + '_axisLabelGroup' });
        var text;
        var bullet = this.bulletChart;
        var locale = this.bulletChart.locale;
        var padding = 5;
        var enableRtl = bullet.enableRtl;
        var tick = (((bullet.tickPosition === bullet.labelPosition) ? bullet.majorTickLines.height : 0) + padding * 2);
        var y = bullet.initialClipRect.y + ((bullet.opposedPosition) ? ((bullet.labelPosition === 'Inside') ? tick : -tick)
            : bullet.initialClipRect.height + ((bullet.labelPosition === 'Inside') ? -tick : tick));
        var x = bullet.initialClipRect.x + ((enableRtl) ? bullet.initialClipRect.width : 0);
        var min = bullet.minimum;
        var max = bullet.maximum;
        var interval = bullet.interval;
        var localizedText = locale && this.bulletChart.enableGroupSeparator;
        var format = this.getFormat(this.bulletChart);
        var strokeColor = bullet.labelStyle.color || bullet.themeStyle.axisLabelFont.color;
        var condition;
        var isCustomFormat = format.match('{value}') !== null;
        this.format = this.bulletChart.intl.getNumberFormat({
            format: isCustomFormat ? '' : format, useGrouping: this.bulletChart.enableGroupSeparator
        });
        var size = bullet.initialClipRect.x + ((bullet.enableRtl) ? bullet.initialClipRect.width : 0);
        y += measureText(this.formatValue(this, isCustomFormat, format, this.bulletChart.maximum), bullet.labelStyle, this.bulletChart.themeStyle.axisLabelFont).height / 3;
        for (var i = min; i <= max; i += interval) {
            condition = (!bullet.enableRtl) ? (i === max) : (i === min);
            if (bullet.labelStyle.useRangeColor) {
                strokeColor = this.bindingRangeStrokes(x - ((condition) ? this.bulletChart.majorTickLines.width / 2 : 0), size, this.bulletChart.orientation, bullet.enableRtl);
            }
            text = localizedText ? i.toLocaleString(locale) : this.formatValue(this, isCustomFormat, format, i);
            var labelOptions = this.labelXOptions(x, y, text, i);
            this.bulletChart.labelStyle.fontFamily = this.bulletChart.labelStyle.fontFamily || this.bulletChart.themeStyle.axisLabelFont.fontFamily;
            this.bulletChart.labelStyle.fontFamily = this.bulletChart.labelStyle.fontFamily || this.bulletChart.themeStyle.axisLabelFont.fontFamily;
            var label = textElement(labelOptions, this.bulletChart.labelStyle, strokeColor, scaleGroup);
            axisLabelGroup.appendChild(label);
            x += (enableRtl) ? -intervalValue : intervalValue;
        }
        scaleGroup.appendChild(axisLabelGroup);
    };
    BulletChartAxis.prototype.labelXOptions = function (labelX, pointY, displayText, i) {
        var labelOptions = {
            'id': this.bulletChart.svgObject.id + '_AxisLabel_' + i,
            'anchor': 'middle',
            'text': displayText,
            'transform': '',
            'x': labelX,
            'y': pointY,
            'baseLine': '',
            'labelRotation': 0
        };
        return labelOptions;
    };
    /**
     * To render axis labels of bullet chart.
     */
    BulletChartAxis.prototype.renderYAxisLabels = function (intervalValue, scaleGroup) {
        var axisLabelGroup = this.bulletChart.renderer.createGroup({ 'id': this.bulletChart.svgObject.id + '_axisLabelGroup' });
        var text;
        var bulletChart = this.bulletChart;
        var locale = bulletChart.locale;
        var padding = 5;
        var enableRtl = bulletChart.enableRtl;
        var tick = (((bulletChart.tickPosition === bulletChart.labelPosition) ?
            bulletChart.majorTickLines.height : 0) + padding * 2);
        var y = bulletChart.initialClipRect.y + ((!enableRtl) ? bulletChart.initialClipRect.height : 0);
        var x = bulletChart.initialClipRect.x + ((!bulletChart.opposedPosition) ?
            ((bulletChart.labelPosition === 'Inside') ? (tick + padding * 2) : -tick)
            : bulletChart.initialClipRect.width + ((bulletChart.labelPosition === 'Inside') ? -(tick + padding * 2) : tick));
        var min = bulletChart.minimum;
        var max = bulletChart.maximum;
        var interval = bulletChart.interval;
        var localizedText = locale && this.bulletChart.enableGroupSeparator;
        var strokeColor = bulletChart.labelStyle.color || bulletChart.themeStyle.axisLabelFont.color;
        var format = this.getFormat(this.bulletChart);
        var isCustomFormat = format.match('{value}') !== null;
        var condition;
        this.format = this.bulletChart.intl.getNumberFormat({
            format: isCustomFormat ? '' : format, useGrouping: this.bulletChart.enableGroupSeparator
        });
        var size = bulletChart.initialClipRect.y + ((!bulletChart.enableRtl) ? bulletChart.initialClipRect.height : 0);
        var labelWidth = measureText(this.formatValue(this, isCustomFormat, format, this.bulletChart.maximum), bulletChart.labelStyle, this.bulletChart.themeStyle.axisLabelFont).width / 2;
        var height = measureText(this.formatValue(this, isCustomFormat, format, this.bulletChart.maximum), bulletChart.labelStyle, this.bulletChart.themeStyle.axisLabelFont).height / 3;
        y += height;
        for (var i = min; i <= max; i += interval) {
            condition = (bulletChart.enableRtl) ? (i === max) : (i === min);
            if (bulletChart.labelStyle.useRangeColor) {
                strokeColor = this.bindingRangeStrokes(y - height - ((condition) ? this.bulletChart.majorTickLines.width / 2 : 0), size, this.bulletChart.orientation, bulletChart.enableRtl);
            }
            text = localizedText ? i.toLocaleString(locale) : this.formatValue(this, isCustomFormat, format, i);
            //labelWidth = measureText(text, bullet.labelStyle).width / 2;
            var labelOptions = this.labelXOptions(x - (!this.bulletChart.opposedPosition ? labelWidth : -labelWidth), y, text, i);
            this.bulletChart.labelStyle.fontFamily = this.bulletChart.labelStyle.fontFamily || this.bulletChart.themeStyle.axisLabelFont.fontFamily;
            this.bulletChart.labelStyle.fontFamily = this.bulletChart.labelStyle.fontFamily || this.bulletChart.themeStyle.axisLabelFont.fontFamily;
            var label = textElement(labelOptions, this.bulletChart.labelStyle, strokeColor, scaleGroup);
            axisLabelGroup.appendChild(label);
            y += (!enableRtl) ? -intervalValue : intervalValue;
        }
        scaleGroup.appendChild(axisLabelGroup);
    };
    /**
     * Format of the axis label.
     *
     * @private
     */
    BulletChartAxis.prototype.getFormat = function (axis) {
        if (axis.labelFormat) {
            return axis.labelFormat;
        }
        return '';
    };
    /**
     * Formatted the axis label.
     *
     * @private
     */
    BulletChartAxis.prototype.formatValue = function (axis, isCustom, format, tempInterval) {
        return isCustom ? format.replace('{value}', axis.format(tempInterval))
            : axis.format(tempInterval);
    };
    return BulletChartAxis;
}());

/**
 * class for Bullet chart Scale Group
 */
var ScaleGroup = /** @__PURE__ @class */ (function () {
    function ScaleGroup(bulletChart) {
        this.comparative = [];
        //super();
        this.dataSource = bulletChart.dataSource;
        this.isVertical = (bulletChart.orientation === 'Vertical');
        this.isTicksInside = (bulletChart.tickPosition === 'Inside');
        this.isLabelsInside = (bulletChart.labelPosition === 'Inside');
        this.isHorizontal = (bulletChart.orientation === 'Horizontal');
        this.isLeft = bulletChart.titlePosition === 'Left';
        this.isRight = bulletChart.titlePosition === 'Right';
        this.isTop = bulletChart.titlePosition === 'Top';
        this.location = 10;
        this.featureBarBounds = [];
        this.majorTickSize = bulletChart.majorTickLines.height;
        this.labelOffset = 15;
        this.labelSize = 12;
        this.bulletChart = bulletChart;
        this.isLabelBelow = !this.bulletChart.opposedPosition;
        this.scaleOrientation = this.bulletChart.orientation;
        this.rangeColor = [];
    }
    /**
     * To render range scale of the bulletChart graph.
     *
     * @param {Element} scaleGroup
     */
    ScaleGroup.prototype.drawScaleGroup = function (scaleGroup) {
        var rangeGroup = this.bulletChart.renderer.createGroup({ 'id': this.bulletChart.svgObject.id + '_rangeGroup' });
        var max = this.bulletChart.maximum;
        var ranges = this.bulletChart.ranges;
        this.scaleSettingsGroup = scaleGroup;
        var rect;
        var bullet = this.bulletChart;
        var enableRtl = bullet.enableRtl;
        var initialRect = bullet.initialClipRect;
        var locX = initialRect.x + ((enableRtl && bullet.orientation === 'Horizontal') ? initialRect.width : 0);
        var locY = initialRect.y + ((!enableRtl && bullet.orientation === 'Vertical') ? initialRect.height : 0);
        var area = 0;
        bullet.rangeCollection = [];
        var start = 0;
        var range = (bullet.orientation === 'Horizontal') ? initialRect.width : initialRect.height;
        var fillRange = (bullet.orientation === 'Horizontal') ? initialRect.height : initialRect.width;
        for (var i = 0; i < ranges.length; i++) {
            area = (range) * ((ranges[i].end - start) / max);
            if (bullet.orientation === 'Horizontal') {
                locX -= (enableRtl) ? area : 0;
            }
            else {
                locY -= (!enableRtl) ? area : 0;
            }
            rect = new RectOption(bullet.svgObject.id + '_range_' + i, 
            // tslint:disable-next-line:no-string-literal
            ranges[i].color || this.bulletChart.themeStyle.rangeStrokes[i]['color'], { width: 1 }, ranges[i].opacity, new Rect(locX, locY, ((bullet.orientation === 'Horizontal') ? area : fillRange), ((bullet.orientation === 'Horizontal') ? fillRange : area)));
            var svgRect = bullet.renderer.drawRectangle(rect);
            rangeGroup.appendChild(svgRect);
            scaleGroup.appendChild(rangeGroup);
            if (bullet.orientation === 'Horizontal') {
                locX += (enableRtl) ? 0 : area;
            }
            else {
                locY += (!enableRtl) ? 0 : area;
            }
            bullet.rangeCollection.push(area);
            start = ranges[i].end;
        }
        return this.bulletChart.rangeCollection;
    };
    ScaleGroup.prototype.sortRangeCollection = function (a, b) {
        return (a - b);
    };
    /**
     * To render the feature bar of the bulletChart chart.
     *
     * @param {number} dataCount Count of the bar.
     */
    ScaleGroup.prototype.renderFeatureBar = function (dataCount) {
        if (dataCount === 0) {
            return;
        }
        this.renderCommonFeatureBar(dataCount, this.isHorizontal);
    };
    /**
     * To render the horizontal feature bar of the bulletChart chart
     *
     * @param {number} dataCount Count of the bar.
     */
    ScaleGroup.prototype.renderCommonFeatureBar = function (dataCount, isHorizontal) {
        var categoryValue;
        var dotWidth = 6;
        var padding = 5;
        var bulletChart = this.bulletChart;
        var initialBoundsStart = isHorizontal ? (bulletChart.initialClipRect.y + bulletChart.initialClipRect.height) :
            bulletChart.initialClipRect.x;
        var lPoint;
        var featueGroup = bulletChart.renderer.createGroup({ 'id': bulletChart.svgObject.id + '_featureGroup' });
        var data;
        var featureBarSize = (isHorizontal ? bulletChart.initialClipRect.height : bulletChart.initialClipRect.width) / dataCount;
        var bounds;
        for (var i = 0; i < dataCount; i++) {
            data = bulletChart.dataSource[i];
            categoryValue = data[bulletChart.categoryField];
            if (isHorizontal) {
                lPoint = initialBoundsStart - (featureBarSize * i) - (featureBarSize + bulletChart.valueHeight) / 2;
            }
            else {
                lPoint = initialBoundsStart + (featureBarSize * i) + (featureBarSize / 2) - bulletChart.valueHeight / 2;
            }
            bounds = this.calculateFeatureMeasureBounds(data[bulletChart.valueField], categoryValue, isHorizontal);
            if (data && bulletChart.type === 'Dot') {
                var value = data[bulletChart.valueField];
                if (isHorizontal) {
                    bounds.pointX = bounds.pointX + (((value > 0) && !bulletChart.enableRtl) ||
                        ((value < 0) && bulletChart.enableRtl) ? (bounds.width) : 0) - dotWidth / 2;
                }
                else {
                    bounds.pointX = bounds.pointX + (((value > 0) && bulletChart.enableRtl) ||
                        ((value < 0) && !bulletChart.enableRtl) ? (bounds.width) : 0) - dotWidth / 2;
                }
                bounds.width = dotWidth;
            }
            // Drawing feature bar rect element
            if (bounds) {
                var svgRect = isHorizontal ? this.featureBar(bounds.pointX, lPoint, bounds.width, i) :
                    this.verticalFeatureBar(lPoint, bounds.pointX, bounds.width, i);
                featueGroup.appendChild(svgRect);
                this.feature = svgRect;
                this.scaleSettingsGroup.appendChild(featueGroup);
                this.featureBarBounds[i] = { x: bounds.pointX, y: lPoint, width: bounds.width, height: bulletChart.valueHeight };
                // Drawing category text element
                if (!isNullOrUndefined(categoryValue)) {
                    var categoryTextSize = measureText(categoryValue, bulletChart.categoryLabelStyle, bulletChart.themeStyle.axisLabelFont);
                    var categorySize = isHorizontal ? categoryTextSize.width : categoryTextSize.height;
                    var initialRect = bulletChart.initialClipRect;
                    var x = void 0;
                    var categoryOptions = void 0;
                    if (isHorizontal) {
                        x = (bulletChart.enableRtl) ? (initialRect.x + initialRect.width + padding + categorySize / 2) :
                            initialRect.x - padding - categorySize / 2;
                        categoryOptions = this.drawcategory(x, lPoint, categoryValue);
                    }
                    else {
                        x = (bulletChart.enableRtl) ? (initialRect.y - padding - categorySize / 2) :
                            initialRect.y + initialRect.height + padding + categorySize / 2;
                        categoryOptions = this.drawcategory(lPoint + bulletChart.valueHeight / 2, x, categoryValue);
                    }
                    bulletChart.categoryLabelStyle.fontFamily = bulletChart.categoryLabelStyle.fontFamily || bulletChart.themeStyle.axisLabelFont.fontFamily;
                    textElement(categoryOptions, bulletChart.categoryLabelStyle, bulletChart.categoryLabelStyle.color || bulletChart.themeStyle.axisLabelFont.color, this.scaleSettingsGroup);
                }
            }
            if ((bulletChart.animation.enable && animationMode != 'Disable') || animationMode === 'Enable') {
                this.doValueBarAnimation();
            }
        }
    };
    ScaleGroup.prototype.featureBar = function (pointX, pointY, width, i) {
        var featureBarOptions = new RectOption(this.bulletChart.svgObject.id + '_FeatureMeasure_' + i, this.bulletChart.dataSource[i][this.bulletChart.valueFill] || this.bulletChart.valueFill, this.bulletChart.valueBorder, 1, new Rect(pointX, pointY, width, this.bulletChart.valueHeight));
        var svgRect = this.bulletChart.renderer.drawRectangle(featureBarOptions);
        svgRect.setAttribute('class', this.bulletChart.svgObject.id + '_FeatureMeasure');
        svgRect.id = this.bulletChart.svgObject.id + '_FeatureMeasure_' + i;
        svgRect.setAttribute('role', 'img');
        svgRect.setAttribute('tabindex', '0');
        svgRect.setAttribute('aria-label', (this.bulletChart.title + ', value: ' + this.bulletChart.dataSource[i].value + ', target: ' + this.bulletChart.dataSource[i].target));
        return svgRect;
    };
    ScaleGroup.prototype.verticalFeatureBar = function (pointX, pointY, width, i) {
        var featureBarOptions = new RectOption(this.bulletChart.svgObject.id + '_FeatureMeasure_' + i, this.bulletChart.dataSource[i][this.bulletChart.valueFill] || this.bulletChart.valueFill, this.bulletChart.valueBorder, 1, new Rect(pointX, pointY, this.bulletChart.valueHeight, width));
        var svgRect = this.bulletChart.renderer.drawRectangle(featureBarOptions);
        svgRect.setAttribute('class', this.bulletChart.svgObject.id + '_FeatureMeasure');
        svgRect.id = this.bulletChart.svgObject.id + '_FeatureMeasure_' + i;
        svgRect.setAttribute('role', 'img');
        svgRect.setAttribute('tabindex', '0');
        svgRect.setAttribute('aria-label', (this.bulletChart.title + ', value: ' + this.bulletChart.dataSource[i].value + ', target: ' + this.bulletChart.dataSource[i].target));
        return svgRect;
    };
    ScaleGroup.prototype.drawcategory = function (lPointX, lPointY, categoryValue) {
        var fontsize = parseInt(this.bulletChart.categoryLabelStyle.size);
        var categoryOptions = {
            'id': '',
            'anchor': 'middle',
            'x': lPointX,
            'y': lPointY + (fontsize / 4 + this.bulletChart.valueHeight / 2),
            'transform': '',
            'text': categoryValue,
            'baseLine': '',
            'labelRotation': 0
        };
        return categoryOptions;
    };
    /**
     * To render comparative symbol of the bulletChart chart.
     *
     * @param {number} dataCount Data count value.
     */
    ScaleGroup.prototype.renderComparativeSymbol = function (dataCount) {
        if (dataCount === 0) {
            return;
        }
        this.renderCommonComparativeSymbol(dataCount, this.isHorizontal);
    };
    ScaleGroup.prototype.renderCommonComparativeSymbol = function (dataCount, isHorizontal) {
        var bulletChart = this.bulletChart;
        var value;
        var rect = bulletChart.initialClipRect;
        var scaleLength = isHorizontal ? rect.width : rect.height;
        var y1;
        var y2;
        var x1;
        var pointY = isHorizontal ? (rect.y + rect.height) : rect.x;
        var comparativeGroup = bulletChart.renderer.createGroup({ 'id': bulletChart.svgObject.id + '_comparativeGroup' });
        var minimum = bulletChart.minimum;
        var maximum = bulletChart.maximum;
        var delta = maximum - minimum;
        var targetWidth = 5;
        var pointX = isHorizontal ? (rect.x - (targetWidth / 2)) : (rect.y + rect.height);
        var temp;
        var values = [];
        var targetTypes = bulletChart.targetTypes;
        var targetType = 'Rect';
        var targetTypeLength = targetTypes.length;
        var featureBarSize = (isHorizontal ? rect.height : rect.width) / dataCount;
        var svgElement;
        for (var k = 0; k < dataCount; k++) {
            value = bulletChart.dataSource[k][bulletChart.targetField];
            values = values.concat(value);
            for (var i = 0; i < values.length; i++) {
                targetType = targetTypes[i % targetTypeLength];
                if (values[i] >= minimum && values[i] <= maximum) {
                    if (isHorizontal) {
                        temp = pointY - (featureBarSize * k) - (featureBarSize / 2);
                    }
                    else {
                        temp = pointY + (featureBarSize * k) + (featureBarSize / 2);
                    }
                    y1 = temp - targetWidth * 1.5;
                    y2 = temp + targetWidth * 1.5;
                    temp = (scaleLength / (delta / (delta - (maximum - values[i]))));
                    if (isHorizontal) {
                        x1 = pointX + (bulletChart.enableRtl ? (scaleLength - temp) : temp);
                    }
                    else {
                        x1 = pointX - (bulletChart.enableRtl ? (scaleLength - temp) : temp);
                    }
                    svgElement = this.getTargetElement(targetType, isHorizontal, x1, y1, y2, values[i], k);
                    this.comparative.push(svgElement);
                    comparativeGroup.appendChild(svgElement);
                    y1 = 0;
                    y2 = 0;
                }
                this.scaleSettingsGroup.appendChild(comparativeGroup);
            }
            values = [];
            if ((bulletChart.animation.enable && animationMode != 'Disable') || animationMode === 'Enable') {
                this.doTargetBarAnimation(0);
            }
        }
    };
    ScaleGroup.prototype.getTargetElement = function (targetType, isHorizontal, x1, y1, y2, value, k) {
        var shapeObject;
        var shapeElement;
        var bulletChart = this.bulletChart;
        var strokeWidth = (targetType === 'Cross') ? bulletChart.targetWidth - 1 : 1;
        var size = (targetType === 'Circle') ? bulletChart.targetWidth - 1 : bulletChart.targetWidth;
        var lx = isHorizontal ? x1 + (size / 2) : y1 + ((y2 - y1) / 2);
        var ly = isHorizontal ? y1 + ((y2 - y1) / 2) : x1;
        var id = bulletChart.svgObject.id + '_ComparativeMeasure_' + k;
        var className = bulletChart.svgObject.id + '_ComparativeMeasure';
        var targetColor = bulletChart.dataSource[k][bulletChart.targetColor] || bulletChart.targetColor;
        if (targetType === 'Rect') {
            shapeObject = isHorizontal ? this.compareMeasure(x1, y1, y2, k, value) : this.compareVMeasure(y1, y2, x1, k);
            shapeElement = bulletChart.renderer.drawLine(shapeObject);
        }
        else if (targetType === 'Circle') {
            shapeObject = new CircleOption(id, targetColor, { width: 1, color: targetColor || 'black' }, 1, lx, ly, size);
            shapeElement = bulletChart.renderer.drawCircle(shapeObject);
        }
        else {
            var crossDirection = 'M ' + (lx - size) + ' ' + (ly - size) + ' L ' + (lx + size) + ' ' + (ly + size) + ' M ' +
                (lx - size) + ' ' + (ly + size) + ' L ' + (lx + size) + ' ' + (ly - size);
            shapeObject = new PathOption(id, 'transparent', strokeWidth, targetColor, 1, '', crossDirection);
            shapeElement = bulletChart.renderer.drawPath(shapeObject);
        }
        shapeElement.setAttribute('class', className);
        return shapeElement;
    };
    ScaleGroup.prototype.compareMeasure = function (x1, y1, y2, i, value) {
        var bulletChart = this.bulletChart;
        var compareMeasureOptions = {
            'class': bulletChart.svgObject.id + '_ComparativeMeasure',
            'id': bulletChart.svgObject.id + '_ComparativeMeasure_' + i,
            'x1': (value === bulletChart.maximum) ? x1 - (bulletChart.targetWidth / 2) :
                (value === bulletChart.minimum) ? x1 + (bulletChart.targetWidth / 2) : x1,
            'y1': y1,
            'x2': (value === bulletChart.maximum) ? x1 - (bulletChart.targetWidth / 2) :
                (value === bulletChart.minimum) ? x1 + (bulletChart.targetWidth / 2) : x1,
            'y2': y2,
            'stroke-width': bulletChart.targetWidth,
            'stroke': bulletChart.dataSource[i][bulletChart.targetColor] || bulletChart.targetColor || 'black'
        };
        return compareMeasureOptions;
    };
    ScaleGroup.prototype.compareVMeasure = function (x1, x2, y1, i) {
        var bulletChart = this.bulletChart;
        var compareMeasureOptions = {
            'class': bulletChart.svgObject.id + '_ComparativeMeasure',
            'id': bulletChart.svgObject.id + '_ComparativeMeasure_' + i,
            'x1': x1,
            'y1': y1,
            'x2': x2,
            'y2': y1,
            'stroke-width': bulletChart.targetWidth,
            'stroke': bulletChart.dataSource[i][bulletChart.targetColor] || bulletChart.targetColor || 'black'
        };
        return compareMeasureOptions;
    };
    /**
     * To calculate the bounds on vertical and horizontal orientation changes
     *
     * @param {number} value Value of the scale.
     * @param {string} categoryValue Value of the category.
     * @param {boolean} isHorizontal Boolean value.
     * @returns {IFeatureMeasureType} calculateFeatureMeasureBounds
     */
    ScaleGroup.prototype.calculateFeatureMeasureBounds = function (value, categoryValue, isHorizontal) {
        var bulletChart = this.bulletChart;
        var min = bulletChart.minimum;
        value = (value < min && min <= 0) ? min : value;
        if (value >= min) {
            var pointX = void 0;
            var lastPointX = void 0;
            var width = void 0;
            var loc = isHorizontal ? bulletChart.initialClipRect.x : bulletChart.initialClipRect.y;
            var scaleLength = isHorizontal ? bulletChart.initialClipRect.width : bulletChart.initialClipRect.height;
            var delta = bulletChart.maximum - bulletChart.minimum;
            var valueDiff = bulletChart.maximum - value;
            var orientation_1 = ((!bulletChart.enableRtl) ? 'forward' : 'backward') + this.scaleOrientation.toLowerCase();
            categoryValue = isNullOrUndefined(categoryValue) ? '' : categoryValue;
            var stringLength = measureText(categoryValue.toString(), bulletChart.labelStyle, this.bulletChart.themeStyle.axisLabelFont).width;
            switch (orientation_1) {
                case 'forwardhorizontal':
                case 'backwardvertical':
                    pointX = loc + ((min > 0) ? 0 : scaleLength / delta * Math.abs(min));
                    width = scaleLength / (delta / ((min > 0) ? delta - valueDiff : value));
                    if (value < 0) {
                        width = Math.abs(width);
                        pointX -= width;
                    }
                    width = (pointX + width < loc + scaleLength) ? width : loc + scaleLength - pointX;
                    lastPointX = loc - ((orientation_1 === 'forwardhorizontal') ? (stringLength / 2 + 5) :
                        this.labelOffset);
                    break;
                default:
                    pointX = loc + (scaleLength - scaleLength / (delta / (delta - valueDiff)));
                    width = (min > 0) ? scaleLength / (delta / (delta - valueDiff)) : scaleLength / (delta / (value));
                    if (value < 0) {
                        width = Math.abs(width);
                        pointX -= width;
                    }
                    if (pointX < loc) {
                        width = pointX + width - loc;
                        pointX = loc;
                    }
                    lastPointX = loc + scaleLength + ((orientation_1 === 'backwardhorizontal') ? (stringLength / 2 +
                        5) : 5);
                    break;
            }
            return { pointX: pointX, width: width, lastPointX: lastPointX };
        }
        return null;
    };
    /**
     * Animates the feature bar.
     *
     * @returns {void}
     */
    ScaleGroup.prototype.doValueBarAnimation = function () {
        var valueBarElement = this.feature;
        if (!valueBarElement) {
            return null;
        }
        var animateOption = this.bulletChart.animation;
        var animateDuration = this.bulletChart.animateSeries ? this.bulletChart.animation.duration : animateOption.duration;
        var effectType = getAnimationFunction('Linear');
        var isValuePlot = this.bulletChart.dataSource < 0;
        var valueX;
        var valueY;
        var elementBarHeight = valueBarElement.getBoundingClientRect().height;
        var elementBarWidth = valueBarElement.getBoundingClientRect().width;
        var centerX;
        var centerY;
        var valueActual;
        if (this.bulletChart.orientation === 'Horizontal' && valueBarElement) {
            valueY = parseInt(valueBarElement.getAttribute('height'), 10);
            valueX = parseInt(valueBarElement.getAttribute('x'), 10);
            centerY = isValuePlot ? valueY : valueY + elementBarHeight;
            centerX = valueX;
        }
        valueBarElement.style.visibility = 'hidden';
        new Animation({}).animate(valueBarElement, {
            duration: (animateDuration === 0 && animationMode === 'Enable') ? 1000 : animateDuration,
            delay: animateOption.delay,
            progress: function (args) {
                if (args.timeStamp >= args.delay) {
                    valueBarElement.style.visibility = 'visible';
                    elementBarWidth = elementBarWidth ? elementBarWidth : 1;
                    valueActual = effectType(args.timeStamp - args.delay, 0, elementBarWidth, args.duration);
                    valueBarElement.setAttribute('transform', 'translate(' + centerX + ' ' + centerY +
                        ') scale(' + (valueActual / elementBarWidth) + ', 1) translate(' + (-centerX) + ' ' + (-centerY) + ')');
                }
            },
            end: function () {
                valueBarElement.setAttribute('transform', 'translate(0,0)');
                valueBarElement.style.visibility = 'visible';
            }
        });
    };
    /**
     * Animates the comparative bar.
     *
     * @param {number} index Defines the feature bar to animate.
     * @returns {void}
     */
    ScaleGroup.prototype.doTargetBarAnimation = function (index) {
        var x;
        var y;
        var centerX;
        var centerY;
        var targetBarelement = this.comparative[index];
        if (!targetBarelement) {
            return null;
        }
        if (this.bulletChart.orientation === 'Horizontal' && targetBarelement) {
            y = parseFloat(targetBarelement.getAttribute('y1')) + parseFloat(targetBarelement.getAttribute('y2'));
            x = parseFloat(targetBarelement.getAttribute('x1'));
            centerY = y;
            centerX = x;
        }
        targetBarelement.style.visibility = 'hidden';
        this.animateRect(targetBarelement, centerX, centerY, index + 1);
    };
    ScaleGroup.prototype.animateRect = function (targetBarelement, centerX, centerY, index) {
        var _this = this;
        var effect = getAnimationFunction('Linear');
        var value;
        var option = this.bulletChart.animation;
        var threshold = this.comparative.length;
        var duration = this.bulletChart.animateSeries ? this.bulletChart.animation.duration : option.duration;
        new Animation({}).animate(targetBarelement, {
            duration: (duration === 0 && animationMode === 'Enable') ? 1000 : duration,
            delay: option.delay,
            progress: function (args) {
                if (args.timeStamp >= args.delay) {
                    targetBarelement.style.visibility = 'visible';
                    value = effect(args.timeStamp - args.delay, 0, 1, args.duration);
                    targetBarelement.setAttribute('transform', 'translate(' + centerX + ' ' + centerY / 2 +
                        ') scale(1,' + (value) + ') translate(' + (-centerX) + ' ' + (-centerY / 2) + ')');
                }
            },
            end: function () {
                targetBarelement.setAttribute('transform', 'translate(0,0)');
                if (index < threshold) {
                    _this.doTargetBarAnimation(index + 1);
                }
            }
        });
    };
    return ScaleGroup;
}());

var __extends$85 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$15 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Configuration of the bullet chart ranges
 */
var Range = /** @__PURE__ @class */ (function (_super) {
    __extends$85(Range, _super);
    function Range() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$15([
        Property(null)
    ], Range.prototype, "end", void 0);
    __decorate$15([
        Property(1)
    ], Range.prototype, "opacity", void 0);
    __decorate$15([
        Property(null)
    ], Range.prototype, "color", void 0);
    __decorate$15([
        Property(null)
    ], Range.prototype, "index", void 0);
    __decorate$15([
        Property(null)
    ], Range.prototype, "name", void 0);
    __decorate$15([
        Property('Rectangle')
    ], Range.prototype, "shape", void 0);
    __decorate$15([
        Property('')
    ], Range.prototype, "legendImageUrl", void 0);
    return Range;
}(ChildProperty));
/**
 * Configures the major tick lines.
 */
var MajorTickLinesSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$85(MajorTickLinesSettings, _super);
    function MajorTickLinesSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$15([
        Property(12)
    ], MajorTickLinesSettings.prototype, "height", void 0);
    __decorate$15([
        Property(1)
    ], MajorTickLinesSettings.prototype, "width", void 0);
    __decorate$15([
        Property(null)
    ], MajorTickLinesSettings.prototype, "color", void 0);
    __decorate$15([
        Property(false)
    ], MajorTickLinesSettings.prototype, "useRangeColor", void 0);
    return MajorTickLinesSettings;
}(ChildProperty));
/**
 * Configures the minor tick lines.
 */
var MinorTickLinesSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$85(MinorTickLinesSettings, _super);
    function MinorTickLinesSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$15([
        Property(8)
    ], MinorTickLinesSettings.prototype, "height", void 0);
    __decorate$15([
        Property(1)
    ], MinorTickLinesSettings.prototype, "width", void 0);
    __decorate$15([
        Property(null)
    ], MinorTickLinesSettings.prototype, "color", void 0);
    __decorate$15([
        Property(false)
    ], MinorTickLinesSettings.prototype, "useRangeColor", void 0);
    return MinorTickLinesSettings;
}(ChildProperty));
/**
 * Configures the fonts in bullet chart.
 */
var BulletLabelStyle = /** @__PURE__ @class */ (function (_super) {
    __extends$85(BulletLabelStyle, _super);
    function BulletLabelStyle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$15([
        Property('Normal')
    ], BulletLabelStyle.prototype, "fontStyle", void 0);
    __decorate$15([
        Property('16px')
    ], BulletLabelStyle.prototype, "size", void 0);
    __decorate$15([
        Property('')
    ], BulletLabelStyle.prototype, "color", void 0);
    __decorate$15([
        Property('Normal')
    ], BulletLabelStyle.prototype, "fontWeight", void 0);
    __decorate$15([
        Property('Segoe UI')
    ], BulletLabelStyle.prototype, "fontFamily", void 0);
    __decorate$15([
        Property('Center')
    ], BulletLabelStyle.prototype, "textAlignment", void 0);
    __decorate$15([
        Property('None')
    ], BulletLabelStyle.prototype, "textOverflow", void 0);
    __decorate$15([
        Property(1)
    ], BulletLabelStyle.prototype, "opacity", void 0);
    __decorate$15([
        Property(true)
    ], BulletLabelStyle.prototype, "enableTrim", void 0);
    __decorate$15([
        Property(null)
    ], BulletLabelStyle.prototype, "maximumTitleWidth", void 0);
    __decorate$15([
        Property(false)
    ], BulletLabelStyle.prototype, "useRangeColor", void 0);
    return BulletLabelStyle;
}(ChildProperty));
/**
 * Configures the ToolTips in the bullet chart.
 */
var BulletTooltipSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$85(BulletTooltipSettings, _super);
    function BulletTooltipSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$15([
        Property(false)
    ], BulletTooltipSettings.prototype, "enable", void 0);
    __decorate$15([
        Property(null)
    ], BulletTooltipSettings.prototype, "fill", void 0);
    __decorate$15([
        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, BulletLabelStyle)
    ], BulletTooltipSettings.prototype, "textStyle", void 0);
    __decorate$15([
        Complex({ color: null, width: null }, Border)
    ], BulletTooltipSettings.prototype, "border", void 0);
    __decorate$15([
        Property(null)
    ], BulletTooltipSettings.prototype, "template", void 0);
    return BulletTooltipSettings;
}(ChildProperty));
/**
 * Configures the DataLabel in the bullet chart.
 */
var BulletDataLabel = /** @__PURE__ @class */ (function (_super) {
    __extends$85(BulletDataLabel, _super);
    function BulletDataLabel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$15([
        Property(false)
    ], BulletDataLabel.prototype, "enable", void 0);
    __decorate$15([
        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, BulletLabelStyle)
    ], BulletDataLabel.prototype, "labelStyle", void 0);
    return BulletDataLabel;
}(ChildProperty));
/**
 * Configures the legends in charts.
 */
var BulletChartLegendSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$85(BulletChartLegendSettings, _super);
    function BulletChartLegendSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$15([
        Property(false)
    ], BulletChartLegendSettings.prototype, "visible", void 0);
    __decorate$15([
        Complex({ x: 0, y: 0 }, Location)
    ], BulletChartLegendSettings.prototype, "location", void 0);
    __decorate$15([
        Property(8)
    ], BulletChartLegendSettings.prototype, "padding", void 0);
    __decorate$15([
        Property('Center')
    ], BulletChartLegendSettings.prototype, "alignment", void 0);
    __decorate$15([
        Property(10)
    ], BulletChartLegendSettings.prototype, "shapeHeight", void 0);
    __decorate$15([
        Property(10)
    ], BulletChartLegendSettings.prototype, "shapeWidth", void 0);
    __decorate$15([
        Complex({ fontFamily: null, size: "14px", fontStyle: 'Normal', fontWeight: '400', color: null }, BulletLabelStyle)
    ], BulletChartLegendSettings.prototype, "textStyle", void 0);
    __decorate$15([
        Property('Auto')
    ], BulletChartLegendSettings.prototype, "position", void 0);
    __decorate$15([
        Complex({ left: 0, right: 0, top: 0, bottom: 0 }, Margin)
    ], BulletChartLegendSettings.prototype, "margin", void 0);
    __decorate$15([
        Complex({}, Border)
    ], BulletChartLegendSettings.prototype, "border", void 0);
    __decorate$15([
        Property(5)
    ], BulletChartLegendSettings.prototype, "shapePadding", void 0);
    __decorate$15([
        Property('transparent')
    ], BulletChartLegendSettings.prototype, "background", void 0);
    __decorate$15([
        Property(1)
    ], BulletChartLegendSettings.prototype, "opacity", void 0);
    __decorate$15([
        Property(3)
    ], BulletChartLegendSettings.prototype, "tabIndex", void 0);
    return BulletChartLegendSettings;
}(ChildProperty));

/** @private
 * @param {ChartTheme} theme Passed theme parameter.
 * @returns {IBulletStyle} It returns bullet style.
 */
// tslint:disable-next-line:max-func-body-length
function getBulletThemeColor(theme) {
    var darkBackground = theme === 'MaterialDark' ? '#383838' : (theme === 'FabricDark' ? '#242424' : '#1b1b1b');
    var style = {
        majorTickLineColor: '#424242',
        minorTickLineColor: '#424242',
        background: '#FFFFFF',
        labelFontColor: 'rgba(0,0,0,0.54)',
        categoryFontColor: '#666666',
        labelFontFamily: 'SegoeUI',
        tooltipFill: '#000816',
        legendLabel: '#353535',
        tooltipBoldLabel: '#ffffff',
        featuredMeasureColor: '#181818',
        comparativeMeasureColor: '#181818',
        titleFontColor: 'rgba(0,0,0,0.87)',
        dataLabelFontColor: '#ffffff',
        titleFontFamily: 'SegoeUI',
        subTitleFontColor: ' rgba(0,0,0,0.54)',
        subTitleFontFamily: 'SegoeUI',
        firstRangeColor: '#959595',
        secondRangeColor: '#BDBDBD',
        thirdRangeColor: '#E3E2E2',
        rangeStrokes: [{ color: '#959595' }, { color: '#BDBDBD' }, { color: '#E3E2E2' }],
        titleFont: {
            color: 'rgba(0, 0, 0, 1)', fontFamily: 'Roboto'
        },
        subTitleFont: {
            color: 'rgba(0, 0, 0, 1)', fontFamily: 'Roboto'
        },
        legendLabelFont: {
            color: 'rgba(97, 97, 97, 1)', fontFamily: 'Roboto'
        },
        axisLabelFont: {
            color: 'rgba(97, 97, 97, 1)', fontFamily: 'Roboto'
        },
        dataLabelFont: {
            color: 'rgba(97, 97, 97, 1)', fontFamily: 'Roboto'
        },
        tooltipLabelFont: {
            color: 'rgba(249, 250, 251, 1)', fontFamily: 'Roboto'
        }
    };
    switch (theme) {
        case 'Fabric':
            style = {
                majorTickLineColor: '#424242',
                minorTickLineColor: '#424242',
                background: '#FFFFFF',
                labelFontColor: '#666666',
                categoryFontColor: '#666666',
                labelFontFamily: 'SegoeUI',
                tooltipFill: '#FFFFFF',
                legendLabel: '#353535',
                tooltipBoldLabel: '#ffffff',
                featuredMeasureColor: '#181818',
                comparativeMeasureColor: '#181818',
                titleFontColor: '#333333',
                dataLabelFontColor: '#ffffff',
                titleFontFamily: 'SegoeUI',
                subTitleFontColor: '#666666',
                subTitleFontFamily: 'SegoeUI',
                firstRangeColor: '#959595',
                secondRangeColor: '#BDBDBD',
                thirdRangeColor: '#E3E2E2',
                rangeStrokes: [{ color: '#959595' }, { color: '#BDBDBD' }, { color: '#E3E2E2' }],
                titleFont: {
                    color: '#333333', fontFamily: 'Segoe UI'
                },
                subTitleFont: {
                    color: '#333333', fontFamily: 'Segoe UI'
                },
                legendLabelFont: {
                    color: '#666666', fontFamily: 'Segoe UI'
                },
                axisLabelFont: {
                    color: '#666666', fontFamily: 'Segoe UI'
                },
                dataLabelFont: {
                    color: '#666666', fontFamily: 'Segoe UI'
                },
                tooltipLabelFont: {
                    color: '#333333', fontFamily: 'Segoe UI'
                }
            };
            break;
        case 'Bootstrap':
            style = {
                majorTickLineColor: '#424242',
                minorTickLineColor: '#424242',
                background: '#FFFFFF',
                labelFontColor: 'rgba(0,0,0,0.54)',
                categoryFontColor: 'rgba(0,0,0,0.54)',
                labelFontFamily: 'Helvetica',
                tooltipFill: '#212529',
                legendLabel: '#212529',
                tooltipBoldLabel: 'rgba(255,255,255)',
                featuredMeasureColor: '#181818',
                comparativeMeasureColor: '#181818',
                titleFontColor: 'rgba(0,0,0,0.87)',
                dataLabelFontColor: '#ffffff',
                titleFontFamily: 'Helvetica-Bold',
                subTitleFontColor: ' rgba(0,0,0,0.54)',
                subTitleFontFamily: 'Helvetica',
                firstRangeColor: '#959595',
                secondRangeColor: '#BDBDBD',
                thirdRangeColor: '#E3E2E2',
                rangeStrokes: [{ color: '#959595' }, { color: '#BDBDBD' }, { color: '#E3E2E2' }],
                titleFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                },
                subTitleFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                },
                legendLabelFont: {
                    color: '#666666', fontFamily: 'Helvetica'
                },
                axisLabelFont: {
                    color: '#676767', fontFamily: 'Helvetica'
                },
                dataLabelFont: {
                    color: '#676767', fontFamily: 'Helvetica'
                },
                tooltipLabelFont: {
                    color: '#F9FAFB', fontFamily: 'Helvetica'
                }
            };
            break;
        case 'HighContrast':
            style = {
                majorTickLineColor: '#FFFFFF',
                minorTickLineColor: '#FFFFFF',
                background: '#000000',
                labelFontColor: '#FFFFFF',
                categoryFontColor: '#FFFFFF',
                labelFontFamily: 'SegoeUI',
                tooltipFill: '#FFFFFF',
                legendLabel: '#ffffff',
                tooltipBoldLabel: '#000000',
                featuredMeasureColor: '#000000',
                comparativeMeasureColor: '#000000',
                titleFontColor: '#FFFFFF',
                dataLabelFontColor: '#ffffff',
                titleFontFamily: 'HelveticaNeue',
                subTitleFontColor: '#FFFFFF',
                subTitleFontFamily: 'SegoeUI',
                firstRangeColor: '#959595',
                secondRangeColor: '#BDBDBD',
                thirdRangeColor: '#E3E2E2',
                rangeStrokes: [{ color: '#757575' }, { color: '#BDBDBD' }, { color: '#EEEEEE' }],
                titleFont: {
                    color: '#FFFFFF', fontFamily: 'Segoe UI'
                },
                subTitleFont: {
                    color: '#FFFFFF', fontFamily: 'Segoe UI'
                },
                legendLabelFont: {
                    color: '#969696', fontFamily: 'Segoe UI'
                },
                axisLabelFont: {
                    color: '#969696', fontFamily: 'Segoe UI'
                },
                dataLabelFont: {
                    color: '#969696', fontFamily: 'Segoe UI'
                },
                tooltipLabelFont: {
                    color: '#000000', fontFamily: 'Segoe UI'
                }
            };
            break;
        case 'MaterialDark':
        case 'FabricDark':
        case 'BootstrapDark':
            style = {
                majorTickLineColor: '#F0F0F0',
                minorTickLineColor: '#F0F0F0',
                background: darkBackground,
                labelFontColor: '#FFFFFF',
                categoryFontColor: '#FFFFFF',
                labelFontFamily: 'Helvetica',
                tooltipFill: theme === 'MaterialDark' ? '#F4F4F4' : theme === 'FabricDark' ? '#A19F9D' : '#F0F0F0',
                legendLabel: '#DADADA',
                tooltipBoldLabel: '#282727',
                featuredMeasureColor: '#181818',
                comparativeMeasureColor: '#181818',
                titleFontColor: '#FFFFFF',
                dataLabelFontColor: '#ffffff',
                titleFontFamily: 'Helvetica-Bold',
                subTitleFontColor: '#FFFFFF',
                subTitleFontFamily: 'Helvetica',
                firstRangeColor: '#8D8D8D',
                secondRangeColor: '#ADADAD',
                thirdRangeColor: '#EEEEEE',
                rangeStrokes: [{ color: '#8D8D8D' }, { color: '#ADADAD' }, { color: '#EEEEEE' }],
                titleFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.87)' : theme === 'FabricDark' ? '#DADADA' : '#FFFFFF', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                subTitleFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.87)' : theme === 'FabricDark' ? '#DADADA' : '#FFFFFF', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                legendLabelFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : theme === 'FabricDark' ? '#A19F9D' : '#676767', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                axisLabelFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : theme === 'FabricDark' ? '#A19F9D' : '#676767', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                dataLabelFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : theme === 'FabricDark' ? '#A19F9D' : '#676767', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                tooltipLabelFont: {
                    color: theme === 'MaterialDark' ? 'rgba(18, 18, 18, 1)' : theme === 'FabricDark' ? '#DADADA' : '#1A1A1A', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                }
            };
            break;
        case 'Bootstrap4':
            style = {
                majorTickLineColor: '#424242',
                minorTickLineColor: '#424242',
                background: '#FFFFFF',
                labelFontColor: '#202528',
                categoryFontColor: '#202528',
                labelFontFamily: 'HelveticaNeue',
                tooltipFill: '#212529',
                legendLabel: '#212529',
                tooltipBoldLabel: 'rgba(255,255,255)',
                featuredMeasureColor: '#181818',
                comparativeMeasureColor: '#181818',
                titleFontColor: '#202528',
                dataLabelFontColor: '#ffffff',
                titleFontFamily: 'HelveticaNeue-Bold',
                subTitleFontColor: 'HelveticaNeue',
                subTitleFontFamily: '#202528',
                firstRangeColor: '#959595',
                secondRangeColor: '#BDBDBD',
                thirdRangeColor: '#E3E2E2',
                rangeStrokes: [{ color: '#959595' }, { color: '#BDBDBD' }, { color: '#E3E2E2' }],
                titleFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                },
                subTitleFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                },
                legendLabelFont: {
                    color: '#666666', fontFamily: 'Helvetica'
                },
                axisLabelFont: {
                    color: '#495057', fontFamily: 'Helvetica'
                },
                dataLabelFont: {
                    color: '#495057', fontFamily: 'Helvetica'
                },
                tooltipLabelFont: {
                    color: '#F9FAFB', fontFamily: 'Helvetica'
                }
            };
            break;
        case 'Tailwind':
            style = {
                majorTickLineColor: '#D1D5DB',
                minorTickLineColor: '#D1D5DB',
                background: 'transparent',
                labelFontColor: '#6B7280',
                categoryFontColor: '#6B7280',
                labelFontFamily: 'Inter',
                tooltipFill: '#111827',
                legendLabel: '#374151',
                tooltipBoldLabel: '#F9FAFB',
                featuredMeasureColor: '#1F2937',
                comparativeMeasureColor: '#1F2937',
                titleFontColor: '#374151',
                dataLabelFontColor: '#F9FAFB',
                titleFontFamily: 'Inter',
                subTitleFontColor: '#374151',
                subTitleFontFamily: 'Inter',
                firstRangeColor: '#9CA3AF',
                secondRangeColor: '#D1D5DB',
                thirdRangeColor: '#E5E7EB',
                rangeStrokes: [{ color: '#9CA3AF' }, { color: '#D1D5DB' }, { color: '#E5E7EB' }],
                titleFont: {
                    color: '#374151', fontFamily: 'Inter'
                },
                subTitleFont: {
                    color: '#374151', fontFamily: 'Inter'
                },
                legendLabelFont: {
                    color: '#374151', fontFamily: 'Inter'
                },
                axisLabelFont: {
                    color: '#6B7280', fontFamily: 'Inter'
                },
                dataLabelFont: {
                    color: '#6B7280', fontFamily: 'Inter'
                },
                tooltipLabelFont: {
                    color: '#F9FAFB', fontFamily: 'Inter'
                }
            };
            break;
        case 'TailwindDark':
            style = {
                majorTickLineColor: '#4B5563',
                minorTickLineColor: '#4B5563',
                background: 'transparent',
                labelFontColor: '#9CA3AF',
                categoryFontColor: '#9CA3AF',
                labelFontFamily: 'Inter',
                tooltipFill: '#E9ECEF',
                legendLabel: '#D1D5DB',
                tooltipBoldLabel: '#1F2937',
                featuredMeasureColor: '#1F2937',
                comparativeMeasureColor: '#1F2937',
                titleFontColor: '#D1D5DB',
                dataLabelFontColor: '#D1D5DB',
                titleFontFamily: 'Inter',
                subTitleFontColor: '#D1D5DB',
                subTitleFontFamily: 'Inter',
                firstRangeColor: '#6B7280',
                secondRangeColor: '#4B5563',
                thirdRangeColor: '#374151',
                rangeStrokes: [{ color: '#6B7280' }, { color: '#4B5563' }, { color: '#374151' }],
                titleFont: {
                    color: '#D1D5DB', fontFamily: 'Inter'
                },
                subTitleFont: {
                    color: '#D1D5DB', fontFamily: 'Inter'
                },
                legendLabelFont: {
                    color: '#D1D5DB', fontFamily: 'Inter'
                },
                axisLabelFont: {
                    color: '#9CA3AF', fontFamily: 'Inter'
                },
                dataLabelFont: {
                    color: '#9CA3AF', fontFamily: 'Inter'
                },
                tooltipLabelFont: {
                    color: '#1F2937', fontFamily: 'Inter'
                }
            };
            break;
        case 'Bootstrap5':
            style = {
                majorTickLineColor: '#CED4DA',
                minorTickLineColor: '#CED4DA',
                background: 'transparent',
                labelFontColor: '#495057',
                categoryFontColor: '#6B7280',
                labelFontFamily: 'Helvetica',
                tooltipFill: '#212529',
                legendLabel: '#343A40',
                tooltipBoldLabel: '#F9FAFB',
                featuredMeasureColor: '#1F2937',
                comparativeMeasureColor: '#1F2937',
                titleFontColor: '#343A40',
                dataLabelFontColor: '#495057',
                titleFontFamily: 'Helvetica',
                subTitleFontColor: '#343A40',
                subTitleFontFamily: 'Helvetica',
                firstRangeColor: '#9CA3AF',
                secondRangeColor: '#D1D5DB',
                thirdRangeColor: '#E5E7EB',
                rangeStrokes: [{ color: '#9CA3AF' }, { color: '#D1D5DB' }, { color: '#E5E7EB' }],
                titleFont: {
                    color: '#343A40', fontFamily: 'Helvetica'
                },
                subTitleFont: {
                    color: '#343A40', fontFamily: 'Helvetica'
                },
                legendLabelFont: {
                    color: '#343A40', fontFamily: 'Helvetica'
                },
                axisLabelFont: {
                    color: '#495057', fontFamily: 'Helvetica'
                },
                dataLabelFont: {
                    color: '#495057', fontFamily: 'Helvetica'
                },
                tooltipLabelFont: {
                    color: '#F9FAFB', fontFamily: 'Helvetica'
                }
            };
            break;
        case 'Bootstrap5Dark':
            style = {
                majorTickLineColor: '#6C757D',
                minorTickLineColor: '#6C757D',
                background: '#212529',
                labelFontColor: '#CED4DA',
                categoryFontColor: '#6B7280',
                labelFontFamily: 'Helvetica',
                tooltipFill: '#E9ECEF',
                legendLabel: '#E9ECEF',
                tooltipBoldLabel: '#212529',
                featuredMeasureColor: '#ADB5BD',
                comparativeMeasureColor: '#ADB5BD',
                titleFontColor: '#E9ECEF',
                dataLabelFontColor: '#CED4DA',
                titleFontFamily: 'Helvetica',
                subTitleFontColor: '#E9ECEF',
                subTitleFontFamily: 'Helvetica',
                firstRangeColor: '#6C757D',
                secondRangeColor: '#495057',
                thirdRangeColor: '#343A40',
                rangeStrokes: [{ color: '#6C757D' }, { color: '#495057' }, { color: '#343A40' }],
                titleFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                },
                subTitleFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                },
                legendLabelFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                },
                axisLabelFont: {
                    color: '#CED4DA', fontFamily: 'Helvetica'
                },
                dataLabelFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                },
                tooltipLabelFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                }
            };
            break;
        case 'Fluent':
            style = {
                majorTickLineColor: '#C8C6C4',
                minorTickLineColor: '#C8C6C4',
                background: 'rgba(255, 255, 255, 0.0001)',
                labelFontColor: '#3B3A39',
                categoryFontColor: '#3B3A39',
                labelFontFamily: 'Segoe UI',
                tooltipFill: '#FFFFFF',
                legendLabel: '#3B3A39',
                tooltipBoldLabel: '#323130',
                featuredMeasureColor: '#A19F9D',
                comparativeMeasureColor: '#A19F9D',
                titleFontColor: '#201F1E',
                dataLabelFontColor: '#3B3A39',
                titleFontFamily: 'Segoe UI',
                subTitleFontColor: '#201F1E',
                subTitleFontFamily: 'Segoe UI',
                firstRangeColor: '#C8C6C4',
                secondRangeColor: '#D2D0CE',
                thirdRangeColor: '#EDEBE9',
                rangeStrokes: [{ color: '#C8C6C4' }, { color: '#D2D0CE' }, { color: '#EDEBE9' }],
                titleFont: {
                    color: '#201F1E', fontFamily: 'Segoe UI'
                },
                subTitleFont: {
                    color: '#323129', fontFamily: 'Segoe UI'
                },
                legendLabelFont: {
                    color: '#49454E', fontFamily: 'Segoe UI'
                },
                axisLabelFont: {
                    color: '#3B3A39', fontFamily: 'Segoe UI'
                },
                dataLabelFont: {
                    color: '#3B3A39', fontFamily: 'Segoe UI'
                },
                tooltipLabelFont: {
                    color: '#323130', fontFamily: 'Segoe UI'
                }
            };
            break;
        case 'FluentDark':
            style = {
                majorTickLineColor: '#484644',
                minorTickLineColor: '#484644',
                background: 'transparent',
                labelFontColor: '#C8C6C4',
                categoryFontColor: '#C8C6C4',
                labelFontFamily: 'Segoe UI',
                tooltipFill: '#323130',
                legendLabel: '#C8C6C4',
                tooltipBoldLabel: '#F3F2F1',
                featuredMeasureColor: '#797775',
                comparativeMeasureColor: '#797775',
                titleFontColor: '#F3F2F1',
                dataLabelFontColor: '#C8C6C4',
                titleFontFamily: 'Segoe UI',
                subTitleFontColor: '#F3F2F1',
                subTitleFontFamily: 'Segoe UI',
                firstRangeColor: '#484644',
                secondRangeColor: '#3B3A39',
                thirdRangeColor: '#292827',
                rangeStrokes: [{ color: '#484644' }, { color: '#3B3A39' }, { color: '#292827' }],
                titleFont: {
                    color: '#C8C6C4', fontFamily: 'Segoe UI'
                },
                subTitleFont: {
                    color: '#F3F2F1', fontFamily: 'Segoe UI'
                },
                legendLabelFont: {
                    color: '#D2D0CE', fontFamily: 'Segoe UI'
                },
                axisLabelFont: {
                    color: '#C8C6C4', fontFamily: 'Segoe UI'
                },
                dataLabelFont: {
                    color: '#D2D0CE', fontFamily: 'Segoe UI'
                },
                tooltipLabelFont: {
                    color: '#F3F2F1', fontFamily: 'Segoe UI'
                }
            };
            break;
        case 'Material3':
            style = {
                majorTickLineColor: '#C4C7C5',
                minorTickLineColor: '#C4C7C5',
                background: 'transparent',
                labelFontColor: '#1E192B',
                categoryFontColor: '#1E192B',
                labelFontFamily: 'Roboto',
                tooltipFill: '#313033',
                legendLabel: '#49454E',
                tooltipBoldLabel: '#F4EFF4',
                featuredMeasureColor: '#79747E',
                comparativeMeasureColor: '#79747E',
                titleFontColor: '#1C1B1F',
                dataLabelFontColor: '#49454E',
                titleFontFamily: 'Roboto',
                subTitleFontColor: '#1C1B1F',
                subTitleFontFamily: 'Roboto',
                firstRangeColor: '#a6a6a9',
                secondRangeColor: '#C4C7C5',
                thirdRangeColor: '#E7E0EC',
                rangeStrokes: [{ color: '#a6a6a9' }, { color: '#C4C7C5' }, { color: '#E7E0EC' }],
                titleFont: {
                    color: '#1C1B1F', fontFamily: 'Roboto'
                },
                subTitleFont: {
                    color: '#49454E', fontFamily: 'Roboto'
                },
                legendLabelFont: {
                    color: '#49454E', fontFamily: 'Roboto'
                },
                axisLabelFont: {
                    color: '#1E192B', fontFamily: 'Roboto'
                },
                dataLabelFont: {
                    color: '#49454E', fontFamily: 'Roboto'
                },
                tooltipLabelFont: {
                    color: '#F4EFF4', fontFamily: 'Roboto'
                }
            };
            break;
        case 'Material3Dark':
            style = {
                majorTickLineColor: '#444746',
                minorTickLineColor: '#444746',
                background: 'transparent',
                labelFontColor: '#E6E1E5',
                categoryFontColor: '#E6E1E5',
                labelFontFamily: 'Roboto',
                tooltipFill: '#E6E1E5',
                legendLabel: '#CAC4D0',
                tooltipBoldLabel: '#313033',
                featuredMeasureColor: '#938F99',
                comparativeMeasureColor: '#938F99',
                titleFontColor: '#E6E1E5',
                dataLabelFontColor: '#CAC4D0',
                titleFontFamily: 'Roboto',
                subTitleFontColor: '#E6E1E5',
                subTitleFontFamily: 'Roboto',
                firstRangeColor: 'rgba(147,143,153,0.4)',
                secondRangeColor: '#444746',
                thirdRangeColor: '#49454F',
                rangeStrokes: [{ color: 'rgba(147,143,153,0.4)' }, { color: '#444746' }, { color: '#49454F' }],
                titleFont: {
                    color: '#E6E1E5', fontFamily: 'Roboto'
                },
                subTitleFont: {
                    color: '#CAC4D0', fontFamily: 'Roboto'
                },
                legendLabelFont: {
                    color: '#CAC4D0', fontFamily: 'Roboto'
                },
                axisLabelFont: {
                    color: '#CAC4D0', fontFamily: 'Roboto'
                },
                dataLabelFont: {
                    color: '#CAC4D0', fontFamily: 'Roboto'
                },
                tooltipLabelFont: {
                    color: '#313033', fontFamily: 'Roboto'
                }
            };
            break;
        default:
            // eslint-disable-next-line no-self-assign
            style = style;
            break;
    }
    return style;
}

var __extends$84 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$14 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * bullet chart
 */
var BulletChart = /** @__PURE__ @class */ (function (_super) {
    __extends$84(BulletChart, _super);
    /**
     * Constructor for creating the bullet chart
     *
     * @hidden
     */
    function BulletChart(options, element) {
        var _this = _super.call(this, options, element) || this;
        /** @private */
        _this.bulletid = 57726;
        /** @private */
        _this.animateSeries = true;
        _this.padding = 5;
        /** @private */
        _this.leftSize = 0;
        /** @private */
        _this.rightSize = 0;
        /** @private */
        _this.topSize = 0;
        /** @private */
        _this.bottomSize = 0;
        /** @private */
        _this.maxLabelSize = new Size(0, 0);
        _this.maxTitleSize = new Size(0, 0);
        /** @private */
        _this.intervalDivs = [10, 5, 2, 1];
        return _this;
    }
    /**
     * Initialize the event handler.
     */
    BulletChart.prototype.preRender = function () {
        this.allowServerDataBinding = false;
        this.unWireEvents();
        this.initPrivateValues();
        this.setCulture();
        this.wireEvents();
    };
    /**
     * To initialize the private variables
     */
    BulletChart.prototype.initPrivateValues = function () {
        this.delayRedraw = false;
        this.scale = new ScaleGroup(this);
        this.bulletAxis = new BulletChartAxis(this);
        if (this.element.id === '') {
            var collection = document.getElementsByClassName('e-BulletChart').length;
            this.element.id = 'BulletChart_' + this.bulletid + '_' + collection;
        }
    };
    /**
     * Method to set culture for BulletChart
     */
    BulletChart.prototype.setCulture = function () {
        this.intl = new Internationalization();
    };
    /**
     * To Initialize the bullet chart rendering.
     */
    BulletChart.prototype.render = function () {
        var _this = this;
        var loadEventData = {
            bulletChart: this,
            theme: this.theme, name: 'load'
        };
        this.trigger('load', loadEventData, function () {
            _this.setTheme();
            _this.createSvg(_this);
            _this.findRange();
            if (_this.bulletChartLegendModule && _this.legendSettings.visible) {
                _this.calculateVisibleElements();
                _this.bulletChartLegendModule.getLegendOptions(_this.visibleRanges);
            }
            _this.calculatePosition();
            _this.renderBulletElements();
            _this.trigger('loaded', { bulletChart: _this });
            _this.allowServerDataBinding = true;
            _this.renderComplete();
        });
    };
    /**
     * Theming for bullet chart
     */
    BulletChart.prototype.setTheme = function () {
        this.themeStyle = getBulletThemeColor(this.theme);
        if ((this.targetColor === null || this.targetColor === '#191919' || this.valueFill == null) && this.theme.indexOf('Fluent') > -1) {
            this.valueFill = !(this.valueFill) ? (this.theme === 'FluentDark' ? '#797775' : '#A19F9D') : this.valueFill;
            this.targetColor = (this.targetColor == '#191919') ? (this.theme === 'FluentDark' ? '#797775' : '#A19F9D') : this.targetColor;
        }
        if ((this.targetColor === null || this.targetColor === '#191919' || this.valueFill == null) && this.theme.indexOf('Material3') > -1) {
            this.valueFill = !(this.valueFill) ? (this.theme === 'Material3Dark' ? '#938F99' : '#79747E') : this.valueFill;
            this.targetColor = (this.targetColor == '#191919') ? (this.theme === 'Material3Dark' ? '#938F99' : '#79747E') : this.targetColor;
        }
    };
    BulletChart.prototype.findRange = function () {
        if (!this.minimum) {
            this.minimum = 0;
        }
        if (!this.maximum) {
            this.maximum = 0;
            for (var i = 0; i < this.ranges.length; i++) {
                this.maximum = this.maximum > this.ranges[i].end ? this.maximum : this.ranges[i].end;
            }
        }
        if (this.maximum === null) {
            if (!isNullOrUndefined(this.dataSource)) {
                for (var i = 0; i < Object.keys(this.dataSource).length; i++) {
                    if (this.dataSource[i][this.targetField] > this.dataSource[i][this.valueField]) {
                        this.maximum = this.maximum > this.dataSource[i][this.targetField] ? this.maximum + this.interval :
                            this.dataSource[i][this.targetField] + this.interval;
                    }
                    else {
                        this.maximum = this.maximum > this.dataSource[i][this.valueField] ? this.maximum + this.interval :
                            this.dataSource[i][this.valueField] + this.interval;
                    }
                }
            }
            else {
                this.maximum = 10;
            }
        }
        if (!this.interval) {
            this.interval = this.calculateNumericNiceInterval(this.maximum - this.minimum);
        }
    };
    BulletChart.prototype.getActualDesiredIntervalsCount = function (availableSize) {
        var size = this.orientation === 'Horizontal' ? availableSize.width : availableSize.height;
        var desiredIntervalsCount = (this.orientation === 'Horizontal' ? 0.533 : 1) * 3;
        desiredIntervalsCount = Math.max((size * (desiredIntervalsCount / 100)), 1);
        return desiredIntervalsCount;
    };
    /**
     * Numeric Nice Interval for the axis.
     *
     * @private
     * @returns {number} calculateNumericNiceInterval.
     */
    BulletChart.prototype.calculateNumericNiceInterval = function (delta) {
        var actualDesiredIntervalsCount = this.getActualDesiredIntervalsCount(this.availableSize);
        var niceInterval = delta / actualDesiredIntervalsCount;
        var minInterval = Math.pow(10, Math.floor(logBase(niceInterval, 10)));
        for (var _i = 0, _a = this.intervalDivs; _i < _a.length; _i++) {
            var interval = _a[_i];
            var currentInterval = minInterval * interval;
            if (actualDesiredIntervalsCount < (delta / currentInterval)) {
                break;
            }
            niceInterval = currentInterval;
        }
        return niceInterval;
    };
    /**
     * To set the left and top position for data label template for center aligned bulletchart
     */
    BulletChart.prototype.setSecondaryElementPosition = function () {
        var element = getElement$1(this.element.id + '_Secondary_Element');
        if (!element) {
            return;
        }
        var rect = this.element.getBoundingClientRect();
        var svgRect = getElement$1(this.element.id + '_svg').getBoundingClientRect();
        element.style.left = Math.max(svgRect.left - rect.left, 0) + 'px';
        element.style.top = Math.max(svgRect.top - rect.top, 0) + 'px';
        element.style.position = 'relative';
    };
    /**
     * Method to create SVG element.
     */
    BulletChart.prototype.createSvg = function (chart) {
        this.removeSvg();
        chart.renderer = new SvgRenderer(chart.element.id);
        this.calculateAvailableSize(this);
        chart.svgObject = chart.renderer.createSvg({
            id: chart.element.id + '_svg',
            width: chart.availableSize.width,
            height: chart.availableSize.height
        });
        this.renderChartBackground();
    };
    /**
     * Creating a background element to the svg object
     */
    BulletChart.prototype.renderChartBackground = function () {
        var rect = new RectOption(this.element.id + '_ChartBorder', this.themeStyle.background, { width: this.border.width || 0, color: this.border.color || 'transparent' }, 1, new Rect(0, 0, this.availableSize.width, this.availableSize.height));
        this.svgObject.appendChild(this.renderer.drawRectangle(rect));
    };
    /**
     * Rendering the bullet elements
     */
    BulletChart.prototype.renderBulletElements = function () {
        var scaleGroup = this.renderer.createGroup({ 'id': this.svgObject.id + '_scaleGroup' });
        this.renderBulletChartTitle();
        this.svgObject.appendChild(scaleGroup);
        this.rangeCollection = this.scale.drawScaleGroup(scaleGroup);
        var size = (this.orientation === 'Horizontal') ? this.initialClipRect.width : this.initialClipRect.height;
        var intervalValue = size / ((this.maximum - this.minimum) / this.interval);
        this.bulletAxis.renderMajorTickLines(intervalValue, scaleGroup);
        this.bulletAxis.renderMinorTickLines(intervalValue, scaleGroup);
        this.bulletAxis.renderAxisLabels(intervalValue, scaleGroup);
        this.bulletChartRect.x = (this.titlePosition === 'Left' ||
            this.titlePosition === 'Right' || this.orientation === 'Vertical') ? this.bulletChartRect.x : 0;
        var elementId = this.element.id;
        if (this.element.tagName !== 'g') {
            var tooltipDiv = redrawElement(this.redraw, elementId + '_Secondary_Element') ||
                this.createElement('div');
            tooltipDiv.id = elementId + '_Secondary_Element';
            appendChildElement(false, this.element, tooltipDiv, this.redraw);
        }
        if (this.tooltip.enable) {
            appendChildElement(false, this.svgObject, this.renderer.createGroup({ id: elementId + '_UserInteraction', style: 'pointer-events:none;' }), this.redraw);
        }
        //this.bulletAxis.renderYAxisLabels(intervalValue, scaleGroup, this.bulletChartRect);
        this.bindData();
        this.renderDataLabel();
        this.renderBulletLegend();
        //this.changeOrientation(scaleGroup);
        this.element.appendChild(this.svgObject);
        this.setSecondaryElementPosition();
    };
    /**
     * To render the legend
     */
    BulletChart.prototype.renderBulletLegend = function () {
        if (this.bulletChartLegendModule && this.bulletChartLegendModule.legendCollections.length) {
            this.bulletChartLegendModule.calTotalPage = true;
            var bounds = this.bulletChartLegendModule.legendBounds;
            this.bulletChartLegendModule.renderLegend(this, this.legendSettings, bounds);
        }
    };
    /**
     * Handles the bullet chart resize.
     *
     * @returns {boolean}
     * @private
     */
    BulletChart.prototype.bulletResize = function () {
        var _this = this;
        this.animateSeries = false;
        var arg = {
            chart: this,
            name: resized,
            currentSize: new Size(0, 0),
            previousSize: new Size(this.availableSize.width, this.availableSize.height)
        };
        if (this.resizeTo) {
            clearTimeout(this.resizeTo);
        }
        this.resizeTo = +setTimeout(function () {
            if (_this.isDestroyed) {
                clearTimeout(_this.resizeTo);
                return;
            }
            _this.createSvg(_this);
            arg.currentSize = _this.availableSize;
            _this.trigger(resized, arg);
            _this.calculatePosition();
            _this.renderBulletElements();
        }, 500);
        return false;
    };
    /**
     * Process the data values of feature and comparative measure bar
     */
    BulletChart.prototype.bindData = function () {
        if (this.dataSource != null) {
            this.dataCount = this.dataSource.length;
            this.drawMeasures(this.dataCount);
        }
    };
    /**
     * Rendering the feature and comaparative measure bars
     */
    BulletChart.prototype.drawMeasures = function (dataCount) {
        this.scale.renderFeatureBar(dataCount);
        this.scale.renderComparativeSymbol(dataCount);
    };
    /**
     * To calculate the title bounds
     */
    BulletChart.prototype.calculatePosition = function () {
        var margin = this.margin;
        // Title Height;
        var titleHeight = 0;
        var subTitleHeight = 0;
        var titleSize = new Size(0, 0);
        var padding = 5;
        this.titleCollections = [];
        this.subTitleCollections = [];
        var maxTitlteWidth = 0;
        var maxTitlteHeight = 0;
        var maxVerticalTitlteHeight = padding;
        if (this.title) {
            this.titleCollections = getTitle(this.title, this.titleStyle, this.titleStyle.maximumTitleWidth, this.enableRtl, this.themeStyle.titleFont);
            titleHeight = (measureText(this.title, this.titleStyle, this.themeStyle.titleFont).height * this.titleCollections.length) + padding;
            for (var _i = 0, _a = this.titleCollections; _i < _a.length; _i++) {
                var titleText = _a[_i];
                titleSize = measureText(titleText, this.titleStyle, this.themeStyle.titleFont);
                maxTitlteWidth = titleSize.width > maxTitlteWidth ? titleSize.width : maxTitlteWidth;
                maxTitlteHeight = titleSize.height > maxTitlteHeight ? titleSize.height : maxTitlteHeight;
            }
            maxVerticalTitlteHeight += maxTitlteHeight;
            this.subTitleCollections = getTitle(this.subtitle, this.subtitleStyle, this.titleStyle.maximumTitleWidth, this.enableRtl);
            if (this.subtitle) {
                for (var _b = 0, _c = this.subTitleCollections; _b < _c.length; _b++) {
                    var subText = _c[_b];
                    titleSize = measureText(subText, this.subtitleStyle, this.themeStyle.subTitleFont);
                    maxTitlteWidth = titleSize.width > maxTitlteWidth ? titleSize.width : maxTitlteWidth;
                    maxTitlteHeight = titleSize.height > maxTitlteHeight ? titleSize.height : maxTitlteHeight;
                }
                subTitleHeight = (measureText(this.subtitle, this.subtitleStyle, this.themeStyle.subTitleFont).height * this.subTitleCollections.length) +
                    padding;
                maxVerticalTitlteHeight += maxTitlteHeight;
            }
        }
        this.maxTitleSize = new Size(maxTitlteWidth, this.orientation === 'Vertical' ? maxVerticalTitlteHeight : maxTitlteHeight);
        this.maxLabelSize = this.getMaxLabelWidth();
        this.initialClipRect = this.getBulletBounds((this.orientation === 'Vertical' ? maxVerticalTitlteHeight : maxTitlteWidth), titleHeight, subTitleHeight, margin);
        this.bulletChartRect = new Rect(this.initialClipRect.x, this.initialClipRect.y, this.initialClipRect.width, this.initialClipRect.height);
        if (this.bulletChartLegendModule) {
            this.bulletChartLegendModule.calculateLegendBounds(this.initialClipRect, this.availableSize, this.maxLabelSize);
        }
    };
    /**
     * Calculate the rect values based on title position.
     *
     * @returns {void}
     * @private
     */
    BulletChart.prototype.getBulletBounds = function (maxTitlteWidth, titleHeight, subTitleHeight, margin) {
        var padding = 5;
        var rect = new Rect(0, 0, 0, 0);
        var enableRtl = this.enableRtl;
        var labelSpace = (this.labelPosition === this.tickPosition) ? padding : 0;
        var tickSize = ((this.tickPosition === 'Inside') ? 0 : (this.majorTickLines.height));
        var labelSize = ((this.labelPosition === 'Inside') ? 0 : padding +
            ((this.tickPosition === 'Outside') ? 0 : (measureText(this.maximum.toString(), this.labelStyle, this.themeStyle.dataLabelFont).height)));
        var topAxisLabel = 0;
        var bottomAxisLabel = 0;
        var leftAxisLabel = 0;
        var rightAxisLabel = 0;
        var topCategory = 0;
        var bottomCategory = 0;
        var leftCategory = 0;
        var rightCategory = 0;
        var title = maxTitlteWidth;
        var format = this.bulletAxis.getFormat(this);
        var isCustomFormat = format.match('{value}') !== null;
        this.bulletAxis.format = this.intl.getNumberFormat({
            format: isCustomFormat ? '' : format, useGrouping: this.enableGroupSeparator
        });
        var formatted = measureText(this.bulletAxis.formatValue(this.bulletAxis, isCustomFormat, format, this.maximum), this.labelStyle, this.themeStyle.axisLabelFont).width;
        var categoryLabelSize;
        if (this.orientation === 'Horizontal') {
            categoryLabelSize = this.maxLabelSize.width;
            topAxisLabel = (this.opposedPosition) ? tickSize + labelSize + labelSpace : 0;
            bottomAxisLabel = (!this.opposedPosition) ? tickSize + labelSize + labelSpace : 0;
            leftCategory = ((categoryLabelSize && !enableRtl) ? (categoryLabelSize) : 0);
            leftCategory += (title && this.titlePosition === 'Left') ? padding * 3 : 0;
            rightCategory = ((categoryLabelSize && enableRtl) ? (categoryLabelSize) : 0);
            rightCategory += (title && this.titlePosition === 'Right') ? padding : 0;
        }
        else {
            categoryLabelSize = this.maxLabelSize.height;
            rightAxisLabel = (this.opposedPosition) ? tickSize + labelSpace : 0;
            rightAxisLabel += (this.opposedPosition && this.labelPosition !== 'Inside') ?
                formatted : 0;
            leftAxisLabel = (!this.opposedPosition) ? tickSize + labelSpace : 0;
            leftAxisLabel += (!this.opposedPosition && this.labelPosition !== 'Inside') ?
                formatted : 0;
            topCategory = ((categoryLabelSize && enableRtl) ? (categoryLabelSize + padding) : 0);
            bottomCategory = ((categoryLabelSize && !enableRtl) ? (categoryLabelSize + padding) : 0);
        }
        switch (this.titlePosition) {
            case 'Left':
                rect.x = margin.left + title + leftCategory + leftAxisLabel;
                rect.width = this.availableSize.width - margin.right - rect.x - rightCategory - rightAxisLabel;
                rect.y = margin.top + topAxisLabel + topCategory;
                rect.height = this.availableSize.height - rect.y - margin.bottom - bottomAxisLabel - bottomCategory;
                break;
            case 'Right':
                rect.x = margin.left + leftCategory + leftAxisLabel;
                rect.width = this.availableSize.width - rightAxisLabel - margin.right - rect.x - (title + padding) - rightCategory;
                rect.y = margin.top + topAxisLabel + topCategory;
                rect.height = this.availableSize.height - rect.y - margin.bottom - bottomAxisLabel - bottomCategory;
                break;
            case 'Top':
                rect.x = margin.left + leftAxisLabel + leftCategory;
                rect.width = this.availableSize.width - margin.right - rect.x - rightCategory - rightAxisLabel;
                rect.y = margin.top + (titleHeight + subTitleHeight) + topAxisLabel + topCategory;
                rect.height = this.availableSize.height - rect.y - margin.bottom - bottomAxisLabel - bottomCategory;
                break;
            case 'Bottom':
                rect.x = margin.left + leftAxisLabel + leftCategory;
                rect.y = margin.top + topAxisLabel + topCategory;
                rect.width = this.availableSize.width - margin.right - rect.x - rightCategory - rightAxisLabel;
                rect.height = this.availableSize.height - rect.y - bottomCategory - margin.bottom - bottomAxisLabel -
                    (titleHeight + subTitleHeight);
                break;
        }
        return rect;
    };
    /**
     * Calculate maximum label width for category values.
     *
     * @private
     * @returns {Size} To get a label width
     */
    BulletChart.prototype.getMaxLabelWidth = function () {
        this.maxLabelSize = new Size(0, 0);
        if (!this.categoryField) {
            return this.maxLabelSize;
        }
        var label;
        for (var i = 0, len = Object.keys(this.dataSource).length; i < len; i++) {
            label = measureText((this.dataSource[i][this.categoryField] || ''), this.categoryLabelStyle, this.themeStyle.axisLabelFont);
            if (label.width > this.maxLabelSize.width) {
                this.maxLabelSize.width = label.width;
            }
            if (label.height > this.maxLabelSize.height) {
                this.maxLabelSize.height = label.height;
            }
        }
        return this.maxLabelSize;
    };
    BulletChart.prototype.calculateVisibleElements = function () {
        var range;
        var rangeCollection = this.ranges;
        this.visibleRanges = [];
        for (var i = 0, len = rangeCollection.length; i < len; i++) {
            range = rangeCollection[i];
            range.index = i;
            // eslint-disable-next-line no-self-assign
            range.color = range.color;
            this.visibleRanges.push(range);
            rangeCollection[i] = range;
        }
    };
    /**
     * To render the title of the bullet chart
     */
    BulletChart.prototype.renderBulletChartTitle = function () {
        var margin = this.margin;
        var x = 0;
        var y = 0;
        var padding = 5;
        var anchor = 'middle';
        var transform = '';
        var alignment = this.titleStyle.textAlignment;
        var elementSize = measureText(this.title, this.titleStyle, this.themeStyle.titleFont);
        var subTitleSize = (this.subtitle) ? measureText(this.subtitle, this.subtitleStyle, this.themeStyle.subTitleFont) : new Size(0, 0);
        if (this.title) {
            if (this.orientation === 'Horizontal') {
                switch (this.titlePosition) {
                    case 'Top':
                        x = this.findHorizontalAlignment(margin);
                        anchor = (alignment === 'Far') ? 'end' : ((alignment === 'Near') ? 'start' : 'middle');
                        y = margin.top + elementSize.height / 2 + padding;
                        break;
                    case 'Bottom':
                        x = this.findHorizontalAlignment(margin);
                        anchor = (alignment === 'Far') ? 'end' : ((alignment === 'Near') ? 'start' : 'middle');
                        y = this.availableSize.height - margin.bottom - elementSize.height / 3 + padding * 2
                            - ((subTitleSize.height) ? subTitleSize.height + padding : 0);
                        break;
                    case 'Left':
                        anchor = 'end';
                        x = margin.left + this.maxTitleSize.width;
                        y = (this.margin.top + (this.availableSize.height) / 2 - elementSize.height / 3)
                            - ((subTitleSize.height) ? subTitleSize.height : 0);
                        break;
                    case 'Right':
                        anchor = 'start';
                        x = (this.availableSize.width - margin.right - this.maxTitleSize.width + padding);
                        y = (this.margin.top + (this.availableSize.height) / 2 - elementSize.height / 3)
                            - ((subTitleSize.height) ? subTitleSize.height : 0);
                        break;
                }
            }
            else {
                switch (this.titlePosition) {
                    case 'Top':
                        x = (this.availableSize.width) / 2 + padding * 2;
                        y = this.margin.top + elementSize.height / 2 + padding;
                        break;
                    case 'Bottom':
                        x = (this.availableSize.width) / 2;
                        y = this.availableSize.height - this.margin.bottom - elementSize.height / 3 + padding * 2
                            - ((subTitleSize.height) ? subTitleSize.height + padding : 0);
                        break;
                    case 'Left':
                        y = this.findVerticalAlignment(margin);
                        anchor = (alignment === 'Far') ? 'start' : ((alignment === 'Near') ? 'end' : 'middle');
                        x = margin.left;
                        break;
                    case 'Right':
                        x = (this.availableSize.width - margin.right - elementSize.height / 3);
                        anchor = (alignment === 'Far') ? 'start' : ((alignment === 'Near') ? 'end' : 'middle');
                        y = this.findVerticalAlignment(margin);
                        break;
                }
                transform = (this.titlePosition === 'Left') ? 'rotate(-90,' + x + ',' + y + ')' :
                    ((this.titlePosition === 'Right') ? 'rotate(90,' + x + ',' + y + ')' : '');
            }
            var options = new TextOption(this.element.id + '_BulletChartTitle', x, y, anchor, this.titleCollections, transform, 'auto');
            var element = textElement$1(this.renderer, options, this.titleStyle, this.titleStyle.color || this.themeStyle.titleFont.color, this.svgObject, null, null, null, null, null, null, null, null, null, null, this.themeStyle.titleFont);
            if (element) {
                element.setAttribute('aria-label', this.title + '. Syncfusion interactive chart.');
                element.setAttribute('tabindex', this.tabIndex.toString());
            }
            if (this.subtitle) {
                this.renderBulletChartSubTitle(x, y, anchor);
            }
        }
    };
    /**
     * To render the data label for bullet chart
     */
    BulletChart.prototype.renderDataLabel = function () {
        var x = 0;
        var y = 0;
        var anchor;
        var transform = '';
        var enableRtl = this.enableRtl;
        var data;
        var featureBounds;
        var alignment = this.dataLabel.labelStyle.textAlignment;
        var format = this.labelFormat ? this.labelFormat : '';
        var isCustomFormat = format.match('{value}') !== null;
        if (this.dataLabel.enable) {
            for (var i = 0, len = Object.keys(this.dataSource).length; i < len; i++) {
                data = this.dataSource[i];
                featureBounds = this.scale.featureBarBounds[i];
                var labelText = (data[this.valueField]).toString();
                this.format = this.intl.getNumberFormat({
                    format: isCustomFormat ? '' : format, useGrouping: this.enableGroupSeparator
                });
                labelText = isCustomFormat ? format.replace('{value}', this.format(labelText)) : labelText;
                var labelSize = measureText(labelText, this.dataLabel.labelStyle, this.themeStyle.axisLabelFont);
                // tslint:disable-next-line:no-string-literal
                var textWidth = labelSize['width'];
                // tslint:disable-next-line:no-string-literal
                var textHeight = labelSize['height'];
                if (this.orientation === 'Horizontal') {
                    anchor = this.type === 'Rect' ? 'end' : (enableRtl ? 'end' : 'start');
                    x = this.findTextAlignment(featureBounds, textWidth, alignment);
                    if (x - textWidth < this.initialClipRect.x) {
                        anchor = 'start';
                    }
                    if (x > this.initialClipRect.width) {
                        x -= textWidth;
                    }
                    y = featureBounds.y + featureBounds.height / 2;
                }
                else {
                    anchor = 'middle';
                    x = featureBounds.y + featureBounds.height / 2;
                    y = this.findTextAlignment(featureBounds, textWidth, alignment);
                    if (y + (textHeight / 2) > this.initialClipRect.height + this.initialClipRect.y) {
                        y = y - (textHeight / 3);
                    }
                }
                var labelOptions = new TextOption(this.element.id + '_DataLabel_' + i, x, y, anchor, labelText, transform, 'middle');
                textElement$1(this.renderer, labelOptions, this.dataLabel.labelStyle, this.dataLabel.labelStyle.color || this.themeStyle.dataLabelFont.color, this.svgObject, null, null, null, null, null, null, null, null, null, null, this.themeStyle.dataLabelFont);
            }
        }
    };
    BulletChart.prototype.findTextAlignment = function (featureBounds, textWidth, alignment) {
        var elementSpacing = 10;
        var x = 0;
        switch (alignment) {
            case 'Center':
                x = featureBounds.x + featureBounds.width / 2;
                break;
            case 'Near':
                x = featureBounds.x + (this.orientation === 'Horizontal' ? (this.enableRtl ? featureBounds.width - elementSpacing / 2 : elementSpacing / 2)
                    : (this.enableRtl ? elementSpacing : featureBounds.width));
                break;
            case 'Far':
                x = featureBounds.x + (this.orientation === 'Horizontal' ? ((this.enableRtl ? (this.type === 'Rect' ? textWidth + elementSpacing : -elementSpacing) :
                    featureBounds.width) + (this.type === 'Rect' ? -elementSpacing / 2 : elementSpacing / 2))
                    : (this.enableRtl ? featureBounds.width + (this.type === 'Rect' ? -elementSpacing : elementSpacing) : 0) +
                        (this.type === 'Rect' ? elementSpacing : -elementSpacing));
                break;
        }
        return x;
    };
    BulletChart.prototype.findHorizontalAlignment = function (margin) {
        var x = 0;
        switch (this.titleStyle.textAlignment) {
            case 'Center':
                x = (this.availableSize.width - margin.left - margin.right) / 2;
                break;
            case 'Near':
                x = margin.left;
                break;
            case 'Far':
                x = this.availableSize.width - margin.right;
                break;
        }
        return x;
    };
    BulletChart.prototype.findVerticalAlignment = function (margin) {
        var y = 0;
        switch (this.titleStyle.textAlignment) {
            case 'Center':
                y = (this.availableSize.height - margin.top - margin.bottom) / 2;
                break;
            case 'Near':
                y = margin.top;
                break;
            case 'Far':
                y = this.availableSize.height - margin.bottom;
                break;
        }
        return y;
    };
    /**
     * To render the sub title of the bullet chart
     */
    BulletChart.prototype.renderBulletChartSubTitle = function (x, y, anchor) {
        var margin = this.margin;
        var padding = 5;
        var transform = '';
        var elementSize = measureText(this.subtitle, this.subtitleStyle, this.themeStyle.subTitleFont);
        if (this.orientation === 'Horizontal') {
            switch (this.titlePosition) {
                case 'Top':
                    y = y + elementSize.height + padding / 2;
                    break;
                case 'Bottom':
                    y = this.availableSize.height - margin.bottom - elementSize.height / 3 + padding;
                    break;
                case 'Left':
                    y = y + elementSize.height + padding / 2;
                    break;
                case 'Right':
                    y = y + elementSize.height + padding / 2;
                    break;
            }
        }
        else {
            switch (this.titlePosition) {
                case 'Top':
                    y = y + elementSize.height + padding / 2;
                    break;
                case 'Bottom':
                    y = this.availableSize.height - margin.bottom - elementSize.height / 3 + padding;
                    break;
                case 'Left':
                    x += elementSize.height + padding / 2;
                    break;
                case 'Right':
                    x -= elementSize.height + padding / 2;
                    break;
            }
            transform = (this.titlePosition === 'Left') ? 'rotate(-90,' + x + ',' + y + ')' :
                ((this.titlePosition === 'Right') ? 'rotate(90,' + x + ',' + y + ')' : '');
        }
        var subTitleOptions = new TextOption(this.element.id + '_BulletChartSubTitle', x, y, anchor, this.subTitleCollections, transform, 'auto');
        var element = textElement$1(this.renderer, subTitleOptions, this.subtitleStyle, this.subtitleStyle.color || this.themeStyle.subTitleFont.color, this.svgObject, null, null, null, null, null, null, null, null, null, null, this.themeStyle.subTitleFont);
        if (element) {
            element.setAttribute('aria-label', this.subtitle);
            element.setAttribute('tabindex', this.tabIndex.toString());
        }
    };
    /**
     * To calculate the available size and width of the container
     */
    BulletChart.prototype.calculateAvailableSize = function (bulletChart) {
        var containerWidth = this.element.clientWidth || this.element.offsetWidth || 200;
        var height = (this.orientation === 'Vertical') ? 450 :
            ((this.titlePosition === 'Left' || this.titlePosition === 'Right') ? 83 : 126);
        var containerHeight = this.element.clientHeight || height;
        bulletChart.availableSize = new Size(stringToNumber(bulletChart.width, containerWidth) || containerWidth, stringToNumber(bulletChart.height, containerHeight) || containerHeight);
    };
    BulletChart.prototype.removeSvg = function () {
        var svgElement = document.getElementById(this.element.id + '_svg');
        if (svgElement) {
            remove(svgElement);
        }
    };
    BulletChart.prototype.getPersistData = function () {
        var keyEntity = ['loaded'];
        return this.addOnPersist(keyEntity);
    };
    /** Wire, UnWire and Event releated calculation Started here */
    /**
     * Method to un-bind events for bullet chart
     */
    BulletChart.prototype.unWireEvents = function () {
        /*! Find the Events type */
        var startEvent = Browser.touchStartEvent;
        var moveEvent = Browser.touchMoveEvent;
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        /*! UnBind the Event handler */
        EventHandler.remove(this.element, startEvent, this.bulletMouseDown);
        EventHandler.remove(this.element, moveEvent, this.bulletMouseMove);
        EventHandler.remove(this.element, cancelEvent, this.bulletMouseLeave);
        EventHandler.remove(this.element, 'click', this.bulletChartOnMouseClick);
        window.removeEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.resizeBound);
    };
    /**
     * Method to bind events for bullet chart
     */
    BulletChart.prototype.wireEvents = function () {
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        /*! Bind the Event handler */
        EventHandler.add(this.element, Browser.touchMoveEvent, this.bulletMouseMove, this);
        EventHandler.add(this.element, cancelEvent, this.bulletMouseLeave, this);
        EventHandler.add(this.element, Browser.touchStartEvent, this.bulletMouseDown, this);
        EventHandler.add(this.element, 'click', this.bulletChartOnMouseClick, this);
        this.resizeBound = this.bulletResize.bind(this);
        window.addEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.resizeBound);
        /*! Apply the style for chart */
        this.setStyle(this.element);
    };
    BulletChart.prototype.setStyle = function (element) {
        element.style.position = 'relative';
        element.style.display = 'block';
    };
    /**
     * Handles the mouse move on the bullet chart.
     *
     * @private
     */
    BulletChart.prototype.bulletMouseMove = function (e) {
        var pageX = e.clientX;
        var pageY = e.clientY;
        this.setPointMouseXY(pageX, pageY);
        var targetId = e.target.id;
        // tslint:disable-next-line:no-string-literal
        var targetClass = e.target.className['baseVal'];
        if (targetClass !== this.svgObject.id + '_FeatureMeasure' || this.svgObject.id + '_ComparativeMeasure') {
            if (!isNullOrUndefined(this.dataSource)) {
                for (var i = 0; i < Object.keys(this.dataSource).length; i++) {
                    document.getElementById(this.svgObject.id + '_FeatureMeasure_' + i).setAttribute('opacity', '1');
                    document.getElementById(this.svgObject.id + '_ComparativeMeasure_' + i).setAttribute('opacity', '1');
                }
            }
        }
        if (!this.isTouchEvent(e)) {
            var id = 'tooltipDiv' + this.element.id;
            var tooltipDiv = document.getElementById(id);
            if (tooltipDiv) {
                // tslint:disable-next-line:no-any
                if (this.isReact) {
                    this.clearTemplate();
                }
                remove(tooltipDiv);
            }
            if (this.bulletTooltipModule) {
                this.bulletTooltipModule._elementTooltip(e, targetClass, targetId, this.mouseX);
                this.bulletTooltipModule._displayTooltip(e, targetClass, targetId, this.mouseX, this.mouseY);
            }
        }
    };
    /**
     * To find mouse x, y for aligned bullet chart element svg position
     */
    BulletChart.prototype.setPointMouseXY = function (pageX, pageY) {
        var svgClientRect = getElement$1(this.svgObject.id).getBoundingClientRect();
        var elemntClientRect = this.element.getBoundingClientRect();
        this.mouseX = (pageX - elemntClientRect.left) - Math.max(svgClientRect.left - elemntClientRect.left, 0);
        this.mouseY = (pageY - elemntClientRect.top) - Math.max(svgClientRect.top - elemntClientRect.top, 0);
    };
    /**
     * Handles the mouse leave on the bullet chart.
     *
     * @private
     */
    BulletChart.prototype.bulletMouseLeave = function (e) {
        if (!this.isTouchEvent(e)) {
            var tooltipDiv = document.getElementById('.tooltipDiv' + this.element.id);
            if (tooltipDiv) {
                // tslint:disable-next-line:no-any
                if (this.isReact) {
                    this.clearTemplate();
                }
                remove(tooltipDiv);
            }
        }
    };
    /**
     * Handles the touch event.
     *
     * @returns {boolean} Touchh event.
     * @private
     */
    BulletChart.prototype.isTouchEvent = function (event) {
        if ((event.pointerType === 'touch') || (event.type.indexOf('touch') > -1)) {
            return true;
        }
        return false;
    };
    /**
     * Handles the mouse down on the bullet chart.
     *
     * @private
     */
    BulletChart.prototype.bulletMouseDown = function (e) {
        var pageX;
        var pageY;
        var touchArg;
        if (e.type === 'touchstart') {
            this.isTouch = true;
            touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            pageY = touchArg.changedTouches[0].clientY;
        }
        else {
            this.isTouch = e.pointerType === 'touch';
            pageX = e.clientX;
            pageY = e.clientY;
        }
        this.setPointMouseXY(pageX, pageY);
        if (this.isTouchEvent(e)) {
            // tslint:disable-next-line:no-any
            if (this.isReact) {
                this.clearTemplate();
            }
            var Element_1 = document.getElementById(('tooltipDiv' + this.element.id));
            if (Element_1) {
                remove(Element_1);
            }
            var targetId = e.target.id;
            // tslint:disable-next-line:no-string-literal
            var targetClass = e.target.className['baseVal'];
            if (this.bulletTooltipModule) {
                this.bulletTooltipModule._elementTooltip(e, targetClass, targetId, this.mouseX);
                this.bulletTooltipModule._displayTooltip(e, targetClass, targetId, this.mouseX, this.mouseY);
            }
        }
    };
    /**
     * Handles the mouse click on bullet chart.
     *
     * @returns {boolean} Mouse click of bullet chart.
     * @private
     */
    BulletChart.prototype.bulletChartOnMouseClick = function (e) {
        var element = e.target;
        this.trigger(bulletChartMouseClick, { target: element.id, x: this.mouseX, y: this.mouseY });
        this.notify('click', e);
        return false;
    };
    /**
     * Handles the print method for bullet chart control.
     */
    BulletChart.prototype.print = function (id) {
        new PrintUtils(this).print(id);
    };
    /**
     * Handles the export method for bullet chart control.
     *
     * @param {ExportType} type Type of the export.
     * @param {string} fileName File name for exporting.
     * @param {PdfPageOrientation} orientation Orientation of the export.
     * @param {Chart | AccumulationChart | RangeNavigator | BulletChart} controls To mention the exporting chart.
     * @param {number} width Width of the export.
     * @param {number} height Height of the export.
     */
    BulletChart.prototype.export = function (type, fileName, orientation, controls, width, height, isVertical) {
        controls = controls ? controls : [this];
        new ExportUtils(this).export(type, fileName, orientation, controls, width, height, isVertical);
    };
    /**
     * Called internally if any of the property value changed.
     *
     * @private
     */
    BulletChart.prototype.onPropertyChanged = function (newProp, oldProp) {
        var renderer = false;
        var refreshBounds = false;
        this.animateSeries = false;
        if (!this.delayRedraw) {
            for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
                var prop = _a[_i];
                switch (prop) {
                    case 'height':
                    case 'width':
                        this.createSvg(this);
                        refreshBounds = true;
                        break;
                    case 'subtitle':
                    case 'title':
                        refreshBounds = true;
                        break;
                    case 'tickPosition':
                        renderer = true;
                        break;
                    case 'labelPosition':
                        renderer = true;
                        break;
                    case 'titlePosition':
                        renderer = true;
                        break;
                    case 'minimum':
                    case 'maximum':
                    case 'interval':
                        refreshBounds = true;
                        break;
                    case 'majorTickLines':
                    case 'minorTickLines':
                    case 'type':
                    case 'ranges':
                    case 'valueFill':
                    case 'targetColor':
                        refreshBounds = true;
                        break;
                    case 'titleStyle':
                        if (newProp.titleStyle) {
                            refreshBounds = true;
                        }
                        else {
                            renderer = true;
                        }
                        break;
                    case 'subtitleStyle':
                        if (newProp.subtitleStyle && (newProp.subtitleStyle.size || newProp.subtitleStyle.textOverflow)) {
                            refreshBounds = true;
                        }
                        else {
                            renderer = true;
                        }
                        break;
                    case 'border':
                        renderer = true;
                        break;
                    case 'opposedPosition':
                        renderer = true;
                        break;
                    case 'dataSource':
                        this.bindData();
                        refreshBounds = true;
                        break;
                    case 'theme':
                        this.animateSeries = true;
                        break;
                    case 'enableRtl':
                    case 'locale':
                    case 'currencyCode':
                        _super.prototype.refresh.call(this);
                        break;
                }
            }
            if (!refreshBounds && renderer) {
                this.removeSvg();
                this.renderBulletElements();
                this.trigger('loaded', { bulletChart: this });
            }
            if (refreshBounds) {
                this.render();
                this.trigger('loaded', { bulletChart: this });
                this.redraw = false;
            }
        }
    };
    /**
     * To provide the array of modules needed for bullet chart rendering
     *
     * @private
     * @returns {ModuleDeclaration[]} requiredModules
     */
    BulletChart.prototype.requiredModules = function () {
        var modules = [];
        var rangeName;
        for (var i = 0; i < this.ranges.length; i++) {
            if (this.ranges[i].name !== null) {
                rangeName = true;
            }
        }
        this.isLegend = (this.legendSettings.visible && ((rangeName) || !!this.isLegend || this.targetField !== '' || this.valueField !== ''));
        if (this.tooltip.enable) {
            modules.push({
                member: 'BulletTooltip',
                args: [this]
            });
        }
        if (this.isLegend) {
            modules.push({
                member: 'BulletChartLegend',
                args: [this]
            });
        }
        return modules;
    };
    BulletChart.prototype.getModuleName = function () {
        return 'bulletChart';
    };
    /**
     * To destroy the widget
     *
     * @returns {void} Destroy method
     * @member of BulletChart
     */
    BulletChart.prototype.destroy = function () {
        this.unWireEvents();
        _super.prototype.destroy.call(this);
        this.removeSvg();
        this.svgObject = null;
        this.element.classList.remove('e-BulletChart');
        this.element.innerText = '';
    };
    __decorate$14([
        Property(null)
    ], BulletChart.prototype, "width", void 0);
    __decorate$14([
        Property(null)
    ], BulletChart.prototype, "height", void 0);
    __decorate$14([
        Property(null)
    ], BulletChart.prototype, "locale", void 0);
    __decorate$14([
        Complex({}, MajorTickLinesSettings)
    ], BulletChart.prototype, "majorTickLines", void 0);
    __decorate$14([
        Complex({}, MinorTickLinesSettings)
    ], BulletChart.prototype, "minorTickLines", void 0);
    __decorate$14([
        Property(null)
    ], BulletChart.prototype, "minimum", void 0);
    __decorate$14([
        Property(null)
    ], BulletChart.prototype, "maximum", void 0);
    __decorate$14([
        Property(null)
    ], BulletChart.prototype, "interval", void 0);
    __decorate$14([
        Property(4)
    ], BulletChart.prototype, "minorTicksPerInterval", void 0);
    __decorate$14([
        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, BulletLabelStyle)
    ], BulletChart.prototype, "labelStyle", void 0);
    __decorate$14([
        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, BulletLabelStyle)
    ], BulletChart.prototype, "categoryLabelStyle", void 0);
    __decorate$14([
        Property('')
    ], BulletChart.prototype, "labelFormat", void 0);
    __decorate$14([
        Property('')
    ], BulletChart.prototype, "title", void 0);
    __decorate$14([
        Complex({ fontFamily: null, size: "14px", fontStyle: 'Normal', fontWeight: '500', color: null }, BulletLabelStyle)
    ], BulletChart.prototype, "titleStyle", void 0);
    __decorate$14([
        Property('')
    ], BulletChart.prototype, "subtitle", void 0);
    __decorate$14([
        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, BulletLabelStyle)
    ], BulletChart.prototype, "subtitleStyle", void 0);
    __decorate$14([
        Property('Horizontal')
    ], BulletChart.prototype, "orientation", void 0);
    __decorate$14([
        Complex({ color: '#DDDDDD', width: 0 }, Border)
    ], BulletChart.prototype, "border", void 0);
    __decorate$14([
        Complex({}, BulletTooltipSettings)
    ], BulletChart.prototype, "tooltip", void 0);
    __decorate$14([
        Collection([{ end: null, opacity: 1, color: '' }, { end: null, opacity: 1, color: '' }, { end: null, opacity: 1, color: '' }], Range)
    ], BulletChart.prototype, "ranges", void 0);
    __decorate$14([
        Property('Outside')
    ], BulletChart.prototype, "labelPosition", void 0);
    __decorate$14([
        Property('Outside')
    ], BulletChart.prototype, "tickPosition", void 0);
    __decorate$14([
        Property('Top')
    ], BulletChart.prototype, "titlePosition", void 0);
    __decorate$14([
        Property(false)
    ], BulletChart.prototype, "opposedPosition", void 0);
    __decorate$14([
        Property('Material')
    ], BulletChart.prototype, "theme", void 0);
    __decorate$14([
        Complex({}, Animation$1)
    ], BulletChart.prototype, "animation", void 0);
    __decorate$14([
        Complex({}, BulletDataLabel)
    ], BulletChart.prototype, "dataLabel", void 0);
    __decorate$14([
        Complex({}, BulletChartLegendSettings)
    ], BulletChart.prototype, "legendSettings", void 0);
    __decorate$14([
        Property(false)
    ], BulletChart.prototype, "enableGroupSeparator", void 0);
    __decorate$14([
        Complex({ top: 15, bottom: 10, left: 15, right: 15 }, Margin)
    ], BulletChart.prototype, "margin", void 0);
    __decorate$14([
        Property(5)
    ], BulletChart.prototype, "targetWidth", void 0);
    __decorate$14([
        Property('#191919')
    ], BulletChart.prototype, "targetColor", void 0);
    __decorate$14([
        Property(6)
    ], BulletChart.prototype, "valueHeight", void 0);
    __decorate$14([
        Property(null)
    ], BulletChart.prototype, "valueFill", void 0);
    __decorate$14([
        Complex({ color: 'transparent', width: 0 }, Border)
    ], BulletChart.prototype, "valueBorder", void 0);
    __decorate$14([
        Property(null)
    ], BulletChart.prototype, "dataSource", void 0);
    __decorate$14([
        Property(null)
    ], BulletChart.prototype, "query", void 0);
    __decorate$14([
        Property(null)
    ], BulletChart.prototype, "categoryField", void 0);
    __decorate$14([
        Property('Rect')
    ], BulletChart.prototype, "type", void 0);
    __decorate$14([
        Property('')
    ], BulletChart.prototype, "valueField", void 0);
    __decorate$14([
        Property('')
    ], BulletChart.prototype, "targetField", void 0);
    __decorate$14([
        Property(['Rect', 'Cross', 'Circle'])
    ], BulletChart.prototype, "targetTypes", void 0);
    __decorate$14([
        Property(0)
    ], BulletChart.prototype, "tabIndex", void 0);
    __decorate$14([
        Event()
    ], BulletChart.prototype, "tooltipRender", void 0);
    __decorate$14([
        Event()
    ], BulletChart.prototype, "load", void 0);
    __decorate$14([
        Event()
    ], BulletChart.prototype, "loaded", void 0);
    __decorate$14([
        Event()
    ], BulletChart.prototype, "bulletChartMouseClick", void 0);
    __decorate$14([
        Event()
    ], BulletChart.prototype, "legendRender", void 0);
    __decorate$14([
        Event()
    ], BulletChart.prototype, "beforePrint", void 0);
    BulletChart = __decorate$14([
        NotifyPropertyChanges
    ], BulletChart);
    return BulletChart;
}(Component));

/**
 * `BulletTooltip` module is used to render the tooltip for bullet chart.
 */
var BulletTooltip = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for tooltip module.
     *
     * @private
     */
    function BulletTooltip(bullet) {
        this.control = bullet;
        this.elementId = bullet.element.id;
        this.bulletAxis = new BulletChartAxis(this.control);
    }
    /**
     * To create tooltip div element.
     */
    BulletTooltip.prototype._elementTooltip = function (e, targetClass, targetId, mouseX) {
        var tooltipDiv = this.control.createElement('div');
        tooltipDiv.id = 'tooltip';
        tooltipDiv.className = 'tooltipDiv';
        var target = e.target;
        var pageX = mouseX + 20;
        var pageY = e.clientY;
        var str = '';
        var font = this.control.tooltip.textStyle.fontStyle ? this.control.tooltip.textStyle.fontStyle :
            this.control.themeStyle.tooltipLabelFont.fontStyle;
        var fill = this.control.tooltip.fill ? this.control.tooltip.fill : this.control.themeStyle.tooltipFill;
        var color = this.control.themeStyle.tooltipLabelFont.color || this.control.themeStyle.tooltipBoldLabel;
        var style = 'left:' + pageX + 'px;' + 'top:' + pageY + 'px;' +
            'display: block; position: absolute; "z-index": "13000",cursor: default;' +
            'font-family: Segoe UI;' + 'color:' + color + '; font-size: 13px; background-color:' +
            fill + '; border: 1px solid #707070;' + 'font-style:' + font + ';';
        // adding css prop to the div
        tooltipDiv.style.cssText = style;
        if (targetClass === this.control.svgObject.id + '_Caption') {
            str = target.textContent === this.control.title ? '' : this.control.title;
        }
        else if (targetClass === this.control.svgObject.id + '_SubTitle') {
            str = target.textContent === this.control.subtitle ? '' : this.control.subtitle;
        }
        if (str !== '') {
            tooltipDiv.innerHTML = '&nbsp' + str + '&nbsp';
            document.body.insertAdjacentElement('afterbegin', tooltipDiv);
        }
    };
    /**
     * To display the bullet chart tooltip.
     */
    // tslint:disable-next-line:max-func-body-length
    BulletTooltip.prototype._displayTooltip = function (e, targetClass, targetId, mouseX, mouseY) {
        if (targetClass !== 'undefined' && this.control.tooltip.enable && (targetClass === this.control.svgObject.id + '_FeatureMeasure' ||
            targetClass === this.control.svgObject.id + '_ComparativeMeasure')) {
            var data = void 0;
            var tooltipData = void 0;
            var measureId = void 0;
            var currentVal = void 0;
            var targetVal = [];
            var categoryVal = void 0;
            var tooltipdiv = void 0;
            var format = this.bulletAxis.getFormat(this.control);
            var isCustomFormat = format.match('{value}') !== null;
            measureId = targetId.substring(targetId.lastIndexOf('_') + 1);
            var targetValues = [];
            this.bulletAxis.format = this.bulletAxis.bulletChart.intl.getNumberFormat({
                format: isCustomFormat ? '' : format, useGrouping: this.bulletAxis.bulletChart.enableGroupSeparator
            });
            currentVal = this.control.dataSource[measureId][this.control.valueField];
            targetVal = targetVal.concat(this.control.dataSource[measureId][this.control.targetField]);
            categoryVal = this.control.dataSource[measureId][this.control.categoryField];
            var labelCurrentText = currentVal ? (currentVal).toString() : '';
            var labelTargetText = targetVal ? (targetVal).toString() : '';
            var labelCategoryText = categoryVal ? (categoryVal).toString() : '';
            labelCurrentText = this.bulletAxis.formatValue(this.bulletAxis, isCustomFormat, format, +currentVal);
            for (var i = 0; i < targetVal.length; i++) {
                targetValues = targetValues.concat(this.bulletAxis.formatValue(this.bulletAxis, isCustomFormat, format, +targetVal[i]));
            }
            labelCategoryText = this.bulletAxis.formatValue(this.bulletAxis, isCustomFormat, format, +categoryVal);
            data = { value: labelCurrentText, target: targetValues, category: labelCategoryText };
            tooltipData = { value: labelCurrentText, target: labelTargetText, category: labelCategoryText };
            var style = 'position: absolute; z-index: 13000; display: block;';
            if (document.getElementsByClassName('tooltipDiv' + this.control.element.id).length === 0) {
                tooltipdiv = this.control.createElement('div');
                tooltipdiv.id = 'tooltipDiv' + this.control.element.id;
                tooltipdiv.style.cssText = style;
                document.getElementById(this.control.element.id + '_Secondary_Element').appendChild(tooltipdiv);
            }
            var argsData = {
                value: data.value, target: data.target, name: tooltipRender
            };
            if (this.control.tooltip.template !== '' && this.control.tooltip.template != null) {
                this.updateTemplateFn();
                var elem = this.control.createElement('div', { id: this.control.element.id + 'parent_template' });
                var templateElement = this.templateFn(tooltipData, this.control, 'template', elem.id + '_blazorTemplate', '', null, elem);
                while (templateElement && templateElement.length > 0) {
                    if (templateElement.length === 1) {
                        elem.appendChild(templateElement[0]);
                        templateElement = null;
                    }
                    else {
                        elem.appendChild(templateElement[0]);
                    }
                }
                argsData.template = elem.innerHTML;
                this.control.trigger(tooltipRender, argsData);
                elem.innerHTML = argsData.template;
                tooltipdiv.appendChild(elem);
            }
            else {
                var argsText = 'Value : ' + argsData.value;
                for (var i = 0; i < argsData.target.length; i++) {
                    argsText += '<br/> Target' + (i === 0 ? '' : '_' + i) + ' : ' + argsData.target[i];
                }
                argsData.text = argsText;
                this.control.trigger(tooltipRender, argsData);
                tooltipdiv.innerHTML = argsData.text;
                tooltipdiv.style.font = this.control.tooltip.textStyle.fontStyle ? this.control.tooltip.textStyle.fontStyle :
                    this.control.themeStyle.tooltipLabelFont.fontStyle;
                tooltipdiv.style.color = this.control.themeStyle.tooltipLabelFont.color || this.control.themeStyle.tooltipBoldLabel;
                tooltipdiv.style.fontSize = this.control.themeStyle.titleFont.size;
            }
            var fill = this.control.tooltip.fill ? this.control.tooltip.fill : this.control.themeStyle.tooltipFill;
            var borderWidth = ((this.control.theme === 'Fabric' || this.control.theme === 'Fluent' && !this.control.tooltip.border.width) ? 1 : this.control.tooltip.border.width);
            var borderColor = ((this.control.theme === 'Fabric' || this.control.theme === 'Fluent' && !this.control.tooltip.border.color) ? '#D2D0CE' : this.control.tooltip.border.color);
            var xPos = mouseX;
            var yPos = mouseY;
            xPos = ((xPos + stringToNumber(tooltipdiv.getAttribute('width'), this.control.containerWidth) < window.innerWidth) ?
                (xPos) : stringToNumber(tooltipdiv.getAttribute('width'), this.control.containerWidth));
            yPos = ((yPos + stringToNumber(tooltipdiv.getAttribute('height'), this.control.containerHeight) < window.innerHeight) ?
                (yPos) : stringToNumber(tooltipdiv.getAttribute('height'), this.control.containerHeight));
            if (xPos === undefined || xPos === null) {
                xPos = mouseX;
            }
            if ((xPos + tooltipdiv.clientWidth) > this.control.availableSize.width) {
                xPos -= tooltipdiv.clientWidth + 20;
            }
            if (yPos === undefined || yPos === null) {
                yPos = e.clientY;
            }
            if (yPos + tooltipdiv.clientHeight > this.control.availableSize.height) {
                yPos -= tooltipdiv.clientHeight + 20;
            }
            if (this.control.tooltip.template !== '' && this.control.tooltip.template != null) {
                tooltipdiv.style.cssText = 'position: absolute;left:' + (xPos + 20) + 'px;' + 'top:' + (yPos + 20) + 'px;';
            }
            else {
                var fontFamily = this.control.tooltip.textStyle.fontFamily || this.control.themeStyle.tooltipLabelFont.fontFamily;
                var color = this.control.tooltip.textStyle.color || this.control.themeStyle.tooltipLabelFont.color;
                var divStyle = style + 'left:' + (xPos + 20) + 'px;' + 'top:' + (yPos + 20) + 'px;' +
                    '-webkit-border-radius: 5px 5px 5px 5px; -moz-border-radius: 5px 5px 5px 5px;-o-border-radius: 5px 5px 5px 5px;' +
                    'border-radius: 5px 5px 5px 5px;' + 'background-color:' + fill + ';' + 'color:' +
                    color + '; border:' + borderWidth + 'px Solid' + ' ' + borderColor + ';' +
                    'padding-bottom: 7px;' + 'font-style:' + this.control.themeStyle.tooltipLabelFont.fontStyle +
                    '; padding-left: 10px; font-family:' + fontFamily + '; font-size:' + this.control.tooltip.textStyle.size + '; padding-right: 10px; padding-top: 7px';
                tooltipdiv.style.cssText = divStyle;
                if ((targetClass === this.control.svgObject.id + '_FeatureMeasure') ||
                    (targetClass === this.control.svgObject.id + '_ComparativeMeasure')) {
                    document.getElementById(targetId).setAttribute('opacity', '0.6');
                }
            }
            // tslint:disable-next-line:no-any
            if (this.control.isReact) {
                this.control.renderReactTemplates();
            }
        }
    };
    /**
     * To update template values in the tooltip.
     */
    BulletTooltip.prototype.updateTemplateFn = function () {
        if (this.control.tooltip.template) {
            try {
                if (typeof this.control.tooltip.template !== 'function' &&
                    document.querySelectorAll(this.control.tooltip.template).length) {
                    this.templateFn = compile(document.querySelector(this.control.tooltip.template).innerHTML.trim());
                }
                else {
                    this.templateFn = compile(this.control.tooltip.template);
                }
            }
            catch (e) {
                this.templateFn = compile(this.control.tooltip.template);
            }
        }
    };
    /**
     * Get module name.
     */
    BulletTooltip.prototype.getModuleName = function () {
        return 'BulletTooltip';
    };
    /**
     * To destroy the tooltip.
     *
     * @returns {void}
     * @private
     */
    BulletTooltip.prototype.destroy = function () {
        // Destroy method called here
    };
    return BulletTooltip;
}());

var __extends$86 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * Chart legend
 */
/**
 * `Legend` module is used to render legend for the chart.
 */
var BulletChartLegend = /** @__PURE__ @class */ (function (_super) {
    __extends$86(BulletChartLegend, _super);
    function BulletChartLegend(chart) {
        var _this = _super.call(this, chart) || this;
        _this.library = _this;
        _this.addEventListener();
        return _this;
    }
    /**
     * Binding events for legend module.
     */
    BulletChartLegend.prototype.addEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.on('click', this.click, this);
        this.chart.on(Browser.touchEndEvent, this.mouseEnd, this);
        this.chart.on(Browser.touchMoveEvent, this.bulletMouseMove, this);
    };
    /**
     * UnBinding events for bullet chart legend module.
     */
    BulletChartLegend.prototype.removeEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.off('click', this.click);
        this.chart.off(Browser.touchEndEvent, this.mouseEnd);
        this.chart.off(Browser.touchMoveEvent, this.bulletMouseMove);
    };
    /**
     * To handle mosue move for legend module
     */
    BulletChartLegend.prototype.bulletMouseMove = function (e) {
        if (this.chart.legendSettings.visible && this.chart.isTouch) {
            this.move(e);
        }
    };
    /**
     * To handle mosue end for legend module
     */
    BulletChartLegend.prototype.mouseEnd = function (e) {
        if (this.chart.legendSettings.visible && this.chart.isTouch) {
            this.move(e);
        }
    };
    /**
     * Get the legend options.
     *
     * @returns {void}
     * @private
     */
    BulletChartLegend.prototype.getLegendOptions = function (visibleRangeCollection) {
        this.legendCollections = [];
        var fill;
        var count = 0;
        var key = 'color';
        var bulletChart = this.chart;
        for (var _i = 0, visibleRangeCollection_1 = visibleRangeCollection; _i < visibleRangeCollection_1.length; _i++) {
            var range = visibleRangeCollection_1[_i];
            if (range.name !== null) {
                fill = range.color ? range.color : bulletChart.themeStyle.rangeStrokes[range.index][key];
                this.legendCollections.push(new LegendOptions(range.name, fill, range.shape, this.chart.legendSettings.visible, null, range.legendImageUrl, null, false, range.index, null));
                count++;
            }
        }
        if (bulletChart.dataSource !== null && bulletChart.valueField !== '') {
            fill = (bulletChart.theme.indexOf('Dark') > -1) ? 'white' : bulletChart.valueFill ? bulletChart.valueFill : 'black';
            var shape = bulletChart.orientation === 'Vertical' ? 'TargetRect' : 'ActualRect';
            this.legendCollections.push(new LegendOptions('Actual', fill, shape, this.chart.legendSettings.visible, null, '', null, false, count++, null));
        }
        if (bulletChart.dataSource !== null && bulletChart.targetField !== '') {
            fill = (bulletChart.theme.indexOf('Dark') > -1) ? 'white' : bulletChart.targetColor ? bulletChart.targetColor : 'black';
            var shape = bulletChart.orientation === 'Vertical' ? 'ActualRect' : 'TargetRect';
            for (var i = 0; i < Object.keys(bulletChart.dataSource).length; i++) {
                if (isNullOrUndefined(bulletChart.dataSource[i][bulletChart.targetField].length)
                    || bulletChart.dataSource[i][bulletChart.targetField].length === 1) {
                    while (i === 0) {
                        this.legendCollections.push(new LegendOptions('Target', fill, shape, this.chart.legendSettings.visible, null, '', null, false, count++, null));
                        break;
                    }
                }
                else {
                    var targetTypes = bulletChart.targetTypes;
                    var targetType = [];
                    var targetTypeLength = targetTypes.length;
                    while (i === 0) {
                        for (var i_1 = 0; i_1 < targetTypeLength; i_1++) {
                            targetType[i_1] = targetTypes[i_1 % targetTypeLength];
                            targetType[i_1] = (targetType[i_1] === 'Rect') ? bulletChart.orientation === 'Vertical' ?
                                'ActualRect' : 'TargetRect' : (targetType[i_1]);
                            targetType[i_1] = (targetType[i_1] === 'Cross') ? 'Multiply' : targetType[i_1];
                            this.legendCollections.push(new LegendOptions('Target_' + i_1, fill, targetType[i_1], this.chart.legendSettings.visible, null, '', null, false, count++, null));
                        }
                        break;
                    }
                }
            }
        }
    };
    /** @private */
    BulletChartLegend.prototype.getLegendBounds = function (availableSize, bulletLegendBounds, legend) {
        var extraWidth = 0;
        var padding = legend.padding;
        var extraHeight = 0;
        if (!this.isVertical) {
            extraHeight = !legend.height ? ((availableSize.height / 100) * 5) : 0;
        }
        else {
            extraWidth = !legend.width ? ((availableSize.width / 100) * 5) : 0;
        }
        bulletLegendBounds.height += extraHeight;
        bulletLegendBounds.width += extraWidth;
        var maximumWidth = 0;
        var legendRowWidth = 0;
        var legendRowCount = 0;
        var legendWidth = 0;
        var columnHeight = 0;
        var shapeWidth = legend.shapeWidth;
        var shapePadding = legend.shapePadding;
        var legendEventArgs;
        this.maxItemHeight = Math.max(measureText('MeasureText', legend.textStyle, this.chart.themeStyle.legendLabelFont).height, legend.shapeHeight);
        var render = false;
        for (var _i = 0, _a = this.legendCollections; _i < _a.length; _i++) {
            var bulletLegendOption = _a[_i];
            legendEventArgs = {
                fill: bulletLegendOption.fill, text: bulletLegendOption.text, shape: bulletLegendOption.shape,
                name: legendRender, cancel: false
            };
            this.chart.trigger(legendRender, legendEventArgs);
            bulletLegendOption.render = !legendEventArgs.cancel;
            bulletLegendOption.text = legendEventArgs.text;
            bulletLegendOption.fill = legendEventArgs.fill;
            bulletLegendOption.shape = legendEventArgs.shape;
            bulletLegendOption.textSize = measureText(bulletLegendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont);
            if (bulletLegendOption.render && bulletLegendOption.text !== '') {
                render = true;
                legendWidth = shapeWidth + shapePadding + bulletLegendOption.textSize.width + padding;
                legendRowWidth = legendRowWidth + legendWidth;
                if (bulletLegendBounds.width < (padding + legendRowWidth) || this.isVertical) {
                    maximumWidth = Math.max(maximumWidth, (legendRowWidth + padding - (this.isVertical ? 0 : legendWidth)));
                    if (legendRowCount === 0 && (legendWidth !== legendRowWidth)) {
                        legendRowCount = 1;
                    }
                    legendRowWidth = this.isVertical ? 0 : legendWidth;
                    legendRowCount++;
                    columnHeight = (legendRowCount * (this.maxItemHeight + padding)) + padding;
                }
            }
        }
        columnHeight = Math.max(columnHeight, (this.maxItemHeight + padding) + padding);
        this.isPaging = bulletLegendBounds.height < columnHeight;
        this.totalPages = legendRowCount;
        if (render) {
            this.setBounds(Math.max((legendRowWidth + padding), maximumWidth), columnHeight, legend, bulletLegendBounds);
        }
        else {
            this.setBounds(0, 0, legend, bulletLegendBounds);
        }
    };
    /** @private */
    BulletChartLegend.prototype.getRenderPoint = function (bulletLegendOption, start, textPadding, prevLegend, rect, count, firstLegend) {
        var previousBound = (prevLegend.location.x + textPadding + prevLegend.textSize.width);
        var padding = this.legend.padding;
        if ((previousBound + (bulletLegendOption.textSize.width + textPadding)) > (rect.x + rect.width + this.legend.shapeWidth / 2) ||
            this.isVertical) {
            bulletLegendOption.location.x = start.x;
            bulletLegendOption.location.y = (count === firstLegend) ? prevLegend.location.y :
                prevLegend.location.y + this.maxItemHeight + padding;
        }
        else {
            bulletLegendOption.location.x = (count === firstLegend) ? prevLegend.location.x : previousBound;
            bulletLegendOption.location.y = prevLegend.location.y;
        }
        var availwidth = (this.legendBounds.x + this.legendBounds.width) - (bulletLegendOption.location.x +
            textPadding - this.legend.shapeWidth / 2);
        bulletLegendOption.text = textTrim(+availwidth.toFixed(4), bulletLegendOption.text, this.legend.textStyle, this.chart.enableRtl, this.chart.themeStyle.legendLabelFont);
    };
    /**
     * To show the tooltip for the trimmed text in legend.
     *
     * @returns {void}
     */
    BulletChartLegend.prototype.click = function (event) {
        var symbolTargetId = event.target.id;
        if (symbolTargetId.indexOf(this.legendID + '_pagedown') > -1) {
            this.changePage(event, false);
        }
        else if (symbolTargetId.indexOf(this.legendID + '_pageup') > -1) {
            this.changePage(event, true);
        }
    };
    /**
     * Get module name
     */
    BulletChartLegend.prototype.getModuleName = function () {
        return 'BulletChartLegend';
    };
    /**
     * To destroy the Legend.
     *
     * @returns {void}
     * @private
     */
    BulletChartLegend.prototype.destroy = function () {
        /**
         * Destroy method calling here
         */
        this.removeEventListener();
    };
    return BulletChartLegend;
}(BaseLegend));

/**
 * Bullet Chart component export methods
 */

var __extends$89 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$17 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SmithchartFont = /** @__PURE__ @class */ (function (_super) {
    __extends$89(SmithchartFont, _super);
    function SmithchartFont() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$17([
        Property('Segoe UI')
    ], SmithchartFont.prototype, "fontFamily", void 0);
    __decorate$17([
        Property('Normal')
    ], SmithchartFont.prototype, "fontStyle", void 0);
    __decorate$17([
        Property('Regular')
    ], SmithchartFont.prototype, "fontWeight", void 0);
    __decorate$17([
        Property('')
    ], SmithchartFont.prototype, "color", void 0);
    __decorate$17([
        Property('12px')
    ], SmithchartFont.prototype, "size", void 0);
    __decorate$17([
        Property(1)
    ], SmithchartFont.prototype, "opacity", void 0);
    return SmithchartFont;
}(ChildProperty));
var SmithchartMargin = /** @__PURE__ @class */ (function (_super) {
    __extends$89(SmithchartMargin, _super);
    function SmithchartMargin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$17([
        Property(Browser.isDevice ? 5 : 10)
    ], SmithchartMargin.prototype, "top", void 0);
    __decorate$17([
        Property(Browser.isDevice ? 5 : 10)
    ], SmithchartMargin.prototype, "bottom", void 0);
    __decorate$17([
        Property(Browser.isDevice ? 5 : 10)
    ], SmithchartMargin.prototype, "right", void 0);
    __decorate$17([
        Property(Browser.isDevice ? 5 : 10)
    ], SmithchartMargin.prototype, "left", void 0);
    return SmithchartMargin;
}(ChildProperty));
var SmithchartBorder = /** @__PURE__ @class */ (function (_super) {
    __extends$89(SmithchartBorder, _super);
    function SmithchartBorder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$17([
        Property(0)
    ], SmithchartBorder.prototype, "width", void 0);
    __decorate$17([
        Property(1)
    ], SmithchartBorder.prototype, "opacity", void 0);
    __decorate$17([
        Property('transparent')
    ], SmithchartBorder.prototype, "color", void 0);
    return SmithchartBorder;
}(ChildProperty));
/**
 * Internal use of type rect
 */
var SmithchartRect = /** @__PURE__ @class */ (function () {
    function SmithchartRect(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    return SmithchartRect;
}());
var LabelCollection = /** @__PURE__ @class */ (function () {
    function LabelCollection() {
    }
    return LabelCollection;
}());
var LegendSeries = /** @__PURE__ @class */ (function () {
    function LegendSeries() {
    }
    return LegendSeries;
}());
var LabelRegion = /** @__PURE__ @class */ (function () {
    function LabelRegion() {
    }
    return LabelRegion;
}());
var HorizontalLabelCollection = /** @__PURE__ @class */ (function (_super) {
    __extends$89(HorizontalLabelCollection, _super);
    function HorizontalLabelCollection() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return HorizontalLabelCollection;
}(LabelCollection));
var RadialLabelCollections = /** @__PURE__ @class */ (function (_super) {
    __extends$89(RadialLabelCollections, _super);
    function RadialLabelCollections() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return RadialLabelCollections;
}(HorizontalLabelCollection));
var LineSegment = /** @__PURE__ @class */ (function () {
    function LineSegment() {
    }
    return LineSegment;
}());
var PointRegion = /** @__PURE__ @class */ (function () {
    function PointRegion() {
    }
    return PointRegion;
}());
/**
 * Smithchart internal class for point
 */
var Point = /** @__PURE__ @class */ (function () {
    function Point() {
    }
    return Point;
}());
var ClosestPoint = /** @__PURE__ @class */ (function () {
    function ClosestPoint() {
    }
    return ClosestPoint;
}());
var MarkerOptions = /** @__PURE__ @class */ (function () {
    function MarkerOptions(id, fill, borderColor, borderWidth, opacity) {
        this.id = id;
        this.fill = fill;
        this.borderColor = borderColor;
        this.borderWidth = borderWidth;
        this.opacity = opacity;
    }
    return MarkerOptions;
}());
var SmithchartLabelPosition = /** @__PURE__ @class */ (function () {
    function SmithchartLabelPosition() {
    }
    return SmithchartLabelPosition;
}());
var Direction = /** @__PURE__ @class */ (function () {
    function Direction() {
        this.counterclockwise = 0;
        this.clockwise = 1;
    }
    return Direction;
}());
var DataLabelTextOptions = /** @__PURE__ @class */ (function () {
    function DataLabelTextOptions() {
    }
    return DataLabelTextOptions;
}());
var LabelOption = /** @__PURE__ @class */ (function () {
    function LabelOption() {
    }
    return LabelOption;
}());
/** @private */
var SmithchartSize = /** @__PURE__ @class */ (function () {
    function SmithchartSize(width, height) {
        this.width = width;
        this.height = height;
    }
    return SmithchartSize;
}());
var GridArcPoints = /** @__PURE__ @class */ (function () {
    function GridArcPoints() {
    }
    return GridArcPoints;
}());

var __extends$88 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable @typescript-eslint/ban-types */
/**
 * To create the svg element.
 *
 * @param {Smithchart} smithchart smithchart instance
 * @returns {void}
 */
function createSvg$1(smithchart) {
    smithchart.renderer = new SvgRenderer(smithchart.element.id);
    calculateSize$1(smithchart);
    smithchart.svgObject = smithchart.renderer.createSvg({
        id: smithchart.element.id + '_svg',
        width: smithchart.availableSize.width,
        height: smithchart.availableSize.height
    });
}
/**
 * To get the html element from DOM.
 *
 * @param {string} id id of the html element
 * @returns {Element} html element.
 */
function getElement$2(id) {
    return document.getElementById(id);
}
/**
 * To trim the text by given width.
 *
 * @param {number} maximumWidth max width of the text
 * @param {string} text text
 * @param {SmithchartFontModel} font text style
 * @returns {string} It returns trimmed text
 */
function textTrim$1(maximumWidth, text, font, themeFontStyle) {
    var label = text;
    var size = measureText$1(text, font, themeFontStyle).width;
    if (size > maximumWidth) {
        var textLength = text.length;
        for (var i = textLength - 1; i >= 0; --i) {
            label = text.substring(0, i) + '...';
            size = measureText$1(label, font, themeFontStyle).width;
            if (size <= maximumWidth || label.length < 4) {
                if (label.length < 4) {
                    label = ' ';
                }
                return label;
            }
        }
    }
    return label;
}
/**
 * Function to compile the template function for maps.
 *
 * @param {string | Function} templateString template with string format
 * @returns {Function} return template function
 * @private
 */
function getTemplateFunction$1(templateString) {
    var templateFn = null;
    try {
        if (typeof templateString !== 'function' && document.querySelectorAll(templateString).length) {
            templateFn = compile(document.querySelector(templateString).innerHTML.trim());
        }
        else {
            templateFn = compile(templateString);
        }
    }
    catch (e) {
        templateFn = compile(templateString);
    }
    return templateFn;
}
/**
 * Get element from label
 *
 * @param {Element} element element
 * @param {string} labelId label id
 * @param {object} data chart data
 * @returns {HTMLElement} html element
 */
function convertElementFromLabel(element, labelId, data) {
    var labelEle = element[0];
    var templateHtml = labelEle.outerHTML;
    var properties = Object.keys(data);
    for (var i = 0; i < properties.length; i++) {
        // eslint-disable-next-line security/detect-non-literal-regexp
        templateHtml = templateHtml.replace(new RegExp('{{:' + properties[i] + '}}', 'g'), data[properties[i].toString()]);
    }
    var templateElement = createElement('div', {
        id: labelId,
        styles: 'position: absolute'
    });
    templateElement.innerText = templateHtml;
    return templateElement;
}
/**
 * Get epsilon value
 *
 * @returns {number} return epsilon value
 */
function _getEpsilonValue() {
    var e = 1.0;
    while ((1.0 + 0.5 * e) !== 1.0) {
        e *= 0.5;
    }
    return e;
}
/**
 * Method to calculate the width and height of the smithchart
 *
 * @param {Smithchart} smithchart smithchart instance
 * @returns {void}
 */
function calculateSize$1(smithchart) {
    var containerWidth = smithchart.element.clientWidth;
    var containerHeight = smithchart.element.clientHeight;
    smithchart.availableSize = new SmithchartSize(stringToNumber$1(smithchart.width, containerWidth) || containerWidth || 600, stringToNumber$1(smithchart.height, containerHeight) || containerHeight || 450);
}
/**
 * Method for template animation
 *
 * @param {Smithchart} smithchart smithchart
 * @param {Element} element html element
 * @param {number} delay animation delay
 * @param {number} duration animation duration
 * @param {Effect} name animation name
 * @returns {void}
 */
function templateAnimate$1(smithchart, element, delay, duration, name) {
    var opacity = 0;
    var delta;
    var value;
    new Animation({}).animate(element, {
        duration: duration,
        delay: delay,
        name: name,
        progress: function (args) {
            delta = ((args.timeStamp - args.delay) / args.duration);
            value = opacity + (delta * 1);
            args.element.style.opacity = value.toString();
        },
        end: function (args) {
            var opacity = 1;
            args.element.style.opacity = opacity.toString();
            smithchart.trigger('animationComplete', event);
        }
    });
}
/**
 * Convert string to number
 *
 * @param {string} value string type value
 * @param {number} containerSize size of the container
 * @returns {number} returns converted number
 */
function stringToNumber$1(value, containerSize) {
    if (value !== null && value !== undefined) {
        return value.indexOf('%') !== -1 ? (containerSize / 100) * parseInt(value, 10) : parseInt(value, 10);
    }
    return null;
}
/**
 * Internal use of path options
 *
 * @private
 */
var PathOption$1 = /** @__PURE__ @class */ (function () {
    function PathOption$$1(id, fill, width, color, opacity, dashArray, d) {
        this.id = id;
        this.opacity = opacity;
        this.fill = fill;
        this.stroke = color;
        this['stroke-width'] = width;
        this['stroke-dasharray'] = dashArray;
        this.d = d;
    }
    return PathOption$$1;
}());
/**
 * Internal use of rectangle options
 *
 * @private
 */
var RectOption$1 = /** @__PURE__ @class */ (function (_super) {
    __extends$88(RectOption, _super);
    function RectOption(id, fill, border, opacity, rect) {
        var _this = _super.call(this, id, fill, border.width, border.color, opacity) || this;
        _this.y = rect.y;
        _this.x = rect.x;
        _this.height = rect.height;
        _this.width = rect.width;
        return _this;
    }
    return RectOption;
}(PathOption$1));
/**
 * Internal use of circle options
 *
 * @private
 */
var CircleOption$1 = /** @__PURE__ @class */ (function (_super) {
    __extends$88(CircleOption, _super);
    function CircleOption(id, fill, border, opacity, cx, cy, r, dashArray) {
        var _this = _super.call(this, id, fill, border.width, border.color, opacity) || this;
        _this.cy = cy;
        _this.cx = cx;
        _this.r = r;
        _this['stroke-dasharray'] = dashArray;
        return _this;
    }
    return CircleOption;
}(PathOption$1));
/**
 * Method for calculate width and height of given string.
 *
 * @param {string} text text value
 * @param {SmithchartFontModel} font text font style
 * @returns {SmithchartSize} size of the text
 */
function measureText$1(text, font, themeFontStyle) {
    var htmlObject = document.getElementById('smithchartmeasuretext');
    if (htmlObject === null) {
        htmlObject = createElement('text', { id: 'smithchartmeasuretext' });
        document.body.appendChild(htmlObject);
    }
    htmlObject.innerText = text;
    htmlObject.style.position = 'absolute';
    htmlObject.style.visibility = 'hidden';
    htmlObject.style.left = '0';
    htmlObject.style.top = '-100';
    htmlObject.style.whiteSpace = 'nowrap';
    htmlObject.style.fontSize = font.size || themeFontStyle.size;
    htmlObject.style.fontWeight = font.fontWeight || themeFontStyle.fontWeight;
    htmlObject.style.fontStyle = font.fontStyle || themeFontStyle.fontStyle;
    htmlObject.style.fontFamily = font.fontFamily || themeFontStyle.fontFamily;
    // For bootstrap line height issue
    htmlObject.style.lineHeight = 'normal';
    return new SmithchartSize(htmlObject.clientWidth, htmlObject.clientHeight);
}
/**
 * Internal use of text options
 *
 * @private
 */
var TextOption$1 = /** @__PURE__ @class */ (function () {
    function TextOption$$1(id, x, y, anchor, text) {
        this.id = id;
        this.x = x;
        this.y = y;
        this.anchor = anchor;
        this.text = text;
    }
    return TextOption$$1;
}());
/**
 * Remove html element from DOM
 *
 * @param {string} id element id
 * @returns {void}
 */
function removeElement$2(id) {
    var element = document.getElementById(id);
    return element ? remove(element) : null;
}
/**
 * Animation Effect Calculation Started Here
 *
 * @param {number} currentTime current time
 * @param {number} startValue start value of the animation
 * @param {number} endValue end value of the animation
 * @param {number} duration animation duration
 * @returns {number} number
 * @private
 */
function linear$1(currentTime, startValue, endValue, duration) {
    return -endValue * Math.cos(currentTime / duration * (Math.PI / 2)) + endValue + startValue;
}
/**
 * Reverse linear calculation
 *
 * @param {number} currentTime current time
 * @param {number} startValue start value of the animation
 * @param {number} endValue end value of the animation
 * @param {number} duration animation duration
 * @returns {number} number
 */
function reverselinear(currentTime, startValue, endValue, duration) {
    return -startValue * Math.sin(currentTime / duration * (Math.PI / 2)) + endValue + startValue;
}
/**
 * Get animation function name
 *
 * @param {string} effect animation effect name
 * @returns {Function} animation function
 * @private
 */
function getAnimationFunction$1(effect) {
    var functionName;
    switch (effect) {
        case 'Linear':
            functionName = linear$1;
            break;
        case 'Reverse':
            functionName = reverselinear;
            break;
    }
    return functionName;
}
/**
 * Internal rendering of text
 *
 * @param {TextOption} options text element options
 * @param {SmithchartFontModel} font text font style
 * @param {string} color color of the text
 * @param {HTMLElement} parent parent element of the text
 * @returns {Element} text element
 * @private
 */
function renderTextElement(options, font, color, parent, themeFontStyle) {
    var renderOptions = {
        'id': options.id,
        'x': options.x,
        'y': options.y,
        'fill': color,
        'font-size': font.size || themeFontStyle.size,
        'font-style': font.fontStyle || themeFontStyle.fontStyle,
        'font-family': font.fontFamily || themeFontStyle.fontFamily,
        'font-weight': font.fontWeight || themeFontStyle.fontWeight,
        'text-anchor': options.anchor,
        'opacity': font.opacity
    };
    var text = options.text;
    var renderer = new SvgRenderer('');
    var htmlObject = renderer.createText(renderOptions, text);
    parent.appendChild(htmlObject);
    return htmlObject;
}

/**
 * @param {SmithchartTheme} theme theme of the smith chart
 * @private
 * @returns {string[]} series colors
 */
function getSeriesColor$1(theme) {
    var palette;
    switch (theme) {
        case 'Fabric':
            palette = ['#4472c4', '#ed7d31', '#ffc000', '#70ad47', '#5b9bd5',
                '#c1c1c1', '#6f6fe2', '#e269ae', '#9e480e', '#997300'];
            break;
        case 'Bootstrap4':
            palette = ['#a16ee5', '#f7ce69', '#55a5c2', '#7ddf1e', '#ff6ea6',
                '#7953ac', '#b99b4f', '#407c92', '#5ea716', '#b91c52'];
            break;
        case 'Bootstrap':
            palette = ['#a16ee5', '#f7ce69', '#55a5c2', '#7ddf1e', '#ff6ea6',
                '#7953ac', '#b99b4f', '#407c92', '#5ea716', '#b91c52'];
            break;
        case 'HighContrastLight':
        case 'HighContrast':
            palette = ['#79ECE4', '#E98272', '#DFE6B6', '#C6E773', '#BA98FF',
                '#FA83C3', '#00C27A', '#43ACEF', '#D681EF', '#D8BC6E'];
            break;
        case 'MaterialDark':
            palette = ['#9ECB08', '#56AEFF', '#C57AFF', '#61EAA9', '#EBBB3E',
                '#F45C5C', '#8A77FF', '#63C7FF', '#FF84B0', '#F7C928'];
            break;
        case 'FabricDark':
            palette = ['#4472c4', '#ed7d31', '#ffc000', '#70ad47', '#5b9bd5',
                '#c1c1c1', '#6f6fe2', '#e269ae', '#9e480e', '#997300'];
            break;
        case 'BootstrapDark':
            palette = ['#a16ee5', '#f7ce69', '#55a5c2', '#7ddf1e', '#ff6ea6',
                '#7953ac', '#b99b4f', '#407c92', '#5ea716', '#b91c52'];
            break;
        case 'Tailwind':
            palette = ['#5A61F6', '#65A30D', '#334155', '#14B8A6', '#8B5CF6',
                '#0369A1', '#F97316', '#9333EA', '#F59E0B', '#15803D'];
            break;
        case 'TailwindDark':
            palette = ['#8B5CF6', '#22D3EE', '#F87171', '#4ADE80', '#E879F9',
                '#FCD34D', '#F97316', '#2DD4BF', '#F472B6', '#10B981'];
            break;
        case 'Bootstrap5':
            palette = ['#262E0B', '#668E1F', '#AF6E10', '#862C0B', '#1F2D50',
                '#64680B', '#311508', '#4C4C81', '#0C7DA0', '#862C0B'];
            break;
        case 'Bootstrap5Dark':
            palette = ['#5ECB9B', '#A860F1', '#EBA844', '#557EF7', '#E9599B',
                '#BFC529', '#3BC6CF', '#7A68EC', '#74B706', '#EA6266'];
            break;
        case 'Fluent':
            palette = ['#1AC9E6', '#DA4CB2', '#EDBB40', '#AF4BCF', '#FF7266',
                '#1BD565', '#EE993D', '#5887FF', '#EC548D', '#7D39C0'];
            break;
        case 'FluentDark':
            palette = ['#1AC9E6', '#DA4CB2', '#EDBB40', '#AF4BCF', '#FF7266',
                '#1BD565', '#EE993D', '#5887FF', '#EC548D', '#7D39C0'];
            break;
        case 'Material3':
            palette = ['#6355C7', '#00AEE0', '#FFB400', '#F7523F', '#963C70',
                '#FD7400', '#4BE0BC', '#2196F5', '#DE3D8A', '#162F88'];
            break;
        case 'Material3Dark':
            palette = ['#4EAAFF', '#FA4EAB', '#FFF500', '#17EA58', '#38FFE7',
                '#FF9E45', '#B3F32F', '#B93CE4', '#FC5664', '#9B55FF'];
            break;
        default:
            palette = ['#00bdae', '#404041', '#357cd2', '#e56590', '#f8b883',
                '#70ad47', '#dd8abd', '#7f84e8', '#7bb4eb', '#ea7a57'];
            break;
    }
    return palette;
}
/**
 * @param {SmithchartTheme} theme smithchart theme
 * @private
 * @returns {ISmithchartThemeStyle} theme style of the smith chart
 */
// tslint:disable-next-line:max-func-body-length
function getThemeColor$1(theme) {
    var style;
    var darkBackground = theme === 'MaterialDark' ? '#383838' : (theme === 'FabricDark' ? '#242424' : '#1b1b1b');
    switch (theme) {
        case 'HighContrast':
            style = {
                axisLabel: '#ffffff',
                axisLine: '#ffffff',
                majorGridLine: '#BFBFBF',
                minorGridLine: '#969696',
                chartTitle: '#ffffff',
                legendLabel: '#ffffff',
                background: '#000000',
                areaBorder: '#ffffff',
                tooltipFill: '#ffffff',
                dataLabel: '#ffffff',
                tooltipBoldLabel: '#000000',
                tooltipLightLabel: '#000000',
                tooltipHeaderLine: '#969696',
                tooltipFontSize: '12px',
                smithchartTitleFont: {
                    color: '#FFFFFF', fontFamily: 'Segoe UI'
                },
                legendLabelFont: {
                    color: '#969696', fontFamily: 'Segoe UI'
                },
                legendTitleFont: {
                    color: '#FFFFFF', fontFamily: 'Roboto'
                },
                dataLabelFont: {
                    color: '#969696', fontFamily: 'Segoe UI'
                },
                axisLabelFont: {
                    color: '#969696', fontFamily: 'Segoe UI'
                },
                smithchartSubtitleFont: {
                    color: '#FFFFFF', fontFamily: 'Segoe UI'
                }
            };
            break;
        case 'MaterialDark':
        case 'BootstrapDark':
        case 'FabricDark':
            style = {
                axisLabel: '#DADADA',
                axisLine: ' #6F6C6C',
                majorGridLine: '#414040',
                minorGridLine: '#514F4F',
                chartTitle: '#ffffff',
                legendLabel: '#DADADA',
                background: darkBackground,
                areaBorder: ' #9A9A9A',
                tooltipFill: theme === 'MaterialDark' ? '#F4F4F4' : theme === 'BootstrapDark' ? '#F0F0F0' : '#A19F9D',
                dataLabel: '#DADADA',
                tooltipBoldLabel: theme === 'MaterialDark' ? 'rgba(18, 18, 18, 1)' : theme === 'BootstrapDark' ? '#1A1A1A' : '#DADADA',
                tooltipLightLabel: theme === 'MaterialDark' ? 'rgba(18, 18, 18, 1)' : theme === 'BootstrapDark' ? '#1A1A1A' : '#DADADA',
                tooltipHeaderLine: '#9A9A9A',
                tooltipFontSize: '12px',
                smithchartTitleFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.87)' : theme === 'BootstrapDark' ? '#FFFFFF' : '#DADADA', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'BootstrapDark' ? 'Helvetica' : 'Segoe UI'
                },
                legendLabelFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : theme === 'BootstrapDark' ? '#676767' : '#A19F9D', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'BootstrapDark' ? 'Helvetica' : 'Segoe UI'
                },
                legendTitleFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.87)' : theme === 'BootstrapDark' ? '#FFFFFF' : '#DADADA', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'BootstrapDark' ? 'Helvetica' : 'Segoe UI'
                },
                dataLabelFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : theme === 'BootstrapDark' ? '#676767' : '#A19F9D', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'BootstrapDark' ? 'Helvetica' : 'Segoe UI'
                },
                axisLabelFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : theme === 'BootstrapDark' ? '#CED4DA' : '#A19F9D', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'BootstrapDark' ? 'Helvetica' : 'Segoe UI'
                },
                smithchartSubtitleFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.87)' : theme === 'BootstrapDark' ? '#FFFFFF' : '#DADADA', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'BootstrapDark' ? 'Helvetica' : 'Segoe UI'
                }
            };
            break;
        case 'Bootstrap4':
            style = {
                axisLabel: '#212529',
                axisLine: '#ADB5BD',
                majorGridLine: '#CED4DA',
                minorGridLine: '#DEE2E6',
                chartTitle: '#212529',
                legendLabel: '#212529',
                background: '#FFFFFF',
                areaBorder: '#DEE2E6',
                tooltipFill: '#212529',
                dataLabel: '#212529',
                tooltipBoldLabel: '#F9FAFB',
                tooltipLightLabel: '#F9FAFB',
                tooltipHeaderLine: '#FFFFFF',
                tooltipFontSize: '12px',
                fontFamily: 'Helvetica',
                fontSize: '16px',
                labelFontFamily: 'Helvetica',
                tooltipFillOpacity: 1,
                tooltipTextOpacity: 0.9,
                smithchartTitleFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                },
                legendLabelFont: {
                    color: '#666666', fontFamily: 'Helvetica'
                },
                legendTitleFont: {
                    color: '#212529', fontFamily: 'Roboto'
                },
                dataLabelFont: {
                    color: '#495057', fontFamily: 'Helvetica'
                },
                axisLabelFont: {
                    color: '#495057', fontFamily: 'Helvetica'
                },
                smithchartSubtitleFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                }
            };
            break;
        case 'Tailwind':
            style = {
                axisLabel: '#6B7280',
                axisLine: '#D1D5DB',
                majorGridLine: '#E5E7EB',
                minorGridLine: '#D1D5DB',
                chartTitle: '#374151',
                legendLabel: '#374151',
                background: '#FFFFFF',
                areaBorder: '#D1D5DB6',
                tooltipFill: '#111827',
                dataLabel: '#F9FAFB',
                tooltipBoldLabel: '#F9FAFB',
                tooltipLightLabel: '#F9FAFB',
                tooltipHeaderLine: '#9CA3AF',
                tooltipFontSize: '12px',
                fontFamily: 'Inter',
                fontSize: '14px',
                labelFontFamily: 'inter',
                tooltipFillOpacity: 1,
                tooltipTextOpacity: 1,
                smithchartTitleFont: {
                    color: '#374151', fontFamily: 'Inter'
                },
                legendLabelFont: {
                    color: '#374151', fontFamily: 'Inter'
                },
                legendTitleFont: {
                    color: '#374151', fontFamily: 'Roboto'
                },
                dataLabelFont: {
                    color: '#6B7280', fontFamily: 'Inter'
                },
                axisLabelFont: {
                    color: '#6B7280', fontFamily: 'Inter'
                },
                smithchartSubtitleFont: {
                    color: '#374151', fontFamily: 'Inter'
                }
            };
            break;
        case 'TailwindDark':
            style = {
                axisLabel: '#9CA3AF',
                axisLine: '#4B5563',
                majorGridLine: '#374151',
                minorGridLine: '#4B5563',
                chartTitle: '#D1D5DB',
                legendLabel: '#D1D5DB',
                background: '#1f2937',
                areaBorder: '#4B5563',
                tooltipFill: '#E9ECEF',
                dataLabel: '#D1D5DB',
                tooltipBoldLabel: '#1F2937',
                tooltipLightLabel: '#1F2937',
                tooltipHeaderLine: '#9CA3AF',
                tooltipFontSize: '12px',
                fontFamily: 'Inter',
                fontSize: '14px',
                labelFontFamily: 'inter',
                tooltipFillOpacity: 1,
                tooltipTextOpacity: 1,
                smithchartTitleFont: {
                    color: '#D1D5DB', fontFamily: 'Inter'
                },
                legendLabelFont: {
                    color: '#D1D5DB', fontFamily: 'Inter'
                },
                legendTitleFont: {
                    color: '#D1D5DB', fontFamily: 'Roboto'
                },
                dataLabelFont: {
                    color: '#9CA3AF', fontFamily: 'Inter'
                },
                axisLabelFont: {
                    color: '#9CA3AF', fontFamily: 'Inter'
                },
                smithchartSubtitleFont: {
                    color: '#D1D5DB', fontFamily: 'Inter'
                }
            };
            break;
        case 'Bootstrap5':
            style = {
                axisLabel: '#495057',
                axisLine: '#D1D5DB',
                majorGridLine: '#E5E7EB',
                minorGridLine: '#E5E7EB',
                chartTitle: '#343A40',
                legendLabel: '#343A40',
                background: 'rgba(255, 255, 255, 0.0)',
                areaBorder: ' #DEE2E6',
                tooltipFill: '#212529',
                dataLabel: '#D1D5DB',
                tooltipBoldLabel: '#F9FAFB',
                tooltipLightLabel: '#F9FAFB',
                tooltipHeaderLine: '#6B7280',
                tooltipFontSize: '12px',
                fontFamily: 'Helvetica',
                fontSize: '14px',
                labelFontFamily: 'Helvetica',
                tooltipFillOpacity: 1,
                tooltipTextOpacity: 1,
                smithchartTitleFont: {
                    color: '#343A40', fontFamily: 'Helvetica'
                },
                legendLabelFont: {
                    color: '#343A40', fontFamily: 'Helvetica'
                },
                legendTitleFont: {
                    color: '#343A40', fontFamily: 'Roboto'
                },
                dataLabelFont: {
                    color: '#495057', fontFamily: 'Helvetica'
                },
                axisLabelFont: {
                    color: '#495057', fontFamily: 'Helvetica'
                },
                smithchartSubtitleFont: {
                    color: '#343A40', fontFamily: 'Helvetica'
                }
            };
            break;
        case 'Bootstrap5Dark':
            style = {
                axisLabel: '#CED4DA',
                axisLine: '#495057',
                majorGridLine: '#495057',
                minorGridLine: '#495057',
                chartTitle: '#E9ECEF',
                legendLabel: '#E9ECEF',
                background: '#212529',
                areaBorder: ' #495057',
                tooltipFill: '#E9ECEF',
                dataLabel: '#D1D5DB',
                tooltipBoldLabel: '#212529',
                tooltipLightLabel: '#212529',
                tooltipHeaderLine: '#6B7280',
                tooltipFontSize: '12px',
                fontFamily: 'Helvetica',
                fontSize: '14px',
                labelFontFamily: 'Helvetica',
                tooltipFillOpacity: 1,
                tooltipTextOpacity: 1,
                smithchartTitleFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                },
                legendLabelFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                },
                legendTitleFont: {
                    color: '#E9ECEF', fontFamily: 'Roboto'
                },
                dataLabelFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                },
                axisLabelFont: {
                    color: '#CED4DA', fontFamily: 'Helvetica'
                },
                smithchartSubtitleFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                }
            };
            break;
        case 'Fluent':
            style = {
                axisLabel: '#3B3A39',
                axisLine: '#D2D0CE',
                majorGridLine: '#D2D0CE',
                minorGridLine: '#EDEBE9',
                chartTitle: '#201F1E',
                legendLabel: '#323130',
                background: '#FFFFFF',
                areaBorder: ' #D2D0CE',
                tooltipFill: '#FFFFFF',
                dataLabel: '#3B3A39',
                tooltipBoldLabel: '#323130',
                tooltipLightLabel: '#323130',
                tooltipHeaderLine: '#D2D0CE',
                tooltipFontSize: '12px',
                fontFamily: 'Segoe UI',
                fontSize: '14px',
                labelFontFamily: 'Segoe UI',
                tooltipFillOpacity: 1,
                tooltipTextOpacity: 1,
                smithchartTitleFont: {
                    color: '#201F1E', fontFamily: 'Segoe UI'
                },
                legendLabelFont: {
                    color: '#49454E', fontFamily: 'Segoe UI'
                },
                legendTitleFont: {
                    color: '#201F1E', fontFamily: 'Roboto'
                },
                dataLabelFont: {
                    color: '#3B3A39', fontFamily: 'Segoe UI'
                },
                axisLabelFont: {
                    color: '#3B3A39', fontFamily: 'Segoe UI'
                },
                smithchartSubtitleFont: {
                    color: '#323129', fontFamily: 'Segoe UI'
                }
            };
            break;
        case 'FluentDark':
            style = {
                axisLabel: '#C8C6C4',
                axisLine: '#3B3A39',
                majorGridLine: '#414040',
                minorGridLine: '#414040',
                chartTitle: '#F3F2F1',
                legendLabel: '#D2D0CE',
                background: 'transparent',
                areaBorder: '#414040',
                tooltipFill: '#323130',
                dataLabel: '#C8C6C4',
                tooltipBoldLabel: '#F3F2F1',
                tooltipLightLabel: '#F3F2F2',
                tooltipHeaderLine: '#3B3A39',
                tooltipFontSize: '12px',
                fontFamily: 'Segoe UI',
                fontSize: '14px',
                labelFontFamily: 'Segoe UI',
                tooltipFillOpacity: 1,
                tooltipTextOpacity: 1,
                smithchartTitleFont: {
                    color: '#C8C6C4', fontFamily: 'Segoe UI'
                },
                legendLabelFont: {
                    color: '#D2D0CE', fontFamily: 'Segoe UI'
                },
                legendTitleFont: {
                    color: '#F3F2F1', fontFamily: 'Roboto'
                },
                dataLabelFont: {
                    color: '#D2D0CE', fontFamily: 'Segoe UI'
                },
                axisLabelFont: {
                    color: '#C8C6C4', fontFamily: 'Segoe UI'
                },
                smithchartSubtitleFont: {
                    color: '#F3F2F1', fontFamily: 'Segoe UI'
                }
            };
            break;
        case 'Material3':
            style = {
                axisLine: '#C4C7C5',
                axisLabel: '#1C1B1F',
                majorGridLine: '#C4C7C5',
                minorGridLine: '#C4C7C5',
                legendLabel: '#1C1B1F',
                background: '#FFFFFF',
                chartTitle: '#1C1B1F',
                areaBorder: ' #E7E0EC',
                dataLabel: '#49454E',
                tooltipFill: '#313033',
                tooltipBoldLabel: '#F4EFF4',
                tooltipLightLabel: '#F4EFF4',
                tooltipHeaderLine: '#F4EFF4',
                tooltipFontFamily: 'Inter',
                tooltipFontSize: '12px',
                fontFamily: 'Inter',
                fontSize: '16px',
                labelFontFamily: 'Inter',
                tooltipFillOpacity: 1,
                tooltipTextOpacity: 1,
                smithchartTitleFont: {
                    color: '#1C1B1F', fontFamily: 'Roboto'
                },
                legendLabelFont: {
                    color: '#49454E', fontFamily: 'Roboto'
                },
                legendTitleFont: {
                    color: '#1C1B1F', fontFamily: 'Roboto'
                },
                dataLabelFont: {
                    color: '#49454E', fontFamily: 'Roboto'
                },
                axisLabelFont: {
                    color: '#1E192B', fontFamily: 'Roboto'
                },
                smithchartSubtitleFont: {
                    color: '#49454E', fontFamily: 'Roboto'
                }
            };
            break;
        case 'Material3Dark':
            style = {
                axisLabel: '#E6E1E5',
                axisLine: '#444746',
                majorGridLine: '#444746',
                minorGridLine: '#444746',
                chartTitle: '#E6E1E5',
                legendLabel: '#E6E1E5',
                background: 'transparent',
                areaBorder: ' #49454F',
                tooltipFill: '#E6E1E5',
                dataLabel: '#CAC4D0',
                tooltipBoldLabel: '#313033',
                tooltipLightLabel: '#313033',
                tooltipHeaderLine: '#313033',
                tooltipFontFamily: 'Roboto',
                tooltipFontSize: '12px',
                fontFamily: 'Roboto',
                fontSize: '16px',
                labelFontFamily: 'Roboto',
                tooltipFillOpacity: 1,
                tooltipTextOpacity: 1,
                smithchartTitleFont: {
                    color: '#E6E1E5', fontFamily: 'Roboto'
                },
                legendLabelFont: {
                    color: '#CAC4D0', fontFamily: 'Roboto'
                },
                legendTitleFont: {
                    color: '#E6E1E5', fontFamily: 'Roboto'
                },
                dataLabelFont: {
                    color: '#CAC4D0', fontFamily: 'Roboto'
                },
                axisLabelFont: {
                    color: '#CAC4D0', fontFamily: 'Roboto'
                },
                smithchartSubtitleFont: {
                    color: '#CAC4D0', fontFamily: 'Roboto'
                }
            };
            break;
        default:
            style = {
                axisLabel: '#686868',
                axisLine: '#b5b5b5',
                majorGridLine: '#dbdbdb',
                minorGridLine: '#eaeaea',
                chartTitle: '#424242',
                legendLabel: '#353535',
                background: '#FFFFFF',
                areaBorder: 'Gray',
                tooltipFill: theme === 'Material' ? '#000816' : theme === 'Bootstrap' ? '#212529' : '#FFFFFF',
                dataLabel: '#424242',
                tooltipBoldLabel: theme === 'Material' ? 'rgba(249, 250, 251, 1)' : theme === 'Bootstrap' ? '#F9FAFB' : '#333333',
                tooltipLightLabel: theme === 'Material' ? 'rgba(249, 250, 251, 1)' : theme === 'Bootstrap' ? '#F9FAFB' : '#333333',
                tooltipHeaderLine: theme === 'Fabric' ? '#D2D0CE' : '#ffffff',
                tooltipFontSize: '12px',
                fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Bootstrap' ? 'Helvetica' : 'Segoe UI',
                smithchartTitleFont: {
                    color: theme === 'Material' ? 'rgba(0, 0, 0, 1)' : theme === 'Bootstrap' ? '#212529' : '#333333', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Bootstrap' ? 'Helvetica' : 'Segoe UI'
                },
                legendLabelFont: {
                    color: theme === 'Material' ? 'rgba(97, 97, 97, 1)' : theme === 'Bootstrap' ? '#666666' : '#666666', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Bootstrap' ? 'Helvetica' : 'Segoe UI'
                },
                legendTitleFont: {
                    color: theme === 'Material' ? 'rgba(0, 0, 0, 1)' : theme === 'Bootstrap' ? '#212529' : '#F3F2F1', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Bootstrap' ? 'Helvetica' : 'Segoe UI'
                },
                dataLabelFont: {
                    color: theme === 'Material' ? 'rgba(97, 97, 97, 1)' : theme === 'Bootstrap' ? '#676767' : '#666666', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Bootstrap' ? 'Helvetica' : 'Segoe UI'
                },
                axisLabelFont: {
                    color: theme === 'Material' ? 'rgba(97, 97, 97, 1)' : theme === 'Bootstrap' ? '#676767' : '#666666', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Bootstrap' ? 'Helvetica' : 'Segoe UI'
                },
                smithchartSubtitleFont: {
                    color: theme === 'Material' ? 'rgba(0, 0, 0, 1)' : theme === 'Bootstrap' ? '#212529' : '#333333', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Bootstrap' ? 'Helvetica' : 'Segoe UI'
                }
            };
            break;
    }
    return style;
}

var __extends$90 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$18 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var LegendTitle = /** @__PURE__ @class */ (function (_super) {
    __extends$90(LegendTitle, _super);
    function LegendTitle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$18([
        Property(true)
    ], LegendTitle.prototype, "visible", void 0);
    __decorate$18([
        Property('')
    ], LegendTitle.prototype, "text", void 0);
    __decorate$18([
        Property('')
    ], LegendTitle.prototype, "description", void 0);
    __decorate$18([
        Property('Center')
    ], LegendTitle.prototype, "textAlignment", void 0);
    __decorate$18([
        Complex({ fontFamily: null, size: "14px", fontStyle: 'Normal', fontWeight: '600', color: null }, SmithchartFont)
    ], LegendTitle.prototype, "textStyle", void 0);
    return LegendTitle;
}(ChildProperty));
var LegendLocation = /** @__PURE__ @class */ (function (_super) {
    __extends$90(LegendLocation, _super);
    function LegendLocation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$18([
        Property(0)
    ], LegendLocation.prototype, "x", void 0);
    __decorate$18([
        Property(0)
    ], LegendLocation.prototype, "y", void 0);
    return LegendLocation;
}(ChildProperty));
var LegendItemStyleBorder = /** @__PURE__ @class */ (function (_super) {
    __extends$90(LegendItemStyleBorder, _super);
    function LegendItemStyleBorder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$18([
        Property(1)
    ], LegendItemStyleBorder.prototype, "width", void 0);
    __decorate$18([
        Property(null)
    ], LegendItemStyleBorder.prototype, "color", void 0);
    return LegendItemStyleBorder;
}(ChildProperty));
var LegendItemStyle = /** @__PURE__ @class */ (function (_super) {
    __extends$90(LegendItemStyle, _super);
    function LegendItemStyle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$18([
        Property(10)
    ], LegendItemStyle.prototype, "width", void 0);
    __decorate$18([
        Property(10)
    ], LegendItemStyle.prototype, "height", void 0);
    __decorate$18([
        Complex({}, LegendItemStyleBorder)
    ], LegendItemStyle.prototype, "border", void 0);
    return LegendItemStyle;
}(ChildProperty));
var LegendBorder = /** @__PURE__ @class */ (function (_super) {
    __extends$90(LegendBorder, _super);
    function LegendBorder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$18([
        Property(1)
    ], LegendBorder.prototype, "width", void 0);
    __decorate$18([
        Property(null)
    ], LegendBorder.prototype, "color", void 0);
    return LegendBorder;
}(ChildProperty));
var SmithchartLegendSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$90(SmithchartLegendSettings, _super);
    function SmithchartLegendSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$18([
        Property(false)
    ], SmithchartLegendSettings.prototype, "visible", void 0);
    __decorate$18([
        Property('bottom')
    ], SmithchartLegendSettings.prototype, "position", void 0);
    __decorate$18([
        Property('Center')
    ], SmithchartLegendSettings.prototype, "alignment", void 0);
    __decorate$18([
        Property(null)
    ], SmithchartLegendSettings.prototype, "width", void 0);
    __decorate$18([
        Property(null)
    ], SmithchartLegendSettings.prototype, "height", void 0);
    __decorate$18([
        Property('circle')
    ], SmithchartLegendSettings.prototype, "shape", void 0);
    __decorate$18([
        Property(null)
    ], SmithchartLegendSettings.prototype, "rowCount", void 0);
    __decorate$18([
        Property(null)
    ], SmithchartLegendSettings.prototype, "columnCount", void 0);
    __decorate$18([
        Property(8)
    ], SmithchartLegendSettings.prototype, "itemPadding", void 0);
    __decorate$18([
        Property(5)
    ], SmithchartLegendSettings.prototype, "shapePadding", void 0);
    __decorate$18([
        Property('')
    ], SmithchartLegendSettings.prototype, "description", void 0);
    __decorate$18([
        Property(true)
    ], SmithchartLegendSettings.prototype, "toggleVisibility", void 0);
    __decorate$18([
        Complex({}, LegendTitle)
    ], SmithchartLegendSettings.prototype, "title", void 0);
    __decorate$18([
        Complex({}, LegendLocation)
    ], SmithchartLegendSettings.prototype, "location", void 0);
    __decorate$18([
        Complex({}, LegendItemStyle)
    ], SmithchartLegendSettings.prototype, "itemStyle", void 0);
    __decorate$18([
        Complex({}, LegendBorder)
    ], SmithchartLegendSettings.prototype, "border", void 0);
    __decorate$18([
        Complex({ fontFamily: null, size: "14px", fontStyle: 'Normal', fontWeight: '400', color: null }, SmithchartFont)
    ], SmithchartLegendSettings.prototype, "textStyle", void 0);
    return SmithchartLegendSettings;
}(ChildProperty));

var __extends$91 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$19 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Configures the major Grid lines in the `axis`.
 */
var SmithchartMajorGridLines = /** @__PURE__ @class */ (function (_super) {
    __extends$91(SmithchartMajorGridLines, _super);
    function SmithchartMajorGridLines() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$19([
        Property(1)
    ], SmithchartMajorGridLines.prototype, "width", void 0);
    __decorate$19([
        Property('')
    ], SmithchartMajorGridLines.prototype, "dashArray", void 0);
    __decorate$19([
        Property(true)
    ], SmithchartMajorGridLines.prototype, "visible", void 0);
    __decorate$19([
        Property(null)
    ], SmithchartMajorGridLines.prototype, "color", void 0);
    __decorate$19([
        Property(1)
    ], SmithchartMajorGridLines.prototype, "opacity", void 0);
    return SmithchartMajorGridLines;
}(ChildProperty));
/**
 * Configures the major grid lines in the `axis`.
 */
var SmithchartMinorGridLines = /** @__PURE__ @class */ (function (_super) {
    __extends$91(SmithchartMinorGridLines, _super);
    function SmithchartMinorGridLines() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$19([
        Property(1)
    ], SmithchartMinorGridLines.prototype, "width", void 0);
    __decorate$19([
        Property('')
    ], SmithchartMinorGridLines.prototype, "dashArray", void 0);
    __decorate$19([
        Property(false)
    ], SmithchartMinorGridLines.prototype, "visible", void 0);
    __decorate$19([
        Property(null)
    ], SmithchartMinorGridLines.prototype, "color", void 0);
    __decorate$19([
        Property(8)
    ], SmithchartMinorGridLines.prototype, "count", void 0);
    return SmithchartMinorGridLines;
}(ChildProperty));
/**
 * Configures the axis lines in the `axis`.
 */
var SmithchartAxisLine = /** @__PURE__ @class */ (function (_super) {
    __extends$91(SmithchartAxisLine, _super);
    function SmithchartAxisLine() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$19([
        Property(true)
    ], SmithchartAxisLine.prototype, "visible", void 0);
    __decorate$19([
        Property(1)
    ], SmithchartAxisLine.prototype, "width", void 0);
    __decorate$19([
        Property(null)
    ], SmithchartAxisLine.prototype, "color", void 0);
    __decorate$19([
        Property('')
    ], SmithchartAxisLine.prototype, "dashArray", void 0);
    return SmithchartAxisLine;
}(ChildProperty));
var SmithchartAxis = /** @__PURE__ @class */ (function (_super) {
    __extends$91(SmithchartAxis, _super);
    function SmithchartAxis() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$19([
        Property(true)
    ], SmithchartAxis.prototype, "visible", void 0);
    __decorate$19([
        Property('Outside')
    ], SmithchartAxis.prototype, "labelPosition", void 0);
    __decorate$19([
        Property('Hide')
    ], SmithchartAxis.prototype, "labelIntersectAction", void 0);
    __decorate$19([
        Complex({}, SmithchartMajorGridLines)
    ], SmithchartAxis.prototype, "majorGridLines", void 0);
    __decorate$19([
        Complex({}, SmithchartMinorGridLines)
    ], SmithchartAxis.prototype, "minorGridLines", void 0);
    __decorate$19([
        Complex({}, SmithchartAxisLine)
    ], SmithchartAxis.prototype, "axisLine", void 0);
    __decorate$19([
        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, SmithchartFont)
    ], SmithchartAxis.prototype, "labelStyle", void 0);
    return SmithchartAxis;
}(ChildProperty));

var __extends$92 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$20 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Subtitle = /** @__PURE__ @class */ (function (_super) {
    __extends$92(Subtitle, _super);
    function Subtitle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$20([
        Property(true)
    ], Subtitle.prototype, "visible", void 0);
    __decorate$20([
        Property('')
    ], Subtitle.prototype, "text", void 0);
    __decorate$20([
        Property('')
    ], Subtitle.prototype, "description", void 0);
    __decorate$20([
        Property('Far')
    ], Subtitle.prototype, "textAlignment", void 0);
    __decorate$20([
        Property(true)
    ], Subtitle.prototype, "enableTrim", void 0);
    __decorate$20([
        Property(null)
    ], Subtitle.prototype, "maximumWidth", void 0);
    __decorate$20([
        Complex({ fontFamily: null, size: "14px", fontStyle: 'Normal', fontWeight: '400', color: null }, SmithchartFont)
    ], Subtitle.prototype, "textStyle", void 0);
    return Subtitle;
}(ChildProperty));
var Title = /** @__PURE__ @class */ (function (_super) {
    __extends$92(Title, _super);
    function Title() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$20([
        Property(true)
    ], Title.prototype, "visible", void 0);
    __decorate$20([
        Property('')
    ], Title.prototype, "text", void 0);
    __decorate$20([
        Property('')
    ], Title.prototype, "description", void 0);
    __decorate$20([
        Property('Center')
    ], Title.prototype, "textAlignment", void 0);
    __decorate$20([
        Property(true)
    ], Title.prototype, "enableTrim", void 0);
    __decorate$20([
        Property(null)
    ], Title.prototype, "maximumWidth", void 0);
    __decorate$20([
        Complex({}, Subtitle)
    ], Title.prototype, "subtitle", void 0);
    __decorate$20([
        Complex({ fontFamily: null, size: "16px", fontStyle: 'Normal', fontWeight: '600', color: null }, SmithchartFont)
    ], Title.prototype, "font", void 0);
    __decorate$20([
        Complex({ fontFamily: null, size: "16px", fontStyle: 'Normal', fontWeight: '600', color: null }, SmithchartFont)
    ], Title.prototype, "textStyle", void 0);
    return Title;
}(ChildProperty));

var __extends$93 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$21 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SeriesTooltipBorder = /** @__PURE__ @class */ (function (_super) {
    __extends$93(SeriesTooltipBorder, _super);
    function SeriesTooltipBorder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$21([
        Property(1)
    ], SeriesTooltipBorder.prototype, "width", void 0);
    __decorate$21([
        Property(null)
    ], SeriesTooltipBorder.prototype, "color", void 0);
    return SeriesTooltipBorder;
}(ChildProperty));
var SeriesTooltip = /** @__PURE__ @class */ (function (_super) {
    __extends$93(SeriesTooltip, _super);
    function SeriesTooltip() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$21([
        Property(false)
    ], SeriesTooltip.prototype, "visible", void 0);
    __decorate$21([
        Property(null)
    ], SeriesTooltip.prototype, "fill", void 0);
    __decorate$21([
        Property(0.75)
    ], SeriesTooltip.prototype, "opacity", void 0);
    __decorate$21([
        Property('')
    ], SeriesTooltip.prototype, "template", void 0);
    __decorate$21([
        Complex({}, SeriesTooltipBorder)
    ], SeriesTooltip.prototype, "border", void 0);
    return SeriesTooltip;
}(ChildProperty));
var SeriesMarkerBorder = /** @__PURE__ @class */ (function (_super) {
    __extends$93(SeriesMarkerBorder, _super);
    function SeriesMarkerBorder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$21([
        Property(3)
    ], SeriesMarkerBorder.prototype, "width", void 0);
    __decorate$21([
        Property('white')
    ], SeriesMarkerBorder.prototype, "color", void 0);
    return SeriesMarkerBorder;
}(ChildProperty));
var SeriesMarkerDataLabelBorder = /** @__PURE__ @class */ (function (_super) {
    __extends$93(SeriesMarkerDataLabelBorder, _super);
    function SeriesMarkerDataLabelBorder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$21([
        Property(0.1)
    ], SeriesMarkerDataLabelBorder.prototype, "width", void 0);
    __decorate$21([
        Property('white')
    ], SeriesMarkerDataLabelBorder.prototype, "color", void 0);
    return SeriesMarkerDataLabelBorder;
}(ChildProperty));
var SeriesMarkerDataLabelConnectorLine = /** @__PURE__ @class */ (function (_super) {
    __extends$93(SeriesMarkerDataLabelConnectorLine, _super);
    function SeriesMarkerDataLabelConnectorLine() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$21([
        Property(1)
    ], SeriesMarkerDataLabelConnectorLine.prototype, "width", void 0);
    __decorate$21([
        Property(null)
    ], SeriesMarkerDataLabelConnectorLine.prototype, "color", void 0);
    return SeriesMarkerDataLabelConnectorLine;
}(ChildProperty));
var SeriesMarkerDataLabel = /** @__PURE__ @class */ (function (_super) {
    __extends$93(SeriesMarkerDataLabel, _super);
    function SeriesMarkerDataLabel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$21([
        Property(false)
    ], SeriesMarkerDataLabel.prototype, "visible", void 0);
    __decorate$21([
        Property('')
    ], SeriesMarkerDataLabel.prototype, "template", void 0);
    __decorate$21([
        Property(null)
    ], SeriesMarkerDataLabel.prototype, "fill", void 0);
    __decorate$21([
        Property(1)
    ], SeriesMarkerDataLabel.prototype, "opacity", void 0);
    __decorate$21([
        Complex({}, SeriesMarkerDataLabelBorder)
    ], SeriesMarkerDataLabel.prototype, "border", void 0);
    __decorate$21([
        Complex({}, SeriesMarkerDataLabelConnectorLine)
    ], SeriesMarkerDataLabel.prototype, "connectorLine", void 0);
    __decorate$21([
        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, SmithchartFont)
    ], SeriesMarkerDataLabel.prototype, "textStyle", void 0);
    return SeriesMarkerDataLabel;
}(ChildProperty));
var SeriesMarker = /** @__PURE__ @class */ (function (_super) {
    __extends$93(SeriesMarker, _super);
    function SeriesMarker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$21([
        Property(false)
    ], SeriesMarker.prototype, "visible", void 0);
    __decorate$21([
        Property('circle')
    ], SeriesMarker.prototype, "shape", void 0);
    __decorate$21([
        Property(6)
    ], SeriesMarker.prototype, "width", void 0);
    __decorate$21([
        Property(6)
    ], SeriesMarker.prototype, "height", void 0);
    __decorate$21([
        Property('')
    ], SeriesMarker.prototype, "imageUrl", void 0);
    __decorate$21([
        Property('')
    ], SeriesMarker.prototype, "fill", void 0);
    __decorate$21([
        Property(1)
    ], SeriesMarker.prototype, "opacity", void 0);
    __decorate$21([
        Complex({}, SeriesMarkerBorder)
    ], SeriesMarker.prototype, "border", void 0);
    __decorate$21([
        Complex({}, SeriesMarkerDataLabel)
    ], SeriesMarker.prototype, "dataLabel", void 0);
    return SeriesMarker;
}(ChildProperty));
var SmithchartSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$93(SmithchartSeries, _super);
    function SmithchartSeries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$21([
        Property('visible')
    ], SmithchartSeries.prototype, "visibility", void 0);
    __decorate$21([
        Property([])
    ], SmithchartSeries.prototype, "points", void 0);
    __decorate$21([
        Property('')
    ], SmithchartSeries.prototype, "resistance", void 0);
    __decorate$21([
        Property('')
    ], SmithchartSeries.prototype, "reactance", void 0);
    __decorate$21([
        Property('')
    ], SmithchartSeries.prototype, "tooltipMappingName", void 0);
    __decorate$21([
        Property(null)
    ], SmithchartSeries.prototype, "dataSource", void 0);
    __decorate$21([
        Property('')
    ], SmithchartSeries.prototype, "name", void 0);
    __decorate$21([
        Property(null)
    ], SmithchartSeries.prototype, "fill", void 0);
    __decorate$21([
        Property(false)
    ], SmithchartSeries.prototype, "enableAnimation", void 0);
    __decorate$21([
        Property('2000ms')
    ], SmithchartSeries.prototype, "animationDuration", void 0);
    __decorate$21([
        Property(false)
    ], SmithchartSeries.prototype, "enableSmartLabels", void 0);
    __decorate$21([
        Property(1)
    ], SmithchartSeries.prototype, "width", void 0);
    __decorate$21([
        Property(1)
    ], SmithchartSeries.prototype, "opacity", void 0);
    __decorate$21([
        Complex({}, SeriesMarker)
    ], SmithchartSeries.prototype, "marker", void 0);
    __decorate$21([
        Complex({}, SeriesTooltip)
    ], SmithchartSeries.prototype, "tooltip", void 0);
    return SmithchartSeries;
}(ChildProperty));

var AreaBounds = /** @__PURE__ @class */ (function () {
    function AreaBounds() {
    }
    AreaBounds.prototype.calculateAreaBounds = function (smithchart, title, bounds) {
        var margin = smithchart.margin;
        var border = smithchart.border;
        var spaceValue = this.getLegendSpace(smithchart, bounds);
        var x = spaceValue['leftLegendWidth'] + margin.left + border.width;
        var rightSpace = spaceValue['rightLegendWidth'] + margin.left + margin.right + (2 * border.width);
        var width = smithchart.availableSize['width'] - (x + rightSpace);
        var y = margin['top'] + (2 * smithchart.elementSpacing) + spaceValue['modelTitleHeight'] +
            spaceValue['modelsubTitleHeight'] + spaceValue['topLegendHeight'] + border.width;
        var height = smithchart.availableSize['height'] - (spaceValue['modelTitleHeight'] +
            (2 * smithchart.elementSpacing) + spaceValue['modelsubTitleHeight'] + margin['top'] +
            spaceValue['topLegendHeight'] + spaceValue['bottomLegendHeight']);
        return { x: x, y: y, width: width, height: height };
    };
    AreaBounds.prototype.getLegendSpace = function (smithchart, bounds) {
        var title = smithchart.title;
        var legend = smithchart.legendSettings;
        var position = legend.position.toLowerCase();
        var subtitleHeight = 0;
        var modelsubTitleHeight = 0;
        var titleHeight = 0;
        var font = smithchart.font;
        var modelTitleHeight = 0;
        var itemPadding = 10;
        var legendBorder = legend.border.width;
        var leftLegendWidth = 0;
        var rightLegendWidth = 0;
        var topLegendHeight = 0;
        var bottomLegendHeight = 0;
        var ltheight = 0;
        var space;
        if (legend['visible']) {
            space = (bounds.width + (itemPadding / 2) + smithchart.elementSpacing + (2 * legendBorder));
            leftLegendWidth = position === 'left' ? space : 0;
            rightLegendWidth = position === 'right' ? space : 0;
            ltheight = legend['title'].visible ? measureText$1(legend['title'].text, font, smithchart.themeStyle.legendLabelFont)['height'] : 0;
            topLegendHeight = position === 'top' ? smithchart.elementSpacing + bounds.height + ltheight : 0;
            bottomLegendHeight = position === 'bottom' ? smithchart.elementSpacing + bounds.height + ltheight : 0;
        }
        subtitleHeight = measureText$1(title.subtitle.text, font, smithchart.themeStyle.legendLabelFont)['height'];
        modelTitleHeight = (title.text === '' || !title['visible']) ? 0 : (titleHeight);
        modelsubTitleHeight = (title['subtitle'].text === '' || !title['subtitle'].visible) ? 0 : (subtitleHeight);
        return {
            leftLegendWidth: leftLegendWidth, rightLegendWidth: rightLegendWidth,
            topLegendHeight: topLegendHeight, bottomLegendHeight: bottomLegendHeight,
            modelTitleHeight: modelTitleHeight, modelsubTitleHeight: modelsubTitleHeight
        };
    };
    return AreaBounds;
}());

/**
 * Specifies smithchart animationComplete event name.
 *
 * @private
 */
var animationComplete$1 = 'animationComplete';
/**
 * Specifies smithchart legendRender event name.
 *
 * @private
 */
var legendRender$1 = 'legendRender';
/**
 * Specifies smithchart titleRender event name.
 *
 * @private
 */
var titleRender = 'titleRender';
/**
 * Specifies smithchart subtitleRender event name.
 *
 * @private
 */
var subtitleRender = 'subtitleRender';
/**
 * Specifies smithchart textRender event name.
 *
 * @private
 */
var textRender$1 = 'textRender';
/**
 * Specifies smithchart seriesRender event name.
 *
 * @private
 */
var seriesRender$1 = 'seriesRender';
/**
 * Specifies smithchart load event name.
 *
 * @private
 */
var load$1 = 'load';
/**
 * Specifies smithchart loaded event name.
 *
 * @private
 */
var loaded$1 = 'loaded';
/**
 * Specifies smithchart axisLabelRender event name.
 *
 * @private
 */
var axisLabelRender$1 = 'axisLabelRender';

var AxisRender = /** @__PURE__ @class */ (function () {
    function AxisRender() {
        this.radialLabels = [-50, -20, -10, -5, -4, -3, -2, -1.5, -1, -0.8, -0.6, -0.4, -0.2,
            0, 0.2, 0.4, 0.6, 0.8, 1, 1.5, 2, 3, 4, 5, 10, 20, 50];
        this.radialLabelCollections = [];
        this.horizontalLabelCollections = [];
        this.labelCollections = [];
        this.direction = new Direction();
    }
    AxisRender.prototype.renderArea = function (smithchart, bounds) {
        this.calculateChartArea(smithchart, bounds);
        this.calculateCircleMargin(smithchart, bounds);
        this.calculateXAxisRange(smithchart);
        this.calculateRAxisRange(smithchart);
        this.measureHorizontalAxis(smithchart);
        this.measureRadialAxis(smithchart);
        if (smithchart.horizontalAxis.visible) {
            this.updateHAxis(smithchart);
        }
        if (smithchart.radialAxis.visible) {
            this.updateRAxis(smithchart);
        }
        if (smithchart.horizontalAxis.visible) {
            this.drawHAxisLabels(smithchart);
        }
        if (smithchart.radialAxis.visible) {
            this.drawRAxisLabels(smithchart);
        }
    };
    AxisRender.prototype.updateHAxis = function (smithchart) {
        var majorGridLines = smithchart.horizontalAxis.majorGridLines;
        var minorGridLines = smithchart.horizontalAxis.minorGridLines;
        var axisLine = smithchart.horizontalAxis.axisLine;
        if (majorGridLines.visible) {
            this.updateHMajorGridLines(smithchart);
        }
        if (minorGridLines.visible) {
            this.updateHMinorGridLines(smithchart);
        }
        if (axisLine.visible) {
            this.updateHAxisLine(smithchart);
        }
    };
    AxisRender.prototype.updateRAxis = function (smithchart) {
        var majorGridLines = smithchart.radialAxis.majorGridLines;
        var minorGridLines = smithchart.radialAxis.minorGridLines;
        var axisLine = smithchart.radialAxis.axisLine;
        if (majorGridLines.visible) {
            this.updateRMajorGridLines(smithchart);
        }
        if (minorGridLines.visible) {
            this.updateRMinorGridLines(smithchart);
        }
        if (axisLine.visible) {
            this.updateRAxisLine(smithchart);
        }
    };
    AxisRender.prototype.measureHorizontalAxis = function (smithchart) {
        var minorGridLines = smithchart.horizontalAxis.minorGridLines;
        this.measureHMajorGridLines(smithchart);
        if (minorGridLines.visible) {
            this.measureHMinorGridLines(smithchart);
        }
    };
    AxisRender.prototype.measureRadialAxis = function (smithchart) {
        var minorGridLines = smithchart.radialAxis.minorGridLines;
        this.measureRMajorGridLines(smithchart);
        if (minorGridLines.visible) {
            this.measureRMinorGridLines(smithchart);
        }
    };
    AxisRender.prototype.calculateChartArea = function (smithchart, bounds) {
        var width = smithchart.availableSize.width;
        var height = smithchart.availableSize.height;
        width = bounds.width;
        height = bounds.height;
        var chartAreaWidth = Math.min(width, height);
        var chartAreaHeight = Math.min(width, height);
        var x = bounds.x + (bounds.width / 2 - chartAreaWidth / 2);
        var y = bounds.y + ((height - chartAreaHeight) / 2 > 0 ? (height - chartAreaHeight) / 2 : 0);
        smithchart.chartArea = { x: x, y: y, width: chartAreaWidth, height: chartAreaHeight };
    };
    AxisRender.prototype.calculateCircleMargin = function (smithchart, bounds) {
        var padding = 10;
        var maxLabelWidth = 0;
        var width = smithchart.chartArea.width;
        var radius = smithchart.radius;
        maxLabelWidth = this.maximumLabelLength(smithchart);
        var labelMargin = (smithchart.radialAxis.labelPosition === 'Outside') ? (maxLabelWidth + padding) : padding;
        var diameter = width - labelMargin * 2 > 0 ? width - labelMargin * 2 : 0;
        var actualRadius = diameter / 2;
        var circleCoefficient = radius > 1 ? 1 : (radius < 0.1 ? 0.1 : radius);
        this.areaRadius = actualRadius * circleCoefficient;
        this.circleLeftX = smithchart.chartArea.x + labelMargin + (actualRadius * (1 - circleCoefficient));
        this.circleTopY = smithchart.chartArea.y + labelMargin + (actualRadius * (1 - circleCoefficient));
        this.circleCenterX = this.circleLeftX + this.areaRadius;
        this.circleCenterY = bounds.y + bounds.height / 2;
    };
    AxisRender.prototype.maximumLabelLength = function (smithchart) {
        var maximumLabelLength = 0;
        var font = smithchart.horizontalAxis.labelStyle;
        var label;
        var textSize;
        for (var i = 0; i < this.radialLabels.length; i++) {
            label = this.radialLabels[i].toString();
            textSize = measureText$1(label, font, smithchart.themeStyle.axisLabelFont);
            if (maximumLabelLength < textSize.width) {
                maximumLabelLength = textSize.width;
            }
        }
        return maximumLabelLength;
    };
    AxisRender.prototype.calculateAxisLabels = function () {
        var spacingBetweenGridLines = 30;
        var previousR = 0;
        var j = 0;
        var labels = [];
        var diameter = this.areaRadius * 2;
        for (var i = 0; i < 2; i = i + 0.1) {
            i = Math.round(i * 10) / 10;
            var coeff = 1 / (i + 1);
            var isOverlap1 = false;
            var isOverlap2 = false;
            var radius = ((diameter * coeff) / 2) * 2;
            if (previousR === 0.0 || i === 1) {
                previousR = radius;
                labels[j] = i;
                j++;
                continue;
            }
            if (i < 1) {
                isOverlap1 = this.isOverlap(1, diameter, radius, spacingBetweenGridLines);
            }
            if (i > 1) {
                isOverlap2 = this.isOverlap(2, diameter, radius, spacingBetweenGridLines);
            }
            if (isOverlap1 || isOverlap2) {
                continue;
            }
            if (previousR - radius >= spacingBetweenGridLines) {
                labels[j] = i;
                j++;
                previousR = radius;
            }
        }
        var staticlabels = [2, 3, 4, 5, 10, 20, 50];
        for (var k = 0; k < staticlabels.length; k++) {
            labels[j] = staticlabels[k];
            j++;
        }
        return labels;
    };
    AxisRender.prototype.isOverlap = function (x, d, previousR, spacingBetweenGridLines) {
        var coeff = 1 / (x + 1); // (1 / 1+r) find the radius for the x value
        var radius = ((d * coeff) / 2) * 2;
        return previousR - radius < spacingBetweenGridLines;
    };
    AxisRender.prototype.calculateXAxisRange = function (smithchart) {
        var x;
        var coeff;
        var radius;
        var cx;
        var diameter = this.areaRadius * 2;
        var horizontalAxisLabels = this.calculateAxisLabels();
        var cy = this.circleCenterY;
        var circleStartX = this.circleLeftX;
        var leftX = this.circleLeftX;
        for (var i = 0; i < horizontalAxisLabels.length; i++) {
            x = horizontalAxisLabels[i];
            coeff = 1 / (x + 1);
            radius = (diameter * coeff) / 2;
            if (smithchart.renderType === 'Impedance') {
                leftX = circleStartX + diameter - (radius * 2);
            }
            cx = leftX + radius;
            this.horizontalLabelCollections.push({
                centerX: cx, centerY: cy, radius: radius, value: x, region: null
            });
        }
    };
    AxisRender.prototype.calculateRAxisRange = function (smithchart) {
        var arcCy;
        var arcRadius;
        var diameter = this.areaRadius * 2;
        var y;
        var point = new Point();
        if (smithchart.renderType === 'Impedance') {
            point.x = this.circleLeftX + diameter;
            point.y = this.circleTopY + this.areaRadius;
        }
        else {
            point.x = this.circleLeftX;
            point.y = this.circleTopY + this.areaRadius;
        }
        for (var i = 0; i < this.radialLabels.length; i++) {
            y = this.radialLabels[i];
            arcRadius = Math.abs(((1 / y) * diameter) / 2);
            if (smithchart.renderType === 'Impedance') {
                arcCy = y > 0 ? point.y - arcRadius : point.y + arcRadius;
            }
            else {
                arcCy = y < 0 ? point.y - arcRadius : point.y + arcRadius;
            }
            this.radialLabelCollections.push({
                centerX: point.x, centerY: arcCy, radius: arcRadius, value: y
            });
        }
    };
    AxisRender.prototype.measureHMajorGridLines = function (smithchart) {
        var arcPoints = [];
        var startPoint;
        var endPoint;
        var radialPoint1;
        var radialPoint2;
        var size;
        this.majorHGridArcPoints = [];
        for (var i = 0; i < this.horizontalLabelCollections.length; i++) {
            var circlePoint = new HorizontalLabelCollection();
            circlePoint = this.horizontalLabelCollections[i];
            arcPoints = this.calculateHMajorArcStartEndPoints(circlePoint.value);
            if (smithchart.renderType === 'Impedance') {
                radialPoint1 = arcPoints[0];
                radialPoint2 = arcPoints[1];
            }
            else {
                radialPoint1 = arcPoints[1];
                radialPoint2 = arcPoints[0];
            }
            size = { width: circlePoint.radius, height: circlePoint.radius };
            if (circlePoint.value !== 0.0 && circlePoint.value !== 50.0) {
                startPoint = this.intersectingCirclePoints(radialPoint1[0].centerX, radialPoint1[0].centerY, radialPoint1[0].radius, circlePoint.centerX, circlePoint.centerY, circlePoint.radius, smithchart.renderType);
                endPoint = this.intersectingCirclePoints(radialPoint2[0].centerX, radialPoint2[0].centerY, radialPoint2[0].radius, circlePoint.centerX, circlePoint.centerY, circlePoint.radius, smithchart.renderType);
                this.majorHGridArcPoints.push({
                    startPoint: startPoint,
                    endPoint: endPoint,
                    rotationAngle: 2 * Math.PI,
                    sweepDirection: (smithchart.renderType === 'Impedance') ?
                        this.direction['counterclockwise'] : this.direction['clockwise'],
                    isLargeArc: true,
                    size: size
                });
            }
            else {
                startPoint = { x: circlePoint.centerX + circlePoint.radius, y: circlePoint.centerY };
                endPoint = { x: circlePoint.centerX + circlePoint.radius, y: circlePoint.centerY - 0.05 };
                this.majorHGridArcPoints.push({
                    startPoint: startPoint,
                    endPoint: endPoint,
                    rotationAngle: 2 * Math.PI,
                    sweepDirection: this.direction['clockwise'],
                    isLargeArc: true,
                    size: size
                });
            }
        }
    };
    AxisRender.prototype.measureRMajorGridLines = function (smithchart) {
        var radialPoint;
        var y;
        var arcPoints = [];
        var innerInterSectPoint;
        var outerInterSectPoint;
        var outterInterSectRadian;
        var outterInterSectAngle;
        var startPoint;
        var endPoint;
        var size;
        var sweepDirection;
        this.majorRGridArcPoints = [];
        this.labelCollections = [];
        var epsilon = _getEpsilonValue();
        for (var i = 0; i < this.radialLabelCollections.length; i++) {
            radialPoint = this.radialLabelCollections[i];
            if (radialPoint.radius <= epsilon) {
                continue;
            }
            y = radialPoint.value;
            arcPoints = this.calculateMajorArcStartEndPoints(radialPoint, Math.abs(y), smithchart);
            innerInterSectPoint = arcPoints[0];
            outerInterSectPoint = arcPoints[1];
            outterInterSectRadian = this.circleXYRadianValue(this.circleCenterX, this.circleCenterY, outerInterSectPoint.x, outerInterSectPoint.y);
            outterInterSectAngle = outterInterSectRadian * (180 / Math.PI);
            if (y !== 0.0) {
                startPoint = { x: innerInterSectPoint.x, y: innerInterSectPoint.y };
                endPoint = { x: outerInterSectPoint.x, y: outerInterSectPoint.y };
                size = { width: radialPoint.radius, height: radialPoint.radius };
                sweepDirection = y > 0 ? this.direction['clockwise'] : this.direction['counterclockwise'];
                this.majorRGridArcPoints.push({
                    startPoint: startPoint,
                    endPoint: endPoint,
                    size: size,
                    rotationAngle: 2 * Math.PI,
                    isLargeArc: false,
                    sweepDirection: sweepDirection
                });
                this.labelCollections.push({
                    centerX: outerInterSectPoint.x,
                    centerY: outerInterSectPoint.y,
                    angle: outterInterSectAngle,
                    value: y,
                    radius: this.areaRadius,
                    region: null
                });
            }
            else {
                startPoint = { x: this.circleLeftX, y: this.circleCenterY };
                endPoint = { x: this.circleCenterX + this.areaRadius, y: this.circleCenterY };
                this.majorRGridArcPoints.push({
                    startPoint: startPoint,
                    endPoint: endPoint,
                    size: null,
                    rotationAngle: null,
                    isLargeArc: null,
                    sweepDirection: null
                });
                this.labelCollections.push({
                    centerX: (smithchart.renderType === 'Impedance') ?
                        (this.circleCenterX - this.areaRadius) : (this.circleCenterX + this.areaRadius),
                    centerY: this.circleCenterY,
                    angle: (smithchart.renderType === 'Impedance') ?
                        180 : 360,
                    value: y,
                    radius: this.areaRadius,
                    region: null
                });
            }
        }
    };
    AxisRender.prototype.circleXYRadianValue = function (centerX, centerY, outterX, outterY) {
        var radian;
        radian = Math.atan2(outterY - centerY, outterX - centerX);
        radian = radian < 0 ? (radian + (360 * Math.PI / 180)) : radian;
        return radian;
    };
    AxisRender.prototype.calculateMajorArcStartEndPoints = function (radialPoint, value, smithchart) {
        var arcPoints = [];
        var circlePoint = [];
        var cx = this.circleCenterX;
        var cy = this.circleCenterY;
        if (value >= 10) {
            arcPoints[0] = (smithchart.renderType === 'Impedance') ?
                { x: cx + this.areaRadius, y: cy } : { x: cx - this.areaRadius, y: cy };
        }
        else if (value >= 3) {
            circlePoint = this.horizontalLabelCollections.filter(function (c) { return c.value === 10; });
        }
        else if (value >= 1) {
            circlePoint = this.horizontalLabelCollections.filter(function (c) { return c.value === 5; });
        }
        else {
            circlePoint = this.horizontalLabelCollections.filter(function (c) { return c.value === 3; });
        }
        if (circlePoint.length > 0) {
            arcPoints[0] = this.intersectingCirclePoints(radialPoint.centerX, radialPoint.centerY, radialPoint.radius, circlePoint[0].centerX, circlePoint[0].centerY, circlePoint[0].radius, smithchart.renderType);
        }
        arcPoints[1] = this.intersectingCirclePoints(radialPoint.centerX, radialPoint.centerY, radialPoint.radius, cx, cy, this.areaRadius, smithchart.renderType);
        return arcPoints;
    };
    AxisRender.prototype.calculateHMajorArcStartEndPoints = function (value) {
        var arcHPoints = [];
        var calValue1;
        var calValue2;
        if (value <= 0.3) {
            calValue1 = 2.0;
            calValue2 = -2.0;
        }
        else if (value <= 1.0) {
            calValue1 = 3.0;
            calValue2 = -3.0;
        }
        else if (value <= 2.0) {
            calValue1 = 5.0;
            calValue2 = -5.0;
        }
        else if (value <= 5.0) {
            calValue1 = 10.0;
            calValue2 = -10.0;
        }
        else {
            calValue1 = 50.0;
            calValue2 = -50.0;
        }
        arcHPoints[0] = this.radialLabelCollections.filter(function (c) { return c.value === calValue1; });
        arcHPoints[1] = this.radialLabelCollections.filter(function (c) { return c.value === calValue2; });
        return arcHPoints;
    };
    AxisRender.prototype.calculateMinorArcStartEndPoints = function (value) {
        var calValue1;
        var calValue2;
        var marcHPoints = [];
        if (value <= 0.1) {
            calValue1 = 1.0;
            calValue2 = -1.0;
        }
        else if (value <= 0.2) {
            calValue1 = 0.8;
            calValue2 = -0.8;
        }
        else if (value <= 0.3) {
            calValue1 = 0.4;
            calValue2 = -0.4;
        }
        else if (value <= 0.6) {
            calValue1 = 1.0;
            calValue2 = -1.0;
        }
        else if (value <= 1.0) {
            calValue1 = 1.5;
            calValue2 = -1.5;
        }
        else if (value <= 1.5) {
            calValue1 = 2.0;
            calValue2 = -2.0;
        }
        else if (value <= 2.0) {
            calValue1 = 1.0;
            calValue2 = -1.0;
        }
        else if (value <= 5.0) {
            calValue1 = 3.0;
            calValue2 = -3.0;
        }
        else {
            calValue1 = 10.0;
            calValue2 = -10.0;
        }
        marcHPoints[0] = this.radialLabelCollections.filter(function (c) { return c['value'] === calValue1; });
        marcHPoints[1] = this.radialLabelCollections.filter(function (c) { return c['value'] === calValue2; });
        return marcHPoints;
    };
    AxisRender.prototype.intersectingCirclePoints = function (x1, y1, r1, x2, y2, r2, renderType) {
        var point = { x: 0, y: 0 };
        var cx = x1 - x2;
        var cy = y1 - y2;
        var midRadius = Math.sqrt(cx * cx + cy * cy);
        var radiusSquare = midRadius * midRadius;
        var a = (r1 * r1 - r2 * r2) / (2 * radiusSquare);
        var radiusSquare2 = (r1 * r1 - r2 * r2);
        var c = Math.sqrt(2 * (r1 * r1 + r2 * r2) / radiusSquare - (radiusSquare2 * radiusSquare2) / (radiusSquare * radiusSquare) - 1);
        var fx = (x1 + x2) / 2 + a * (x2 - x1);
        var gx = c * (y2 - y1) / 2;
        var ix1 = fx + gx;
        var ix2 = fx - gx;
        var fy = (y1 + y2) / 2 + a * (y2 - y1);
        var gy = c * (x1 - x2) / 2;
        var iy1 = fy + gy;
        var iy2 = fy - gy;
        if (renderType === 'Impedance') {
            if (ix2 < ix1) {
                point.x = ix2;
                point.y = iy2;
            }
            else {
                point.x = ix1;
                point.y = iy1;
            }
        }
        else {
            if (ix1 > ix2) {
                point.x = ix1;
                point.y = iy1;
            }
            else {
                point.x = ix2;
                point.y = iy2;
            }
        }
        return { x: point.x, y: point.y };
    };
    AxisRender.prototype.updateHMajorGridLines = function (smithchart) {
        var majorGridLine = smithchart.horizontalAxis.majorGridLines;
        var groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_horizontalAxisMajorGridLines' });
        groupElement.setAttribute('aria-hidden', 'true');
        var path = this.calculateGridLinesPath(this.majorHGridArcPoints);
        var haxismgoptions = new PathOption$1(smithchart.element.id + '_horizontalAxisMajorGridLines', 'none', majorGridLine['width'], majorGridLine.color ? majorGridLine.color : smithchart.themeStyle.majorGridLine, majorGridLine['opacity'], majorGridLine['dashArray'], path);
        var element = smithchart.renderer.drawPath(haxismgoptions);
        groupElement.appendChild(element);
        smithchart.svgObject.appendChild(groupElement);
    };
    AxisRender.prototype.updateRMajorGridLines = function (smithchart) {
        var majorGridLine = smithchart.radialAxis.majorGridLines;
        var groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_radialAxisMajorGridLines' });
        groupElement.setAttribute('aria-hidden', 'true');
        var path = this.calculateGridLinesPath(this.majorRGridArcPoints);
        var raxismgoptions = new PathOption$1(smithchart.element.id + '_radialAxisMajorGridLines', 'none', majorGridLine['width'], majorGridLine.color ? majorGridLine.color : smithchart.themeStyle.majorGridLine, majorGridLine['opacity'], majorGridLine['dashArray'], path);
        var element = smithchart.renderer.drawPath(raxismgoptions);
        groupElement.appendChild(element);
        smithchart.svgObject.appendChild(groupElement);
    };
    AxisRender.prototype.updateHAxisLine = function (smithchart) {
        var radius = this.areaRadius;
        var axisLine = smithchart.horizontalAxis.axisLine;
        var groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_hAxisLine' });
        groupElement.setAttribute('aria-hidden', 'true');
        var point1 = { x: this.circleCenterX + radius, y: this.circleCenterY };
        var point2 = { x: this.circleCenterX + radius, y: (this.circleCenterY - 0.05) };
        var size = { width: radius, height: radius };
        var sweep = this.direction['clockwise'];
        var isLargeArc = 1;
        var angle = Math.PI * 2;
        var direction = 'M' + '' + point1.x + ' ' + point1.y + ' ' + 'A' + ' ' + size.width +
            ' ' + size.height + ' ' + angle + ' ' + isLargeArc + ' ' + sweep + ' ' + point2.x + ' ' + point2.y + '';
        var options = new PathOption$1(smithchart.element.id + '_horizontalAxisLine', 'none', axisLine.width, axisLine.color ? axisLine.color : smithchart.themeStyle.axisLine, 1, axisLine.dashArray, direction);
        var element = smithchart.renderer.drawPath(options);
        groupElement.appendChild(element);
        smithchart.svgObject.appendChild(groupElement);
    };
    AxisRender.prototype.updateRAxisLine = function (smithchart) {
        var radius = this.areaRadius;
        var axisLine = smithchart.radialAxis.axisLine;
        var point1 = { x: this.circleCenterX - radius, y: this.circleCenterY };
        var point2 = { x: this.circleCenterX + radius, y: this.circleCenterY };
        var size = { width: 0, height: 0 };
        var sweep = this.direction['counterclockwise'];
        var isLargeArc = 0;
        var angle = 0;
        var direction = 'M' + ' ' + point1.x + ' ' + point1.y + ' ' + 'A' + ' ' +
            size.width + ' ' + size.height + ' ' + angle + ' ' + isLargeArc + ' ' + sweep + ' ' +
            point2.x + ' ' + point2.y + '';
        var options = new PathOption$1(smithchart.element.id + '_radialAxisLine', 'none', axisLine.width, axisLine.color ? axisLine.color : smithchart.themeStyle.axisLine, 1, axisLine.dashArray, direction);
        var groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_rAxisLine' });
        groupElement.setAttribute('aria-hidden', 'true');
        var element = smithchart.renderer.drawPath(options);
        groupElement.appendChild(element);
        smithchart.svgObject.appendChild(groupElement);
    };
    AxisRender.prototype.drawHAxisLabels = function (smithchart) {
        var hAxis = smithchart.horizontalAxis;
        smithchart.radialAxis.labelStyle.fontFamily = smithchart.themeStyle.fontFamily || smithchart.radialAxis.labelStyle.fontFamily;
        var font = smithchart.horizontalAxis.labelStyle;
        var circleAxis;
        var label;
        var x;
        var y;
        var textSize;
        var curLabel;
        var curLabelBounds;
        var curWidth;
        var curX;
        var preLabel;
        var preLabelBounds;
        var preWidth;
        var preX;
        var groupEle = smithchart.renderer.createGroup({ id: smithchart.element.id + '_HAxisLabels' });
        groupEle.setAttribute('aria-hidden', 'true');
        var _loop_1 = function (i) {
            circleAxis = this_1.horizontalLabelCollections[i];
            label = this_1.horizontalLabelCollections[i].value.toString();
            if (circleAxis.value !== 0.0) {
                x = (smithchart.renderType === 'Impedance') ?
                    circleAxis.centerX - circleAxis.radius : circleAxis.centerX + circleAxis.radius;
                y = circleAxis.centerY;
                textSize = measureText$1(label, font, smithchart.themeStyle.axisLabelFont);
                x = (smithchart.renderType === 'Impedance') ? x - textSize.width : x;
                if (hAxis.labelPosition === 'Outside') {
                    y -= textSize.height / 4;
                }
                else {
                    y += textSize.height;
                }
                this_1.horizontalLabelCollections[i].region = this_1.calculateRegion(label, textSize, x, y);
                if (hAxis.labelIntersectAction === 'Hide') {
                    curLabel = this_1.horizontalLabelCollections[i];
                    curLabelBounds = curLabel.region.bounds;
                    curWidth = curLabelBounds.width;
                    curX = curLabelBounds.x;
                    for (var j = 1; j < i; j++) {
                        preLabel = this_1.horizontalLabelCollections[j];
                        preLabelBounds = preLabel.region.bounds;
                        preWidth = preLabelBounds.width;
                        preX = preLabelBounds.x;
                        if ((smithchart.renderType === 'Impedance') &&
                            (preX + preWidth) > (curX)) {
                            label = '';
                        }
                        if ((smithchart.renderType === 'Admittance') &&
                            (preX) < curX + curWidth) {
                            label = '';
                        }
                    }
                }
                var axisLabelRenderEventArgs_1 = {
                    text: label.toString(),
                    x: x,
                    y: y,
                    name: axisLabelRender$1,
                    cancel: false
                };
                var axisLabelRenderSuccess = function (args) {
                    if (!args.cancel) {
                        var options = new TextOption$1(smithchart.element.id + '_HLabel_' + i, axisLabelRenderEventArgs_1.x, axisLabelRenderEventArgs_1.y, 'none', axisLabelRenderEventArgs_1.text);
                        var color = font.color ? font.color : smithchart.themeStyle.axisLabelFont.color;
                        font.fontFamily = font.fontFamily || smithchart.themeStyle.labelFontFamily;
                        var element = renderTextElement(options, font, color, groupEle, smithchart.themeStyle.axisLabelFont);
                        groupEle.appendChild(element);
                    }
                };
                axisLabelRenderSuccess.bind(this_1);
                smithchart.trigger(axisLabelRender$1, axisLabelRenderEventArgs_1, axisLabelRenderSuccess);
            }
        };
        var this_1 = this;
        for (var i = 0; i < this.horizontalLabelCollections.length; i++) {
            _loop_1(i);
        }
        smithchart.svgObject.appendChild(groupEle);
    };
    AxisRender.prototype.drawRAxisLabels = function (smithchart) {
        var paddingRadius = 2;
        smithchart.radialAxis.labelStyle.fontFamily = smithchart.themeStyle.fontFamily || smithchart.radialAxis.labelStyle.fontFamily;
        var font = smithchart.radialAxis.labelStyle;
        var interSectPoint = new RadialLabelCollections();
        var label;
        var textSize;
        var angle;
        var position;
        var textPosition;
        var curX;
        var curY;
        var curWidth;
        var curHeight;
        var curLabel;
        var curLabelBounds;
        var preX;
        var preY;
        var preWidth;
        var preHeight;
        var preLabel;
        var preLabelBounds;
        var rAxis = smithchart.radialAxis;
        var groupEle = smithchart.renderer.createGroup({ id: smithchart.element.id + '_RAxisLabels' });
        groupEle.setAttribute('aria-hidden', 'true');
        var _loop_2 = function (i) {
            interSectPoint = this_2.labelCollections[i];
            label = interSectPoint.value.toString();
            textSize = measureText$1(label, font, smithchart.themeStyle.axisLabelFont);
            angle = Math.round(interSectPoint.angle * 100) / 100;
            if (rAxis.labelPosition === 'Outside') {
                position = this_2.circlePointPosition(this_2.circleCenterX, this_2.circleCenterY, interSectPoint['angle'], this_2.areaRadius + paddingRadius);
                textPosition = this_2.setLabelsOutsidePosition(angle, position.x, position.y, textSize);
            }
            else {
                position = this_2.circlePointPosition(this_2.circleCenterX, this_2.circleCenterY, interSectPoint['angle'], this_2.areaRadius - paddingRadius);
                textPosition = this_2.setLabelsInsidePosition(angle, position.x, position.y, textSize);
            }
            this_2.labelCollections[i]['region'] = this_2.calculateRegion(label, textSize, textPosition.x, textPosition.y);
            if (rAxis.labelIntersectAction === 'Hide') {
                curLabel = this_2.labelCollections[i];
                curLabelBounds = curLabel['region']['bounds'];
                curWidth = curLabelBounds['width'];
                curHeight = curLabelBounds['height'];
                curX = curLabelBounds['x'];
                curY = curLabelBounds['y'];
                for (var j = 0; j < i; j++) {
                    preLabel = this_2.labelCollections[j];
                    preLabelBounds = preLabel['region']['bounds'];
                    preWidth = preLabelBounds['width'];
                    preHeight = preLabelBounds['height'];
                    preX = preLabelBounds['x'];
                    preY = preLabelBounds['y'];
                    if ((preX <= curX + curWidth) && (curX <= preX + preWidth) && (preY <= curY + curHeight)
                        && (curY <= preY + preHeight)) {
                        label = ' ';
                    }
                }
            }
            var axisLabelRenderEventArgs = {
                text: label.toString(),
                x: textPosition.x,
                y: textPosition.y,
                name: axisLabelRender$1,
                cancel: false
            };
            var axisLabelRenderSuccess = function (args) {
                if (!args.cancel) {
                    var options = new TextOption$1(smithchart.element.id + '_RLabel_' + i, axisLabelRenderEventArgs.x, axisLabelRenderEventArgs.y, 'none', axisLabelRenderEventArgs.text);
                    var color = font.color ? font.color : smithchart.themeStyle.axisLabelFont.color;
                    font.fontFamily = smithchart.themeStyle.labelFontFamily ? smithchart.themeStyle.labelFontFamily : font.fontFamily;
                    var element = renderTextElement(options, font, color, groupEle, smithchart.themeStyle.axisLabelFont);
                    groupEle.appendChild(element);
                }
            };
            axisLabelRenderSuccess.bind(this_2);
            smithchart.trigger(axisLabelRender$1, axisLabelRenderEventArgs, axisLabelRenderSuccess);
        };
        var this_2 = this;
        for (var i = 0; i < this.labelCollections.length; i++) {
            _loop_2(i);
        }
        smithchart.svgObject.appendChild(groupEle);
    };
    AxisRender.prototype.calculateRegion = function (label, textSize, textPositionX, textPositionY) {
        var xAxisLabelRegions = new LabelRegion();
        var bounds = { x: textPositionX, y: textPositionY, width: textSize.width, height: textSize.height };
        xAxisLabelRegions = { bounds: bounds, labelText: label };
        return xAxisLabelRegions;
    };
    AxisRender.prototype.updateHMinorGridLines = function (smithchart) {
        var minorGridLine = smithchart.horizontalAxis.minorGridLines;
        var groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_horizontalAxisMinorGridLines' });
        var path = this.calculateGridLinesPath(this.minorHGridArcPoints);
        var haxismioptions = new PathOption$1(smithchart.element.id + '_horizontalAxisMinorGridLines', 'none', minorGridLine['width'], minorGridLine.color ? minorGridLine.color : smithchart.themeStyle.minorGridLine, minorGridLine['opacity'], minorGridLine['dashArray'], path);
        var element = smithchart.renderer.drawPath(haxismioptions);
        groupElement.appendChild(element);
        smithchart.svgObject.appendChild(groupElement);
    };
    AxisRender.prototype.updateRMinorGridLines = function (smithchart) {
        var minorGridLine = smithchart.radialAxis.minorGridLines;
        var groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_radialAxisMinorGridLines' });
        var path = this.calculateGridLinesPath(this.minorGridArcPoints);
        var raxismioptions = new PathOption$1(smithchart.element.id + '_radialAxisMinorGridLines', 'none', minorGridLine['width'], minorGridLine.color ? minorGridLine.color : smithchart.themeStyle.minorGridLine, minorGridLine['opacity'], minorGridLine['dashArray'], path);
        var element = smithchart.renderer.drawPath(raxismioptions);
        groupElement.appendChild(element);
        smithchart.svgObject.appendChild(groupElement);
    };
    AxisRender.prototype.calculateGridLinesPath = function (points) {
        var x1;
        var y1;
        var x2;
        var y2;
        var r1;
        var r2;
        var pathSegment = new GridArcPoints();
        var angle;
        var isLargeArc;
        var sweep;
        var sb = '';
        for (var i = 0; i < points.length; i++) {
            pathSegment = points[i];
            x1 = pathSegment.startPoint.x;
            y1 = pathSegment.startPoint.y;
            x2 = pathSegment.endPoint.x;
            y2 = pathSegment.endPoint.y;
            r1 = pathSegment.size ? pathSegment.size.width : 0;
            r2 = pathSegment.size ? pathSegment.size.height : 0;
            angle = pathSegment.rotationAngle ? pathSegment.rotationAngle : 0;
            isLargeArc = pathSegment.isLargeArc ? 1 : 0;
            sweep = pathSegment.sweepDirection ? pathSegment.sweepDirection : 0;
            sb = sb + ('M' + ' ' + x1 + ' ' + y1 + ' ' + 'A' + ' ' + r1 + ' ' + r2 + ' ' +
                angle + ' ' + isLargeArc + ' ' + sweep + ' ' + x2 + ' ' + y2 + ' ');
        }
        var path = sb.toString();
        return path;
    };
    AxisRender.prototype.measureHMinorGridLines = function (smithchart) {
        var radialPoint1;
        var radialPoint2;
        var arcPoints = [];
        var isLargeArc;
        var startPoint;
        var endPoint;
        var size;
        var cx;
        var maxCount = smithchart.horizontalAxis.minorGridLines.count;
        var previous;
        var next;
        var space;
        var count;
        var interval;
        var radius;
        var leftX;
        this.minorHGridArcPoints = [];
        var diameter = this.areaRadius * 2;
        for (var i = 0; i < this.horizontalLabelCollections.length - 3; i++) {
            previous = this.horizontalLabelCollections[i];
            next = this.horizontalLabelCollections[i + 1];
            space = (previous['radius'] - next['radius']) * 2;
            count = Math.floor((maxCount / 100) * space);
            interval = space / count;
            for (var j = 0; j < count; j++) {
                radius = next['radius'] + (j * interval) / 2;
                leftX = (smithchart.renderType === 'Impedance') ?
                    (this.circleLeftX + diameter) - (radius * 2) : this.circleLeftX;
                cx = leftX + radius;
                isLargeArc = next['value'] > 5;
                arcPoints = this.calculateMinorArcStartEndPoints(next['value']);
                if (smithchart.renderType === 'Impedance') {
                    radialPoint1 = arcPoints[0];
                    radialPoint2 = arcPoints[1];
                }
                else {
                    radialPoint1 = arcPoints[1];
                    radialPoint2 = arcPoints[0];
                }
                startPoint = this.intersectingCirclePoints(radialPoint1[0].centerX, radialPoint1[0].centerY, radialPoint1[0].radius, cx, previous['centerY'], radius, smithchart.renderType);
                endPoint = this.intersectingCirclePoints(radialPoint2[0].centerX, radialPoint2[0].centerY, radialPoint2[0].radius, cx, previous['centerY'], radius, smithchart.renderType);
                size = { width: radius, height: radius };
                this.minorHGridArcPoints.push({
                    startPoint: startPoint,
                    endPoint: endPoint,
                    rotationAngle: 2 * Math.PI,
                    sweepDirection: (smithchart.renderType === 'Impedance') ?
                        this.direction['counterclockwise'] : this.direction['clockwise'],
                    isLargeArc: isLargeArc,
                    size: size
                });
            }
        }
    };
    AxisRender.prototype.measureRMinorGridLines = function (smithchart) {
        var maxCount = smithchart.radialAxis.minorGridLines.count;
        var arcCx;
        var nextAngle;
        var betweenAngle;
        var circlePoint;
        var previous;
        var next;
        var size;
        var distance;
        var count;
        var interval;
        var centerValue;
        var circumference = Math.PI * (this.areaRadius * 2);
        var arcStartX = arcCx = (smithchart.renderType === 'Impedance') ?
            this.circleCenterX + this.areaRadius : this.circleCenterX - this.areaRadius;
        var arcStartY = this.circleCenterY;
        this.minorGridArcPoints = [];
        var arcStartPoint = { x: arcStartX, y: arcStartY };
        for (var i = 2; i < this.labelCollections.length - 3; i++) {
            previous = this.labelCollections[i];
            next = this.labelCollections[i + 1];
            if (smithchart.renderType === 'Impedance') {
                nextAngle = next['angle'] === 360 ? 0 : next['angle'];
                betweenAngle = Math.abs(nextAngle - previous['angle']);
            }
            else {
                nextAngle = previous['angle'] === 360 ? 0 : previous['angle'];
                betweenAngle = Math.abs(nextAngle - next['angle']);
            }
            distance = (circumference / 360) * betweenAngle;
            count = Math.floor((maxCount / 100) * distance);
            interval = betweenAngle / count;
            centerValue = next['value'] > 0 ? next['value'] : previous['value'];
            circlePoint = this.minorGridLineArcIntersectCircle(Math.abs(centerValue));
            for (var j = 1; j < count; j++) {
                var outterInterSectAngle = (interval * j) + (previous['angle'] === 360 ? nextAngle : previous['angle']);
                var outerInterSectPoint = this.circlePointPosition(this.circleCenterX, this.circleCenterY, outterInterSectAngle, this.areaRadius);
                var radius = this.arcRadius(arcStartPoint, outerInterSectPoint, outterInterSectAngle);
                var arcCy = outterInterSectAngle > 180 ? this.circleCenterY - radius : this.circleCenterY + radius;
                var innerInterSectPoint = this.intersectingCirclePoints(arcCx, arcCy, radius, circlePoint[0].centerX, circlePoint[0].centerY, circlePoint[0].radius, smithchart.renderType);
                var startPoint = { x: innerInterSectPoint.x, y: innerInterSectPoint.y };
                var endPoint = { x: outerInterSectPoint.x, y: outerInterSectPoint.y };
                size = { width: radius, height: radius };
                var sweepDirection = previous['value'] >= 0 ? this.direction['clockwise'] : this.direction['counterclockwise'];
                this.minorGridArcPoints.push({
                    startPoint: startPoint,
                    endPoint: endPoint,
                    rotationAngle: 2 * Math.PI,
                    sweepDirection: sweepDirection,
                    isLargeArc: false,
                    size: size
                });
                
            }
        }
    };
    AxisRender.prototype.minorGridLineArcIntersectCircle = function (centerValue) {
        var calValue;
        if (centerValue >= 3) {
            calValue = 20;
        }
        else if (centerValue >= 1.5) {
            calValue = 10;
        }
        else if (centerValue >= 0.6) {
            calValue = 3;
        }
        else {
            calValue = 2;
        }
        var circlePoint = this.horizontalLabelCollections.filter(function (c) { return c['value'] === calValue; });
        return circlePoint;
    };
    AxisRender.prototype.circlePointPosition = function (cx, cy, angle, r) {
        var radian = angle * (Math.PI / 180);
        var pointX = cx + r * Math.cos(radian);
        var pointY = cy + r * Math.sin(radian);
        return { x: pointX, y: pointY };
    };
    AxisRender.prototype.setLabelsInsidePosition = function (angle, px, py, textSize) {
        var x = px;
        var y = py;
        if (angle === 0 || angle === 360) {
            x -= textSize.width;
            y -= textSize.height / 2;
        }
        else if (angle === 90) {
            x -= textSize.width;
            y += textSize.height / 8;
        }
        else if (angle === 180) {
            y += textSize.height;
        }
        else if (angle === 270) {
            y += textSize.height / 2;
        }
        else if (angle > 0 && angle <= 20) {
            x -= (textSize.width);
        }
        else if (angle > 20 && angle <= 60) {
            x -= (textSize.width + textSize.width / 2);
            y += textSize.height / 2;
        }
        else if (angle > 60 && angle < 90) {
            x -= (textSize.width + textSize.width / 4);
            y += textSize.height / 4;
        }
        else if (angle > 90 && angle <= 135) {
            x -= (textSize.width / 2);
            y += (textSize.height) / 16;
        }
        else if (angle > 135 && angle <= 150) {
            x += (textSize.width / 2);
            y += (textSize.height / 2);
        }
        else if (angle > 150 && angle < 180) {
            x += (textSize.width / 2);
            y += (textSize.height);
        }
        else if (angle > 180 && angle <= 210) {
            x += (textSize.width / 6);
            y += (textSize.height / 6);
        }
        else if (angle > 210 && angle < 240) {
            y += (textSize.height / 4);
        }
        else if (angle > 225 && angle < 270) {
            y += (textSize.height / 3);
        }
        else if (angle > 270 && angle <= 300) {
            x -= (textSize.width + textSize.width / 4);
            y += (textSize.height / 4);
        }
        else if (angle > 300 && angle <= 330) {
            x -= (textSize.width + textSize.width / 3);
            y += (textSize.height / 4);
        }
        else if (angle > 330 && angle <= 340) {
            x -= (textSize.width + textSize.width / 2);
            y += textSize.height / 4;
        }
        else if (angle > 340) {
            x -= textSize.width;
            y += textSize.height / 8;
        }
        return { x: x, y: y };
    };
    AxisRender.prototype.setLabelsOutsidePosition = function (angle, px, py, textSize) {
        var x = px;
        var y = py;
        if (angle === 90) {
            x -= textSize.width / 2;
            y += textSize.height;
        }
        else if (angle === 180) {
            x -= (textSize.width + 5);
            y -= textSize.height / 4;
        }
        else if (angle === 270) {
            x -= textSize.width / 2;
            y -= textSize.height / 4;
        }
        else if (angle === 360) {
            x += 5;
            y -= textSize.height / 2;
        }
        else if (angle > 0 && angle <= 30) {
            x += textSize.width / 4;
            y += textSize.height / 8;
        }
        else if (angle > 30 && angle <= 60) {
            x += textSize.width / 2;
            y += textSize.height / 4;
        }
        else if (angle > 60 && angle <= 90) {
            x -= textSize.width / 2;
            y += textSize.height;
        }
        else if (angle > 90 && angle <= 135) {
            x -= textSize.width;
            y += textSize.height;
        }
        else if (angle > 135 && angle <= 180) {
            x -= (textSize.width + textSize.width / 4);
            y += textSize.height / 4;
        }
        else if (angle > 180 && angle <= 210) {
            x -= textSize.width + textSize.width / 4;
            y -= textSize.height / 4;
        }
        else if (angle > 210 && angle <= 270) {
            x -= textSize.width;
            y -= textSize.height / 4;
        }
        else if (angle > 270 && angle <= 340) {
            y -= textSize.height / 4;
        }
        else if (angle > 340) {
            y += textSize.height / 4;
            x += textSize.width / 6;
        }
        return { x: x, y: y };
    };
    AxisRender.prototype.arcRadius = function (startPoint, endPoint, angle) {
        var radian = angle > 180 ? (90 * Math.PI / 180) : (270 * Math.PI / 180); // Angle 90 and 270 used for calculating upper and lower circle
        var mx = (endPoint.x - startPoint.x) / 2;
        var my = (endPoint.y - startPoint.y) / 2;
        var u = (Math.cos(radian) * my - Math.sin(radian) * mx) / (Math.cos(radian) * mx + Math.sin(radian) * my);
        var t = (my - mx * u) / Math.sin(radian);
        var cy = startPoint.y + Math.sin(radian) * t;
        var radius = Math.abs(startPoint.y - cy);
        return radius;
    };
    return AxisRender;
}());

var Marker$1 = /** @__PURE__ @class */ (function () {
    function Marker() {
    }
    Marker.prototype.drawMarker = function (smithchart, seriesindex, groupElement, pointsRegion) {
        if (smithchart.series[seriesindex].marker.visible) {
            var marker = smithchart.series[seriesindex].marker;
            var count = smithchart.series[seriesindex].points.length - 1;
            var width = marker.width;
            var height = marker.height;
            var symbolName = marker.shape;
            var gmEle = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' +
                    '_series' + seriesindex + '_Marker' });
            groupElement.appendChild(gmEle);
            var borderWidth = marker.border.width;
            var borderColor = marker.border.color;
            var opacity = marker.opacity;
            var fill = marker.fill ? marker.fill : (smithchart.series[seriesindex].fill ||
                smithchart.seriesColors[seriesindex % smithchart.seriesColors.length]);
            for (var i = 0; i < count + 1; i++) {
                var location_1 = pointsRegion[i]['point'];
                var pointIndex = i;
                var options = new MarkerOptions(smithchart.element.id + '_Series' + seriesindex + '_Points' + pointIndex + '_Marker' + pointIndex, fill, borderColor, borderWidth, opacity);
                gmEle.appendChild(this.drawSymbol(symbolName, marker.imageUrl, location_1, new SmithchartSize(width, height), options, smithchart));
            }
        }
    };
    Marker.prototype.drawSymbol = function (symbolName, url, location, size, options, smithchart) {
        var markerEle;
        var shape = symbolName.toLowerCase();
        var circleOptions;
        var pathOptions;
        var path;
        var border = { color: options['borderColor'], width: options['borderWidth'] };
        var opacity = options.opacity;
        var startX = location.x;
        var startY = location.y;
        var radius = Math.sqrt(size.height * size.height + size.width * size.width) / 2;
        var eq = 72;
        switch (shape) {
            case 'circle':
                circleOptions = new CircleOption$1(options['id'], options['fill'], border, opacity, location.x, location.y, radius, null);
                markerEle = smithchart.renderer.drawCircle(circleOptions);
                break;
            case 'rectangle':
                path = 'M' + ' ' + (startX + (-size.width / 2)) + ' ' + (startY + (-size.height / 2)) +
                    ' ' + 'L' + ' ' + (startX + (size.width / 2)) + ' ' + (startY + (-size.height / 2)) + ' ' +
                    'L' + ' ' + (startX + (size.width / 2)) + ' ' + (startY + (size.height / 2)) +
                    ' ' + 'L' + ' ' + (startX + (-size.width / 2)) +
                    ' ' + (startY + (size.height / 2)) + ' ' + 'L' + ' ' +
                    (startX + (-size.width / 2)) + ' ' + (startY + (-size.height / 2)) + 'z';
                pathOptions = new PathOption$1(options['id'], options['fill'], border.width, border.color, opacity, '', path);
                markerEle = smithchart.renderer.drawPath(pathOptions);
                break;
            case 'triangle':
                path = 'M' + ' ' + (startX + (-size.width / 2)) + ' ' + (startY + (size.height / 2)) + ' ' + 'L' + ' ' + (startX) + ' ' +
                    (startY + (-size.height / 2)) + ' ' + 'L' + ' ' + (startX + (size.width / 2)) + ' ' +
                    (startY + (size.height / 2)) + ' ' + 'L' + ' ' +
                    (startX + (-size.width / 2)) + ' ' + (startY + (size.height / 2)) + 'z';
                pathOptions = new PathOption$1(options['id'], options['fill'], border.width, border.color, opacity, '', path);
                markerEle = smithchart.renderer.drawPath(pathOptions);
                break;
            case 'diamond':
                path = 'M' + ' ' + (startX + (-size.width / 2)) + ' ' + (startY) + ' ' + 'L' + ' ' +
                    (startX) + ' ' + (startY + (-size.height / 2)) + ' ' + 'L' + ' ' + (startX + (size.width / 2)) + ' ' +
                    (startY) + ' ' + 'L' + ' ' + (startX) + ' ' + (startY + (size.height / 2)) + ' ' + 'L' + ' ' +
                    (startX + (-size.width / 2)) + ' ' + (startY) + 'z';
                pathOptions = new PathOption$1(options['id'], options['fill'], border.width, border.color, opacity, '', path);
                markerEle = smithchart.renderer.drawPath(pathOptions);
                break;
            case 'pentagon':
                for (var i = 0; i <= 5; i++) {
                    var xValue = radius * Math.cos((Math.PI / 180) * (i * eq));
                    var yValue = radius * Math.sin((Math.PI / 180) * (i * eq));
                    if (i === 0) {
                        path = 'M' + ' ' + (startX + xValue) + ' ' + (startY + yValue) + ' ';
                    }
                    else {
                        path = path.concat('L' + ' ' + (startX + xValue) + ' ' + (startY + yValue) + ' ');
                    }
                }
                path = path.concat('Z');
                pathOptions = new PathOption$1(options['id'], options['fill'], border.width, border.color, opacity, '', path);
                markerEle = smithchart.renderer.drawPath(pathOptions);
                break;
        }
        markerEle.setAttribute('role', 'img');
        markerEle.setAttribute('aria-label', 'x: ' + (location.x) + ', ' + 'y: ' + (location.y));
        return markerEle;
    };
    return Marker;
}());

var DataLabel$1 = /** @__PURE__ @class */ (function () {
    function DataLabel() {
        this.textOptions = [];
        this.labelOptions = [];
        this.allPoints = [];
    }
    DataLabel.prototype.drawDataLabel = function (smithchart, seriesindex, groupElement, pointsRegion, bounds) {
        this.textOptions = [];
        this.allPoints = [];
        var margin = smithchart.margin;
        var pointIndex;
        var marker = smithchart.series[seriesindex].marker;
        var region;
        var labelPosition;
        var labelText;
        var textSize;
        var dataLabel = marker.dataLabel;
        var font = dataLabel.textStyle;
        var count = pointsRegion.length;
        for (var i = 0; i < count; i++) {
            labelText = smithchart.series[seriesindex].points[i].reactance.toString();
            textSize = measureText$1(labelText, font, smithchart.themeStyle.dataLabelFont);
            region = pointsRegion[i]['point'];
            var xPos = region.x - textSize.width / 2;
            var yPos = region.y - (textSize.height + marker['height'] + (margin.top));
            var width = textSize.width + (margin.left / 2) + (margin.right / 2);
            var height = textSize.height + (margin.top / 2) + (margin.bottom / 2);
            font.fontFamily = font.fontFamily ? font.fontFamily : smithchart.themeStyle.dataLabelFont.fontFamily;
            pointIndex = i;
            labelPosition = new SmithchartLabelPosition();
            labelPosition = { textX: xPos + (margin.left / 2), textY: yPos + (height / 2) + margin.top / 2, x: xPos, y: yPos };
            this.textOptions[i] = {
                id: smithchart.element.id + '_Series' + seriesindex + '_Points' + pointIndex + '_dataLabel' + '_displayText' + i,
                x: labelPosition['textX'],
                y: labelPosition['textY'],
                fill: 'black',
                text: labelText,
                font: font,
                xPosition: xPos,
                yPosition: yPos,
                width: width,
                height: height,
                location: region,
                labelOptions: labelPosition,
                visible: true,
                connectorFlag: null
            };
        }
        var labelOption = new LabelOption();
        labelOption.textOptions = this.textOptions;
        this.labelOptions.push(labelOption);
        this.drawDatalabelSymbol(smithchart, seriesindex, dataLabel, groupElement, bounds, pointsRegion);
    };
    DataLabel.prototype.calculateSmartLabels = function (points, seriesIndex) {
        var length = points['textOptions'].length;
        var count = 0;
        for (var k = 0; k < length; k++) {
            this.allPoints[this.allPoints.length] = points['textOptions'][k];
            this.connectorFlag = false;
            this.compareDataLabels(k, points, count, seriesIndex);
            this.labelOptions[seriesIndex]['textOptions'][k] = points['textOptions'][k];
            this.labelOptions[seriesIndex]['textOptions'][k].connectorFlag = this.connectorFlag;
        }
    };
    DataLabel.prototype.compareDataLabels = function (i, points, count, m) {
        var length = this.allPoints.length;
        var padding = 10;
        var collide;
        var currentLabel;
        var prevLabel;
        for (var j = 0; j < length; j++) {
            prevLabel = this.allPoints[j];
            currentLabel = this.allPoints[length - 1];
            collide = this.isCollide(prevLabel, currentLabel);
            if (collide) {
                this.connectorFlag = true;
                switch (count) {
                    case 0:
                        // Right
                        this.resetValues(currentLabel);
                        this.prevLabel = prevLabel;
                        currentLabel['xPosition'] = this.prevLabel['xPosition'] + (this.prevLabel['width'] / 2 +
                            currentLabel['width'] / 2 + padding);
                        currentLabel['x'] = currentLabel['xPosition'] + padding / 2;
                        count += 1;
                        this.compareDataLabels(i, points, count, m);
                        break;
                    case 1:
                        // Right Bottom
                        this.resetValues(currentLabel);
                        currentLabel['xPosition'] = this.prevLabel['xPosition'] + this.prevLabel['width'] / 2 +
                            currentLabel['width'] / 2 + padding;
                        currentLabel['x'] = currentLabel['xPosition'] + padding / 2;
                        currentLabel['yPosition'] = currentLabel['location'].y + currentLabel['height'] / 2 + padding / 2;
                        currentLabel['y'] = currentLabel['yPosition'] + ((currentLabel['height'] / 2)) + padding / 2;
                        count += 1;
                        this.compareDataLabels(i, points, count, m);
                        break;
                    case 2:
                        // Bottom
                        this.resetValues(currentLabel);
                        currentLabel['yPosition'] = currentLabel['location'].y + currentLabel['height'] / 2 + padding / 2;
                        currentLabel['y'] = currentLabel['yPosition'] + (currentLabel['height'] / 2) + padding / 2;
                        count += 1;
                        this.compareDataLabels(i, points, count, m);
                        break;
                    case 3:
                        // Left Bottom
                        this.resetValues(currentLabel);
                        currentLabel['xPosition'] = this.prevLabel['xPosition'] - this.prevLabel['width'] / 2
                            - currentLabel['width'] / 2 - padding;
                        currentLabel['x'] = currentLabel['xPosition'] + padding / 2;
                        currentLabel['yPosition'] = currentLabel['height'] / 2 + currentLabel['location'].y + padding / 2;
                        currentLabel['y'] = currentLabel['yPosition'] + ((currentLabel['height'] / 2)) + padding / 2;
                        count += 1;
                        this.compareDataLabels(i, points, count, m);
                        break;
                    case 4:
                        // Left
                        this.resetValues(currentLabel);
                        currentLabel['xPosition'] = (this.prevLabel['xPosition'] - this.prevLabel['width'] / 2 -
                            currentLabel['width'] / 2 - padding);
                        currentLabel['x'] = currentLabel['xPosition'] + padding / 2;
                        count += 1;
                        this.compareDataLabels(i, points, count, m);
                        break;
                    case 5:
                        //Left Top
                        this.resetValues(currentLabel);
                        currentLabel['xPosition'] = this.prevLabel['xPosition'] - this.prevLabel['width'] / 2 -
                            currentLabel['width'] / 2 - padding;
                        currentLabel['x'] = currentLabel['xPosition'] + padding / 2;
                        currentLabel['yPosition'] = this.prevLabel['yPosition'] - currentLabel['height'] - padding;
                        currentLabel['y'] = currentLabel['yPosition'] + currentLabel['height'] / 2 + padding / 2;
                        count += 1;
                        this.compareDataLabels(i, points, count, m);
                        break;
                    case 6:
                        // Top
                        this.resetValues(currentLabel);
                        currentLabel['yPosition'] = (this.prevLabel['yPosition']) - (currentLabel['height'] + padding);
                        currentLabel['y'] = currentLabel['yPosition'] + (currentLabel['height'] / 2) + padding / 2;
                        count += 1;
                        this.compareDataLabels(i, points, count, m);
                        break;
                    case 7:
                        // Right Top
                        this.resetValues(currentLabel);
                        currentLabel['xPosition'] = this.prevLabel['xPosition'] + this.prevLabel['width'] / 2 +
                            currentLabel['width'] / 2 + padding;
                        currentLabel['x'] = currentLabel['xPosition'] + padding / 2;
                        currentLabel['yPosition'] = this.prevLabel['yPosition'] - currentLabel['height'] - padding;
                        currentLabel['y'] = currentLabel['yPosition'] + (currentLabel['height'] / 2) + padding / 2;
                        count += 1;
                        this.compareDataLabels(i, points, count, m);
                        break;
                    case 8:
                        count = 0;
                        this.compareDataLabels(i, points, count, m);
                        break;
                }
            }
        }
    };
    DataLabel.prototype.isCollide = function (dataLabel1, dataLabel2) {
        var state = false;
        if (dataLabel1 !== dataLabel2) {
            state = !( // to compare data labels
            ((dataLabel1['y'] + dataLabel1['height']) < (dataLabel2['y'])) ||
                (dataLabel1['y'] > (dataLabel2['y'] + dataLabel2['height'])) ||
                ((dataLabel1['x'] + dataLabel1['width'] / 2) < dataLabel2['x'] - dataLabel2['width'] / 2) ||
                (dataLabel1['x'] - dataLabel1['width'] / 2 > (dataLabel2['x'] + dataLabel2['width'] / 2)));
        }
        return state;
    };
    DataLabel.prototype.resetValues = function (currentPoint) {
        currentPoint['xPosition'] = currentPoint['labelOptions']['x'];
        currentPoint['yPosition'] = currentPoint['labelOptions']['y'];
        currentPoint['x'] = currentPoint['labelOptions']['textX'];
        currentPoint['y'] = currentPoint['labelOptions']['textY'];
    };
    DataLabel.prototype.drawConnectorLines = function (smithchart, seriesIndex, index, currentPoint, groupElement) {
        var location = currentPoint['location'];
        var endY;
        if (location.y > currentPoint['y']) {
            endY = (currentPoint['y']);
        }
        else {
            endY = (currentPoint['y'] - currentPoint['height'] / 2); // bottom
        }
        var connectorDirection = 'M' + ' ' + (location.x) + ' ' + (location.y) + ' ' + 'L' + ' ' +
            (currentPoint['x']) + ' ' + (endY);
        var connectorLineValues = smithchart.series[seriesIndex].
            marker.dataLabel.connectorLine;
        var stroke = connectorLineValues.color ? connectorLineValues.color :
            (smithchart.series[seriesIndex].fill ||
                smithchart.seriesColors[seriesIndex % smithchart.seriesColors.length]);
        var options = new PathOption$1(smithchart.element.id + '_dataLabelConnectorLine' + '_series' + seriesIndex + '_point' + index, 'none', connectorLineValues.width, stroke, 1, 'none', connectorDirection);
        var element = smithchart.renderer.drawPath(options);
        groupElement.appendChild(element);
    };
    DataLabel.prototype.drawDatalabelSymbol = function (smithchart, seriesindex, dataLabel, groupElement, bounds, pointsRegion) {
        for (var i = 0; i < smithchart.series[seriesindex].points.length; i++) {
            if (dataLabel.template) {
                var labelTemplateElement = createElement('div', {
                    id: smithchart.element.id + '_seriesIndex_' + seriesindex + '_Label_Template_Group',
                    className: 'template',
                    styles: 'position: absolute;'
                    /* 'top:' + bounds['x'] + 'px;' +
                'left:' + bounds['y'] + 'px;' +
                'height:' + smithchart.availableSize.height + 'px;' +
                'width:' + smithchart.availableSize.width + 'px;'*/
                });
                document.getElementById(smithchart.element.id + '_Secondary_Element').appendChild(labelTemplateElement);
                var id = dataLabel.template + '_seriesIndex' + seriesindex + '_pointIndex' + i + smithchart.element.id;
                var data = { point: smithchart.series[seriesindex].points[i].reactance };
                var templateFn = getTemplateFunction$1(dataLabel.template);
                var templateElement = templateFn(smithchart);
                var labelElement = convertElementFromLabel(templateElement, id, data);
                labelTemplateElement.appendChild(labelElement);
                labelElement.style.left = pointsRegion[i].point.x - labelElement.offsetWidth / 2 + 'px';
                labelElement.style.top = pointsRegion[i].point.y - labelElement.offsetHeight -
                    smithchart.series[seriesindex].marker.height / 2 + 'px';
                var left = parseInt(labelElement.style.left, 10);
                var top_1 = parseInt(labelElement.style.top, 10);
                var width = labelElement.offsetWidth;
                var height = labelElement.offsetHeight;
                var region = pointsRegion[i]['point'];
                var labelPosition = { textX: left, textY: top_1,
                    x: left, y: top_1 };
                this.labelOptions[seriesindex]['textOptions'][i] = {
                    id: id,
                    x: left,
                    y: top_1,
                    fill: 'black',
                    text: '',
                    font: dataLabel.textStyle,
                    xPosition: left,
                    yPosition: top_1,
                    width: width,
                    height: height,
                    location: region,
                    labelOptions: labelPosition,
                    visible: true,
                    connectorFlag: null
                };
            }
        }
    };
    return DataLabel;
}());

var SeriesRender = /** @__PURE__ @class */ (function () {
    function SeriesRender() {
        this.xValues = [];
        this.yValues = [];
        this.pointsRegion = [];
        this.lineSegments = [];
        this.location = [];
        this.dataLabel = new DataLabel$1();
    }
    SeriesRender.prototype.processData = function (series) {
        var dataArray = series.dataSource;
        var resistance = series.resistance;
        var reactance = series.reactance;
        var tooltip = series.tooltipMappingName;
        series.points = [];
        for (var i = 0; i < dataArray.length; i++) {
            series.points.push({
                resistance: dataArray[i][resistance],
                reactance: dataArray[i][reactance],
                tooltip: dataArray[i][tooltip]
            });
        }
    };
    /* eslint-disable  */
    SeriesRender.prototype.draw = function (smithchart, axisRender, bounds) {
        var groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_seriesCollections' });
        var resistantCx;
        var reactanceCy;
        var series = smithchart.series;
        var seriesLength = series.length;
        var chartAreaRadius = axisRender.areaRadius;
        var interSectPoint;
        var index;
        for (var m = 0; m < seriesLength; m++) {
            var seriesIndex = m;
            if (series[m].dataSource && series[m].resistance && series[m].reactance) {
                this.processData(series[m]);
            }
            this.pointsRegion[m] = [];
            this.location[m] = [];
            for (var j = 0; j < series[m].points.length; j++) {
                this.xValues[j] = series[m].points[j]['resistance'];
                this.yValues[j] = series[m].points[j]['reactance'];
            }
            var chartAreaCx = axisRender.circleCenterX;
            var chartAreaCy = axisRender.circleCenterY;
            var diameter = axisRender.areaRadius * 2;
            var reactanceStartPoint = {
                x: chartAreaCx + ((smithchart.renderType === 'Impedance') ?
                    chartAreaRadius : -chartAreaRadius), y: chartAreaCy
            };
            var resistantCy = chartAreaCy;
            var reactanceCx = reactanceStartPoint.x;
            for (var k = 0; k < series[m].points.length; k++) {
                var resistance = this.xValues[k];
                var resistantR = (diameter * (1 / (resistance + 1))) / 2;
                var reactance = this.yValues[k];
                var reactanceR = Math.abs(((1 / reactance) * diameter) / 2);
                if (smithchart.renderType === 'Impedance') {
                    reactanceCy = reactance > 0 ? chartAreaCy - reactanceR : chartAreaCy + reactanceR;
                    resistantCx = (axisRender.circleLeftX + diameter - resistantR);
                }
                else {
                    reactanceCy = reactance < 0 ? chartAreaCy - reactanceR : chartAreaCy + reactanceR;
                    resistantCx = (axisRender.circleLeftX + resistantR);
                }
                interSectPoint = axisRender.intersectingCirclePoints(reactanceCx, reactanceCy, reactanceR, resistantCx, resistantCy, resistantR, smithchart.renderType);
                var epsilon = _getEpsilonValue();
                if (Math.abs(reactance) < epsilon) {
                    interSectPoint.x = (smithchart.renderType === 'Impedance') ?
                        resistantCx - resistantR : resistantCx + resistantR;
                    interSectPoint.y = chartAreaCy;
                }
                this.pointsRegion[m][k] = new PointRegion();
                this.pointsRegion[m][k] = { point: interSectPoint, x: resistance, y: reactance };
                this.location[m][k] = { x: interSectPoint.x, y: interSectPoint.y };
            }
            for (var i = 0; i < series[m].points.length - 1; i++) {
                index = i + 1;
                this.lineSegments[i] = new LineSegment();
                this.lineSegments[i] = { x1: this.xValues[i], y1: this.yValues[i], x2: this.xValues[index], y2: this.yValues[index] };
            }
            smithchart.svgObject.appendChild(groupElement);
            this.drawSeries(smithchart, seriesIndex, groupElement, bounds);
        }
        for (var j = 0; j < smithchart.series.length; j++) {
            if (smithchart.series[j].enableSmartLabels && smithchart.series[j].marker.dataLabel.visible) {
                var gdlcEle = smithchart.renderer.createGroup({
                    'id': smithchart.element.id + '_svg'
                        + '_series' + j + '_Datalabel' + '_connectorLines'
                });
                var element = document.getElementById(smithchart.element.id + '_svg' + '_seriesCollection' + j);
                if (element) {
                    element.setAttribute('aria-label', ('Smithchart with ' + series[j].points.length + ' points'));
                    element.appendChild(gdlcEle);
                }
                this.dataLabel.calculateSmartLabels(this.dataLabel.labelOptions[j], j);
                for (var k = 0; k < smithchart.series[j].points.length; k++) {
                    var currentPoint = this.dataLabel.labelOptions[j]['textOptions'][k];
                    if ((currentPoint.xPosition + currentPoint.width) > (smithchart.chartArea.x + smithchart.chartArea.width)
                        || currentPoint.xPosition < smithchart.chartArea.x || currentPoint.yPosition < smithchart.chartArea.y ||
                        currentPoint.yPosition + currentPoint.height > smithchart.chartArea.y + smithchart.chartArea.height) {
                        this.dataLabel.labelOptions[j].textOptions[k].connectorFlag = false;
                        this.dataLabel.labelOptions[j].textOptions[k].visible = false;
                    }
                    if (currentPoint['connectorFlag']) {
                        this.dataLabel.drawConnectorLines(smithchart, j, k, currentPoint, gdlcEle);
                    }
                }
            }
        }
        var _loop_1 = function (j) {
            var dataLabel = smithchart.series[j].marker.dataLabel;
            if (smithchart.series[j].marker.dataLabel.visible) {
                var element = document.getElementById(smithchart.element.id + '_svg' + '_seriesCollection' + j);
                var gdEle_1 = smithchart.renderer.createGroup({
                    'id': smithchart.element.id + '_svg'
                        + '_series' + j + '_Datalabel'
                });
                gdEle_1.setAttribute('aria-hidden', 'true');
                if (element) {
                    element.appendChild(gdEle_1);
                }
                var _loop_2 = function (k) {
                    var currentPoint = this_1.dataLabel.labelOptions[j]['textOptions'][k];
                    if (!dataLabel.template && currentPoint.visible) {
                        var options_1 = new DataLabelTextOptions();
                        options_1 = this_1.dataLabel.labelOptions[j]['textOptions'][k];
                        var font_1 = dataLabel.textStyle;
                        var x = options_1['xPosition'];
                        var y = options_1['yPosition'];
                        var id = smithchart.element.id + '_Series' + j + '_Points' + k + '_dataLabel' + '_symbol' + k;
                        var fill = dataLabel['fill'] ? dataLabel['fill'] : (smithchart.series[j].fill ||
                            smithchart.seriesColors[j % smithchart.seriesColors.length]);
                        var border = smithchart.series[j].marker.dataLabel.border;
                        var rectOptions = new RectOption$1(id, fill, border, options_1['opacity'], new SmithchartRect(x, y, options_1['width'], options_1['height']));
                        var dataEle = smithchart.renderer.drawRectangle(rectOptions);
                        gdEle_1.appendChild(dataEle);
                        var textRenderEventArgs = {
                            text: options_1['text'],
                            x: options_1['x'],
                            y: options_1['y'],
                            seriesIndex: j,
                            pointIndex: k,
                            name: textRender$1,
                            cancel: false
                        };
                        var textRenderSuccess = function (args) {
                            if (!args.cancel) {
                                var textoptions = new TextOption$1(options_1['id'], args.x, args.y, 'start', args.text);
                                var color = font_1.color ? font_1.color : smithchart.themeStyle.dataLabelFont.color;
                                var element_1 = renderTextElement(textoptions, font_1, color, gdEle_1, smithchart.themeStyle.dataLabelFont);
                                gdEle_1.appendChild(element_1);
                            }
                        };
                        textRenderSuccess.bind(this_1);
                        smithchart.trigger(textRender$1, textRenderEventArgs, textRenderSuccess);
                    }
                    else if (dataLabel.template) {
                        var element_2 = document.getElementById(dataLabel.template + '_seriesIndex' + j + '_pointIndex' +
                            k + smithchart.element.id);
                        element_2.style.left = this_1.dataLabel.labelOptions[j]['textOptions'][k].xPosition + 'px';
                        element_2.style.top = this_1.dataLabel.labelOptions[j]['textOptions'][k].yPosition + 'px';
                    }
                };
                for (var k = 0; k < smithchart.series[j].points.length; k++) {
                    _loop_2(k);
                }
            }
        };
        var this_1 = this;
        for (var j = 0; j < smithchart.series.length; j++) {
            _loop_1(j);
        }
        for (var i = 0; i < smithchart.series.length; i++) {
            if (((smithchart.series[i].enableAnimation && animationMode != 'Disable') || animationMode === 'Enable') && smithchart.animateSeries) {
                if (smithchart.series[i].marker.dataLabel.template) {
                    this.animateDataLabelTemplate(i, smithchart);
                }
                var element = document.getElementById(smithchart.element.id + '_svg' + '_seriesCollection' + i);
                element.setAttribute('aria-label', ('Smithchart with ' + series[i].points.length + ' points'));
                this.performAnimation(smithchart, element, i);
            }
        }
    };
    SeriesRender.prototype.drawSeries = function (smithchart, seriesindex, groupElement, bounds) {
        var _this = this;
        var gsEle = smithchart.renderer.createGroup({
            'id': smithchart.element.id + '_svg' + '_seriesCollection' + seriesindex,
            'clip-path': 'url(#' + smithchart.element.id + '_ChartSeriesClipRect_' +
                seriesindex + ')'
        });
        gsEle.setAttribute('visibility', smithchart.series[seriesindex].visibility);
        gsEle.setAttribute('aria-label', ('Smithchart with ' + smithchart.series[seriesindex].points.length + ' points'));
        groupElement.appendChild(gsEle);
        var sb = '';
        var path;
        var marker = smithchart.series[seriesindex].marker;
        var element;
        var count = smithchart.series[seriesindex].points.length - 1;
        for (var i = 0; i < count; i++) {
            var point1 = this.pointsRegion[seriesindex][i]['point'];
            var point2 = this.pointsRegion[seriesindex][i + 1]['point'];
            sb = sb + ('M' + ' ' + (point1.x) + ' ' + (point1.y) + ' ' + 'L' +
                ' ' + (point2.x) + ' ' + (point2.y) + ' ');
        }
        path = sb.toString();
        var fill = smithchart.series[seriesindex].fill || smithchart.seriesColors[seriesindex % smithchart.seriesColors.length];
        var seriesEventArgs = {
            text: smithchart.series[seriesindex].name,
            fill: fill,
            name: seriesRender$1,
            cancel: false
        };
        var seriesRenderSuccess = function (args) {
            if (!args.cancel) {
                var options = new PathOption$1(smithchart.element.id + '_series' + seriesindex + '_points', 'none', smithchart.series[seriesindex].width, seriesEventArgs.fill, smithchart.series[seriesindex].opacity, 'none', path);
                _this.clipRectElement = smithchart.renderer.drawClipPath(new RectOption$1(smithchart.element.id + '_ChartSeriesClipRect_' + seriesindex, 'transparent', { width: 1, color: 'Gray' }, 1, {
                    x: bounds.x, y: bounds.y,
                    width: smithchart.availableSize.width,
                    height: smithchart.availableSize.height
                }));
                gsEle.appendChild(_this.clipRectElement);
                var gspEle = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + seriesindex });
                element = smithchart.renderer.drawPath(options);
                gspEle.appendChild(element);
                gsEle.appendChild(gspEle);
            }
        };
        seriesRenderSuccess.bind(this);
        smithchart.trigger(seriesRender$1, seriesEventArgs, seriesRenderSuccess);
        var markerrender = new Marker$1();
        markerrender.drawMarker(smithchart, seriesindex, gsEle, this.pointsRegion[seriesindex]);
        this.dataLabel.drawDataLabel(smithchart, seriesindex, gsEle, this.pointsRegion[seriesindex], bounds);
    };
    SeriesRender.prototype.animateDataLabelTemplate = function (seriesindex, smithchart) {
        var length = smithchart.series[seriesindex].points.length;
        var delay = 0;
        var duration = parseFloat(smithchart.series[seriesindex].animationDuration);
        for (var i = 0; i < length; i++) {
            var element = document.getElementById(smithchart.series[seriesindex].marker.dataLabel.template +
                '_seriesIndex' + seriesindex + '_pointIndex' + i + smithchart.element.id);
            element.style.visibility = 'hidden';
            templateAnimate$1(smithchart, element, delay, duration, 'FadeIn');
            // this.fadein(element);
        }
    };
    /*private fadein(element: HTMLElement): void {
      let op: number = 0.1;
      element.style.display = 'block';
      let timer: number = setInterval( (): void => {
            if (op >= 1) {
                clearInterval(timer);
            }
            element.style.opacity = op.toString();
            element.style.filter = 'alpha(opacity=' + op * 100 + ')';
            op += op * 0.1;
    }, 50);
    
    }*/
    SeriesRender.prototype.performAnimation = function (smithchart, gsEle, seriesIndex) {
        var animation = new Animation({});
        var element = document.getElementById('container_svg_seriesCollections');
        var clipRect = gsEle.childNodes[0].childNodes[0].childNodes[0];
        var effect = getAnimationFunction$1('Linear');
        var reveffect = getAnimationFunction$1('Reverse');
        var width = +clipRect.getAttribute('width');
        var x = +clipRect.getAttribute('x');
        var value;
        animation.animate(clipRect, {
            duration: (parseFloat(smithchart.series[seriesIndex].animationDuration) === 0 && animationMode === 'Enable') ? 2000 : parseFloat(smithchart.series[seriesIndex].animationDuration),
            progress: function (args) {
                if (smithchart.renderType === 'Impedance') {
                    value = effect(args.timeStamp - args.delay, 0, width, args.duration);
                    clipRect.setAttribute('width', value.toString());
                }
                else {
                    value = reveffect(args.timeStamp - args.delay, width, 0, args.duration);
                    clipRect.setAttribute('x', value.toString());
                }
            },
            end: function (model) {
                if (smithchart.renderType === 'Impedance') {
                    clipRect.setAttribute('width', width.toString());
                }
                else {
                    clipRect.setAttribute('x', x.toString());
                }
                var event = {
                    cancel: false,
                    name: animationComplete$1,
                    smithchart: smithchart
                };
                smithchart.trigger(animationComplete$1, event);
            }
        });
    };
    SeriesRender.prototype.getLocation = function (seriesindex, pointIndex) {
        var x;
        var y;
        x = this.location[seriesindex][pointIndex].x;
        y = this.location[seriesindex][pointIndex].y;
        return { x: x, y: y };
    };
    return SeriesRender;
}());

/**
 * Specifies TreeMap beforePrint event name.
 *
 * @private
 */
var smithchartBeforePrint = 'beforePrint';

/* eslint-disable valid-jsdoc */
/**
 * Annotation Module handles the Annotation for Maps
 */
var ExportUtils$1 = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for Maps
     *
     * @param {Smithchart} control smithchart instance
     */
    function ExportUtils(control) {
        this.control = control;
    }
    /**
     * To print the Maps
     *
     * @param {string} elements html element
     * @returns {void}
     */
    ExportUtils.prototype.print = function (elements) {
        this.smithchartPrint = window.open('', 'print', 'height=' + window.outerHeight + ',width=' + window.outerWidth + ',tabbar=no');
        this.smithchartPrint.moveTo(0, 0);
        this.smithchartPrint.resizeTo(screen.availWidth, screen.availHeight);
        var argsData = {
            cancel: false,
            htmlContent: this.getHTMLContent(elements),
            name: smithchartBeforePrint
        };
        this.control.trigger(smithchartBeforePrint, argsData);
        if (!argsData.cancel) {
            print(argsData.htmlContent, this.smithchartPrint);
        }
    };
    /**
     * To get the html string of the Maps
     *
     * @param {string} svgElements svg element
     * @private
     * @returns {Element} content of the html element
     */
    ExportUtils.prototype.getHTMLContent = function (svgElements) {
        var div = createElement('div');
        if (svgElements) {
            if (svgElements instanceof Array) {
                svgElements.forEach(function (value) {
                    div.appendChild(getElement$2(value).cloneNode(true));
                });
            }
            else if (svgElements instanceof Element) {
                div.appendChild(svgElements.cloneNode(true));
            }
            else {
                div.appendChild(getElement$2(svgElements).cloneNode(true));
            }
        }
        else {
            div.appendChild(this.control.element.cloneNode(true));
        }
        return div;
    };
    /**
     * To export the file as image/svg format.
     *
     * @param {SmithchartExportType} exportType export type
     * @param {string} fileName export file name
     * @param {PdfPageOrientation} orientation orientation of the page
     * @returns {void}
     */
    ExportUtils.prototype.export = function (exportType, fileName, orientation) {
        var _this = this;
        var canvas = createElement('canvas', {
            id: 'ej2-canvas',
            attrs: {
                'width': this.control.availableSize.width.toString(),
                'height': this.control.availableSize.height.toString()
            }
        });
        var isDownload = !(Browser.userAgent.toString().indexOf('HeadlessChrome') > -1);
        orientation = isNullOrUndefined(orientation) ? PdfPageOrientation.Landscape : orientation;
        var svgData = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' +
            this.control.svgObject.outerHTML +
            '</svg>';
        var url = window.URL.createObjectURL(new Blob(exportType === 'SVG' ? [svgData] :
            [(new XMLSerializer()).serializeToString(this.control.svgObject)], { type: 'image/svg+xml' }));
        if (exportType === 'SVG') {
            this.triggerDownload(fileName, exportType, url, isDownload);
        }
        else {
            var image_1 = new Image();
            var ctx_1 = canvas.getContext('2d');
            image_1.onload = (function () {
                ctx_1.drawImage(image_1, 0, 0);
                window.URL.revokeObjectURL(url);
                if (exportType === 'PDF') {
                    var document_1 = new PdfDocument();
                    var imageString = canvas.toDataURL('image/jpeg').replace('image/jpeg', 'image/octet-stream');
                    document_1.pageSettings.orientation = orientation;
                    imageString = imageString.slice(imageString.indexOf(',') + 1);
                    document_1.pages.add().graphics.drawImage(new PdfBitmap(imageString), 0, 0, (_this.control.availableSize.width - 60), _this.control.availableSize.height);
                    if (isDownload) {
                        document_1.save(fileName + '.pdf');
                        document_1.destroy();
                    }
                }
                else {
                    _this.triggerDownload(fileName, exportType, canvas.toDataURL('image/png').replace('image/png', 'image/octet-stream'), isDownload);
                }
            });
            image_1.src = url;
        }
    };
    /**
     * To trigger the download element.
     *
     * @param {string} fileName export file name
     * @param {SmithchartExportType} exportType export type
     * @param {string} url file url
     * @param {boolean} isDownload download
     */
    ExportUtils.prototype.triggerDownload = function (fileName, exportType, url, isDownload) {
        createElement('a', {
            attrs: {
                'download': fileName + '.' + exportType.toLocaleLowerCase(),
                'href': url
            }
        }).dispatchEvent(new MouseEvent(isDownload ? 'click' : 'move', {
            view: window,
            bubbles: false,
            cancelable: true
        }));
    };
    return ExportUtils;
}());

var __extends$87 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$16 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable jsdoc/require-returns */
/* eslint-disable jsdoc/require-param */
/* eslint-disable valid-jsdoc */
/**
 * Represents the Smithchart control.
 * ```html
 * <div id="smithchart"/>
 * <script>
 *   var chartObj = new Smithchart({ isResponsive : true });
 *   chartObj.appendTo("#smithchart");
 * </script>
 * ```
 */
var Smithchart = /** @__PURE__ @class */ (function (_super) {
    __extends$87(Smithchart, _super);
    /**
     * Constructor for creating the Smithchart widget
     */
    function Smithchart(options, element) {
        return _super.call(this, options, element) || this;
    }
    /**
     * Get component name
     */
    Smithchart.prototype.getModuleName = function () {
        return 'smithchart';
    };
    /**
     * Get the properties to be maintained in the persisted state.
     *
     * @private
     */
    Smithchart.prototype.getPersistData = function () {
        return '';
    };
    /**
     * Method to create SVG element.
     */
    Smithchart.prototype.createChartSvg = function () {
        this.removeSvg();
        createSvg$1(this);
    };
    Smithchart.prototype.renderTitle = function (title, type, groupEle) {
        var _this = this;
        var font = title.textStyle;
        var textSize = measureText$1(title.text, font, this.themeStyle.smithchartTitleFont);
        var x;
        var textAlignment = title.textAlignment;
        var titleText = title.text;
        var maxTitleWidth = (isNullOrUndefined(title.maximumWidth)) ?
            Math.abs(this.margin.left + this.margin.right - (this.availableSize.width)) :
            title.maximumWidth;
        var titleWidthEnable = textSize.width > maxTitleWidth ? true : false;
        if (textSize.width > this.availableSize.width) {
            x = this.margin.left + this.border.width;
        }
        else {
            x = textAlignment === 'Center' ? (this.availableSize.width / 2 - textSize['width'] / 2) :
                (textAlignment === 'Near' ? (this.margin.left + this.elementSpacing + this.border.width) : (this.availableSize.width
                    - textSize['width'] - (this.margin.right + this.elementSpacing + this.border.width)));
        }
        var y = this.margin.top + textSize['height'] / 2 + this.elementSpacing;
        if (title.enableTrim && titleWidthEnable) {
            titleText = textTrim$1(maxTitleWidth, title.text, font, this.themeStyle.smithchartTitleFont);
            textSize = measureText$1(titleText, font, this.themeStyle.smithchartTitleFont);
        }
        groupEle = this.renderer.createGroup({ id: this.element.id + '_Title_Group' });
        var titleEventArgs = {
            text: titleText,
            x: x,
            y: y,
            name: titleRender,
            cancel: false
        };
        var options;
        var titleRenderSuccess = function (args) {
            if (!args.cancel) {
                options = new TextOption$1(_this.element.id + '_Smithchart_' + type, args.x, args.y, 'start', args.text);
                var element = renderTextElement(options, font, font.color || _this.themeStyle.smithchartTitleFont.color, groupEle, _this.themeStyle.smithchartTitleFont);
                element.setAttribute('tabindex', '0');
                var titleLocation = { x: args.x, y: args.y, textSize: textSize };
                _this.svgObject.appendChild(groupEle);
                if (title.subtitle.text !== '' && title.subtitle.visible) {
                    _this.renderSubtitle(title, type, textSize, _this.availableSize, titleLocation, groupEle);
                }
            }
        };
        titleRenderSuccess.bind(this);
        this.trigger(titleRender, titleEventArgs, titleRenderSuccess);
    };
    Smithchart.prototype.renderSubtitle = function (title, type, textSize, size, titleLocation, groupEle) {
        var _this = this;
        var font = title.subtitle.textStyle;
        var subTitle = title.subtitle;
        var subTitleSize = measureText$1(subTitle.text, font, this.themeStyle.smithchartSubtitleFont);
        var subTitleText = subTitle.text;
        var maxSubTitleWidth = isNullOrUndefined(subTitle.maximumWidth) ?
            (this.bounds.width * 0.75) : subTitle.maximumWidth;
        if (subTitle.enableTrim && subTitleSize.width > maxSubTitleWidth) {
            subTitleText = textTrim$1(maxSubTitleWidth, subTitle.text, font, this.themeStyle.smithchartSubtitleFont);
        }
        var x = title['subtitle'].textAlignment === 'Far' ? (titleLocation.x + (titleLocation.textSize.width)) :
            (title['subtitle'].textAlignment === 'Near') ? titleLocation.x :
                (titleLocation.x + (titleLocation.textSize.width / 2));
        var y = titleLocation.y + (2 * this.elementSpacing);
        var textAnchor = title['subtitle'].textAlignment === 'Far' ? 'end' :
            (title['subtitle'].textAlignment === 'Near') ? 'start' : 'middle';
        var subtitleEventArgs = {
            text: subTitleText,
            x: x,
            y: y,
            name: subtitleRender,
            cancel: false
        };
        var subtitleRenderSuccess = function (args) {
            if (!args.cancel) {
                var options = new TextOption$1(_this.element.id + '_Smithchart_' + type, args.x, args.y, textAnchor, args.text);
                var element = renderTextElement(options, font, font.color || _this.themeStyle.smithchartSubtitleFont.color, groupEle, _this.themeStyle.smithchartSubtitleFont);
                element.setAttribute('aria-label', subTitle.description || args.text);
                groupEle.appendChild(element);
            }
        };
        subtitleRenderSuccess.bind(this);
        this.trigger(subtitleRender, subtitleEventArgs, subtitleRenderSuccess);
    };
    /**
     * Render the smithchart border
     *
     * @private
     */
    Smithchart.prototype.renderBorder = function () {
        var border = this.border;
        this.background = this.background ? this.background : this.themeStyle.background;
        var borderRect = new RectOption$1(this.element.id + '_SmithchartBorder', this.background, border, 1, new SmithchartRect(border.width / 2, border.width / 2, this.availableSize.width - border.width, this.availableSize.height - border.width));
        var element = this.svgObject.appendChild(this.renderer.drawRectangle(borderRect));
        element.setAttribute('aria-hidden', 'true');
    };
    /**
     * Called internally if any of the property value changed.
     *
     * @private
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Smithchart.prototype.onPropertyChanged = function (newProp, oldProp) {
        var renderer = false;
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'background':
                case 'border':
                case 'series':
                case 'legendSettings':
                case 'radius':
                case 'enableRtl':
                    renderer = true;
                    break;
                case 'size':
                    this.createChartSvg();
                    renderer = true;
                    break;
                case 'theme':
                case 'renderType':
                    this.animateSeries = true;
                    renderer = true;
                    break;
            }
        }
        if (renderer) {
            this.render();
        }
    };
    /**
     * Initialize the event handler.
     */
    Smithchart.prototype.preRender = function () {
        this.allowServerDataBinding = false;
        this.trigger(load$1, { smithchart: this });
        this.unWireEVents();
        this.initPrivateVariable();
        this.wireEVents();
    };
    Smithchart.prototype.initPrivateVariable = function () {
        this.animateSeries = true;
        this.element.setAttribute('role', 'region');
        this.element.setAttribute('aria-label', this.title.description || this.title.text + '. Syncfusion interactive chart.');
        this.element.setAttribute('tabindex', '0');
    };
    /**
     * To Initialize the control rendering.
     */
    Smithchart.prototype.setTheme = function () {
        /*! Set theme */
        this.themeStyle = getThemeColor$1(this.theme);
        this.seriesColors = getSeriesColor$1(this.theme);
        // let count: number = colors.length;
        // for (let i: number = 0; i < this.series.length; i++) {
        //     this.series[i].fill = this.series[i].fill ? this.series[i].fill : colors[i % count];
        // }
    };
    Smithchart.prototype.render = function () {
        this.createChartSvg();
        this.element.appendChild(this.svgObject);
        this.setTheme();
        this.createSecondaryElement();
        this.renderBorder();
        if (this.smithchartLegendModule && this.legendSettings.visible) {
            this.legendBounds = this.smithchartLegendModule.renderLegend(this);
        }
        this.legendBounds = this.legendBounds ? this.legendBounds : { x: 0, y: 0, width: 0, height: 0 };
        var areaBounds = new AreaBounds();
        this.bounds = areaBounds.calculateAreaBounds(this, this.title, this.legendBounds);
        if (this.title.text !== '' && this.title.visible) {
            this.renderTitle(this.title, 'title', null);
        }
        var axisRender = new AxisRender();
        axisRender.renderArea(this, this.bounds);
        this.seriesrender = new SeriesRender();
        this.seriesrender.draw(this, axisRender, this.bounds);
        this.renderComplete();
        this.allowServerDataBinding = true;
        this.trigger(loaded$1, { smithchart: this });
    };
    Smithchart.prototype.createSecondaryElement = function () {
        if (isNullOrUndefined(document.getElementById(this.element.id + '_Secondary_Element'))) {
            var secondaryElement = createElement('div', {
                id: this.element.id + '_Secondary_Element',
                styles: 'z-index:1;'
            });
            this.element.appendChild(secondaryElement);
            var rect = this.element.getBoundingClientRect();
            var svgRect = document.getElementById(this.element.id + '_svg');
            if (svgRect) {
                var svgClientRect = svgRect.getBoundingClientRect();
                secondaryElement.style.left = Math.max(svgClientRect.left - rect.left, 0) + 'px';
                secondaryElement.style.top = Math.max(svgClientRect.top - rect.top, 0) + 'px';
            }
        }
        else {
            removeElement$2(this.element.id + '_Secondary_Element');
        }
    };
    /**
     * To destroy the widget
     *
     * @returns {void}.
     */
    Smithchart.prototype.destroy = function () {
        if (this.element) {
            this.unWireEVents();
            _super.prototype.destroy.call(this);
            this.element.classList.remove('e-smithchart');
            this.removeSvg();
            this.svgObject = null;
        }
    };
    /**
     * To bind event handlers for smithchart.
     */
    Smithchart.prototype.wireEVents = function () {
        EventHandler.add(this.element, 'click', this.smithchartOnClick, this);
        EventHandler.add(this.element, Browser.touchMoveEvent, this.mouseMove, this);
        EventHandler.add(this.element, Browser.touchEndEvent, this.mouseEnd, this);
        window.addEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.smithchartOnResize.bind(this));
    };
    Smithchart.prototype.mouseMove = function (e) {
        if (e.type === 'touchmove') {
            this.isTouch = true;
        }
        else {
            this.isTouch = e.pointerType === 'touch' || e.pointerType === '2' || this.isTouch;
        }
        if (this.tooltipRenderModule && !this.isTouch) {
            this.tooltipRenderModule.smithchartMouseMove(this, e);
        }
    };
    Smithchart.prototype.mouseEnd = function (e) {
        if (e.type === 'touchend') {
            this.isTouch = true;
        }
        else {
            this.isTouch = e.pointerType === 'touch' || e.pointerType === '2';
        }
        if (this.tooltipRenderModule && this.isTouch) {
            var tooltipElement_1 = this.tooltipRenderModule.smithchartMouseMove(this, e);
            if (tooltipElement_1) {
                this.fadeoutTo = +setTimeout(function () {
                    tooltipElement_1.fadeOut();
                }, 2000);
            }
        }
    };
    /**
     * To handle the click event for the smithchart.
     */
    Smithchart.prototype.smithchartOnClick = function (e) {
        var targetEle = e.target;
        var targetId = targetEle.id;
        var parentElement = document.getElementById(targetId).parentElement;
        var grpElement = document.getElementById(parentElement.id).parentElement;
        if (grpElement.id === 'containerlegendItem_Group' && this.legendSettings.toggleVisibility) {
            var childElement = parentElement.childNodes[1];
            var circleElement = parentElement.childNodes[0];
            var legendText = childElement.textContent;
            var seriesIndex = void 0;
            var fill = void 0;
            for (var i = 0; i < this.smithchartLegendModule.legendSeries.length; i++) {
                if (legendText === this.smithchartLegendModule.legendSeries[i]['text']) {
                    seriesIndex = this.smithchartLegendModule.legendSeries[i].seriesIndex;
                    fill = this.smithchartLegendModule.legendSeries[i].fill;
                }
            }
            var seriesElement = document.getElementById(this.element.id + '_svg' + '_seriesCollection' + seriesIndex);
            if (seriesElement.getAttribute('visibility') === 'visible') {
                circleElement.setAttribute('fill', 'gray');
                seriesElement.setAttribute('visibility', 'hidden');
                this.series[seriesIndex].visibility = 'hidden';
            }
            else {
                circleElement.setAttribute('fill', fill);
                seriesElement.setAttribute('visibility', 'visible');
                this.series[seriesIndex].visibility = 'visible';
            }
        }
    };
    /**
     * To unbind event handlers from smithchart.
     */
    Smithchart.prototype.unWireEVents = function () {
        EventHandler.remove(this.element, 'click', this.smithchartOnClick);
        EventHandler.remove(this.element, Browser.touchMoveEvent, this.mouseMove);
        EventHandler.remove(this.element, Browser.touchEndEvent, this.mouseEnd);
        window.removeEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.smithchartOnResize);
    };
    Smithchart.prototype.print = function (id) {
        var exportChart = new ExportUtils$1(this);
        exportChart.print(id);
    };
    /**
     * Handles the export method for chart control.
     */
    Smithchart.prototype.export = function (type, fileName, orientation) {
        var exportMap = new ExportUtils$1(this);
        exportMap.export(type, fileName, orientation);
    };
    /**
     * To handle the window resize event on smithchart.
     */
    Smithchart.prototype.smithchartOnResize = function () {
        var _this = this;
        this.animateSeries = false;
        if (this.resizeTo) {
            clearTimeout(this.resizeTo);
        }
        this.resizeTo = +setTimeout(function () {
            _this.render();
        }, 500);
        return false;
    };
    /**
     * To provide the array of modules needed for smithchart rendering
     *
     * @private
     */
    Smithchart.prototype.requiredModules = function () {
        var modules = [];
        if (this.legendSettings.visible) {
            modules.push({
                member: 'SmithchartLegend',
                args: [this]
            });
        }
        for (var i = 0; i < this.series.length; i++) {
            if (this.series[i].tooltip.visible) {
                modules.push({
                    member: 'TooltipRender',
                    args: [this]
                });
                break;
            }
        }
        return modules;
    };
    /**
     * To Remove the SVG.
     *
     * @private
     */
    Smithchart.prototype.removeSvg = function () {
        removeElement$2(this.element.id + '_Secondary_Element');
        var removeLength = 0;
        if (this.svgObject) {
            while (this.svgObject.childNodes.length > removeLength) {
                this.svgObject.removeChild(this.svgObject.firstChild);
            }
            if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode) {
                remove(this.svgObject);
            }
        }
    };
    __decorate$16([
        Property('Impedance')
    ], Smithchart.prototype, "renderType", void 0);
    __decorate$16([
        Property('')
    ], Smithchart.prototype, "width", void 0);
    __decorate$16([
        Property('')
    ], Smithchart.prototype, "height", void 0);
    __decorate$16([
        Property('Material')
    ], Smithchart.prototype, "theme", void 0);
    __decorate$16([
        Complex({}, SmithchartMargin)
    ], Smithchart.prototype, "margin", void 0);
    __decorate$16([
        Complex({}, SmithchartFont)
    ], Smithchart.prototype, "font", void 0);
    __decorate$16([
        Complex({}, SmithchartBorder)
    ], Smithchart.prototype, "border", void 0);
    __decorate$16([
        Complex({}, Title)
    ], Smithchart.prototype, "title", void 0);
    __decorate$16([
        Collection([{}], SmithchartSeries)
    ], Smithchart.prototype, "series", void 0);
    __decorate$16([
        Complex({}, SmithchartLegendSettings)
    ], Smithchart.prototype, "legendSettings", void 0);
    __decorate$16([
        Complex({}, SmithchartAxis)
    ], Smithchart.prototype, "horizontalAxis", void 0);
    __decorate$16([
        Complex({}, SmithchartAxis)
    ], Smithchart.prototype, "radialAxis", void 0);
    __decorate$16([
        Property(null)
    ], Smithchart.prototype, "background", void 0);
    __decorate$16([
        Property(10)
    ], Smithchart.prototype, "elementSpacing", void 0);
    __decorate$16([
        Property(1)
    ], Smithchart.prototype, "radius", void 0);
    __decorate$16([
        Event()
    ], Smithchart.prototype, "beforePrint", void 0);
    __decorate$16([
        Event()
    ], Smithchart.prototype, "animationComplete", void 0);
    __decorate$16([
        Event()
    ], Smithchart.prototype, "load", void 0);
    __decorate$16([
        Event()
    ], Smithchart.prototype, "loaded", void 0);
    __decorate$16([
        Event()
    ], Smithchart.prototype, "legendRender", void 0);
    __decorate$16([
        Event()
    ], Smithchart.prototype, "titleRender", void 0);
    __decorate$16([
        Event()
    ], Smithchart.prototype, "subtitleRender", void 0);
    __decorate$16([
        Event()
    ], Smithchart.prototype, "textRender", void 0);
    __decorate$16([
        Event()
    ], Smithchart.prototype, "axisLabelRender", void 0);
    __decorate$16([
        Event()
    ], Smithchart.prototype, "seriesRender", void 0);
    __decorate$16([
        Event()
    ], Smithchart.prototype, "tooltipRender", void 0);
    Smithchart = __decorate$16([
        NotifyPropertyChanges
    ], Smithchart);
    return Smithchart;
}(Component));

/**
 * To render tooltip
 */
var TooltipRender = /** @__PURE__ @class */ (function () {
    function TooltipRender() {
    }
    TooltipRender.prototype.smithchartMouseMove = function (smithchart, e) {
        var touchArg;
        var pageX;
        var pageY;
        if (e.type === 'touchend' || e.type === 'touchmove') {
            touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            pageY = touchArg.changedTouches[0].clientY;
            this.tooltipElement = undefined;
        }
        else {
            pageY = e.clientY;
            pageX = e.clientX;
        }
        this.setMouseXY(smithchart, pageX, pageY);
        for (var i = 0; i < smithchart.series.length; i++) {
            var series = smithchart.series[i];
            var seriesIndex = i;
            var closestPoint = new ClosestPoint();
            closestPoint = this.closestPointXY(smithchart, this.mouseX, this.mouseY, series, seriesIndex);
            if (closestPoint.location && series.tooltip.visible && series.visibility === 'visible') {
                this.createTooltip(smithchart, e, closestPoint.index, seriesIndex, series);
                break;
            }
            else if (this.tooltipElement) {
                if (this.tooltipElement.enable && !series.tooltip.template) {
                    this.tooltipElement.enable = false;
                }
                this.tooltipElement.fadeOut();
            }
        }
        return this.tooltipElement;
    };
    TooltipRender.prototype.setMouseXY = function (smithchart, pageX, pageY) {
        var svgRectElement = document.getElementById(smithchart.element.id + '_svg');
        if (smithchart.element && svgRectElement) {
            var rect = smithchart.element.getBoundingClientRect();
            var svgRect = svgRectElement.getBoundingClientRect();
            this.mouseX = (pageX - rect.left) - Math.max(svgRect.left - rect.left, 0);
            this.mouseY = (pageY - rect.top) - Math.max(svgRect.top - rect.top, 0);
        }
    };
    TooltipRender.prototype.createTooltip = function (smithchart, e, pointindex, seriesindex, series) {
        var _this = this;
        var currentPoint = series.points[pointindex];
        var pointX = currentPoint.resistance;
        var pointY = currentPoint.reactance;
        var tooltip = currentPoint.tooltip ? [currentPoint.tooltip] : null;
        var tooltipText = [pointX + ' ' + ':' + ' ' + '<b>' + pointY + '</b>'];
        var argsData = {
            cancel: false, name: 'tooltipRender',
            text: tooltip || tooltipText,
            headerText: '<b>' + series.name + '</b>',
            template: series.tooltip.template,
            point: currentPoint
        };
        var smithChartTooltipSuccess = function (argsData) {
            var markerHeight = smithchart.series[seriesindex].marker.height / 2;
            var div = document.getElementById(smithchart.element.id + '_smithchart_tooltip_div');
            if (isNullOrUndefined(div)) {
                div = createElement('div', {
                    id: smithchart.element.id + '_smithchart_tooltip_div',
                    styles: 'pointer-events: none; position: absolute;z-index:1;'
                });
                document.getElementById(smithchart.element.id + '_Secondary_Element').appendChild(div);
            }
            _this.tooltipElement = new Tooltip({
                enable: true,
                header: argsData.headerText,
                content: argsData.text,
                border: series.tooltip.border,
                fill: series.tooltip.fill || smithchart.themeStyle.tooltipFill,
                opacity: series.tooltip.opacity,
                data: currentPoint,
                template: argsData.template,
                location: {
                    x: _this.locationX + smithchart.element.offsetLeft,
                    y: _this.locationY - markerHeight + smithchart.element.offsetTop
                },
                shared: false,
                areaBounds: new SmithchartRect(smithchart.bounds.x, smithchart.bounds.y, smithchart.bounds.width, smithchart.bounds.height),
                palette: [series.fill || smithchart.seriesColors[seriesindex % smithchart.seriesColors.length]],
                shapes: ['Circle'],
                availableSize: smithchart.availableSize,
                theme: smithchart.theme
            });
            _this.tooltipElement.opacity = smithchart.themeStyle.tooltipFillOpacity || _this.tooltipElement.opacity;
            _this.tooltipElement.textStyle.fontFamily = smithchart.themeStyle.fontFamily || 'Roboto, Segoe UI, Noto, Sans-serif';
            _this.tooltipElement.textStyle.size = smithchart.themeStyle.tooltipFontSize || '13px';
            _this.tooltipElement.textStyle.color = smithchart.themeStyle.tooltipBoldLabel || _this.tooltipElement.textStyle.color;
            _this.tooltipElement.appendTo(div);
            var element = document.getElementById(smithchart.element.id + '_smithchart_tooltip_div_Trackball_0');
            if (element) {
                element.setAttribute('role', 'img');
            }
        };
        smithChartTooltipSuccess.bind(this, smithchart);
        smithchart.trigger('tooltipRender', argsData, smithChartTooltipSuccess);
    };
    TooltipRender.prototype.closestPointXY = function (smithchart, x, y, series, seriesindex) {
        var pointIndex;
        var chartPoint;
        var closePoint;
        for (var j = 0; j < series.points.length; j++) {
            chartPoint = smithchart.seriesrender.getLocation(seriesindex, j);
            this.locationX = chartPoint.x;
            this.locationY = chartPoint.y;
            pointIndex = j;
            var a = x - chartPoint.x;
            var b = y - chartPoint.y;
            var distance = Math.abs(Math.sqrt((a * a) + (b * b)));
            if (distance < series.marker.width) {
                closePoint = chartPoint;
                pointIndex = j;
                break;
            }
        }
        return { location: closePoint, index: pointIndex };
    };
    /**
     * Get module name.
     *
     * @returns {string} It returns module name
     */
    TooltipRender.prototype.getModuleName = function () {
        return 'TooltipRender';
    };
    /**
     * To destroy the legend.
     *
     * @returns {void}
     * @private
     */
    TooltipRender.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return TooltipRender;
}());

var SmithchartLegend = /** @__PURE__ @class */ (function () {
    function SmithchartLegend() {
        this.legendSeries = [];
    }
    SmithchartLegend.prototype.renderLegend = function (smithchart) {
        this.calculateLegendBounds(smithchart);
        this._drawLegend(smithchart);
        return this.legendActualBounds;
    };
    SmithchartLegend.prototype.calculateLegendBounds = function (smithchart) {
        this.legendSeries = [];
        var padding = 10;
        var legend = smithchart.legendSettings;
        var legendSizeHeight = legend.height;
        var legendSizeWidth = legend.width;
        var itemPadding = legend.itemPadding > 0 ? legend.itemPadding : 0;
        var position = legend.position.toLowerCase();
        var font = legend.title.textStyle;
        var width = 0;
        var height = 0;
        var legendItemWidth = 0;
        var legendItemHeight = 0;
        var legendHeight = 0;
        var svgObjectWidth = smithchart.availableSize.width - ((smithchart.elementSpacing * 4) - (legend.border.width * 2)
            + (smithchart.border.width * 2));
        var rowCount = legend.rowCount;
        var columnCount = legend.columnCount;
        var titleSize = measureText$1(smithchart.legendSettings['title']['text'], font, smithchart.themeStyle.legendTitleFont);
        var maxRowWidth = 0;
        var totalRowHeight = 0;
        var curRowWidth = 0;
        var curRowHeight = 0;
        var allowItems;
        var itemsCountRow = 0;
        var length = smithchart.series.length;
        var legendBounds;
        if (smithchart.legendSettings.visible && length !== 0) {
            if (position === 'bottom' || position === 'top' || position === 'custom') {
                if ((rowCount && columnCount) && (rowCount <= columnCount)) {
                    rowCount = length / columnCount;
                }
                else if (rowCount == null && columnCount != null) {
                    rowCount = length / columnCount;
                }
                else if (rowCount == null && columnCount == null) {
                    rowCount = 1;
                }
                if (rowCount) {
                    allowItems = Math.ceil(length / rowCount);
                }
            }
            else {
                if ((rowCount && columnCount) && (rowCount <= columnCount)) {
                    columnCount = length / rowCount;
                }
                else if (rowCount != null && columnCount == null) {
                    columnCount = length / rowCount;
                }
                else if (rowCount == null && columnCount == null) {
                    columnCount = 1;
                }
                if (columnCount) {
                    allowItems = columnCount;
                }
            }
            for (var i = 0; i < length; i++) {
                this.legendSeries.push({
                    text: smithchart.series[i]['name'] ? smithchart.series[i]['name'] : 'series' + i,
                    seriesIndex: i,
                    shape: smithchart.legendSettings.shape,
                    fill: smithchart.series[i].fill || smithchart.seriesColors[i % smithchart.seriesColors.length],
                    bounds: null
                });
                var legendsize = this._getLegendSize(smithchart, this.legendSeries[i]);
                legendItemWidth = Math.max(legendsize['width'], legendItemWidth);
                legendItemHeight = Math.max(legendsize['height'], legendItemHeight);
                this.legendSeries[i]['bounds'] = { width: legendItemWidth, height: legendItemHeight };
                itemsCountRow = itemsCountRow + 1;
                curRowWidth = curRowWidth + legendItemWidth + itemPadding;
                curRowHeight = Math.max(legendItemHeight, curRowHeight);
                if (position === 'top' || position === 'bottom' || position === 'custom') {
                    if (curRowWidth > svgObjectWidth) {
                        curRowWidth -= legendsize.width + itemPadding;
                        maxRowWidth = Math.max(maxRowWidth, curRowWidth);
                        curRowWidth = legendsize.width + itemPadding;
                        totalRowHeight = totalRowHeight + curRowHeight + itemPadding;
                    }
                }
                if (itemsCountRow === allowItems || i === length - 1) {
                    maxRowWidth = Math.max(maxRowWidth, curRowWidth);
                    totalRowHeight = totalRowHeight + curRowHeight + itemPadding;
                    legendHeight = totalRowHeight;
                    itemsCountRow = 0;
                    curRowHeight = 0;
                    curRowWidth = 0;
                }
            }
            width = (titleSize.width) > maxRowWidth - itemPadding ? (titleSize.width + padding * 2 + itemPadding) :
                maxRowWidth + padding * 2 - (smithchart.border.width * 2);
            height = legendHeight + smithchart.elementSpacing;
            legendBounds = { x: 0, y: 0, width: width, height: height };
        }
        this.legendActualBounds = legendBounds;
        if (legendSizeWidth != null) {
            this.legendActualBounds.width = legendSizeWidth;
        }
        if (legendSizeHeight != null) {
            this.legendActualBounds.height = legendSizeHeight;
        }
    };
    SmithchartLegend.prototype._getLegendSize = function (smithchart, series) {
        var legend = smithchart.legendSettings;
        var symbolWidth = legend.itemStyle.width;
        var symbolHeight = legend.itemStyle.height;
        var textSize = measureText$1(series.text, legend.textStyle, smithchart.themeStyle.legendLabelFont);
        var width = symbolWidth + textSize.width + legend.shapePadding;
        var height = Math.max(symbolHeight, textSize.height);
        return { width: width, height: height };
    };
    /* eslint-disable  */
    SmithchartLegend.prototype._drawLegend = function (smithchart) {
        var legend = smithchart.legendSettings;
        var legendPosition = legend.position.toLowerCase();
        var alignment = legend.alignment;
        var legendBounds = this.legendActualBounds;
        var maxWidth = 0;
        var startX;
        var startY;
        var titleFont = smithchart.title.font ? smithchart.title.font : smithchart.title.textStyle;
        var smithchartTitleHeight = measureText$1(smithchart.title.text, titleFont, smithchart.themeStyle.legendLabelFont).height;
        var smithchartSubtitleHeight = measureText$1(smithchart.title.subtitle.text, smithchart.title.subtitle.textStyle, smithchart.themeStyle.legendLabelFont).height;
        var elementSpacing = smithchart.elementSpacing;
        var offset = smithchartTitleHeight + smithchartSubtitleHeight + elementSpacing + smithchart.margin.top;
        var itemPadding = legend.itemPadding > 0 ? legend.itemPadding : 0;
        var svgObjectWidth = smithchart.availableSize.width;
        var svgObjectHeight = smithchart.availableSize.height;
        var legendBorder = legend.border.width;
        var legendWidth = 0;
        var titleSize = measureText$1(legend['title']['text'], legend.title.textStyle, smithchart.themeStyle.legendLabelFont);
        var legendTitleHeight = titleSize.height;
        var borderSize = smithchart.border.width;
        var svgWidth = svgObjectWidth - ((borderSize * 2));
        var svgHeight = svgObjectHeight - ((borderSize * 2));
        legendBounds.height += legendTitleHeight;
        if (legendPosition !== 'custom') {
            switch (legendPosition) {
                case 'bottom':
                    legendBounds.y = svgHeight - (legendBounds.height + (legendBorder) + elementSpacing);
                    break;
                case 'top':
                    legendBounds.y = borderSize + offset;
                    break;
                case 'right':
                    legendBounds.x = svgWidth - legendBounds.width - (elementSpacing * 2);
                    break;
                case 'left':
                    legendBounds.x = borderSize + (elementSpacing * 2);
                    break;
            }
            if (legendPosition === 'left' || legendPosition === 'right') {
                switch (alignment) {
                    case 'Center':
                        legendBounds.y = (svgHeight / 2) - ((legendBounds.height + legendBorder * 2) / 2) + (elementSpacing / 2);
                        break;
                    case 'Near':
                        legendBounds.y = borderSize + (elementSpacing * 2) + offset;
                        break;
                    case 'Far':
                        legendBounds.y = svgHeight - (legendBounds.height + (legendBorder)) - (elementSpacing * 2);
                        break;
                }
            }
            else {
                switch (alignment) {
                    case 'Center':
                        legendBounds.x = (svgWidth / 2) - ((legendBounds.width + legendBorder * 2) / 2) + (elementSpacing / 2);
                        break;
                    case 'Near':
                        legendBounds.x = borderSize + (elementSpacing * 2);
                        break;
                    case 'Far':
                        legendBounds.x = svgWidth - (legendBounds.width + (legendBorder)) - (elementSpacing * 2);
                        break;
                }
            }
        }
        else {
            legendBounds.y = (legend.location.y < svgHeight) ? legend.location.y : 0;
            legendBounds.x = (legend.location.x < svgWidth) ? legend.location.x : 0;
        }
        if (legendPosition === 'bottom' || legendPosition === 'top') {
            for (var i = 0; i < this.legendSeries.length; i++) {
                legendWidth += this.legendSeries[i].bounds.width + itemPadding;
                if (legendWidth > svgWidth) {
                    legendBounds.x = (svgWidth / 2) - ((legendBounds.width + legendBorder * 2) / 2) + (elementSpacing / 2);
                    break;
                }
            }
        }
        var gLegendEle = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_legend_group' });
        smithchart.svgObject.appendChild(gLegendEle);
        this.legendItemGroup = smithchart.renderer.createGroup({ 'id': smithchart.element.id + 'legendItem_Group' });
        var currentX = startX = elementSpacing;
        var currentY = startY = elementSpacing;
        if (legend.title.text !== '' && legend.title.visible) {
            gLegendEle.appendChild(this.drawLegendTitle(smithchart, legend, legendBounds, gLegendEle));
            currentY = startY = elementSpacing + legendTitleHeight;
        }
        for (var k = 0; k < this.legendSeries.length; k++) {
            if ((legend.rowCount < legend.columnCount || legend.rowCount === legend.columnCount) &&
                (legendPosition === 'top' || legendPosition === 'bottom' || legendPosition === 'custom')) {
                if ((currentX + this.legendSeries[k]['bounds'].width) > legendBounds.width + startX) {
                    currentX = elementSpacing;
                    currentY += this.legendSeries[k]['bounds'].height + itemPadding;
                }
                this.legendGroup = this.drawLegendItem(smithchart, legend, this.legendSeries[k], k, currentX, (currentY), legendBounds);
                gLegendEle.appendChild(this.legendGroup);
                currentX += this.legendSeries[k]['bounds'].width + itemPadding;
            }
            else {
                if (((currentY + this.legendSeries[k]['bounds'].height + itemPadding) +
                    legendTitleHeight + borderSize > legendBounds.height + startY)) {
                    currentY = startY;
                    currentX += maxWidth + (itemPadding);
                }
                this.legendGroup = this.drawLegendItem(smithchart, legend, this.legendSeries[k], k, (currentX), (currentY), legendBounds);
                gLegendEle.appendChild(this.legendGroup);
                currentY += this.legendSeries[k]['bounds'].height + itemPadding;
                maxWidth = Math.max(maxWidth, this.legendSeries[k]['bounds'].width);
            }
        }
        gLegendEle.setAttribute('transform', 'translate(' + legendBounds.x.toString() + ',' + legendBounds.y.toString() + ')');
        this.drawLegendBorder(gLegendEle, smithchart, legend, legendBounds);
    };
    SmithchartLegend.prototype.drawLegendBorder = function (gLegendEle, smithchart, legend, legendBounds) {
        var borderRect = new RectOption$1(smithchart.element.id + '_svg' + '_legendRect', 'none', legend.border, 1, new SmithchartRect(0, 0, legendBounds.width, legendBounds.height));
        gLegendEle.appendChild(smithchart.renderer.drawRectangle(borderRect));
    };
    SmithchartLegend.prototype.drawLegendTitle = function (smithchart, legend, legendBounds, gLegendEle) {
        var elementSpacing = smithchart.elementSpacing;
        var titleSize = measureText$1(legend.title.text, legend.title.textStyle, smithchart.themeStyle.legendLabelFont);
        var titleWidth = titleSize.width;
        var titleHeight = titleSize.height;
        var textAlignment = legend.title.textAlignment;
        var startX = 0;
        var legendBoundsWidth = legendBounds.width;
        var startY = elementSpacing + (titleHeight / 2);
        switch (textAlignment) {
            case 'Far':
                startX = legendBoundsWidth - titleWidth - startX;
                break;
            case 'Center':
                startX = legendBoundsWidth / 2 - (titleWidth) / 2;
                break;
        }
        if (startX < 0) {
            startX = 0;
            legendBoundsWidth = titleWidth;
        }
        if (legendBoundsWidth < titleWidth + startX) {
            legendBoundsWidth = titleWidth + startX;
        }
        var options = new TextOption$1(smithchart.element.id + '_LegendTitleText', startX, startY, 'start', legend.title.text);
        var element = renderTextElement(options, legend.title.textStyle, legend.title.textStyle.color || smithchart.themeStyle.legendTitleFont.color, gLegendEle, smithchart.themeStyle.legendTitleFont);
        element.setAttribute('aria-label', legend.title.description || legend.title.text);
        return element;
    };
    SmithchartLegend.prototype.drawLegendItem = function (smithchart, legend, legendSeries, k, x, y, legendBounds) {
        var _this = this;
        var location;
        var radius;
        var symbol = legend.itemStyle;
        var itemPadding = legend.itemPadding;
        var textHeight;
        radius = Math.sqrt(symbol['width'] * symbol['width'] + symbol['height'] * symbol['height']) / 2;
        textHeight = measureText$1(legendSeries['text'], legend.textStyle, smithchart.themeStyle.legendLabelFont).height;
        location = {
            x: x + symbol['width'] / 2,
            y: (y + (textHeight > symbol['height'] ? textHeight : symbol['height']) / 2)
        };
        var legendGroup = smithchart.renderer.createGroup({ id: smithchart.element.id + '_svg' + '_Legend' + k.toString() });
        legendGroup['style']['cursor'] = legend.toggleVisibility ? 'pointer' : 'default';
        var legendEventArgs = {
            text: legendSeries['text'],
            fill: legendSeries['fill'],
            shape: legendSeries['shape'],
            name: legendRender$1,
            cancel: false
        };
        var legendRenderSuccess = function (args) {
            if (!args.cancel) {
                var shape = _this.drawLegendShape(smithchart, legendSeries, location.x, location.y, k, legend, args);
                legendGroup.appendChild(shape);
                var options = new TextOption$1(smithchart.element.id + '_LegendItemText' + k.toString(), location.x + symbol['width'] / 2 + legend.shapePadding, location.y + textHeight / 4, 'start', args.text);
                legend.textStyle.fontFamily = legend.textStyle.fontFamily || smithchart.themeStyle.legendLabelFont.fontFamily;
                legend.textStyle.size = legend.textStyle.size || smithchart.themeStyle.legendLabelFont.size;
                var element = renderTextElement(options, legend.textStyle, legend.textStyle.color || smithchart.themeStyle.legendLabelFont.color, legendGroup, smithchart.themeStyle.legendLabelFont);
                legendGroup.setAttribute('aria-label', legend.description || ('Show ' + options.text));
                legendGroup.appendChild(element);
                _this.legendItemGroup.appendChild(legendGroup);
            }
        };
        legendRenderSuccess.bind(this);
        smithchart.trigger(legendRender$1, legendEventArgs, legendRenderSuccess);
        return this.legendItemGroup;
    };
    SmithchartLegend.prototype.drawLegendShape = function (smithchart, legendSeries, locX, locY, index, legend, legendEventArgs) {
        var element;
        var circleOptions;
        var pathOptions;
        var path;
        var symbol = legend.itemStyle;
        var width = symbol['width'];
        var height = symbol['height'];
        var x = locX + (-width / 2);
        var border = { color: symbol.border.color, width: symbol.border.width };
        var opacity = 1;
        var fill = (smithchart.series[index].visibility === 'visible') ? legendEventArgs.fill : 'grey';
        var shape = legendEventArgs.shape.toLowerCase();
        var radius = Math.sqrt(height * height + width * width) / 2;
        switch (shape) {
            case 'circle':
                circleOptions = new CircleOption$1(smithchart.element.id + '_svg' + '_LegendItemShape' + index.toString(), fill, border, opacity, locX, locY, radius, null);
                element = smithchart.renderer.drawCircle(circleOptions);
                break;
            case 'rectangle':
                path = 'M' + ' ' + x + ' ' + (locY + (-height / 2)) + ' ' +
                    'L' + ' ' + ((width / 2) + locX) + ' ' + (locY + (-height / 2)) + ' ' +
                    'L' + ' ' + (locX + (width / 2)) + ' ' + (locY + (height / 2)) + ' ' +
                    'L' + ' ' + x + ' ' + (locY + (height / 2)) + ' ' +
                    'L' + ' ' + x + ' ' + (locY + (-height / 2)) + ' z';
                pathOptions = new PathOption$1(smithchart.element.id + '_svg' + '_LegendItemShape' + index.toString(), fill, border.width, border.color, 1, '', path);
                element = smithchart.renderer.drawPath(pathOptions);
                break;
            case 'diamond':
                path = 'M' + ' ' + x + ' ' + locY + ' ' +
                    'L' + ' ' + locX + ' ' + (locY + (-height / 2)) + ' ' +
                    'L' + ' ' + ((width / 2) + locX) + ' ' + locY + ' ' +
                    'L' + ' ' + locX + ' ' + (locY + (height / 2)) + ' ' +
                    'L' + ' ' + x + ' ' + locY + ' z';
                pathOptions = new PathOption$1(smithchart.element.id + '_svg' + '_LegendItemShape' + index.toString(), fill, border.width, border.color, 1, '', path);
                element = smithchart.renderer.drawPath(pathOptions);
                break;
            case 'pentagon':
                var eq = 72;
                for (var j = 0; j <= 5; j++) {
                    var xValue = radius * Math.cos((Math.PI / 180) * (j * eq));
                    var yValue = radius * Math.sin((Math.PI / 180) * (j * eq));
                    if (j === 0) {
                        path = 'M' + ' ' + (xValue + locX) + ' ' + (locY + yValue) + ' ';
                    }
                    else {
                        path = path.concat('L' + ' ' + (locX + xValue) + ' ' + (locY + yValue) + ' ');
                    }
                }
                path = path.concat('Z');
                pathOptions = new PathOption$1(smithchart.element.id + '_svg' + '_LegendItemShape' + index.toString(), fill, border.width, border.color, 1, '', path);
                element = smithchart.renderer.drawPath(pathOptions);
                break;
            case 'triangle':
                path = 'M' + ' ' + x + ' ' + ((height / 2) + locY) + ' ' +
                    'L' + ' ' + locX + ' ' + (locY + (-height / 2)) + ' ' +
                    'L' + ' ' + (locX + (width / 2)) + ' ' + (locY + (height / 2)) + ' ' +
                    'L' + ' ' + x + ' ' + (locY + (height / 2)) + ' Z';
                pathOptions = new PathOption$1(smithchart.element.id + '_svg' + '_LegendItemShape' + index.toString(), fill, border.width, border.color, 1, '', path);
                element = smithchart.renderer.drawPath(pathOptions);
                break;
        }
        return element;
    };
    /**
     * Get module name.
     */
    SmithchartLegend.prototype.getModuleName = function () {
        return 'SmithchartLegend';
    };
    /**
     * To destroy the legend.
     * @return {void}
     * @private
     */
    SmithchartLegend.prototype.destroy = function (smithchart) {
        /**
         * Destroy method performed here
         */
    };
    return SmithchartLegend;
}());

var __extends$95 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$23 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Sparkline base API Class declarations.
 */
/**
 * Configures the borders in the Sparkline.
 */
var SparklineBorder = /** @__PURE__ @class */ (function (_super) {
    __extends$95(SparklineBorder, _super);
    function SparklineBorder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$23([
        Property('')
    ], SparklineBorder.prototype, "color", void 0);
    __decorate$23([
        Property(0)
    ], SparklineBorder.prototype, "width", void 0);
    return SparklineBorder;
}(ChildProperty));
/**
 * Configures the fonts in sparklines.
 */
var SparklineFont = /** @__PURE__ @class */ (function (_super) {
    __extends$95(SparklineFont, _super);
    function SparklineFont() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$23([
        Property(null)
    ], SparklineFont.prototype, "size", void 0);
    __decorate$23([
        Property(null)
    ], SparklineFont.prototype, "color", void 0);
    __decorate$23([
        Property('Roboto, Segoe UI, Noto, Sans-serif')
    ], SparklineFont.prototype, "fontFamily", void 0);
    __decorate$23([
        Property(null)
    ], SparklineFont.prototype, "fontWeight", void 0);
    __decorate$23([
        Property(null)
    ], SparklineFont.prototype, "fontStyle", void 0);
    __decorate$23([
        Property(1)
    ], SparklineFont.prototype, "opacity", void 0);
    return SparklineFont;
}(ChildProperty));
/**
 * To configure the tracker line settings.
 */
var TrackLineSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$95(TrackLineSettings, _super);
    function TrackLineSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$23([
        Property(false)
    ], TrackLineSettings.prototype, "visible", void 0);
    __decorate$23([
        Property(null)
    ], TrackLineSettings.prototype, "color", void 0);
    __decorate$23([
        Property(1)
    ], TrackLineSettings.prototype, "width", void 0);
    return TrackLineSettings;
}(ChildProperty));
/**
 * To configure the tooltip settings for sparkline.
 */
var SparklineTooltipSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$95(SparklineTooltipSettings, _super);
    function SparklineTooltipSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$23([
        Property(false)
    ], SparklineTooltipSettings.prototype, "visible", void 0);
    __decorate$23([
        Property('')
    ], SparklineTooltipSettings.prototype, "fill", void 0);
    __decorate$23([
        Property('')
    ], SparklineTooltipSettings.prototype, "template", void 0);
    __decorate$23([
        Property('')
    ], SparklineTooltipSettings.prototype, "format", void 0);
    __decorate$23([
        Complex({ color: null, width: null }, SparklineBorder)
    ], SparklineTooltipSettings.prototype, "border", void 0);
    __decorate$23([
        Complex({ size: '12px', fontWeight: null, fontStyle: 'Normal', fontFamily: null }, SparklineFont)
    ], SparklineTooltipSettings.prototype, "textStyle", void 0);
    __decorate$23([
        Complex({}, TrackLineSettings)
    ], SparklineTooltipSettings.prototype, "trackLineSettings", void 0);
    return SparklineTooltipSettings;
}(ChildProperty));
/**
 * To configure the sparkline container area customization
 */
var ContainerArea = /** @__PURE__ @class */ (function (_super) {
    __extends$95(ContainerArea, _super);
    function ContainerArea() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$23([
        Property('transparent')
    ], ContainerArea.prototype, "background", void 0);
    __decorate$23([
        Complex({}, SparklineBorder)
    ], ContainerArea.prototype, "border", void 0);
    return ContainerArea;
}(ChildProperty));
/**
 * To configure axis line settings
 */
var LineSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$95(LineSettings, _super);
    function LineSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$23([
        Property(false)
    ], LineSettings.prototype, "visible", void 0);
    __decorate$23([
        Property(null)
    ], LineSettings.prototype, "color", void 0);
    __decorate$23([
        Property('')
    ], LineSettings.prototype, "dashArray", void 0);
    __decorate$23([
        Property(1)
    ], LineSettings.prototype, "width", void 0);
    __decorate$23([
        Property(1)
    ], LineSettings.prototype, "opacity", void 0);
    return LineSettings;
}(ChildProperty));
/**
 * To configure the sparkline rangeband.
 */
var RangeBandSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$95(RangeBandSettings, _super);
    function RangeBandSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$23([
        Property(null)
    ], RangeBandSettings.prototype, "startRange", void 0);
    __decorate$23([
        Property(null)
    ], RangeBandSettings.prototype, "endRange", void 0);
    __decorate$23([
        Property(null)
    ], RangeBandSettings.prototype, "color", void 0);
    __decorate$23([
        Property(1)
    ], RangeBandSettings.prototype, "opacity", void 0);
    return RangeBandSettings;
}(ChildProperty));
/**
 * To configure the sparkline axis.
 */
var AxisSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$95(AxisSettings, _super);
    function AxisSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$23([
        Property(null)
    ], AxisSettings.prototype, "minX", void 0);
    __decorate$23([
        Property(null)
    ], AxisSettings.prototype, "maxX", void 0);
    __decorate$23([
        Property(null)
    ], AxisSettings.prototype, "minY", void 0);
    __decorate$23([
        Property(null)
    ], AxisSettings.prototype, "maxY", void 0);
    __decorate$23([
        Property(0)
    ], AxisSettings.prototype, "value", void 0);
    __decorate$23([
        Complex({}, LineSettings)
    ], AxisSettings.prototype, "lineSettings", void 0);
    return AxisSettings;
}(ChildProperty));
/**
 * To configure the sparkline padding.
 */
var Padding = /** @__PURE__ @class */ (function (_super) {
    __extends$95(Padding, _super);
    function Padding() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$23([
        Property(5)
    ], Padding.prototype, "left", void 0);
    __decorate$23([
        Property(5)
    ], Padding.prototype, "right", void 0);
    __decorate$23([
        Property(5)
    ], Padding.prototype, "bottom", void 0);
    __decorate$23([
        Property(5)
    ], Padding.prototype, "top", void 0);
    return Padding;
}(ChildProperty));
/**
 * To configure the sparkline marker options.
 */
var SparklineMarkerSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$95(SparklineMarkerSettings, _super);
    function SparklineMarkerSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$23([
        Property([])
    ], SparklineMarkerSettings.prototype, "visible", void 0);
    __decorate$23([
        Property(1)
    ], SparklineMarkerSettings.prototype, "opacity", void 0);
    __decorate$23([
        Property(8)
    ], SparklineMarkerSettings.prototype, "size", void 0);
    __decorate$23([
        Property('#00bdae')
    ], SparklineMarkerSettings.prototype, "fill", void 0);
    __decorate$23([
        Complex({ width: 1 }, SparklineBorder)
    ], SparklineMarkerSettings.prototype, "border", void 0);
    return SparklineMarkerSettings;
}(ChildProperty));
/**
 * To configure the datalabel offset
 */
var LabelOffset = /** @__PURE__ @class */ (function (_super) {
    __extends$95(LabelOffset, _super);
    function LabelOffset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$23([
        Property(0)
    ], LabelOffset.prototype, "x", void 0);
    __decorate$23([
        Property(0)
    ], LabelOffset.prototype, "y", void 0);
    return LabelOffset;
}(ChildProperty));
/**
 * To configure the sparkline dataLabel options.
 */
var SparklineDataLabelSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$95(SparklineDataLabelSettings, _super);
    function SparklineDataLabelSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$23([
        Property([])
    ], SparklineDataLabelSettings.prototype, "visible", void 0);
    __decorate$23([
        Property(1)
    ], SparklineDataLabelSettings.prototype, "opacity", void 0);
    __decorate$23([
        Property('transparent')
    ], SparklineDataLabelSettings.prototype, "fill", void 0);
    __decorate$23([
        Property('')
    ], SparklineDataLabelSettings.prototype, "format", void 0);
    __decorate$23([
        Complex({ color: 'transparent', width: 0 }, SparklineBorder)
    ], SparklineDataLabelSettings.prototype, "border", void 0);
    __decorate$23([
        Complex({ size: '12px', fontWeight: '400', fontStyle: 'Medium', fontFamily: null }, SparklineFont)
    ], SparklineDataLabelSettings.prototype, "textStyle", void 0);
    __decorate$23([
        Complex({}, LabelOffset)
    ], SparklineDataLabelSettings.prototype, "offset", void 0);
    __decorate$23([
        Property('None')
    ], SparklineDataLabelSettings.prototype, "edgeLabelMode", void 0);
    return SparklineDataLabelSettings;
}(ChildProperty));

var __extends$96 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Sparkline control helper file
 */
/**
 * sparkline internal use of `Size` type
 */
var Size$1 = /** @__PURE__ @class */ (function () {
    function Size$$1(width, height) {
        this.width = width;
        this.height = height;
    }
    return Size$$1;
}());
/** @private */
function getSeriesColor$2(theme) {
    var palette;
    switch (theme) {
        case 'Fabric':
            palette = ['#4472c4', '#ed7d31', '#ffc000', '#70ad47', '#5b9bd5',
                '#c1c1c1', '#6f6fe2', '#e269ae', '#9e480e', '#997300'];
            break;
        case 'Bootstrap4':
            palette = ['#a16ee5', '#f7ce69', '#55a5c2', '#7ddf1e', '#ff6ea6',
                '#7953ac', '#b99b4f', '#407c92', '#5ea716', '#b91c52'];
            break;
        case 'Bootstrap':
            palette = ['#a16ee5', '#f7ce69', '#55a5c2', '#7ddf1e', '#ff6ea6',
                '#7953ac', '#b99b4f', '#407c92', '#5ea716', '#b91c52'];
            break;
        case 'HighContrastLight':
        case 'HighContrast':
            palette = ['#79ECE4', '#E98272', '#DFE6B6', '#C6E773', '#BA98FF',
                '#FA83C3', '#00C27A', '#43ACEF', '#D681EF', '#D8BC6E'];
            break;
        case 'MaterialDark':
            palette = ['#9ECB08', '#56AEFF', '#C57AFF', '#61EAA9', '#EBBB3E',
                '#F45C5C', '#8A77FF', '#63C7FF', '#FF84B0', '#F7C928'];
            break;
        case 'FabricDark':
            palette = ['#4472c4', '#ed7d31', '#ffc000', '#70ad47', '#5b9bd5',
                '#c1c1c1', '#6f6fe2', '#e269ae', '#9e480e', '#997300'];
            break;
        case 'BootstrapDark':
            palette = ['#a16ee5', '#f7ce69', '#55a5c2', '#7ddf1e', '#ff6ea6',
                '#7953ac', '#b99b4f', '#407c92', '#5ea716', '#b91c52'];
            break;
        case 'Tailwind':
            palette = ['#5A61F6', '#65A30D', '#334155', '#14B8A6', '#8B5CF6',
                '#0369A1', '#F97316', '#9333EA', '#F59E0B', '#15803D'];
            break;
        case 'TailwindDark':
            palette = ['#8B5CF6', '#22D3EE', '#F87171', '#4ADE80', '#E879F9',
                '#FCD34D', '#F97316', '#2DD4BF', '#F472B6', '#10B981'];
            break;
        case 'Bootstrap5':
            palette = ['#6355C7', '#FFB400', '#2196F5', '#F7523F', '#963C70',
                '#4BE0BC', '#FD7400', '#C9E422', '#DE3D8A', '#162F88'];
            break;
        case 'Bootstrap5Dark':
            palette = ['#8F80F4', '#FFD46D', '#6CBDFF', '#FF7F71', '#FF6DB3',
                '#63F5D2', '#FCAA65', '#ECFF77', '#EF8EFF', '#5F82FD'];
            break;
        case 'FluentDark':
            palette = ['#1AC9E6', '#DA4CB2', '#EDBB40', '#AF4BCF', '#FF7266',
                '#1BD565', '#EE993D', '#5887FF', '#EC548D', '#7D39C0'];
            break;
        case 'Fluent':
            palette = ['#1AC9E6', '#DA4CB2', '#EDBB40', '#AF4BCF', '#FF7266',
                '#1BD565', '#EE993D', '#5887FF', '#EC548D', '#7D39C0'];
            break;
        case 'Material3':
            palette = ['#6355C7', '#00AEE0', '#FFB400', '#F7523F', '#963C70',
                '#FD7400', '#4BE0BC', '#2196F5', '#DE3D8A', '#162F88'];
            break;
        case 'Material3Dark':
            palette = ['#4EAAFF', '#FA4EAB', '#FFF500', '#17EA58', '#38FFE7',
                '#FF9E45', '#B3F32F', '#B93CE4', '#FC5664', '#9B55FF'];
            break;
        default:
            palette = ['#00bdae', '#404041', '#357cd2', '#e56590', '#f8b883',
                '#70ad47', '#dd8abd', '#7f84e8', '#7bb4eb', '#ea7a57'];
            break;
    }
    return palette;
}
/**
 * To find the default colors based on theme.
 *
 * @private
 */
// tslint:disable-next-line:max-func-body-length
function getThemeColor$2(theme) {
    var themeColors;
    switch (theme) {
        case 'BootstrapDark':
        case 'FabricDark':
        case 'MaterialDark':
        case 'HighContrast':
            themeColors = {
                axisLineColor: '#ffffff',
                dataLabelColor: theme === 'BootstrapDark' ? '#676767' : theme === 'FabricDark' ? '#A19F9D' : theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : '#969696',
                rangeBandColor: '#ffffff',
                tooltipFill: theme === 'BootstrapDark' ? '#F0F0F0' : theme === 'FabricDark' ? '#A19F9D' : theme === 'MaterialDark' ? '#F4F4F4' : '#FFFFFF',
                background: '#000000',
                tooltipFontColor: theme === 'BootstrapDark' ? '#1A1A1A' : theme === 'FabricDark' ? '#DADADA' : theme === 'MaterialDark' ? 'rgba(18, 18, 18, 1)' : '#000000',
                trackerLineColor: '#ffffff',
                labelFontFamily: theme === 'BootstrapDark' ? 'Helvetica' : theme === 'FabricDark' ? 'Segoe UI' : theme === 'MaterialDark' ? 'Roboto' : 'Segoe UI',
                tooltipFontFamily: theme === 'BootstrapDark' ? 'Helvetica' : theme === 'FabricDark' ? 'Segoe UI' : theme === 'MaterialDark' ? 'Roboto' : 'Segoe UI',
                dataLabelFont: {
                    fontFamily: theme === 'BootstrapDark' ? 'Helvetica' : theme === 'FabricDark' ? 'Segoe UI' : theme === 'MaterialDark' ? 'Roboto' : 'Segoe UI', color: theme === 'BootstrapDark' ? '#676767' : theme === 'FabricDark' ? '#A19F9D' : theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : '#969696'
                }
            };
            break;
        case 'Bootstrap4':
            themeColors = {
                axisLineColor: '#6C757D',
                dataLabelColor: '#495057',
                rangeBandColor: '#212529',
                tooltipFill: '#212529',
                background: '#FFFFFF',
                tooltipFontColor: '#F9FAFB',
                trackerLineColor: '#212529',
                fontFamily: 'Helvetica',
                tooltipFillOpacity: 1,
                tooltipTextOpacity: 0.9,
                labelFontFamily: 'Helvetica',
                tooltipFontFamily: 'Helvetica',
                dataLabelFont: {
                    fontFamily: 'Helvetica', color: '#495057'
                }
            };
            break;
        case 'Tailwind':
            themeColors = {
                axisLineColor: '#4B5563',
                dataLabelColor: '#6B7280',
                rangeBandColor: '#212529',
                background: '#FFFFFF',
                tooltipFill: '#111827',
                tooltipFontColor: '#F9FAFB',
                trackerLineColor: '#1F2937',
                fontFamily: 'Inter',
                tooltipFillOpacity: 1,
                tooltipTextOpacity: 1,
                labelFontFamily: 'Inter',
                tooltipFontFamily: 'Inter',
                dataLabelFont: {
                    fontFamily: 'Inter', color: '#6B7280'
                }
            };
            break;
        case 'TailwindDark':
            themeColors = {
                axisLineColor: '#D1D5DB',
                dataLabelColor: '#9CA3AF',
                rangeBandColor: '#F9FAFB',
                background: 'transparent',
                tooltipFill: '#E9ECEF',
                tooltipFontColor: '#1F2937',
                trackerLineColor: '#9CA3AF',
                fontFamily: 'Inter',
                tooltipFillOpacity: 1,
                tooltipTextOpacity: 1,
                labelFontFamily: 'Inter',
                tooltipFontFamily: 'Inter',
                dataLabelFont: {
                    fontFamily: 'Inter', color: '#9CA3AF'
                }
            };
            break;
        case 'Bootstrap5':
            themeColors = {
                axisLineColor: '#D1D5DB',
                dataLabelColor: '#495057',
                rangeBandColor: '#212529',
                background: 'rgba(255, 255, 255, 0.0)',
                tooltipFill: '#212529',
                tooltipFontColor: '#F9FAFB',
                trackerLineColor: '#1F2937',
                fontFamily: 'Helvetica',
                tooltipFillOpacity: 1,
                tooltipTextOpacity: 1,
                labelFontFamily: 'Helvetica',
                tooltipFontFamily: 'Helvetica',
                dataLabelFont: {
                    fontFamily: 'Helvetica', color: '#495057'
                }
            };
            break;
        case 'Bootstrap5Dark':
            themeColors = {
                axisLineColor: '#D1D5DB',
                dataLabelColor: '#E9ECEF',
                rangeBandColor: '#ADB5BD',
                background: 'rgba(255, 255, 255, 0.0)',
                tooltipFill: '#E9ECEF',
                tooltipFontColor: '#212529',
                trackerLineColor: '#ADB5BD',
                fontFamily: 'Helvetica',
                tooltipFillOpacity: 1,
                tooltipTextOpacity: 1,
                labelFontFamily: 'Helvetica',
                tooltipFontFamily: 'Helvetica',
                dataLabelFont: {
                    fontFamily: 'Helvetica', color: '#E9ECEF'
                }
            };
            break;
        case 'Fluent':
            themeColors = {
                axisLineColor: '#D2D0CE;',
                dataLabelColor: '#3B3A39',
                rangeBandColor: '#A19F9D',
                background: 'rgba(255, 255, 255, 0.0001)',
                tooltipFill: '#FFFFFF',
                tooltipFontColor: '#323130',
                trackerLineColor: '#A19F9D',
                fontFamily: 'Segoe UI',
                tooltipFillOpacity: 1,
                tooltipTextOpacity: 1,
                labelFontFamily: 'Segoe UI',
                tooltipFontFamily: 'Segoe UI',
                dataLabelFont: {
                    fontFamily: 'Segoe UI', color: '#3B3A39'
                }
            };
            break;
        case 'FluentDark':
            themeColors = {
                axisLineColor: '#3B3A39;',
                dataLabelColor: '#D2D0CE',
                rangeBandColor: '#797775',
                background: 'transparent',
                tooltipFill: '#323130',
                tooltipFontColor: '#F3F2F1',
                trackerLineColor: '#797775',
                fontFamily: 'Segoe UI',
                tooltipFillOpacity: 1,
                tooltipTextOpacity: 1,
                labelFontFamily: 'Segoe UI',
                tooltipFontFamily: 'Segoe UI',
                dataLabelFont: {
                    fontFamily: 'Segoe UI', color: '#D2D0CE'
                }
            };
            break;
        case 'Material3':
            themeColors = {
                axisLineColor: '#C4C7C5',
                dataLabelColor: '#49454E',
                rangeBandColor: 'rgba(73, 69, 78, 0.3)',
                background: 'rgba(255, 255, 255, 0.0001)',
                tooltipFill: '#313033',
                tooltipFontColor: '#F4EFF4',
                trackerLineColor: '#49454E',
                fontFamily: 'Roboto',
                tooltipFillOpacity: 1,
                tooltipTextOpacity: 1,
                labelFontFamily: 'Roboto',
                tooltipFontFamily: 'Roboto',
                dataLabelFont: {
                    fontFamily: 'Roboto', color: '#49454E'
                }
            };
            break;
        case 'Material3Dark':
            themeColors = {
                axisLineColor: '#49454F',
                dataLabelColor: '#CAC4D0',
                rangeBandColor: 'rgba(202, 196, 208, 0.3)',
                background: 'transparent',
                tooltipFill: '#E6E1E5',
                tooltipFontColor: '#313033',
                trackerLineColor: '#CAC4D0',
                fontFamily: 'Roboto',
                tooltipFillOpacity: 1,
                tooltipTextOpacity: 1,
                labelFontFamily: 'Roboto',
                tooltipFontFamily: 'Roboto',
                dataLabelFont: {
                    fontFamily: 'Roboto', color: '#CAC4D0'
                }
            };
            break;
        default: {
            themeColors = {
                axisLineColor: '#000000',
                dataLabelColor: theme === 'Bootstrap' ? '#676767' : theme === 'Fabric' ? '#666666' : 'rgba(97, 97, 97, 1)',
                rangeBandColor: '#000000',
                background: '#FFFFFF',
                tooltipFill: theme === 'Bootstrap' ? '#212529' : theme === 'Fabric' ? '#FFFFFF' : '#000816',
                tooltipFontColor: theme === 'Bootstrap' ? '#F9FAFB' : theme === 'Fabric' ? '#333333' : 'rgba(249, 250, 251, 1)',
                trackerLineColor: '#000000',
                labelFontFamily: theme === 'Bootstrap' ? 'Helvetica' : theme === 'Fabric' ? 'Segoe UI' : 'Roboto',
                tooltipFontFamily: theme === 'Bootstrap' ? 'Helvetica' : theme === 'Fabric' ? 'Segoe UI' : 'Roboto',
                dataLabelFont: {
                    fontFamily: theme === 'Bootstrap' ? 'Helvetica' : theme === 'Fabric' ? 'Segoe UI' : 'Roboto', color: theme === 'Bootstrap' ? '#676767' : theme === 'Fabric' ? '#666666' : 'rgba(97, 97, 97, 1)'
                }
            };
            break;
        }
    }
    return themeColors;
}
/**
 * To find number from string
 *
 * @private
 */
function stringToNumber$2(value, containerSize) {
    if (value !== null && value !== undefined) {
        return value.indexOf('%') !== -1 ? (containerSize / 100) * parseInt(value, 10) : parseInt(value, 10);
    }
    return null;
}
/**
 * Method to calculate the width and height of the sparkline.
 */
function calculateSize$2(sparkline) {
    var containerWidth = !sparkline.element.clientWidth ? (!sparkline.element.parentElement ? 100 :
        (!sparkline.element.parentElement.clientWidth ? window.innerWidth : sparkline.element.parentElement.clientWidth)) :
        sparkline.element.clientWidth;
    var containerHeight = !sparkline.element.clientHeight ? (!sparkline.element.parentElement ? 50 :
        sparkline.element.parentElement.clientHeight) : sparkline.element.clientHeight;
    sparkline.availableSize = new Size$1(stringToNumber$2(sparkline.width, containerWidth) || containerWidth, stringToNumber$2(sparkline.height, containerHeight) || containerHeight || (sparkline.isDevice ?
        Math.min(window.innerWidth, window.innerHeight) : containerHeight));
}
/**
 * Method to create svg for sparkline.
 */
function createSvg$2(sparkline) {
    sparkline.renderer = new SvgRenderer(sparkline.element.id);
    calculateSize$2(sparkline);
    sparkline.svgObject = sparkline.renderer.createSvg({
        id: sparkline.element.id + '_svg',
        width: sparkline.availableSize.width,
        height: sparkline.availableSize.height
    });
}
/**
 * Internal use of type rect
 *
 * @private
 */
var Rect$1 = /** @__PURE__ @class */ (function () {
    function Rect$$1(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    return Rect$$1;
}());
/**
 * Internal use of path options
 *
 * @private
 */
var PathOption$2 = /** @__PURE__ @class */ (function () {
    function PathOption$$1(id, fill, width, color, opacity, dashArray, d) {
        this.id = id;
        this.fill = fill;
        this.opacity = opacity;
        this['stroke-width'] = width;
        this.stroke = color;
        this.d = d;
        this['stroke-dasharray'] = dashArray;
    }
    return PathOption$$1;
}());
/**
 * Internal use of rectangle options
 *
 * @private
 */
var RectOption$2 = /** @__PURE__ @class */ (function (_super) {
    __extends$96(RectOption, _super);
    function RectOption(id, fill, border, opacity, rect, tl, tr, bl, br) {
        if (tl === void 0) { tl = 0; }
        if (tr === void 0) { tr = 0; }
        if (bl === void 0) { bl = 0; }
        if (br === void 0) { br = 0; }
        var _this = _super.call(this, id, fill, border.width, border.color, opacity) || this;
        _this.rect = rect;
        _this.topLeft = tl;
        _this.topRight = tr;
        _this.bottomLeft = bl;
        _this.bottomRight = br;
        return _this;
    }
    return RectOption;
}(PathOption$2));
/**
 * Internal use of circle options
 *
 * @private
 */
var CircleOption$2 = /** @__PURE__ @class */ (function (_super) {
    __extends$96(CircleOption, _super);
    function CircleOption(id, fill, border, opacity, cx, cy, r, dashArray) {
        var _this = _super.call(this, id, fill, border.width, border.color, opacity) || this;
        _this.cy = cy;
        _this.cx = cx;
        _this.r = r;
        _this['stroke-dasharray'] = dashArray;
        return _this;
    }
    return CircleOption;
}(PathOption$2));
/**
 * Internal use of append shape element
 *
 * @private
 */
function appendShape(shape, element) {
    if (element) {
        element.appendChild(shape);
    }
    return shape;
}
/**
 * Internal rendering of Circle
 *
 * @private
 */
function drawCircle(sparkline, options, element) {
    return appendShape(sparkline.renderer.drawCircle(options), element);
}
/**
 * To get rounded rect path direction.
 */
function calculateRoundedRectPath(r, topLeft, topRight, bottomLeft, bottomRight) {
    return 'M' + ' ' + r.x + ' ' + (topLeft + r.y) +
        ' Q ' + r.x + ' ' + r.y + ' ' + (r.x + topLeft) + ' ' +
        r.y + ' ' + 'L' + ' ' + (r.x + r.width - topRight) + ' ' + r.y +
        ' Q ' + (r.x + r.width) + ' ' + r.y + ' ' +
        (r.x + r.width) + ' ' + (r.y + topRight) + ' ' + 'L ' +
        (r.x + r.width) + ' ' + (r.y + r.height - bottomRight)
        + ' Q ' + (r.x + r.width) + ' ' + (r.y + r.height) + ' ' + (r.x + r.width - bottomRight) + ' ' +
        (r.y + r.height) + ' ' + 'L ' + (r.x + bottomLeft) + ' ' + (r.y + r.height) + ' Q ' + r.x + ' ' +
        (r.y + r.height) + ' ' + r.x + ' ' + (r.y + r.height - bottomLeft) + ' ' + 'L' + ' ' + r.x + ' ' +
        (topLeft + r.y) + ' ' + 'Z';
}
/**
 * Internal rendering of Rectangle
 *
 * @private
 */
function drawRectangle(sparkline, options, element) {
    options.d = calculateRoundedRectPath(options.rect, options.topLeft, options.topRight, options.bottomLeft, options.bottomRight);
    return appendShape(sparkline.renderer.drawPath(options), element);
}
/**
 * Internal rendering of Path
 *
 * @private
 */
function drawPath(sparkline, options, element) {
    return appendShape(sparkline.renderer.drawPath(options), element);
}
/**
 * Function to measure the height and width of the text.
 *
 * @private
 */
function measureText$2(text, font, themeStyle) {
    var htmlObject = document.getElementById('sparklinesmeasuretext');
    if (htmlObject === null) {
        htmlObject = createElement('text', { id: 'sparklinesmeasuretext' });
        document.body.appendChild(htmlObject);
    }
    htmlObject.innerText = text;
    htmlObject.style.fontStyle = font.fontStyle;
    htmlObject.style.fontFamily = font.fontFamily || themeStyle.fontFamily;
    htmlObject.style.visibility = 'hidden';
    htmlObject.style.top = '-100';
    htmlObject.style.left = '0';
    htmlObject.style.position = 'absolute';
    htmlObject.style.fontSize = font.size;
    htmlObject.style.fontWeight = font.fontWeight;
    htmlObject.style.whiteSpace = 'nowrap';
    // For Bootstrap line height issue
    htmlObject.style.lineHeight = 'normal';
    return new Size$1(htmlObject.clientWidth, htmlObject.clientHeight);
}
/**
 * Internal use of text options
 *
 * @private
 */
var TextOption$2 = /** @__PURE__ @class */ (function () {
    function TextOption$$1(id, x, y, anchor, text, baseLine, transform) {
        if (transform === void 0) { transform = ''; }
        this.transform = '';
        this.baseLine = 'auto';
        this.id = id;
        this.x = x;
        this.y = y;
        this.anchor = anchor;
        this.text = text;
        this.transform = transform;
        this.baseLine = baseLine;
    }
    return TextOption$$1;
}());
/**
 * Internal rendering of text
 *
 * @private
 */
function renderTextElement$1(options, font, color, parent, themeStyle) {
    var textOptions = {
        'id': options.id,
        'x': options.x,
        'y': options.y,
        'transform': options.transform,
        'opacity': font.opacity,
        'fill': color,
        'font-family': font.fontFamily || themeStyle.fontFamily,
        'font-weight': font.fontWeight,
        'font-size': font.size,
        'font-style': font.fontStyle,
        'text-anchor': options.anchor,
        'dominant-baseline': options.baseLine
    };
    var renderer = new SvgRenderer('');
    var htmlObject = renderer.createText(textOptions, options.text);
    htmlObject.style['user-select'] = 'none';
    htmlObject.style['-moz-user-select'] = 'none';
    htmlObject.style['-webkit-touch-callout'] = 'none';
    htmlObject.style['-webkit-user-select'] = 'none';
    htmlObject.style['-khtml-user-select'] = 'none';
    htmlObject.style['-ms-user-select'] = 'none';
    htmlObject.style['-o-user-select'] = 'none';
    parent.appendChild(htmlObject);
    return htmlObject;
}
/**
 * To remove element by id.
 */
function removeElement$3(id) {
    var element = document.getElementById(id);
    return element ? remove(element) : null;
}
/**
 * To find the element by id.
 */
function getIdElement(id) {
    return document.getElementById(id);
}
/**
 * To find point within the bounds.
 */
function withInBounds$1(x, y, bounds) {
    return (x >= bounds.x && x <= bounds.x + bounds.width && y >= bounds.y && y <= bounds.y + bounds.height);
}

/**
 * Sparkline rendering calculation file
 */
var SparklineRenderer = /** @__PURE__ @class */ (function () {
    /**
     * Sparkline data calculations
     */
    function SparklineRenderer(sparkline) {
        this.sparkline = sparkline;
    }
    /**
     * To process the sparkline data.
     */
    SparklineRenderer.prototype.processData = function () {
        var data = this.sparkline.dataSource;
        if (isNullOrUndefined(data) || !data.length) {
            return;
        }
        else if (!isNaN(this.sparkline.dataSource[0]) || this.sparkline.valueType === 'Numeric') {
            data = (this.sparkline.enableRtl) ? data.reverse() : data;
            this.sparkline.sparklineData = data; // extend([], data) as Object[];
        }
        else {
            this['process' + this.sparkline.valueType]();
        }
        this.axisCalculation();
    };
    SparklineRenderer.prototype.processDataManager = function () {
        var _this = this;
        var dataModule;
        var queryModule;
        if (this.sparkline.dataSource instanceof DataManager) {
            dataModule = this.sparkline.dataSource;
            queryModule = this.sparkline.query instanceof Query ? this.sparkline.query : new Query();
            var dataManager = dataModule.executeQuery(queryModule);
            dataManager.then(function (e) {
                _this.sparkline.setProperties({ dataSource: e['result'] }, true);
                _this.sparkline.sparklineData = _this.sparkline.dataSource;
                _this.sparkline.processSparklineData();
            });
        }
        else {
            this.sparkline.processSparklineData();
        }
    };
    /**
     * To process sparkline category data.
     */
    SparklineRenderer.prototype.processCategory = function (data, x, y) {
        var _this = this;
        if (data === void 0) { data = this.sparkline.dataSource; }
        if (x === void 0) { x = this.sparkline.xName; }
        if (y === void 0) { y = this.sparkline.yName; }
        var temp = [];
        var xValues = [];
        data.forEach(function (value) {
            if (xValues.indexOf(value[x]) === -1) {
                xValues.push(value[x]);
            }
            var currentData = {};
            currentData[_this.sparkline.xName] = xValues.indexOf(value[x]);
            currentData[_this.sparkline.yName] = value[y];
            temp.push(currentData);
        });
        this.sparkline.sparklineData = temp;
    };
    /**
     * To process sparkline DateTime data.
     */
    SparklineRenderer.prototype.processDateTime = function (data, x, y) {
        if (data === void 0) { data = this.sparkline.dataSource; }
        if (x === void 0) { x = this.sparkline.xName; }
        if (y === void 0) { y = this.sparkline.yName; }
        var temp = [];
        data.forEach(function (value) {
            var currentData = {};
            currentData[x] = value[x].getTime();
            currentData[y] = value[y];
            temp.push(currentData);
        });
        this.sparkline.sparklineData = temp;
    };
    /**
     * To render sparkline series.
     *
     * @private
     */
    SparklineRenderer.prototype.renderSeries = function () {
        var _this = this;
        var spark = this.sparkline;
        this.clipId = spark.element.id + '_sparkline_clip_path';
        this.drawAxis();
        var argsData = {
            name: 'seriesRendering',
            cancel: false,
            lineWidth: spark.lineWidth,
            border: spark.border,
            fill: spark.fill,
            sparkline: spark
        };
        var seriesRenderingSuccess = function (args) {
            if (!_this.visiblePoints || args.cancel) {
                return;
            }
            if (spark.type !== 'Pie' && spark.type !== 'WinLoss' && spark.rangeBandSettings.length) {
                var group = _this.sparkline.renderer.createGroup({ id: _this.sparkline.element.id + '_sparkline_rangeband_g' });
                for (var i = 0; i < spark.rangeBandSettings.length; i++) {
                    if ((spark.axisSettings.minY <= spark.rangeBandSettings[i].startRange) ||
                        (spark.axisSettings.maxY >= spark.rangeBandSettings[i].endRange)) {
                        _this.rangeBand(spark.rangeBandSettings[i], group, i);
                    }
                }
                _this.sparkline.svgObject.appendChild(group);
            }
            _this['render' + spark.type](_this.visiblePoints, args);
            _this.renderMarker(_this.visiblePoints);
            _this.renderLabel(_this.visiblePoints);
        };
        seriesRenderingSuccess.bind(this);
        spark.trigger('seriesRendering', argsData, seriesRenderingSuccess);
    };
    /**
     * To render a range band
     */
    SparklineRenderer.prototype.rangeBand = function (rangeBandSettings, group, index) {
        var model = this.sparkline;
        var height = (model.availableSize.height) - model.padding.top * 2;
        var width = (model.availableSize.width) - model.padding.left * 2;
        var stValue = rangeBandSettings.startRange;
        var edValue = rangeBandSettings.endRange;
        var stHeight = (height - ((height / this.unitY) * (stValue - this.min))) + model.padding.top;
        var edHeight = (height - ((height / this.unitY) * (edValue - this.min))) + model.padding.top;
        var color = rangeBandSettings.color || this.sparkline.sparkTheme.rangeBandColor;
        if (edHeight > (height + model.padding.top)) {
            edHeight = (height + model.padding.top);
        }
        else if (edHeight < (0 + model.padding.top)) {
            edHeight = (0 + model.padding.top);
        }
        if (stHeight > (height + model.padding.top)) {
            stHeight = (height + model.padding.top);
        }
        else if (stHeight < (0 + model.padding.top)) {
            stHeight = (0 + model.padding.top);
        }
        var path = 'M ' + (model.padding.left) + ' ' + stHeight + ' L ' + (width + (model.padding.left)) + ' ' + stHeight +
            ' L ' + (width + (model.padding.left)) + ' ' + edHeight + ' L ' + (model.padding.left) + ' ' + edHeight + ' Z ';
        var pathOption = {
            'id': model.element.id + '_rangeBand_' + index,
            'fill': color,
            'opacity': rangeBandSettings.opacity,
            'stroke': 'transparent',
            'stroke-width': model.lineWidth,
            'd': path,
            'stroke-dasharray': ''
        };
        drawPath(this.sparkline, pathOption, group);
    };
    /**
     * To render line series
     */
    SparklineRenderer.prototype.renderLine = function (points, args) {
        var spark = this.sparkline;
        var g = this.sparkline.renderer.createGroup({
            id: spark.element.id + '_sparkline_g',
            'clip-path': 'url(#' + this.clipId + ')'
        });
        var color = this.sparkline.fill;
        color = (this.sparkline.fill === '#00bdae' && this.sparkline.theme === 'Bootstrap4')
            ? this.sparkline.sparkTheme.axisLineColor : color;
        var pathOption = new PathOption$2(spark.element.id + '_sparkline_line', 'transparent', args.lineWidth, color, spark.opacity);
        var d = '';
        for (var i = 0, len = points.length; i < len; i++) {
            if (i === 0) {
                d = 'M ' + points[0].x + ' ' + points[i].y + ' ';
            }
            d += 'L ' + points[i].x + ' ' + points[i].y + ' ';
        }
        pathOption.d = d;
        pathOption['aria-label'] = 'Line series with' + points.length + 'data points';
        drawPath(this.sparkline, pathOption, g);
        this.sparkline.svgObject.appendChild(g);
    };
    /**
     * To render pie series
     */
    SparklineRenderer.prototype.renderPie = function (points, args) {
        var spark = this.sparkline;
        var height = spark.availableSize.height - (spark.padding.top + spark.padding.bottom);
        var width = spark.availableSize.width - (spark.padding.left + spark.padding.right);
        var area = (height <= width) ? height / 2 : width / 2;
        var X = spark.availableSize.width / 2; // center position of x
        var Y = spark.availableSize.height / 2; // center position of y
        var deg = 0;
        var stRad;
        var edRad;
        var stroke = args.border.color;
        var opacity = spark.opacity;
        var strokeWidth = args.border.width;
        var colors = (spark.palette.length) ? spark.palette : getSeriesColor$2(this.sparkline.theme);
        var group = this.sparkline.renderer.createGroup({ id: spark.element.id + '_sparkline_g' });
        var low;
        var high;
        var locations = extend([], [], points);
        if (spark.highPointColor || spark.lowPointColor) {
            var pointsYvalues = locations.map(function (a) { return a.yVal; });
            low = Math.min.apply(null, pointsYvalues);
            high = Math.max.apply(null, pointsYvalues);
        }
        this.negativePointIndexes = [];
        for (var i = 0, stDeg = 90, edDeg = void 0, flag = void 0; i < points.length; i++) {
            stDeg += deg;
            deg = points[i]['degree'];
            deg = (deg === 360 ? deg - 0.001 : deg);
            edDeg = stDeg + deg;
            stRad = (stDeg - 90) * Math.PI / 180.0;
            edRad = (edDeg - 90) * Math.PI / 180.0;
            points[i]['stAng'] = stRad;
            points[i]['endAng'] = edRad;
            flag = (deg < 180) ? '0' : '1';
            var temp = points[i]['coordinates'] = {
                sX: X + (area * Math.cos(stRad)), sY: Y +
                    (area * Math.sin(stRad)), eX: X + (area * Math.cos(edRad)), eY: Y + (area * Math.sin(edRad))
            };
            var pathArc = 'M ' + X + ' ' + Y + ' L ' + temp['eX'] + ' ' + temp['eY'] + ' A ' + area + ' ' +
                area + ' 0 ' + flag + ',0 ' + temp['sX'] + ' ' + temp['sY'] + ' Z';
            var pathOption = {
                'id': spark.element.id + '_sparkline_pie_' + i,
                'opacity': opacity,
                'fill': colors[i % colors.length],
                'stroke': stroke,
                'stroke-width': strokeWidth,
                'd': pathArc,
                'stroke-dasharray': ''
            };
            this.getPieSpecialPoint(points[i], spark, pathOption, i, high, low, points.length);
            var pointArgs = this.triggerPointRender('pointRendering', i, pathOption.fill, { color: stroke, width: strokeWidth });
            pathOption.fill = pointArgs.fill;
            pathOption.stroke = pointArgs.border.color;
            pathOption['stroke-width'] = pointArgs.border.width;
            if (!pointArgs.cancel) {
                var element = drawPath(this.sparkline, pathOption, group);
                element.setAttribute('role', 'img');
                element.setAttribute('aria-label', spark.dataSource[i][spark.xName] + ' : ' + points[i].yVal);
            }
            var diffRadian = edRad - stRad;
            var mid = {
                x: X + ((area / 2) * Math.cos(stRad + (diffRadian / 2))),
                y: Y + ((area / 2) * Math.sin(stRad + (diffRadian / 2)))
            };
            points[i].location.x = mid.x;
            points[i].location.y = mid.y;
        }
        this.sparkline.svgObject.appendChild(group);
    };
    /**
     * To get special point color and option for Pie series.
     */
    SparklineRenderer.prototype.getPieSpecialPoint = function (temp, spark, option, i, high, low, length) {
        if (temp.yVal < 0 && spark.negativePointColor) {
            option.fill = spark.negativePointColor;
            this.negativePointIndexes.push(i);
        }
        if (i === 0 && spark.startPointColor) {
            option.fill = spark.startPointColor;
            this.startPointIndex = i;
        }
        else if ((i === (length - 1)) && spark.endPointColor) {
            option.fill = spark.endPointColor;
            this.endPointIndex = i;
        }
        if (temp.yVal === high && spark.highPointColor) {
            option.fill = spark.highPointColor;
            this.highPointIndex = i;
        }
        else if (temp.yVal === low && spark.lowPointColor) {
            option.fill = spark.lowPointColor;
            this.lowPointIndex = i;
        }
    };
    /**
     * To render area series
     */
    SparklineRenderer.prototype.renderArea = function (points, args) {
        var spark = this.sparkline;
        var group = this.sparkline.renderer.createGroup({
            id: spark.element.id + '_sparkline_g',
            'clip-path': 'url(#' + this.clipId + ')'
        });
        var pathOption = new PathOption$2(spark.element.id + '_sparkline_area', args.fill, 0, 'transparent', spark.opacity);
        var d = '';
        var str = '';
        for (var i = 0, len = points.length; i < len; i++) {
            if (i !== 0) {
                str += 'L ' + points[i].x + ' ' + points[i].y + ' ';
            }
            else {
                d = 'M ' + points[i].x + ' ' + this.axisHeight + ' ';
                str = 'M ' + points[i].x + ' ' + points[i].y + ' ';
            }
            d += 'L ' + points[i].x + ' ' + points[i].y + ' ';
            if (i === (len - 1)) {
                d += 'L ' + points[i].x + ' ' + this.axisHeight + ' Z';
            }
        }
        pathOption.d = d;
        pathOption['aria-label'] = 'Area series with' + points.length + 'data points';
        drawPath(this.sparkline, pathOption, group);
        pathOption = new PathOption$2(spark.element.id + '_sparkline_area_str', 'transparent', args.border.width, args.border.color, spark.opacity, '', str);
        drawPath(this.sparkline, pathOption, group);
        this.sparkline.svgObject.appendChild(group);
    };
    /**
     * To render column series
     */
    SparklineRenderer.prototype.renderColumn = function (points, args) {
        var _this = this;
        var spark = this.sparkline;
        var locations = extend([], [], points);
        var group = this.sparkline.renderer.createGroup({
            id: spark.element.id + '_sparkline_g',
            'clip-path': 'url(#' + this.clipId + ')'
        });
        var lowPos;
        var highPos;
        if (this.sparkline.highPointColor || this.sparkline.lowPointColor) {
            var pointsYPos = locations.map(function (a) { return a.markerPosition; });
            highPos = Math.min.apply(null, pointsYPos);
            lowPos = Math.max.apply(null, pointsYPos);
        }
        var id = spark.element.id + '_sparkline_column_';
        var rectOptions = new RectOption$2(id, '', args.border, spark.opacity, null);
        var temp;
        var len = points.length;
        this.negativePointIndexes = [];
        var colors = (spark.palette.length) ? spark.palette : getSeriesColor$2(this.sparkline.theme);
        var _loop_1 = function (i) {
            temp = points[i];
            rectOptions.id = id + i;
            rectOptions.fill = colors[0];
            rectOptions.rect = new Rect$1(temp.x, temp.y, temp.width, temp.height);
            this_1.getSpecialPoint(true, temp, spark, rectOptions, i, highPos, lowPos, len);
            temp.location.y = (temp.markerPosition <= this_1.axisHeight) ? temp.y : (temp.y + temp.height);
            temp.location.x = temp.x + (temp.width / 2);
            rectOptions.stroke = args.border.color ? (args.border.color) : rectOptions.fill;
            var pointArgs = {
                name: 'pointRendering', cancel: false, pointIndex: i, fill: rectOptions.fill,
                border: { color: rectOptions.stroke, width: args.border.width }
            };
            this_1.sparkline.trigger('pointRendering', pointArgs, function () {
                temp = points[i];
                rectOptions.id = id + i;
                rectOptions.rect = new Rect$1(temp.x, temp.y, temp.width, temp.height);
                _this.getSpecialPoint(true, temp, spark, rectOptions, i, highPos, lowPos, len);
                rectOptions.fill = pointArgs.fill;
                rectOptions.stroke = pointArgs.border.color;
                temp.location.y = (temp.markerPosition <= _this.axisHeight) ? temp.y : (temp.y + temp.height);
                rectOptions['stroke-width'] = pointArgs.border.width;
                temp.location.x = temp.x + (temp.width / 2);
                if (!pointArgs.cancel) {
                    var element = drawRectangle(spark, rectOptions, group);
                    element.setAttribute('role', 'img');
                    element.setAttribute('aria-label', spark.dataSource[i][spark.xName] + ' : ' + points[i].yVal);
                    group.appendChild(element);
                }
            });
        };
        var this_1 = this;
        for (var i = 0; i < len; i++) {
            _loop_1(i);
        }
        this.sparkline.svgObject.appendChild(group);
    };
    /**
     * To render WinLoss series
     */
    SparklineRenderer.prototype.renderWinLoss = function (points, args) {
        var spark = this.sparkline;
        var group = this.sparkline.renderer.createGroup({
            id: spark.element.id + '_sparkline_g',
            'clip-path': 'url(#' + this.clipId + ')'
        });
        var id = spark.element.id + '_sparkline_winloss_';
        var options = new RectOption$2(id, '', args.border, spark.opacity, null);
        var temp;
        var len = points.length;
        var paletteLength = spark.palette.length;
        var colors = (spark.palette.length) ? spark.palette : getSeriesColor$2(this.sparkline.theme);
        for (var i = 0; i < len; i++) {
            temp = points[i];
            options.id = id + i;
            options.fill = (paletteLength) ? spark.palette[i % paletteLength] : ((temp.yVal === this.axisValue) ?
                (this.sparkline.tiePointColor || '#a216f3') : ((temp.yVal > this.axisValue) ? args.fill || colors[i % colors.length] :
                (spark.negativePointColor || '#e20f07')));
            options.stroke = (args.border.color) ? (args.border.color) : options.fill;
            options.rect = new Rect$1(temp.x, temp.y, temp.width, temp.height);
            temp.location.x = temp.x + (temp.width / 2);
            temp.location.y = (temp.yVal >= this.axisValue) ? (temp.y) : (temp.y + temp.height);
            var pointArgs = this.triggerPointRender('pointRendering', i, options.fill, { color: options.stroke, width: args.border.width });
            options.fill = pointArgs.fill;
            options.stroke = pointArgs.border.color;
            options['stroke-width'] = pointArgs.border.width;
            if (!pointArgs.cancel) {
                var element = drawRectangle(spark, options, group);
                element.setAttribute('role', 'img');
                element.setAttribute('aria-label', spark.dataSource[i][spark.xName] + ' : ' + points[i].yVal);
            }
        }
        this.sparkline.svgObject.appendChild(group);
    };
    SparklineRenderer.prototype.renderMarker = function (points) {
        var spark = this.sparkline;
        var marker = spark.markerSettings;
        if ((spark.type === 'Pie' || spark.type === 'WinLoss' || !marker.visible.length)) {
            return;
        }
        var locations = extend([], [], points);
        var group = this.sparkline.renderer.createGroup({
            id: spark.element.id + '_sparkline_marker_g',
            'clip-path': 'url(#' + this.clipId + ')'
        });
        var temp;
        var id = spark.element.id + '_sparkline_marker_';
        var option = new CircleOption$2('', marker.fill, marker.border, marker.opacity, 0, 0, marker.size / 2, '');
        var highPos;
        var lowPos;
        var visible = marker.visible.join();
        if ((visible.toLowerCase().indexOf('high') > -1) || (visible.toLowerCase().indexOf('low') > -1)) {
            var pointsYPos = locations.map(function (a) { return a.markerPosition; });
            highPos = Math.min.apply(null, pointsYPos);
            lowPos = Math.max.apply(null, pointsYPos);
        }
        this.negativePointIndexes = [];
        var _loop_2 = function (i, length_1) {
            temp = points[i];
            option.id = id + i;
            option.cx = temp.location.x;
            option.cy = temp.location.y;
            option.fill = marker.fill;
            var render = (visible.toLowerCase().indexOf('all') > -1);
            render = this_2.getSpecialPoint(render, temp, spark, option, i, highPos, lowPos, length_1, visible.toLowerCase());
            option.stroke = marker.border.color || option.fill;
            var markerArgs = {
                name: 'markerRendering', cancel: false,
                border: { color: option.stroke, width: marker.border.width },
                fill: option.fill, pointIndex: i,
                sparkline: this_2.sparkline,
                x: option.cx, y: option.cy, size: marker.size
            };
            this_2.sparkline.trigger('markerRendering', markerArgs, function () {
                if (render && !markerArgs.cancel) {
                    option.id = id + i;
                    option.cx = markerArgs.x;
                    option.cy = markerArgs.y;
                    option.fill = markerArgs.fill;
                    option.stroke = markerArgs.border.color;
                    option['stroke-width'] = markerArgs.border.width;
                    option.r = markerArgs.size / 2;
                    var element = drawCircle(spark, option, group);
                    element.setAttribute('role', 'img');
                    element.setAttribute('aria-label', spark.dataSource[i][spark.xName] + ' : ' + points[i].yVal);
                    group.appendChild(element);
                }
            });
        };
        var this_2 = this;
        for (var i = 0, length_1 = points.length; i < length_1; i++) {
            _loop_2(i, length_1);
        }
        this.sparkline.svgObject.appendChild(group);
    };
    /**
     * To get special point color and option.
     */
    SparklineRenderer.prototype.getSpecialPoint = function (render, temp, spark, option, i, highPos, lowPos, length, visible) {
        if (visible === void 0) { visible = ''; }
        if (temp.markerPosition > this.axisHeight) {
            option.fill = spark.negativePointColor || option.fill;
            this.negativePointIndexes.push(i);
            render = render || (visible.indexOf('negative') > -1);
        }
        if (i === 0) {
            option.fill = spark.startPointColor || option.fill;
            this.startPointIndex = i;
            render = render || (visible.indexOf('start') > -1);
        }
        else if ((i === (length - 1))) {
            option.fill = spark.endPointColor || option.fill;
            this.endPointIndex = i;
            render = render || (visible.indexOf('end') > -1);
        }
        if (temp.markerPosition === highPos) {
            option.fill = spark.highPointColor || option.fill;
            this.highPointIndex = i;
            render = render || (visible.indexOf('high') > -1);
        }
        else if (temp.markerPosition === lowPos) {
            option.fill = spark.lowPointColor || option.fill;
            this.lowPointIndex = i;
            render = render || (visible.indexOf('low') > -1);
        }
        if (visible.indexOf('none') > -1) {
            render = false;
        }
        return render;
    };
    /**
     * To render data label for sparkline.
     */
    SparklineRenderer.prototype.renderLabel = function (points) {
        var _this = this;
        var spark = this.sparkline;
        var dataLabel = spark.dataLabelSettings;
        var color = dataLabel.textStyle.color || spark.sparkTheme.dataLabelColor;
        if ((spark.type === 'WinLoss' || !dataLabel.visible.length)) {
            return;
        }
        var locations = extend([], [], points);
        var id = spark.element.id + '_sparkline_label_';
        var group = this.sparkline.renderer.createGroup({
            id: spark.element.id + '_sparkline_label_g',
            style: 'pointer-events: none;'
        });
        group.setAttribute('aria-hidden', 'true');
        var g;
        var temp;
        var textId = id + 'text_';
        var rectId = id + 'rect_';
        var option = new TextOption$2('', 0, 0, 'middle', '', 'middle');
        var labelStyle = dataLabel.textStyle;
        var pointsYPos = locations.map(function (a) { return a.markerPosition; });
        var highPos = Math.min.apply(null, pointsYPos);
        var lowPos = Math.max.apply(null, pointsYPos);
        var space = 1;
        var padding = (dataLabel.fill !== 'transparent' || dataLabel.border.width) ? 2 : 0;
        var size = measureText$2('sparkline_measure_text', labelStyle, this.sparkline.sparkTheme.dataLabelFont);
        var rectOptions = new RectOption$2('', dataLabel.fill, dataLabel.border, dataLabel.opacity, null);
        var edgeLabelOption;
        var _loop_3 = function (i, length_2) {
            temp = points[i];
            option.id = textId + i;
            option.x = temp.location.x + dataLabel.offset.x;
            option.y = ((spark.type === 'Pie') ? temp.location.y : ((temp.markerPosition > this_3.axisHeight) ? (temp.location.y +
                (size.height / 2) + space + 2 + padding) : (temp.location.y - (size.height / 2) - space - padding))) + dataLabel.offset.y;
            option.text = (dataLabel.format !== '') ? this_3.formatter(dataLabel.format, this_3.sparkline.dataSource[i]) :
                temp.yVal.toString();
            var labelArgs = {
                name: 'dataLabelRendering', cancel: false,
                border: dataLabel.border, fill: dataLabel.fill, pointIndex: i,
                sparkline: this_3.sparkline,
                x: option.x, y: option.y, text: option.text, color: color
            };
            this_3.sparkline.trigger('dataLabelRendering', labelArgs, function () {
                size = measureText$2(labelArgs.text, labelStyle, _this.sparkline.sparkTheme.dataLabelFont);
                option.text = labelArgs.text;
                var renderLabel = (dataLabel.visible.join().toLowerCase().indexOf('all') > -1);
                renderLabel = _this.getLabelVisible(renderLabel, temp, i, dataLabel, length_2, highPos, lowPos);
                edgeLabelOption = _this.arrangeLabelPosition(dataLabel.edgeLabelMode, renderLabel, labelArgs.x, i, length_2, size, padding);
                if (renderLabel && !labelArgs.cancel && edgeLabelOption.render) {
                    rectOptions.id = rectId + i;
                    rectOptions.fill = labelArgs.fill;
                    rectOptions.stroke = labelArgs.border.color;
                    rectOptions['stroke-width'] = labelArgs.border.width;
                    option.y = labelArgs.y;
                    option.x = edgeLabelOption.x;
                    rectOptions.rect = new Rect$1(option.x - ((size.width / 2) + padding), (option.y - padding - (size.height / 1.75)), size.width + (padding * 2), size.height + (padding * 2));
                    g = _this.sparkline.renderer.createGroup({ id: id + 'g' + i });
                    drawRectangle(spark, rectOptions, g);
                    renderTextElement$1(option, labelStyle, labelArgs.color, g, _this.sparkline.sparkTheme.dataLabelFont);
                    group.appendChild(g);
                }
            });
        };
        var this_3 = this;
        for (var i = 0, length_2 = points.length; i < length_2; i++) {
            _loop_3(i, length_2);
        }
        this.sparkline.svgObject.appendChild(group);
    };
    SparklineRenderer.prototype.arrangeLabelPosition = function (edgeLabel, render, x, index, length, size, padding) {
        if (edgeLabel === 'None') {
            return { x: x, render: render };
        }
        if (index === 0 && ((x - (size.width / 2) - padding) <= 0)) {
            if (edgeLabel === 'Hide') {
                render = false;
            }
            else {
                x = this.sparkline.padding.left + padding + (size.width / 2);
            }
        }
        else if (index === length - 1 && ((x + (size.width / 2) + padding) >= this.sparkline.availableSize.width)) {
            if (edgeLabel === 'Hide') {
                render = false;
            }
            else {
                x -= (size.width / 2 + padding);
            }
        }
        return { x: x, render: render };
    };
    /**
     * To get special point color and option.
     */
    SparklineRenderer.prototype.getLabelVisible = function (render, temp, i, label, length, highPos, lowPos) {
        var labelVisible = label.visible.join().toLowerCase();
        if (temp.markerPosition > this.axisHeight) {
            render = render || (labelVisible.indexOf('negative') > -1);
        }
        if (i === 0) {
            render = render || (labelVisible.indexOf('start') > -1);
        }
        else if ((i === (length - 1))) {
            render = render || (labelVisible.indexOf('end') > -1);
        }
        if (temp.markerPosition === highPos) {
            render = render || (labelVisible.indexOf('high') > -1);
        }
        else if (temp.markerPosition === lowPos) {
            render = render || (labelVisible.indexOf('low') > -1);
        }
        if (label.visible.join().toLowerCase().indexOf('none') > -1) {
            render = false;
        }
        return render;
    };
    /**
     * To format text
     */
    SparklineRenderer.prototype.formatter = function (format, data) {
        if (isNullOrUndefined(format)) {
            return null;
        }
        var keys = Object.keys(data);
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            format = format.split('${' + key + '}').join(data[key]);
        }
        return format;
    };
    /**
     * To calculate min max for x and y axis
     */
    SparklineRenderer.prototype.axisCalculation = function () {
        this.findRanges(this.sparkline.sparklineData);
    };
    /**
     * To find x axis interval.
     */
    SparklineRenderer.prototype.getInterval = function (data, x) {
        var interval = 1;
        var x1 = data[0][x];
        var x2 = isNullOrUndefined(data[1]) ? undefined : data[1][x];
        if (!isNullOrUndefined(x1) && !isNullOrUndefined(x2)) {
            var temp = extend([], data);
            var validData_1 = [];
            temp.forEach(function (value) {
                if (!isNullOrUndefined(value[x])) {
                    validData_1.push(value);
                }
            });
            validData_1.sort(function (a, b) {
                if (isNullOrUndefined(a[x]) || isNullOrUndefined(b[x])) {
                    return 0;
                }
                return a[x] - b[x];
            });
            validData_1 = (this.sparkline.enableRtl) ? validData_1.reverse() : validData_1;
            interval = validData_1[1][x] - validData_1[0][x];
        }
        return interval;
    };
    /**
     * To find x axis interval.
     */
    SparklineRenderer.prototype.getPaddingInterval = function (data, x, type, delta) {
        var interval = 1;
        var size = this.sparkline.availableSize.height;
        var intervalCount = interval * data.length;
        intervalCount = Math.max((size * (intervalCount / 100)), 1);
        var niceInterval = delta / intervalCount;
        for (var _i = 0, _a = this.sparkline.intervalDivs; _i < _a.length; _i++) {
            var intervalVal = _a[_i];
            var currentInterval = interval * intervalVal;
            if (intervalCount < (delta / currentInterval)) {
                break;
            }
            niceInterval = currentInterval;
        }
        return niceInterval;
    };
    /**
     * To calculate axis ranges internally.
     */
    SparklineRenderer.prototype.findRanges = function (data) {
        var model = this.sparkline;
        var max;
        var min;
        var minX;
        var maxX;
        var maxPointsLength = data.length;
        var temp;
        var sumofValues = 0;
        var isNumericArray = Array.isArray(data) && typeof data[0] !== 'object';
        if (isNumericArray) {
            if (model.type === 'Pie') {
                for (var i = 0; i < maxPointsLength; i++) {
                    sumofValues += Math.abs(data[i]);
                }
            }
            else {
                max = Math.max.apply(null, data);
                min = Math.min.apply(null, data);
                minX = 0;
                maxX = maxPointsLength - 1;
            }
        }
        else {
            if (model.type === 'Pie') {
                for (var i = 0; i < maxPointsLength; i++) {
                    sumofValues += Math.abs(data[i][model.yName]);
                }
            }
            else {
                if (isNullOrUndefined(data[0][model.xName])) {
                    var x_1 = data.map(function (z) { return z[model.yName]; });
                    max = Math.max.apply(null, x_1);
                    min = Math.min.apply(null, x_1);
                }
                else {
                    temp = extend([], data);
                    temp = temp.sort(function (a, b) { return a[model.yName] - b[model.yName]; });
                    max = temp[temp.length - 1][model.yName];
                    min = temp[0][model.yName];
                }
                if (!isNullOrUndefined(data[0][model.xName])) {
                    temp = temp.sort(function (a, b) { return a[model.xName] - b[model.xName]; });
                    temp = (this.sparkline.enableRtl) ? temp.reverse() : temp;
                    maxX = temp[temp.length - 1][model.xName];
                    minX = temp[0][model.xName];
                }
                else {
                    minX = 0;
                    maxX = maxPointsLength - 1;
                }
            }
        }
        var y2;
        var height;
        var width;
        var x1 = 0;
        var y1;
        var padding = model.padding;
        var point;
        var axis = model.axisSettings;
        var value = axis.value;
        if (model.type !== 'Pie') {
            this.maxLength = maxPointsLength;
            height = model.availableSize.height - (padding.bottom + padding.top);
            width = model.availableSize.width - (padding.left + padding.right);
            maxX = isNullOrUndefined(axis.maxX) ? maxX : axis.maxX;
            minX = isNullOrUndefined(axis.minX) ? minX : axis.minX;
            max = isNullOrUndefined(axis.maxY) ? max : axis.maxY;
            min = isNullOrUndefined(axis.minY) ? min : axis.minY;
            var color = axis.lineSettings.color || this.sparkline.sparkTheme.axisLineColor;
            var eventArgs = {
                name: 'axisRendering', cancel: false, sparkline: model,
                maxX: maxX, minX: minX, maxY: max, minY: min, value: axis.value,
                lineColor: color, lineWidth: axis.lineSettings.width
            };
            model.trigger('axisRendering', eventArgs);
            if (eventArgs.cancel) {
                this.visiblePoints = [];
                return;
            }
            maxX = eventArgs.maxX;
            minX = eventArgs.minX;
            max = eventArgs.maxY;
            min = eventArgs.minY;
            value = this.axisValue = eventArgs.value;
            this.axisColor = eventArgs.lineColor;
            this.axisWidth = eventArgs.lineWidth;
        }
        var unitX = maxX - minX;
        var unitY = max - min;
        unitX = (unitX === 0) ? 1 : unitX;
        unitY = (unitY === 0) ? 1 : unitY;
        this.unitX = unitX;
        this.unitY = unitY;
        this.min = min;
        x1 = 0;
        y1 = height - ((height / unitY) * (-min));
        y1 = (min < 0 && max <= 0) ? 0 : (min < 0 && max > 0) ? y1 : height;
        if (value >= min && value <= max) {
            y1 = height - Math.round(height * ((value - min) / this.unitY));
        }
        this.axisHeight = y1 + padding.top;
        var percent;
        var x;
        var y;
        var visiblePoints = [];
        var delta = max - min;
        var interval = this.getInterval(data, model.xName);
        var interVal = this.getPaddingInterval(data, model.xName, model.valueType, delta);
        for (var i = 0; i < maxPointsLength; i++) {
            if (isNullOrUndefined(data[i][model.xName]) && isNullOrUndefined(data[i][model.yName]) &&
                ((data[i][model.yName]) !== 0) && isNumericArray) {
                x = i;
                y = data[i];
            }
            else if (isNullOrUndefined(data[i][model.xName])) {
                x = i;
                y = data[i][model.yName];
            }
            else {
                x = data[i][model.xName];
                y = data[i][model.yName];
            }
            if (isNullOrUndefined(x) || isNullOrUndefined(y)) {
                continue;
            }
            if (model.type === 'Line' || model.type === 'Area') {
                y2 = (min !== max && maxPointsLength !== 1) ? height - Math.round(height * ((y - min) / this.unitY)) : padding.top;
                point = { x: (minX !== maxX) ? Math.round(width * ((x - minX) / this.unitX)) : width / 2, y: y2, markerPosition: y2 };
            }
            else if (model.type === 'Column' || model.type === 'WinLoss') {
                var colWidth = width / (((maxX - minX) / interval) + 1);
                var calSpace = 0.5;
                var space = (calSpace * 2); //calspace is default space for column and winloss
                colWidth -= (space);
                x1 = (((x - minX) / interval) * (colWidth + space)) + (space / 2);
                if (model.type === 'WinLoss') {
                    // win or gain column height half of the height , draw(zero) height factor
                    var winLossFactor = 0.5;
                    var drawHeightFactor = 40;
                    y2 = (y > value) ? (height / 4) : (y < value) ? (height * winLossFactor) :
                        ((height * winLossFactor) - (height / drawHeightFactor));
                    point = {
                        x: x1, y: y2, height: (y !== value) ? (height / 4) : height / 20, width: colWidth,
                        markerPosition: (y2 > y1) ? (y1 + Math.abs(y2 - y1)) : y2
                    };
                }
                else {
                    if (i === 0 && model.rangePadding !== 'None') {
                        min -= model.rangePadding === 'Additional' ? (interVal + padding.top) : interVal;
                        max += model.rangePadding === 'Additional' ? (interVal + padding.top) : interVal;
                        unitX = maxX - minX;
                        unitY = max - min;
                        unitX = (unitX === 0) ? 1 : unitX;
                        unitY = (unitY === 0) ? 1 : unitY;
                        this.unitX = unitX;
                        this.unitY = unitY;
                        this.min = min;
                    }
                    var z = ((height / this.unitY) * (y - min));
                    var z1 = (y === min && y > value) ? ((maxPointsLength !== 1 && this.unitY !== 1) ?
                        (height / this.unitY) * (min / 2) : (z | 1)) :
                        (y === max && y < value && maxPointsLength !== 1 && this.unitY !== 1) ? (height / this.unitY) * (-max / 2) : z;
                    y2 = Math.abs(height - z1);
                    point = {
                        x: x1, y: (y2 > y1) ? y1 : y2, height: Math.abs(y2 - y1),
                        width: colWidth, markerPosition: (y2 > y1) ? (y1 + Math.abs(y2 - y1)) : y2
                    };
                }
            }
            else if (model.type === 'Pie') {
                percent = (Math.abs(y) / sumofValues) * 100;
                point = {
                    percent: percent, degree: ((Math.abs(y) / sumofValues) * 360)
                };
            }
            if (model.type !== 'Pie') {
                point.x += padding.left;
                point.y += padding.top;
            }
            if (model.type !== 'WinLoss') {
                point.markerPosition += padding.top;
            }
            point.location = { x: point.x, y: point.y };
            point.xVal = x;
            point.yVal = y;
            visiblePoints.push(point);
        }
        visiblePoints.sort(function (a, b) {
            return a.x - b.x;
        });
        this.visiblePoints = visiblePoints;
    };
    /**
     * To render the sparkline axis
     */
    SparklineRenderer.prototype.drawAxis = function () {
        var spark = this.sparkline;
        var height = this.axisHeight;
        if ((spark.type !== 'WinLoss') && (spark.type !== 'Pie') && spark.axisSettings.lineSettings.visible) {
            var xAxis = {
                'id': spark.element.id + '_Sparkline_XAxis',
                'x1': spark.padding.left, 'y1': height,
                'x2': spark.availableSize.width - spark.padding.right, 'y2': height,
                'stroke': this.axisColor,
                'opacity': spark.axisSettings.lineSettings.opacity,
                'stroke-dasharray': spark.axisSettings.lineSettings.dashArray,
                'stroke-width': this.axisWidth,
                'clip-path': 'url(#' + this.clipId + ')'
            };
            spark.svgObject.appendChild(spark.renderer.drawLine(xAxis));
        }
    };
    /**
     * To trigger point render event
     */
    SparklineRenderer.prototype.triggerPointRender = function (name, i, fill, border) {
        var args = {
            name: name, cancel: false,
            border: border, fill: fill,
            sparkline: this.sparkline,
            pointIndex: i
        };
        this.sparkline.trigger(name, args);
        return args;
    };
    return SparklineRenderer;
}());

var __extends$94 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$22 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable */
/**
 * Represents the Sparkline control.
 * ```html
 * <div id="sparkline"/>
 * <script>
 *   var sparkline = new Sparkline();
 *   sparkline.appendTo("#sparkline");
 * </script>
 * ```
 */
var Sparkline = /** @__PURE__ @class */ (function (_super) {
    __extends$94(Sparkline, _super);
    // Sparkline rendering starts from here.
    /**
     * Constructor for creating the Sparkline widget
     */
    function Sparkline(options, element) {
        var _this = _super.call(this, options, element) || this;
        /** @private */
        _this.isDevice = Browser.isDevice;
        /** @private */
        _this.intervalDivs = [10, 5, 2, 1];
        return _this;
    }
    /**
     * Initializing pre-required values for sparkline.
     */
    Sparkline.prototype.preRender = function () {
        this.allowServerDataBinding = false;
        this.unWireEvents();
        this.trigger('load', { sparkline: this });
        this.sparkTheme = getThemeColor$2(this.theme);
        this.sparklineRenderer = new SparklineRenderer(this);
        this.createSVG();
        this.wireEvents();
        this.setCulture();
    };
    /**
     * Sparkline Elements rendering starting.
     */
    Sparkline.prototype.render = function () {
        // Sparkline rendering splitted into rendering and calculations
        this.sparklineRenderer.processDataManager();
        this.renderComplete();
        this.allowServerDataBinding = true;
    };
    /**
     * @private
     */
    Sparkline.prototype.processSparklineData = function () {
        this.sparklineRenderer.processData();
        this.renderSparkline();
        this.element.appendChild(this.svgObject);
        this.setSecondaryElementPosition();
        this.trigger('loaded', { sparkline: this });
    };
    /**
     * To render sparkline elements
     */
    Sparkline.prototype.renderSparkline = function () {
        // To render the sparkline elements
        this.renderBorder();
        this.createDiv();
        this.sparklineRenderer.renderSeries();
    };
    /**
     * Create secondary element for the tooltip
     */
    Sparkline.prototype.createDiv = function () {
        var tooltipDiv = document.createElement('div');
        tooltipDiv.id = this.element.id + '_Secondary_Element';
        tooltipDiv.style.position = 'relative';
        this.element.appendChild(tooltipDiv);
        this.element.style.display = 'block';
        this.element.style.position = 'relative';
    };
    /**
     * To set the left and top position for data label template for sparkline
     */
    Sparkline.prototype.setSecondaryElementPosition = function () {
        var element = getIdElement(this.element.id + '_Secondary_Element');
        if (!element) {
            return;
        }
        var rect = this.element.getBoundingClientRect();
        var svgRect = getIdElement(this.element.id + '_svg').getBoundingClientRect();
        element.style.left = Math.max(svgRect.left - rect.left, 0) + 'px';
        element.style.top = Math.max(svgRect.top - rect.top, 0) + 'px';
    };
    /**
     * @private
     * Render the sparkline border
     */
    Sparkline.prototype.renderBorder = function () {
        var width = this.containerArea.border.width;
        var borderRect;
        if (width > 0 || this.containerArea.background !== 'transparent') {
            borderRect = new RectOption$2(this.element.id + '_SparklineBorder', this.sparkTheme.background, this.containerArea.border, 1, new Rect$1(width / 2, width / 2, this.availableSize.width - width, this.availableSize.height - width));
            this.svgObject.appendChild(drawRectangle(this, borderRect));
        }
        // Used to create clip path sparkline
        var padding = this.padding;
        if (this.markerSettings.visible.length) {
            padding.left = 0;
            padding.right = 0;
            padding.bottom = 0;
            padding.top = 0;
        }
        borderRect = new RectOption$2(this.element.id + '_sparkline_clip_rect', 'transparent', { color: 'transparent', width: 0 }, 1, new Rect$1(padding.left, padding.top, this.availableSize.width - (padding.left + padding.right), this.availableSize.height - (padding.top + padding.bottom)));
        var clipPath = this.renderer.createClipPath({ id: this.element.id + '_sparkline_clip_path' });
        drawRectangle(this, borderRect, clipPath);
        this.svgObject.appendChild(clipPath);
    };
    /**
     * To create svg element for sparkline
     */
    Sparkline.prototype.createSVG = function () {
        this.removeSvg();
        createSvg$2(this);
    };
    /**
     * To Remove the Sparkline SVG object
     */
    Sparkline.prototype.removeSvg = function () {
        if (this.svgObject) {
            while (this.svgObject.childNodes.length > 0) {
                this.svgObject.removeChild(this.svgObject.firstChild);
            }
            if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode) {
                remove(this.svgObject);
            }
        }
        removeElement$3(this.element.id + '_Secondary_Element');
        if (this.sparklineTooltipModule) {
            this.sparklineTooltipModule.removeTooltipElements();
        }
    };
    /**
     * Method to set culture for sparkline
     */
    Sparkline.prototype.setCulture = function () {
        this.intl = new Internationalization();
        this.localeObject = new L10n(this.getModuleName(), this.defaultLocalConstants, this.locale);
    };
    /**
     * To provide the array of modules needed for sparkline rendering
     * @return {ModuleDeclaration[]}
     * @private
     */
    Sparkline.prototype.requiredModules = function () {
        var modules = [];
        if (this.tooltipSettings.visible || this.tooltipSettings.trackLineSettings.visible) {
            modules.push({
                member: 'SparklineTooltip',
                args: [this]
            });
        }
        return modules;
    };
    /**
     * Method to unbind events for sparkline chart
     */
    Sparkline.prototype.unWireEvents = function () {
        var move = Browser.touchMoveEvent;
        var cancel = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        /*! UnBind the Event handler */
        EventHandler.remove(this.element, Browser.touchMoveEvent, this.sparklineMove);
        EventHandler.remove(this.element, cancel, this.sparklineMouseLeave);
        EventHandler.remove(this.element, Browser.touchEndEvent, this.sparklineMouseEnd);
        window.removeEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.sparklineResize);
    };
    /**
     * Method to bind events for the sparkline
     */
    Sparkline.prototype.wireEvents = function () {
        var cancel = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        /*! Bind the Event handler */
        EventHandler.add(this.element, Browser.touchMoveEvent, this.sparklineMove, this);
        EventHandler.add(this.element, 'click', this.sparklineClick, this);
        EventHandler.add(this.element, cancel, this.sparklineMouseLeave, this);
        EventHandler.add(this.element, Browser.touchEndEvent, this.sparklineMouseEnd, this);
        window.addEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.sparklineResize.bind(this));
        new Touch(this.element);
    };
    /**
     * Sparkline resize event.
     * @private
     */
    Sparkline.prototype.sparklineResize = function (e) {
        var _this = this;
        var args = {
            name: 'resize',
            previousSize: this.availableSize,
            sparkline: this,
            currentSize: new Size$1(0, 0)
        };
        if (this.resizeTo) {
            clearTimeout(this.resizeTo);
        }
        this.resizeTo = +setTimeout(function () {
            if (_this.isDestroyed) {
                clearTimeout(_this.resizeTo);
                return;
            }
            _this.unWireEvents();
            _this.createSVG();
            _this.refreshing = true;
            _this.wireEvents();
            args.currentSize = _this.availableSize;
            _this.trigger('resize', args);
            _this.render();
            _this.refreshing = false;
        }, 500);
        return false;
    };
    /**
     * Handles the mouse move on sparkline.
     * @return {boolean}
     * @private
     */
    Sparkline.prototype.sparklineMove = function (e) {
        this.setSparklineMouseXY(e);
        this.notify(Browser.touchMoveEvent, e);
        var args = {
            name: 'sparklineMouseMove', cancel: false,
            sparkline: this, event: e
        };
        this.trigger(args.name, args);
        var pointClick = this.isPointRegion(e);
        if (pointClick.isPointRegion) {
            var pointArgs = {
                name: 'pointRegionMouseMove', cancel: false,
                event: e, sparkline: this,
                pointIndex: pointClick.pointIndex
            };
            this.trigger(pointArgs.name, pointArgs);
        }
        return false;
    };
    /**
     * Handles the mouse click on sparkline.
     * @return {boolean}
     * @private
     */
    Sparkline.prototype.sparklineClick = function (e) {
        this.setSparklineMouseXY(e);
        var args = {
            name: 'sparklineMouseClick', cancel: false,
            sparkline: this, event: e
        };
        this.trigger(args.name, args);
        var pointClick = this.isPointRegion(e);
        if (pointClick.isPointRegion) {
            var pointArgs = {
                name: 'pointRegionMouseClick', cancel: false,
                event: e, sparkline: this,
                pointIndex: pointClick.pointIndex
            };
            this.trigger(pointArgs.name, pointArgs);
        }
        return false;
    };
    /**
     * To check mouse event target is point region or not.
     */
    Sparkline.prototype.isPointRegion = function (e) {
        var _this = this;
        var startId = this.element.id + '_';
        var id = e.target.id.replace(startId, '').split('_');
        if (id[1] === this.type.toLowerCase()) {
            var index_1 = parseInt(id[2], 10);
            if ((isNullOrUndefined(index_1) || isNaN(index_1)) && (this.type === 'Line' || this.type === 'Area')) {
                this.sparklineRenderer.visiblePoints.forEach(function (point, i) {
                    if (withInBounds$1(_this.mouseX, _this.mouseY, new Rect$1(point.x - 5, point.y - 5, 10, 10))) {
                        index_1 = i;
                        return;
                    }
                });
            }
            return { isPointRegion: true, pointIndex: index_1 };
        }
        return { isPointRegion: false, pointIndex: null };
    };
    /**
     * Handles the mouse end.
     * @return {boolean}
     * @private
     */
    Sparkline.prototype.sparklineMouseEnd = function (e) {
        this.setSparklineMouseXY(e);
        this.notify(Browser.touchEndEvent, e);
        return false;
    };
    /**
     * Handles the mouse leave on sparkline.
     * @return {boolean}
     * @private
     */
    Sparkline.prototype.sparklineMouseLeave = function (e) {
        this.setSparklineMouseXY(e);
        this.notify(Browser.isPointer ? 'pointerleave' : 'mouseleave', e);
        return false;
    };
    /**
     * Method to set mouse x, y from events
     */
    Sparkline.prototype.setSparklineMouseXY = function (e) {
        var pageY;
        var pageX;
        if (e.type.indexOf('touch') > -1) {
            this.isTouch = true;
            var touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            pageY = touchArg.changedTouches[0].clientY;
        }
        else {
            this.isTouch = e.pointerType === 'touch' || e.pointerType === '2';
            pageY = e.clientY;
            pageX = e.clientX;
        }
        var rect = this.element.getBoundingClientRect();
        var svgRect = getIdElement(this.element.id + '_svg').getBoundingClientRect();
        this.mouseY = (pageY - rect.top) - Math.max(svgRect.top - rect.top, 0);
        this.mouseX = (pageX - rect.left) - Math.max(svgRect.left - rect.left, 0);
    };
    /**
     * To change rendering while property value modified.
     * @private
     */
    Sparkline.prototype.onPropertyChanged = function (newProp, oldProp) {
        var render = false;
        var refresh = false;
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'xName':
                case 'yName':
                case 'axisSettings':
                case 'rangeBandSettings':
                case 'type':
                case 'valueType':
                case 'enableRtl':
                    refresh = true;
                    break;
                case 'dataSource':
                    refresh = true;
                    break;
                case 'border':
                case 'markerSettings':
                case 'dataLabelSettings':
                case 'tooltipSettings':
                case 'startPointColor':
                case 'highPointColor':
                case 'lowPointColor':
                case 'endPointColor':
                case 'negativePointColor':
                case 'theme':
                    render = true;
                    break;
            }
        }
        if (refresh) {
            this.createSVG();
            this.sparklineRenderer.processData();
            this.refreshSparkline();
        }
        else if (render) {
            this.createSVG();
            this.refreshSparkline();
        }
    };
    /**
     * To render sparkline series and appending.
     */
    Sparkline.prototype.refreshSparkline = function () {
        // Issue fix. React had native render method. So OnProperty change used render method won't wrok. 
        this.renderSparkline();
        this.element.appendChild(this.svgObject);
        this.setSecondaryElementPosition();
    };
    /**
     * Get component name
     */
    Sparkline.prototype.getModuleName = function () {
        return 'sparkline';
    };
    /**
     * Destroy the component
     */
    Sparkline.prototype.destroy = function () {
        this.sparklineData = [];
        // let element: HTMLElement = document.getElementById(this.element.id + 'Keyboard_chart_focus');
        // if (element) { element.remove(); }
        if (this.element) {
            this.unWireEvents();
            _super.prototype.destroy.call(this);
            this.removeSvg();
            this.svgObject = null;
        }
    };
    /**
     * Get the properties to be maintained in the persisted state.
     * @private
     */
    Sparkline.prototype.getPersistData = function () {
        return '';
    };
    __decorate$22([
        Property(null)
    ], Sparkline.prototype, "width", void 0);
    __decorate$22([
        Property(null)
    ], Sparkline.prototype, "height", void 0);
    __decorate$22([
        Complex({}, SparklineBorder)
    ], Sparkline.prototype, "border", void 0);
    __decorate$22([
        Property('Line')
    ], Sparkline.prototype, "type", void 0);
    __decorate$22([
        Property('None')
    ], Sparkline.prototype, "rangePadding", void 0);
    __decorate$22([
        Property(null)
    ], Sparkline.prototype, "dataSource", void 0);
    __decorate$22([
        Property(null)
    ], Sparkline.prototype, "query", void 0);
    __decorate$22([
        Property('Numeric')
    ], Sparkline.prototype, "valueType", void 0);
    __decorate$22([
        Property(null)
    ], Sparkline.prototype, "xName", void 0);
    __decorate$22([
        Property(null)
    ], Sparkline.prototype, "yName", void 0);
    __decorate$22([
        Property('#00bdae')
    ], Sparkline.prototype, "fill", void 0);
    __decorate$22([
        Property('')
    ], Sparkline.prototype, "highPointColor", void 0);
    __decorate$22([
        Property('')
    ], Sparkline.prototype, "lowPointColor", void 0);
    __decorate$22([
        Property('')
    ], Sparkline.prototype, "startPointColor", void 0);
    __decorate$22([
        Property('')
    ], Sparkline.prototype, "endPointColor", void 0);
    __decorate$22([
        Property('')
    ], Sparkline.prototype, "negativePointColor", void 0);
    __decorate$22([
        Property('')
    ], Sparkline.prototype, "tiePointColor", void 0);
    __decorate$22([
        Property([])
    ], Sparkline.prototype, "palette", void 0);
    __decorate$22([
        Property(1)
    ], Sparkline.prototype, "lineWidth", void 0);
    __decorate$22([
        Property(1)
    ], Sparkline.prototype, "opacity", void 0);
    __decorate$22([
        Property(null)
    ], Sparkline.prototype, "format", void 0);
    __decorate$22([
        Property(false)
    ], Sparkline.prototype, "useGroupingSeparator", void 0);
    __decorate$22([
        Complex({}, SparklineTooltipSettings)
    ], Sparkline.prototype, "tooltipSettings", void 0);
    __decorate$22([
        Complex({}, ContainerArea)
    ], Sparkline.prototype, "containerArea", void 0);
    __decorate$22([
        Collection([], RangeBandSettings)
    ], Sparkline.prototype, "rangeBandSettings", void 0);
    __decorate$22([
        Complex({}, AxisSettings)
    ], Sparkline.prototype, "axisSettings", void 0);
    __decorate$22([
        Complex({}, SparklineMarkerSettings)
    ], Sparkline.prototype, "markerSettings", void 0);
    __decorate$22([
        Complex({}, SparklineDataLabelSettings)
    ], Sparkline.prototype, "dataLabelSettings", void 0);
    __decorate$22([
        Complex({}, Padding)
    ], Sparkline.prototype, "padding", void 0);
    __decorate$22([
        Property('Material')
    ], Sparkline.prototype, "theme", void 0);
    __decorate$22([
        Event()
    ], Sparkline.prototype, "loaded", void 0);
    __decorate$22([
        Event()
    ], Sparkline.prototype, "load", void 0);
    __decorate$22([
        Event()
    ], Sparkline.prototype, "tooltipInitialize", void 0);
    __decorate$22([
        Event()
    ], Sparkline.prototype, "seriesRendering", void 0);
    __decorate$22([
        Event()
    ], Sparkline.prototype, "axisRendering", void 0);
    __decorate$22([
        Event()
    ], Sparkline.prototype, "pointRendering", void 0);
    __decorate$22([
        Event()
    ], Sparkline.prototype, "pointRegionMouseMove", void 0);
    __decorate$22([
        Event()
    ], Sparkline.prototype, "pointRegionMouseClick", void 0);
    __decorate$22([
        Event()
    ], Sparkline.prototype, "sparklineMouseMove", void 0);
    __decorate$22([
        Event()
    ], Sparkline.prototype, "sparklineMouseClick", void 0);
    __decorate$22([
        Event()
    ], Sparkline.prototype, "dataLabelRendering", void 0);
    __decorate$22([
        Event()
    ], Sparkline.prototype, "markerRendering", void 0);
    __decorate$22([
        Event()
    ], Sparkline.prototype, "resize", void 0);
    Sparkline = __decorate$22([
        NotifyPropertyChanges
    ], Sparkline);
    return Sparkline;
}(Component));

var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
/**
 * Sparkline Tooltip Module
 */
var SparklineTooltip = /** @__PURE__ @class */ (function () {
    function SparklineTooltip(sparkline) {
        this.sparkline = sparkline;
        this.addEventListener();
    }
    /**
     * @hidden
     */
    SparklineTooltip.prototype.addEventListener = function () {
        if (this.sparkline.isDestroyed) {
            return;
        }
        // this.sparkline.on('mouseleave', this.mouseLeaveHandler, this);
        this.sparkline.on(Browser.isPointer ? 'pointerleave' : 'mouseleave', this.mouseLeaveHandler, this);
        this.sparkline.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
        this.sparkline.on(Browser.touchEndEvent, this.mouseUpHandler, this);
    };
    SparklineTooltip.prototype.mouseLeaveHandler = function () {
        this.removeTooltipElements();
    };
    SparklineTooltip.prototype.mouseUpHandler = function (e) {
        if (!this.sparkline.isTouch) {
            return;
        }
        this.processTooltip(e);
        this.fadeOut();
    };
    SparklineTooltip.prototype.fadeOut = function () {
        clearTimeout(this.clearTooltip);
        this.clearTooltip = +setTimeout(this.removeTooltipElements.bind(this), 5000);
    };
    /**
     * To remove tooltip and tracker elements.
     *
     * @private
     */
    SparklineTooltip.prototype.removeTooltipElements = function () {
        this.removeTooltip();
        this.removeTracker();
    };
    SparklineTooltip.prototype.mouseMoveHandler = function (e) {
        this.processTooltip(e);
    };
    SparklineTooltip.prototype.processTooltip = function (e) {
        var pointIndex;
        var spark = this.sparkline;
        var visiblePoints = spark.sparklineRenderer.visiblePoints;
        var mouseX = spark.mouseX;
        var mouseY = spark.mouseY;
        if (spark.type !== 'Pie') {
            var locations = extend([], [], visiblePoints);
            var trackerPositions = locations.map(function (point) { return point.location.x; });
            var temp = Infinity;
            for (var i = 0, diff = void 0, len = trackerPositions.length; i < len; i++) {
                diff = Math.abs(mouseX - trackerPositions[i]);
                if (temp > diff) {
                    temp = diff;
                    pointIndex = i;
                }
            }
        }
        else {
            var target = e.target.id;
            pointIndex = parseInt(target.split('_pie_')[1], 10);
        }
        if (isNaN(pointIndex) || !withInBounds$1(mouseX, mouseY, new Rect$1(0, 0, spark.availableSize.width, spark.availableSize.height))) {
            this.removeTracker();
            this.removeTooltip();
            return;
        }
        if (this.pointIndex === pointIndex) {
            return;
        }
        this.pointIndex = pointIndex;
        this.renderTrackerLine(visiblePoints[pointIndex]);
        this.renderTooltip(visiblePoints[pointIndex]);
    };
    /**
     * To render tracker line
     */
    SparklineTooltip.prototype.renderTrackerLine = function (points) {
        var spark = this.sparkline;
        var theme = spark.theme.toLowerCase();
        var tracker = spark.tooltipSettings.trackLineSettings;
        var color = spark.sparkTheme.trackerLineColor ? spark.sparkTheme.trackerLineColor : tracker.color;
        if (!tracker.visible || spark.type === 'Pie') {
            return;
        }
        var group = getIdElement(spark.element.id + '_sparkline_tracker_g');
        if (isNullOrUndefined(group)) {
            group = spark.renderer.createGroup({ id: spark.element.id + '_sparkline_tracker_g' });
            spark.svgObject.appendChild(group);
        }
        var pathEle = getIdElement(spark.element.id + '_sparkline_tracker');
        var d = 'M ' + points.location.x + ' ' + spark.padding.top + ' L ' + points.location.x + ' ' +
            (spark.availableSize.height - spark.padding.bottom);
        if (isNullOrUndefined(pathEle)) {
            var pathOption = new PathOption$2(spark.element.id + '_sparkline_tracker', color, tracker.width, color, 1);
            pathOption.d = d;
            drawPath(spark, pathOption, group);
        }
        else {
            pathEle.setAttribute('d', d);
            pathEle.setAttribute('stroke-width', tracker.width.toString());
            pathEle.setAttribute('stroke', color);
        }
    };
    /**
     * To render line series
     */
    SparklineTooltip.prototype.renderTooltip = function (points) {
        var _this = this;
        var spark = this.sparkline;
        var tooltip = spark.tooltipSettings;
        if (!tooltip.visible) {
            return;
        }
        var div = getIdElement(spark.element.id + '_sparkline_tooltip_div');
        if (isNullOrUndefined(div)) {
            div = createElement('div', {
                id: spark.element.id + '_sparkline_tooltip_div',
                styles: 'pointer-events: none; position: absolute;z-index:1;'
            });
            getIdElement(spark.element.id + '_Secondary_Element').appendChild(div);
        }
        var x = points.xVal.toString();
        if (spark.valueType === 'Category') {
            x = spark.dataSource[points.xVal][spark.xName];
        }
        else if (spark.valueType === 'DateTime') {
            x = new Date(points.xVal).toDateString();
        }
        var text = this.getFormat(spark.tooltipSettings.format, spark, x, this.formatValue(points.yVal, spark).toString());
        var location = { x: points.location.x, y: points.location.y };
        location = spark.type === 'Pie' ? { x: points.location.x, y: points.location.y } : location;
        var textColor = tooltip.textStyle.color || spark.sparkTheme.tooltipFontColor;
        var backgroundColor = tooltip.fill === '' ? spark.sparkTheme.tooltipFill : tooltip.fill;
        var tooltipEvent = {
            name: 'tooltipInitialize', cancel: false, text: text,
            textStyle: {
                size: tooltip.textStyle.size,
                opacity: spark.sparkTheme.tooltipTextOpacity || tooltip.textStyle.opacity,
                fontWeight: tooltip.textStyle.fontWeight,
                fontStyle: tooltip.textStyle.fontStyle,
                fontFamily: tooltip.textStyle.fontFamily || spark.sparkTheme.tooltipFontFamily,
                color: textColor
            }
        };
        spark.trigger('tooltipInitialize', tooltipEvent, function () {
            _this.addTooltip(tooltipEvent, spark, backgroundColor, tooltip, location, div);
        });
    };
    SparklineTooltip.prototype.addTooltip = function (tooltipEvent, spark, backgroundColor, tooltip, location, div, eventArgs) {
        var cancel;
        var tootipArgs;
        if (!isNullOrUndefined(tooltipEvent)) {
            var c = tooltipEvent.cancel, otherArgs = __rest(tooltipEvent, ["cancel"]);
            cancel = c;
            tootipArgs = tooltipEvent;
        }
        else {
            cancel = eventArgs.cancel;
            tootipArgs = eventArgs;
        }
        if (tooltipEvent.cancel) {
            return;
        }
        var element = new Tooltip({
            content: tootipArgs.text,
            border: tooltip.border,
            template: tooltip.template,
            data: spark.dataSource[this.pointIndex],
            fill: backgroundColor,
            textStyle: tootipArgs.textStyle,
            enableAnimation: false,
            location: { x: location.x, y: location.y },
            shared: false,
            availableSize: this.sparkline.availableSize,
            areaBounds: new Rect$1(0, 0, spark.availableSize.width, spark.availableSize.height),
            theme: spark.theme
        });
        element.opacity = spark.sparkTheme.tooltipFillOpacity || element.opacity;
        element.appendTo(div);
    };
    /**
     * To get tooltip format.
     */
    SparklineTooltip.prototype.getFormat = function (format, spark, x, y) {
        if (isNullOrUndefined(format) || format === '') {
            return [y];
        }
        var text = format;
        text = text.split('${' + spark.xName + '}').join(x).split('${' + spark.yName + '}').join(y);
        return [text];
    };
    SparklineTooltip.prototype.formatValue = function (value, sparkline) {
        var formatValue;
        var formatFunction;
        if (sparkline.format && !isNaN(Number(value))) {
            formatFunction = sparkline.intl.getNumberFormat({ format: sparkline.format, useGrouping: sparkline.useGroupingSeparator });
            formatValue = formatFunction(value);
        }
        else {
            formatValue = value;
        }
        return formatValue;
    };
    /**
     * To remove tracker line.
     */
    SparklineTooltip.prototype.removeTracker = function () {
        var tracker = this.sparkline.element.querySelector('#' + this.sparkline.element.id + '_sparkline_tracker_g');
        return tracker ? remove(tracker) : null;
    };
    /**
     * To remove tooltip element.
     */
    SparklineTooltip.prototype.removeTooltip = function () {
        this.pointIndex = null;
        var tooltip = this.sparkline.element.querySelector('#' + this.sparkline.element.id + '_sparkline_tooltip_div');
        return tooltip ? remove(tooltip) : null;
    };
    /**
     * Get module name.
     */
    SparklineTooltip.prototype.getModuleName = function () {
        return 'SparklineTooltip';
    };
    /**
     * To destroy the tooltip.
     */
    SparklineTooltip.prototype.destroy = function (sparkline) {
        // To remove tooltip module
    };
    return SparklineTooltip;
}());

/**
 * Exporting all modules from Sparkline Component
 */

/**
 * Specifies the Cartesian Axis Layout.
 */
var axisPadding$1 = 10;
/**
 * The `CartesianAxisLayoutPanel` class is responsible for managing the layout of Cartesian axes in a 3D chart.
 */
var CartesianAxisLayoutPanel$1 = /** @__PURE__ @class */ (function () {
    /**
     *
     *
     * @param {Chart3D} chartModule - Specifies the chart module.
     * @private
     */
    function CartesianAxisLayoutPanel(chartModule) {
        this.chart = chartModule;
    }
    /**
     * Measures and calculates the dimensions of the axis based on the provided rectangle.
     *
     * @param {Rect} rect - The rectangle used as a reference for axis measurement and sizing.
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.measureAxis = function (rect) {
        var chart = this.chart;
        this.seriesClipRect = new Rect(rect.x, rect.y, rect.width, rect.height);
        this.initialClipRect = rect;
        this.leftSize = 0;
        this.rightSize = 0;
        this.topSize = 0;
        this.bottomSize = 0;
        this.measureRowAxis(chart, this.initialClipRect);
        this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));
        this.measureColumnAxis(chart, this.initialClipRect);
        this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));
        if (!this.chart.delayRedraw) {
            this.calculateAxisSize(this.initialClipRect);
        }
        this.leftSize = 0;
        this.rightSize = 0;
        this.topSize = 0;
        this.bottomSize = 0;
        this.measureRowAxis(chart, this.initialClipRect);
        this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));
        this.measureColumnAxis(chart, this.initialClipRect);
        this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));
        if (!this.chart.delayRedraw) {
            chart.refreshAxis();
            this.calculateAxisSize(this.seriesClipRect);
        }
    };
    /**
     * Measures and calculates the dimensions of the row axis within the 3D chart.
     *
     * @param {Chart3D} chart - The 3D chart containing the row axis.
     * @param {Rect} rect - The initial rect values.
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.measureRowAxis = function (chart, rect) {
        var row;
        this.calculateRowSize(rect);
        for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {
            var item = _a[_i];
            row = item;
            row.nearSizes = [];
            row.farSizes = [];
            this.arrangeAxis(row);
            this.measureDefinition(row, chart, new Size(chart.availableSize.width, row.computedHeight));
            if (this.leftSize < sum(row.nearSizes)) {
                this.leftSize = sum(row.nearSizes);
            }
            if (this.rightSize < sum(row.farSizes)) {
                this.rightSize = sum(row.farSizes);
            }
        }
    };
    /**
     * Measures and calculates the dimensions of the column axis within the 3D chart.
     *
     * @param {Chart3D} chart - The 3D chart containing the column axis.
     * @param {Rect} rect - The initial rect values.
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.measureColumnAxis = function (chart, rect) {
        var column;
        this.calculateColumnSize(rect);
        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {
            var item = _a[_i];
            column = item;
            column.farSizes = [];
            column.nearSizes = [];
            this.arrangeAxis(column);
            this.measureDefinition(column, chart, new Size(column.computedWidth, chart.availableSize.height));
            if (this.bottomSize < sum(column.nearSizes)) {
                this.bottomSize = sum(column.nearSizes);
            }
            if (this.topSize < sum(column.farSizes)) {
                this.topSize = sum(column.farSizes);
            }
        }
    };
    /**
     * Measure the column and row in chart.
     *
     * @param {Chart3DRow | Chart3DColumn} definition - Specifies the row or column.
     * @param {Chart3D} chart - Specifies the chart.
     * @param {Size} size - Specifies the size.
     * @returns {void}
     * @private
     */
    CartesianAxisLayoutPanel.prototype.measureDefinition = function (definition, chart, size) {
        for (var _i = 0, _a = definition.axes; _i < _a.length; _i++) {
            var axis = _a[_i];
            axis.getModule(chart);
            axis.baseModule.calculateRangeAndInterval(size, axis);
            definition.computeSize(axis, chart);
        }
        if (definition.farSizes.length > 0) {
            definition.farSizes[definition.farSizes.length - 1] -= axisPadding$1;
        }
        if (definition.nearSizes.length > 0) {
            definition.nearSizes[definition.nearSizes.length - 1] -= axisPadding$1;
        }
    };
    /**
     * Measure the axis.
     *
     * @param {Rect} rect - The initial rect values.
     * @returns {void}
     * @private
     */
    CartesianAxisLayoutPanel.prototype.calculateAxisSize = function (rect) {
        var chart = this.chart;
        var row;
        var column;
        var definition;
        var axis;
        var nearCount = 0;
        var farCount = 0;
        var size = 0;
        var x;
        var y;
        var axisOffset;
        this.calculateRowSize(rect);
        for (var i = 0, len = chart.rows.length; i < len; i++) {
            row = chart.rows[i];
            nearCount = 0;
            farCount = 0;
            for (var j = 0, len_1 = row.axes.length; j < len_1; j++) {
                axis = row.axes[j];
                axisOffset = axis.plotOffset;
                if (axis.rect.height === 0) {
                    axis.rect.height = row.computedHeight;
                    size = 0;
                    for (var k = i + 1, len_2 = i + axis.span; k < len_2; k++) {
                        definition = chart.rows[k];
                        size += definition.computedHeight;
                    }
                    axis.rect.y = (row.computedTop - size) + (axis.plotOffsetTop ? axis.plotOffsetTop : axisOffset);
                    axis.rect.height = (axis.rect.height + size) -
                        (this.getAxisOffsetValue(axis.plotOffsetTop, axis.plotOffsetBottom, axis.plotOffset));
                    axis.rect.width = 0;
                }
                if (axis.isAxisOpposedPosition) {
                    x = rect.x + rect.width + sum(subArray(row.farSizes, farCount));
                    axis.rect.x = axis.rect.x >= x ? axis.rect.x : x;
                    farCount++;
                }
                else {
                    x = rect.x - sum(subArray(row.nearSizes, nearCount));
                    axis.rect.x = axis.rect.x <= x ? axis.rect.x : x;
                    nearCount++;
                }
            }
        }
        this.calculateColumnSize(rect);
        for (var i = 0, len = chart.columns.length; i < len; i++) {
            column = chart.columns[i];
            nearCount = 0;
            farCount = 0;
            for (var j = 0, len_3 = column.axes.length; j < len_3; j++) {
                axis = column.axes[j];
                axisOffset = axis.plotOffset;
                if (axis.rect.width === 0) {
                    for (var k = i, len_4 = (i + axis.span); k < len_4; k++) {
                        definition = chart.columns[k];
                        axis.rect.width += definition.computedWidth;
                    }
                    axis.rect.x = column.computedLeft + (axis.plotOffsetLeft ? axis.plotOffsetLeft : axisOffset);
                    axis.rect.width -= (this.getAxisOffsetValue(axis.plotOffsetLeft, axis.plotOffsetRight, axis.plotOffset));
                    axis.rect.height = 0;
                }
                if (axis.isAxisOpposedPosition) {
                    y = rect.y - sum(subArray(column.farSizes, farCount));
                    axis.rect.y = axis.rect.y <= y ? axis.rect.y : y;
                    farCount++;
                }
                else {
                    y = rect.y + rect.height + sum(subArray(column.nearSizes, nearCount));
                    axis.rect.y = axis.rect.y >= y ? axis.rect.y : y;
                    nearCount++;
                }
            }
        }
    };
    /**
     * Measure the axis.
     *
     * @returns {void}
     * @private
     */
    CartesianAxisLayoutPanel.prototype.measure = function () {
        var chart = this.chart;
        var row;
        var column;
        var definition;
        var actualIndex;
        var span;
        for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {
            var axis = _a[_i];
            if (axis.orientation === 'Vertical') {
                chart.verticalAxes.push(axis);
                actualIndex = this.getActualRow(axis);
                row = chart.rows[actualIndex];
                this.pushAxis(row, axis);
                span = ((actualIndex + axis.span) > chart.rows.length ? chart.rows.length : (actualIndex + axis.span));
                for (var j = actualIndex + 1; j < span; j++) {
                    definition = chart.rows[j];
                    definition.axes[row.axes.length - 1] = axis;
                    chart.rows[j] = definition;
                }
                chart.rows[actualIndex] = row;
            }
            else {
                chart.horizontalAxes.push(axis);
                actualIndex = this.getActualColumn(axis);
                column = chart.columns[actualIndex];
                this.pushAxis(column, axis);
                span = ((actualIndex + axis.span) > chart.columns.length ? chart.columns.length : (actualIndex + axis.span));
                for (var j = actualIndex + 1; j < span; j++) {
                    definition = chart.columns[j];
                    definition.axes[column.axes.length - 1] = axis;
                    chart.columns[j] = definition;
                }
                chart.columns[actualIndex] = column;
            }
            axis.isRTLEnabled = chart.enableRtl;
            axis.setIsInversedAndOpposedPosition();
        }
    };
    /**
     * Calculates the offset value for an axis based on positions and a plot offset.
     *
     * @param {number} position1 - The first position.
     * @param {number} position2 - The second position.
     * @param {number} plotOffset - The plot offset value.
     * @returns {number} - The calculated axis offset value.
     */
    CartesianAxisLayoutPanel.prototype.getAxisOffsetValue = function (position1, position2, plotOffset) {
        var rangeOffset = position1 ? (position1 + (position2 ? position2 :
            plotOffset)) : (position2 ? position2 + plotOffset : 2 * plotOffset);
        return rangeOffset;
    };
    /**
     * Pushes an axis definition into the specified row or column within the 3D chart.
     *
     * @param {Chart3DRow | Chart3DColumn} definition - The row or column definition to which the axis is added.
     * @param {Chart3DAxis} axis - The axis to be pushed into the definition.
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.pushAxis = function (definition, axis) {
        for (var i = 0, len = definition.axes.length; i <= len; i++) {
            if (!definition.axes[i]) {
                definition.axes[i] = axis;
                break;
            }
        }
    };
    /**
     * Arranges and positions axis elements within the specified row or column definition.
     *
     * @param {Chart3DRow | Chart3DColumn} definition - The row or column definition in which axis elements are arranged.
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.arrangeAxis = function (definition) {
        var axisCollection = [];
        for (var i = 0, len = definition.axes.length; i <= len; i++) {
            if (definition.axes[i]) {
                axisCollection.push(definition.axes[i]);
            }
        }
        definition.axes = axisCollection;
    };
    /**
     * Retrieves the actual column index for the specified axis within the 3D chart.
     *
     * @param {Chart3DAxis} axis - The axis for which the actual column index is retrieved.
     * @returns {number} - The actual column index.
     */
    CartesianAxisLayoutPanel.prototype.getActualColumn = function (axis) {
        var actualLength = this.chart.columns.length;
        var pos = axis.columnIndex;
        var result = pos >= actualLength ? actualLength - 1 : (pos < 0 ? 0 : pos);
        return result;
    };
    /**
     * Retrieves the actual row index for the specified axis within the 3D chart.
     *
     * @param {Chart3DAxis} axis - The axis for which the actual row index is retrieved.
     * @returns {number} - The actual row index.
     */
    CartesianAxisLayoutPanel.prototype.getActualRow = function (axis) {
        var actualLength = this.chart.rows.length;
        var pos = axis.rowIndex;
        var result = pos >= actualLength ? actualLength - 1 : (pos < 0 ? 0 : pos);
        return result;
    };
    /**
     * Measure the row size.
     *
     * @param {Rect} rect - The available rect value.
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.calculateRowSize = function (rect) {
        /*! Calculate row size */
        var chart = this.chart;
        var row;
        var rowTop = rect.y + rect.height;
        var height = 0;
        var remainingHeight = Math.max(0, rect.height);
        for (var i = 0, len = chart.rows.length; i < len; i++) {
            row = chart.rows[i];
            if (row.height.indexOf('%') !== -1) {
                height = Math.min(remainingHeight, (rect.height * parseInt(row.height, 10) / 100));
            }
            else {
                height = Math.min(remainingHeight, parseInt(row.height, 10));
            }
            height = (i !== (len - 1)) ? height : remainingHeight;
            row.computedHeight = height;
            rowTop -= height;
            row.computedTop = rowTop;
            remainingHeight -= height;
        }
    };
    /**
     * Measure the column size.
     *
     * @param {Rect} rect - The available rect value.
     * @returns {void}
     */
    CartesianAxisLayoutPanel.prototype.calculateColumnSize = function (rect) {
        /*! Calculate column size */
        var chart = this.chart;
        var column;
        var columnLeft = rect.x;
        var width = 0;
        var remainingWidth = Math.max(0, rect.width);
        for (var i = 0, len = chart.columns.length; i < len; i++) {
            column = chart.columns[i];
            if (column.width.indexOf('%') !== -1) {
                width = Math.min(remainingWidth, (rect.width * parseInt(column.width, 10) / 100));
            }
            else {
                width = Math.min(remainingWidth, parseInt(column.width, 10));
            }
            width = (i !== (len - 1)) ? width : remainingWidth;
            column.computedWidth = width;
            column.computedLeft = columnLeft;
            columnLeft += width;
            remainingWidth -= width;
        }
    };
    return CartesianAxisLayoutPanel;
}());

/**
 * Gets the 3D theme color based on the specified chart theme.
 *
 * @param {ChartTheme} theme - The theme to determine the 3D color for.
 * @returns {Chart3DThemeStyle} An object containing 3D theme color styles.
 * @private
 */
function get3DThemeColor(theme) {
    var style;
    switch (theme) {
        case 'HighContrastLight':
        case 'HighContrast':
            style = {
                axisLabel: '#969696',
                axisTitle: '#969696',
                majorGridLine: '#BFBFBF',
                minorGridLine: '#969696',
                majorTickLine: '#BFBFBF',
                minorTickLine: '#969696',
                chartTitle: '#ffffff',
                legendLabel: '#ffffff',
                background: 'transparent',
                tooltipFill: '#ffffff',
                tooltipBoldLabel: '#000000',
                tooltipLightLabel: '#000000',
                tooltipHeaderLine: '#969696',
                tabColor: '#FFD939',
                backWallColor: '#222222',
                leftWallColor: '#272727',
                chartTitleFont: {
                    color: '#FFFFFF', fontFamily: 'Segoe UI'
                },
                axisLabelFont: {
                    color: '#969696', fontFamily: 'Segoe UI'
                },
                legendTitleFont: {
                    color: '#FFFFFF', fontFamily: 'Segoe UI'
                },
                legendLabelFont: {
                    color: '#969696', fontFamily: 'Segoe UI'
                },
                tooltipLabelFont: {
                    color: '#000000', fontFamily: 'Segoe UI'
                },
                axisTitleFont: {
                    color: '#000000', fontFamily: 'Segoe UI'
                },
                datalabelFont: {
                    color: '#969696', fontFamily: 'Segoe UI'
                },
                chartSubTitleFont: {
                    color: '#FFFFFF', fontFamily: 'Segoe UI'
                }
            };
            break;
        case 'MaterialDark':
        case 'FabricDark':
        case 'BootstrapDark':
            style = {
                axisLabel: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : theme === 'FabricDark' ? '#A19F9D' : '#676767',
                axisTitle: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : theme === 'FabricDark' ? '#A19F9D' : '#676767',
                majorGridLine: '#414040',
                minorGridLine: '#514F4F',
                majorTickLine: '#414040',
                minorTickLine: '#4A4848',
                chartTitle: '#ffffff',
                legendLabel: '#DADADA',
                background: 'transparent',
                tooltipFill: '#F4F4F4',
                tooltipBoldLabel: '#282727',
                tooltipLightLabel: '#333232',
                tooltipHeaderLine: '#9A9A9A',
                backWallColor: '#222222',
                leftWallColor: '#272727',
                tabColor: theme === 'MaterialDark' ? '#00B0FF' : theme === 'FabricDark' ? '#0074CC' : '#0070F0',
                chartTitleFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.87)' : theme === 'FabricDark' ? '#DADADA' : '#FFFFFF', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                axisLabelFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : theme === 'FabricDark' ? '#A19F9D' : '#676767', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                legendTitleFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.87)' : theme === 'FabricDark' ? '#DADADA' : '#FFFFFF', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                legendLabelFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : theme === 'FabricDark' ? '#A19F9D' : '#676767', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                tooltipLabelFont: {
                    color: theme === 'MaterialDark' ? 'rgba(18, 18, 18, 1)' : theme === 'FabricDark' ? '#DADADA' : '#1A1A1A', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                axisTitleFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : theme === 'FabricDark' ? '#A19F9D' : '#676767', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                datalabelFont: {
                    color: theme === 'MaterialDark' ? '#000000' : theme === 'FabricDark' ? '#000000' : '#FFFFFF', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                },
                chartSubTitleFont: {
                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.87)' : theme === 'FabricDark' ? '#DADADA' : '#FFFFFF', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
                }
            };
            break;
        case 'Bootstrap4':
            style = {
                axisLabel: '#222222',
                axisTitle: '#212529',
                majorGridLine: '#CED4DA',
                minorGridLine: '#DEE2E6',
                majorTickLine: '#ADB5BD',
                minorTickLine: '#CED4DA',
                chartTitle: '#212529',
                legendLabel: '#212529',
                background: 'transparent',
                tooltipFill: '#020202',
                tooltipBoldLabel: 'rgba(255,255,255)',
                tooltipLightLabel: 'rgba(255,255,255, 0.9)',
                tooltipHeaderLine: 'rgba(255,255,255, 0.2)',
                tabColor: '#007BFF',
                backWallColor: '#F9F9F9',
                leftWallColor: '#EBEBEB',
                chartTitleFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                },
                axisLabelFont: {
                    color: '#222222', fontFamily: 'Helvetica'
                },
                legendTitleFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                },
                legendLabelFont: {
                    color: '#666666', fontFamily: 'Helvetica'
                },
                tooltipLabelFont: {
                    color: '#F9FAFB', fontFamily: 'Helvetica'
                },
                axisTitleFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                },
                datalabelFont: {
                    color: '#222222', fontFamily: 'Helvetica'
                },
                chartSubTitleFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                }
            };
            break;
        case 'Tailwind':
            style = {
                axisLabel: '#222222',
                axisTitle: '#374151',
                majorGridLine: '#E5E7EB',
                minorGridLine: '#E5E7EB',
                majorTickLine: '#D1D5DB',
                minorTickLine: '#D1D5DB',
                chartTitle: '#374151',
                legendLabel: '#374151',
                background: 'transparent',
                tooltipFill: '#111827',
                tooltipBoldLabel: '#D1D5DB',
                tooltipLightLabel: '#F9FAFB',
                tooltipHeaderLine: '#6B7280',
                tabColor: '#4F46E5',
                backWallColor: '#F9F9F9',
                leftWallColor: '#EBEBEB',
                chartTitleFont: {
                    color: '#374151', fontFamily: 'Inter'
                },
                axisLabelFont: {
                    color: '#222222', fontFamily: 'Inter'
                },
                legendTitleFont: {
                    color: '#374151', fontFamily: 'Inter'
                },
                legendLabelFont: {
                    color: '#374151', fontFamily: 'Inter'
                },
                tooltipLabelFont: {
                    color: '#F9FAFB', fontFamily: 'Inter'
                },
                axisTitleFont: {
                    color: '#374151', fontFamily: 'Inter'
                },
                datalabelFont: {
                    color: '#FFFFFF', fontFamily: 'Inter'
                },
                chartSubTitleFont: {
                    color: '#374151', fontFamily: 'Inter'
                }
            };
            break;
        case 'TailwindDark':
            style = {
                axisLabel: '#D1D5DB',
                axisTitle: '#D1D5DB',
                majorGridLine: '#374151',
                minorGridLine: '#374151',
                majorTickLine: '#4B5563',
                minorTickLine: '#4B5563',
                chartTitle: '#D1D5DB',
                legendLabel: '#D1D5DB',
                background: 'transparent',
                tooltipFill: '#F9FAFB',
                tooltipBoldLabel: '#6B7280',
                tooltipLightLabel: '#1F2937',
                tooltipHeaderLine: '#9CA3AF',
                tabColor: '#22D3EE',
                backWallColor: '#222222',
                leftWallColor: '#272727',
                chartTitleFont: {
                    color: '#D1D5DB', fontFamily: 'Inter'
                },
                axisLabelFont: {
                    color: '#D1D5DB', fontFamily: 'Inter'
                },
                legendTitleFont: {
                    color: '#D1D5DB', fontFamily: 'Inter'
                },
                legendLabelFont: {
                    color: '#D1D5DB', fontFamily: 'Inter'
                },
                tooltipLabelFont: {
                    color: '#1F2937', fontFamily: 'Inter'
                },
                axisTitleFont: {
                    color: '#D1D5DB', fontFamily: 'Inter'
                },
                datalabelFont: {
                    color: '#9CA3AF', fontFamily: 'Inter'
                },
                chartSubTitleFont: {
                    color: '#D1D5DB', fontFamily: 'Inter'
                }
            };
            break;
        case 'Bootstrap5':
            style = {
                axisLabel: '#222222',
                axisTitle: '#343A40',
                majorGridLine: '#E5E7EB',
                minorGridLine: '#E5E7EB',
                majorTickLine: '#D1D5DB',
                minorTickLine: '#D1D5DB',
                chartTitle: '#343A40',
                legendLabel: '#343A40',
                background: 'transparent',
                tooltipFill: '#212529',
                tooltipBoldLabel: '#F9FAFB',
                tooltipLightLabel: '#F9FAFB',
                tooltipHeaderLine: '#9CA3AF',
                tabColor: '#0D6EFD',
                backWallColor: '#F9F9F9',
                leftWallColor: '#EBEBEB',
                chartTitleFont: {
                    color: '#343A40', fontFamily: 'Helvetica'
                },
                axisLabelFont: {
                    color: '#222222', fontFamily: 'Helvetica'
                },
                legendTitleFont: {
                    color: '#343A40', fontFamily: 'Helvetica'
                },
                legendLabelFont: {
                    color: '#343A40', fontFamily: 'Helvetica'
                },
                tooltipLabelFont: {
                    color: '#F9FAFB', fontFamily: 'Helvetica'
                },
                axisTitleFont: {
                    color: '#343A40', fontFamily: 'Helvetica'
                },
                datalabelFont: {
                    color: '#FFFFFF', fontFamily: 'Helvetica'
                },
                chartSubTitleFont: {
                    color: '#343A40', fontFamily: 'Helvetica'
                }
            };
            break;
        case 'Bootstrap5Dark':
            style = {
                axisLabel: '#E9ECEF',
                axisTitle: '#E9ECEF',
                majorGridLine: '#343A40',
                minorGridLine: '#343A40',
                majorTickLine: '#495057',
                minorTickLine: '#495057',
                chartTitle: '#E9ECEF',
                legendLabel: '#E9ECEF',
                background: 'transparent',
                tooltipFill: '#E9ECEF',
                tooltipBoldLabel: '#212529',
                tooltipLightLabel: '#212529',
                tooltipHeaderLine: '#ADB5BD',
                tabColor: '#0D6EFD',
                backWallColor: '#222222',
                leftWallColor: '#272727',
                chartTitleFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                },
                axisLabelFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                },
                legendTitleFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                },
                legendLabelFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                },
                tooltipLabelFont: {
                    color: '#212529', fontFamily: 'Helvetica'
                },
                axisTitleFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                },
                datalabelFont: {
                    color: '#000000', fontFamily: 'Helvetica'
                },
                chartSubTitleFont: {
                    color: '#E9ECEF', fontFamily: 'Helvetica'
                }
            };
            break;
        case 'Fluent':
            style = {
                axisLabel: '#222222',
                axisTitle: '#201F1E',
                majorGridLine: '#DDDDDD',
                minorGridLine: '#DDDDDD',
                majorTickLine: '#DDDDDD',
                minorTickLine: '#DDDDDD',
                chartTitle: '#201F1E',
                legendLabel: '#323130',
                background: 'transparent',
                tooltipFill: '#FFFFFF',
                tooltipBoldLabel: '#323130',
                tooltipLightLabel: '#323130',
                tooltipHeaderLine: '#D2D0CE',
                tabColor: '#0078D4',
                backWallColor: '#F9F9F9',
                leftWallColor: '#EBEBEB',
                chartTitleFont: {
                    color: '#201F1E', fontFamily: 'Segoe UI'
                },
                axisLabelFont: {
                    color: '#222222', fontFamily: 'Segoe UI'
                },
                legendTitleFont: {
                    color: '#201F1E', fontFamily: 'Segoe UI'
                },
                legendLabelFont: {
                    color: '#49454E', fontFamily: 'Segoe UI'
                },
                tooltipLabelFont: {
                    color: '#323130', fontFamily: 'Segoe UI'
                },
                axisTitleFont: {
                    color: '#201F1E', fontFamily: 'Segoe UI'
                },
                datalabelFont: {
                    color: '#FFFFFF', fontFamily: 'Segoe UI'
                },
                chartSubTitleFont: {
                    color: '#323129', fontFamily: 'Segoe UI'
                }
            };
            break;
        case 'FluentDark':
            style = {
                axisLabel: '#D2D0CE',
                axisTitle: '#D2D0CE',
                majorGridLine: '#414040',
                minorGridLine: '#414040',
                majorTickLine: '#3B3A39',
                minorTickLine: '#3B3A39',
                chartTitle: '#F3F2F1',
                legendLabel: '#D2D0CE',
                background: 'transparent',
                tooltipFill: '#252423',
                tooltipBoldLabel: '#F3F2F1',
                tooltipLightLabel: '#F3F2F1',
                tooltipHeaderLine: '#3B3A39',
                tabColor: '#0078D4',
                backWallColor: '#222222',
                leftWallColor: '#272727',
                chartTitleFont: {
                    color: '#C8C6C4', fontFamily: 'Segoe UI'
                },
                axisLabelFont: {
                    color: '#D2D0CE', fontFamily: 'Segoe UI'
                },
                legendTitleFont: {
                    color: '#F3F2F1', fontFamily: 'Segoe UI'
                },
                legendLabelFont: {
                    color: '#D2D0CE', fontFamily: 'Segoe UI'
                },
                tooltipLabelFont: {
                    color: '#F3F2F1', fontFamily: 'Segoe UI'
                },
                axisTitleFont: {
                    color: '#F3F2F2', fontFamily: 'Segoe UI'
                },
                datalabelFont: {
                    color: '#000000', fontFamily: 'Segoe UI'
                },
                chartSubTitleFont: {
                    color: '#F3F2F1', fontFamily: 'Segoe UI'
                }
            };
            break;
        case 'Material3':
            style = {
                axisLabel: '#222222',
                axisTitle: '#1C1B1F',
                majorGridLine: '#DDDDDD',
                minorGridLine: '#DDDDDD',
                majorTickLine: '#DDDDDD',
                minorTickLine: '#DDDDDD',
                chartTitle: '#1C1B1F',
                legendLabel: '#49454E',
                background: 'transparent',
                tooltipFill: '#313033',
                tooltipBoldLabel: '#F4EFF4',
                tooltipLightLabel: '#F4EFF4',
                tooltipHeaderLine: '#F4EFF4',
                tabColor: '#49454E',
                backWallColor: '#F9F9F9',
                leftWallColor: '#EBEBEB',
                chartTitleFont: {
                    color: '#1C1B1F', fontFamily: 'Roboto'
                },
                axisLabelFont: {
                    color: '#222222', fontFamily: 'Roboto'
                },
                legendTitleFont: {
                    color: '#1C1B1F', fontFamily: 'Roboto'
                },
                legendLabelFont: {
                    color: '#49454E', fontFamily: 'Roboto'
                },
                tooltipLabelFont: {
                    color: '#F4EFF4', fontFamily: 'Roboto'
                },
                axisTitleFont: {
                    color: '#1C1B1F', fontFamily: 'Roboto'
                },
                datalabelFont: {
                    color: '#FFFFFF', fontFamily: 'Roboto'
                },
                chartSubTitleFont: {
                    color: '#49454E', fontFamily: 'Roboto'
                }
            };
            break;
        case 'Material3Dark':
            style = {
                axisLabel: '#CAC4D0',
                axisTitle: '#CAC4D0',
                majorGridLine: '#444746',
                minorGridLine: '#444746',
                majorTickLine: '#444746',
                minorTickLine: '#444746',
                chartTitle: '#E6E1E5',
                legendLabel: '#CAC4D0',
                background: 'transparent',
                tooltipFill: '#E6E1E5',
                tooltipBoldLabel: '#313033',
                tooltipLightLabel: '#313033',
                tooltipHeaderLine: '#313033',
                tabColor: '#CAC4D0',
                backWallColor: '#222222',
                leftWallColor: '#272727',
                chartTitleFont: {
                    color: '#E6E1E5', fontFamily: 'Roboto'
                },
                axisLabelFont: {
                    color: '#CAC4D0', fontFamily: 'Roboto'
                },
                legendTitleFont: {
                    color: '#E6E1E5', fontFamily: 'Roboto'
                },
                legendLabelFont: {
                    color: '#CAC4D0', fontFamily: 'Roboto'
                },
                tooltipLabelFont: {
                    color: '#313033', fontFamily: 'Roboto'
                },
                axisTitleFont: {
                    color: '#E6E1E5', fontFamily: 'Roboto'
                },
                datalabelFont: {
                    color: '#000000', fontFamily: 'Roboto'
                },
                chartSubTitleFont: {
                    color: '#CAC4D0', fontFamily: 'Roboto'
                }
            };
            break;
        default:
            style = {
                axisLabel: '#222222',
                axisTitle: '#424242',
                majorGridLine: '#dbdbdb',
                minorGridLine: '#eaeaea',
                majorTickLine: '#b5b5b5',
                minorTickLine: '#d6d6d6',
                chartTitle: '#424242',
                legendLabel: '#353535',
                background: 'transparent',
                tooltipFill: '#000816',
                tooltipBoldLabel: '#ffffff',
                tooltipLightLabel: '#dbdbdb',
                tooltipHeaderLine: '#ffffff',
                backWallColor: '#F9F9F9',
                leftWallColor: '#EBEBEB',
                tabColor: theme === 'Material' ? '#ff4081' : theme === 'Fabric' ? '#0078D6' : '#317AB9',
                chartTitleFont: {
                    color: theme === 'Material' ? 'rgba(0, 0, 0, 1)' : theme === 'Fabric' ? '#333333' : '#212529', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
                },
                axisLabelFont: {
                    color: '#222222', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
                },
                legendTitleFont: {
                    color: theme === 'Material' ? 'rgba(0, 0, 0, 1)' : theme === 'Fabric' ? '#333333' : '#212529', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
                },
                legendLabelFont: {
                    color: theme === 'Material' ? 'rgba(97, 97, 97, 1)' : theme === 'Fabric' ? '#666666' : '#666666', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
                },
                tooltipLabelFont: {
                    color: theme === 'Material' ? 'rgba(249, 250, 251, 1)' : theme === 'Fabric' ? '#333333' : '#F9FAFB', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
                },
                axisTitleFont: {
                    color: theme === 'Material' ? 'rgba(0, 0, 0, 1)' : theme === 'Fabric' ? '#333333' : '#212529', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
                },
                datalabelFont: {
                    color: '#FFFFFF', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
                },
                chartSubTitleFont: {
                    color: theme === 'Material' ? 'rgba(0, 0, 0, 1)' : theme === 'Fabric' ? '#333333' : '#212529', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
                }
            };
            break;
    }
    return style;
}
/**
 * Gets the color palette for 3D chart series based on the specified theme.
 *
 * @param {ChartTheme} theme - The theme to determine the color palette for.
 * @returns {string[]} An array of color values representing the 3D series color palette.
 * @private
 */
function get3DSeriesColor(theme) {
    var palette;
    switch (theme) {
        case 'Fabric':
            palette = ['#06DCFF', '#EF36BB', '#ffc000', '#70ad47', '#5b9bd5',
                '#c1c1c1', '#6f6fe2', '#e269ae', '#9e480e', '#997300'];
            break;
        case 'Bootstrap4':
            palette = ['#9B43F4', '#F7523F', '#55a5c2', '#7ddf1e', '#ff6ea6',
                '#7953ac', '#b99b4f', '#407c92', '#5ea716', '#b91c52'];
            break;
        case 'Bootstrap':
            palette = ['#6355C7', '#FFB400', '#55a5c2', '#7ddf1e', '#ff6ea6',
                '#7953ac', '#b99b4f', '#407c92', '#5ea716', '#b91c52'];
            break;
        case 'HighContrastLight':
        case 'HighContrast':
            palette = ['#41E4FF', '#FF5B5B', '#DFE6B6', '#C6E773', '#BA98FF',
                '#FA83C3', '#00C27A', '#43ACEF', '#D681EF', '#D8BC6E'];
            break;
        case 'MaterialDark':
            palette = ['#55C75A', '#FFB400', '#C57AFF', '#61EAA9', '#EBBB3E',
                '#F45C5C', '#8A77FF', '#63C7FF', '#FF84B0', '#F7C928'];
            break;
        case 'FabricDark':
            palette = ['#41E4FF', '#FD7400', '#ffc000', '#70ad47', '#5b9bd5',
                '#c1c1c1', '#6f6fe2', '#e269ae', '#9e480e', '#997300'];
            break;
        case 'BootstrapDark':
            palette = ['#BC43F4', '#FFC539', '#55a5c2', '#7ddf1e', '#ff6ea6',
                '#7953ac', '#b99b4f', '#407c92', '#5ea716', '#b91c52'];
            break;
        case 'Tailwind':
            palette = ['#5C43F4', '#FFB400', '#334155', '#14B8A6', '#8B5CF6',
                '#0369A1', '#F97316', '#9333EA', '#F59E0B', '#15803D'];
            break;
        case 'TailwindDark':
            palette = ['#00C2FF', '#FD7400', '#F87171', '#4ADE80', '#E879F9',
                '#FCD34D', '#F97316', '#2DD4BF', '#F472B6', '#10B981'];
            break;
        case 'Bootstrap5':
            palette = ['#6355C7', '#9B43F4', '#2196F5', '#F7523F', '#963C70',
                '#4BE0BC', '#FD7400', '#C9E422', '#DE3D8A', '#162F88'];
            break;
        case 'Bootstrap5Dark':
            palette = ['#A598FF', '#FF7E6F', '#6CBDFF', '#FF7F71', '#FF6DB3',
                '#63F5D2', '#FCAA65', '#ECFF77', '#EF8EFF', '#5F82FD'];
            break;
        case 'FluentDark':
            palette = ['#41E4FF', '#FF7E6F', '#EDBB40', '#AF4BCF', '#FF7266',
                '#1BD565', '#EE993D', '#5887FF', '#EC548D', '#7D39C0'];
            break;
        case 'Fluent':
            palette = ['#2196F5', '#FC7400', '#EDBB40', '#AF4BCF', '#FF7266',
                '#1BD565', '#EE993D', '#5887FF', '#EC548D', '#7D39C0'];
            break;
        case 'Material3':
            palette = ['#6A56FF', '#00DBFF', '#FFB400', '#F7523F', '#963C70',
                '#FD7400', '#4BE0BC', '#2196F5', '#DE3D8A', '#162F88'];
            break;
        case 'Material3Dark':
            palette = ['#00C2FF', '#FFB400', '#FFF500', '#17EA58', '#38FFE7',
                '#FF9E45', '#B3F32F', '#B93CE4', '#FC5664', '#9B55FF'];
            break;
        default:
            palette = ['#6355C7', '#00AEE0', '#357cd2', '#e56590', '#f8b883',
                '#70ad47', '#dd8abd', '#7f84e8', '#7bb4eb', '#ea7a57'];
            break;
    }
    return palette;
}

/* eslint-disable valid-jsdoc */
/* eslint-disable security/detect-unsafe-regex */
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
/**
 * Represents a 3D rendering configuration for the EJ3D rendering engine.
 *
 */
var Chart3DRender = /** @__PURE__ @class */ (function () {
    function Chart3DRender() {
        this.transform = null; // Chart3DBasicTransform
    }
    return Chart3DRender;
}());
var chart3DRender = new Chart3DRender();
/**
 * Represents a three-dimensional vector in space.
 */
var Vector3D = /** @__PURE__ @class */ (function () {
    /**
     * Constructs a new Vector3D instance.
     *
     * @constructor
     * @param {number | { x: number, y: number }} pointX - Either an object with x and y properties or the x-coordinate.
     * @param {number} [vy] - The y-coordinate (if the first parameter is a number).
     * @param {number} [vz] - The z-coordinate (if the first parameter is a number).
     */
    function Vector3D(pointX, vy, vz) {
        /** The x-coordinate of the vector. */
        this.x = 0;
        /** The y-coordinate of the vector. */
        this.y = 0;
        /** The z-coordinate of the vector. */
        this.z = 0;
        /** A small value used for epsilon comparisons to handle floating-point inaccuracies.*/
        this.epsilon = 0.00001;
        this.x = pointX;
        this.y = vy || 0;
        this.z = vz || 0;
    }
    /**
     * Checks if a vector is valid (not NaN for any component).
     *
     * @param {Chart3DVector} point - The vector to check.
     * @returns {boolean} - True if the vector is valid, false otherwise.
     */
    Vector3D.prototype.isValid = function (point) {
        return !isNaN(point.x) && !isNaN(point.y) && !isNaN(point.z);
    };
    /**
     * Creates a new Vector3D instance from provided coordinates.
     *
     * @param {number | { x: number, y: number }} vx - Either an object with x and y properties or the x-coordinate.
     * @param {number} vy - The y-coordinate.
     * @param {number} vz - The z-coordinate.
     * @returns {Chart3DVector} - The new Vector3D instance.
     */
    Vector3D.prototype.vector3D = function (vx, vy, vz) {
        this.x = vx;
        this.y = vy;
        this.z = vz;
        return { x: this.x, y: this.y, z: this.z };
    };
    /**
     * Subtracts one vector from another and returns the result.
     *
     * @param {Chart3DVector} v1 - The first vector.
     * @param {Chart3DVector} v2 - The second vector to subtract from the first.
     * @returns {Chart3DVector} - The resulting vector.
     */
    Vector3D.prototype.vector3DMinus = function (v1, v2) {
        return this.vector3D(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
    };
    /**
     * Adds two vectors and returns the result.
     *
     * @param {Chart3DVector} v1 - The first vector.
     * @param {Chart3DVector} v2 - The second vector to add to the first.
     * @returns {Chart3DVector} - The resulting vector.
     */
    Vector3D.prototype.vector3DPlus = function (v1, v2) {
        return this.vector3D(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
    };
    /**
     * Multiplies two vectors using the cross product and returns the result.
     *
     * @param {Chart3DVector} v1 - The first vector.
     * @param {Chart3DVector} v2 - The second vector.
     * @returns {Chart3DVector} - The resulting vector.
     */
    Vector3D.prototype.vector3DMultiply = function (v1, v2) {
        var x = v1.y * v2.z - v2.y * v1.z;
        var y = v1.z * v2.x - v2.z * v1.x;
        var z = v1.x * v2.y - v2.x * v1.y;
        return this.vector3D(x, y, z);
    };
    /**
     * Calculates the dot product of two vectors.
     *
     * @param {Chart3DVector} v1 - The first vector.
     * @param {Chart3DVector} v2 - The second vector.
     * @returns {number} - The dot product.
     */
    Vector3D.prototype.vector3DAdd = function (v1, v2) {
        return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
    };
    /**
     * Multiplies a vector by a scalar value.
     *
     * @param {Vector} v1 - The vector to multiply.
     * @param {number} value - The scalar value.
     * @returns {Vector} - The resulting vector.
     */
    Vector3D.prototype.vector3DStarMultiply = function (v1, value) {
        var x = v1.x * value;
        var y = v1.y * value;
        var z = v1.z * value;
        return this.vector3D(x, y, z);
    };
    /**
     * Calculates the length of a vector.
     *
     * @param {Chart3DVector} vector - The vector to calculate the length of.
     * @returns {number} - The length of the vector.
     */
    Vector3D.prototype.getLength = function (vector) {
        var sqt = this.vector3DAdd(vector, vector);
        return Math.sqrt(sqt);
    };
    /**
     * Normalizes the vector to have a length of 1.
     *
     * @returns {void}
     */
    Vector3D.prototype.normalize = function () {
        var length = this.getLength(this);
        this.x /= length;
        this.y /= length;
        this.z /= length;
    };
    /**
     * Calculates the normal vector of a triangle defined by three vectors.
     *
     * @param {Chart3DVector} v1 - The first vertex of the triangle.
     * @param {Chart3DVector} v2 - The second vertex of the triangle.
     * @param {Chart3DVector} v3 - The third vertex of the triangle.
     * @returns {Chart3DVector} - The normal vector of the triangle.
     */
    Vector3D.prototype.getNormal = function (v1, v2, v3) {
        var vector4 = this.vector3DMinus(v1, v2);
        var vector5 = this.vector3DMinus(v3, v2);
        var n = this.vector3DMultiply(vector4, vector5);
        var length = this.getLength(n);
        if (length < this.epsilon) {
            return this.vector3D(0, 0, 0);
        }
        return this.vector3D(n.x / length, n.y / length, n.z / length);
    };
    return Vector3D;
}());
/**
 * Represents a 3x3 or 4x4 matrix in 3D space and provides various matrix operations.
 *
 */
var Matrix3D = /** @__PURE__ @class */ (function () {
    function Matrix3D() {
        /** The size of the matrix, which is set to 4 by default. */
        this.matrixSize = 4;
    }
    /**
     * Creates a 3D matrix with the specified size.
     *
     * @param {number} size - The size of the matrix.
     * @returns {number[][]} - The created 3D matrix.
     */
    Matrix3D.prototype.matrix3D = function (size) {
        var matrixData = [];
        for (var i = 0; i < size; i++) {
            matrixData[i] = this.createArray(size);
        }
        return matrixData;
    };
    /**
     * Checks if a matrix is an affine matrix.
     *
     * @param {number[][]} matrixData - The matrix to check.
     * @returns {boolean} - True if the matrix is an affine matrix, false otherwise.
     */
    Matrix3D.prototype.isAffine = function (matrixData) {
        return matrixData[0][3] === 0 && matrixData[1][3] === 0 && matrixData[2][3] === 0 && matrixData[3][3] === 1;
    };
    /**
     * Creates a new array with zeros.
     *
     * @param {number} initialSize - The size of the array.
     * @returns {number[]} - The created array.
     */
    Matrix3D.prototype.createArray = function (initialSize) {
        var matrixData = [];
        for (var index = 0; index < initialSize; ++index) {
            matrixData[index] = 0;
        }
        return matrixData;
    };
    /**
     * Gets the identity matrix.
     *
     * @returns {number[][]} -The identity matrix.
     */
    Matrix3D.prototype.getIdentity = function () {
        var matrixData = this.matrix3D(this.matrixSize);
        for (var i = 0; i < this.matrixSize; i++) {
            matrixData[i][i] = 1.0;
        }
        return matrixData;
    };
    /**
     * Gets the interval of a matrix.
     *
     * @param {number[][]} matrix - The matrix to get the interval for.
     * @returns {number[][]} - The interval matrix.
     */
    Matrix3D.prototype.getInterval = function (matrix) {
        var matrixData = this.getIdentity();
        for (var i = 0; i < this.matrixSize; i++) {
            for (var j = 0; j < this.matrixSize; j++) {
                matrixData[i][j] = this.getMinor(matrix, i, j);
            }
        }
        matrixData = this.transposed(matrixData);
        matrixData = this.getMatrixMultiple(1 / this.getDeterminant(matrix), matrixData);
        return matrixData;
    };
    /**
     * Multiplies all elements of a matrix by a factor.
     *
     * @param {number} factor - The factor to multiply with.
     * @param {number[][]} matrix - The matrix to multiply.
     * @returns {number[][]} - The resulting matrix.
     */
    Matrix3D.prototype.getMatrixMultiple = function (factor, matrix) {
        for (var i = 0; i < matrix.length; i++) {
            for (var j = 0; j < matrix[i].length; j++) {
                matrix[i][j] = matrix[i][j] * factor;
            }
        }
        return matrix;
    };
    /**
     * Multiplies a matrix by a vector.
     *
     * @param {number[][]} matrix - The matrix.
     * @param {Chart3DVector} point - The vector to multiply with.
     * @returns {Chart3DVector} - The resulting vector.
     */
    Matrix3D.prototype.getMatrixVectorMultiple = function (matrix, point) {
        var x = matrix[0][0] * point.x +
            matrix[1][0] * point.y +
            matrix[2][0] * point.z +
            matrix[3][0];
        var y = matrix[0][1] * point.x +
            matrix[1][1] * point.y +
            matrix[2][1] * point.z +
            matrix[3][1];
        var z = matrix[0][2] * point.x +
            matrix[1][2] * point.y +
            matrix[2][2] * point.z +
            matrix[3][2];
        if (!this.isAffine(matrix)) {
            var c = 1 / (matrix[0][3] * point.x + matrix[1][3] * point.y + matrix[2][3] * point.z + matrix[3][3]);
            x *= c;
            y *= c;
            z *= c;
        }
        return { x: x, y: y, z: z };
    };
    /**
     * Multiplies a matrix by a vector and applies translation.
     *
     * @param {number[][]} matrix - The matrix.
     * @param {Chart3DVector} vector - The vector to multiply with.
     * @returns {Vector3D} - The resulting vector.
     */
    Matrix3D.prototype.getMatrixVectorAnd = function (matrix, vector) {
        var x = matrix[0][0] * vector.x +
            matrix[1][0] * vector.y +
            matrix[2][0] * vector.z;
        var y = matrix[0][1] * vector.x +
            matrix[1][1] * vector.y +
            matrix[2][1] * vector.z;
        var z = matrix[0][2] * vector.x +
            matrix[1][2] * vector.y +
            matrix[2][2] * vector.z;
        return new Vector3D(x, y, z);
    };
    /**
     * Multiplies two matrices.
     *
     * @param {number[][]} matrix1 - The first matrix.
     * @param {number[][]} matrix2 - The second matrix.
     * @returns {number[][]} - The resulting matrix.
     */
    Matrix3D.prototype.getMatrixMultiplication = function (matrix1, matrix2) {
        var result = this.getIdentity();
        for (var i = 0; i < this.matrixSize; i++) {
            for (var j = 0; j < this.matrixSize; j++) {
                var value = 0;
                for (var k = 0; k < this.matrixSize; k++) {
                    value += matrix1[k][j] * matrix2[i][k];
                }
                result[i][j] = value;
            }
        }
        return result;
    };
    /**
     * Gets the minor of a matrix.
     *
     * @param {number[][]} matrix - The matrix.
     * @param {number} columnIndex - The column index.
     * @param {number} rowIndex - The row index.
     * @returns {number} - The minor of the matrix.
     * @private
     */
    Matrix3D.prototype.getMinor = function (matrix, columnIndex, rowIndex) {
        return ((columnIndex + rowIndex) % 2 === 0 ? 1 : -1) * this.getDeterminant(this.getMatrix(matrix, columnIndex, rowIndex));
    };
    /**
     * Gets a submatrix of a matrix.
     *
     * @param {number[][]} matrix - The matrix.
     * @param {number} columnIndex - The column index.
     * @param {number} rowIndex - The row index.
     * @returns {number[][]} - The submatrix.
     */
    Matrix3D.prototype.getMatrix = function (matrix, columnIndex, rowIndex) {
        var count = matrix.length - 1;
        var subMatrix = this.createArray(count);
        for (var i = 0; i < count; i++) {
            var matrixColumn = i >= columnIndex ? i + 1 : i;
            subMatrix[i] = this.createArray(count);
            for (var j = 0; j < count; j++) {
                var matrixRow = j >= rowIndex ? j + 1 : j;
                subMatrix[i][j] = matrix[matrixColumn][matrixRow];
            }
        }
        return subMatrix;
    };
    /**
     * Gets the determinant of a matrix.
     *
     * @param {number[][]} matrix - The matrix.
     * @returns {number} - The determinant of the matrix.
     */
    Matrix3D.prototype.getDeterminant = function (matrix) {
        var count = matrix.length;
        var determinant = 0;
        if (count < 2) {
            determinant = matrix[0][0];
        }
        else {
            var k = 1;
            for (var i = 0; i < count; i++) {
                var submatrix = this.getMatrix(matrix, i, 0);
                determinant += k * matrix[i][0] * this.getDeterminant(submatrix);
                k = k > 0 ? -1 : 1;
            }
        }
        return determinant;
    };
    /**
     * Transforms a matrix by translation.
     *
     * @param {number} x - The x-coordinate of the translation.
     * @param {number} y - The y-coordinate of the translation.
     * @param {number} z - The z-coordinate of the translation.
     * @returns {number[][]} - The transformed matrix.
     */
    Matrix3D.prototype.transform = function (x, y, z) {
        var transformedMatrix = this.getIdentity();
        transformedMatrix[3][0] = x;
        transformedMatrix[3][1] = y;
        transformedMatrix[3][2] = z;
        return transformedMatrix;
    };
    /**
     * Creates a matrix for rotation around the y-axis.
     *
     * @param {number} angle - The angle of rotation.
     * @returns {number[][]} - The rotation matrix.
     */
    Matrix3D.prototype.turn = function (angle) {
        var rotatedMatrix = this.getIdentity();
        rotatedMatrix[0][0] = Math.cos(angle);
        rotatedMatrix[2][0] = -Math.sin(angle);
        rotatedMatrix[0][2] = Math.sin(angle);
        rotatedMatrix[2][2] = Math.cos(angle);
        return rotatedMatrix;
    };
    /**
     * Creates a matrix for rotation around the x-axis.
     *
     * @param {number} angle - The angle of rotation.
     * @returns {number[][]} - The rotation matrix.
     */
    Matrix3D.prototype.tilt = function (angle) {
        var rotatedMatrix = this.getIdentity();
        rotatedMatrix[1][1] = Math.cos(angle);
        rotatedMatrix[2][1] = Math.sin(angle);
        rotatedMatrix[1][2] = -Math.sin(angle);
        rotatedMatrix[2][2] = Math.cos(angle);
        return rotatedMatrix;
    };
    /**
     * Transposes a matrix.
     *
     * @param {number[][]} matrix3D - The matrix to transpose.
     * @returns {number[][]} - The transposed matrix.
     */
    Matrix3D.prototype.transposed = function (matrix3D) {
        var transposedMatrix = this.getIdentity();
        for (var i = 0; i < this.matrixSize; i++) {
            for (var j = 0; j < this.matrixSize; j++) {
                transposedMatrix[i][j] = matrix3D[j][i];
            }
        }
        return transposedMatrix;
    };
    return Matrix3D;
}());
/**
 * Represents a 3D chart transformation utility that provides methods for transforming
 * and projecting 3D coordinates onto a 2D screen.
 *
 */
var ChartTransform3D = /** @__PURE__ @class */ (function () {
    /**
     * Initializes a new instance of the `ChartTransform3D` class.
     */
    function ChartTransform3D() {
        /** Represents the angle conversion factor from degrees to radians. */
        this.toRadial = Math.PI / 180;
        this.vector = new Vector3D(0, 0, 0);
        this.matrixObj = new Matrix3D();
    }
    /**
     * Creates a 3D transformation based on the specified size.
     *
     * @param {Size} size - The size of the viewing area.
     * @returns {Chart3DBasicTransform} - The 3D transformation.
     */
    ChartTransform3D.prototype.transform3D = function (size) {
        return {
            viewingArea: size,
            rotation: 0,
            tilt: 0,
            depth: 0,
            perspectiveAngle: 0,
            needUpdate: true,
            centeredMatrix: this.matrixObj.getIdentity(),
            perspective: this.matrixObj.getIdentity(),
            resultMatrix: this.matrixObj.getIdentity(),
            viewMatrix: this.matrixObj.getIdentity()
        };
    };
    /**
     * Applies the specified 3D transformation to the current state.
     *
     * @param {Chart3DBasicTransform} transform - The 3D transformation to apply.
     * @returns {void} - The 3D transformation.
     */
    ChartTransform3D.prototype.transform = function (transform) {
        this.setCenter(this.vector.vector3D(transform.viewingArea.width / 2, transform.viewingArea.height / 2, transform.depth / 2), transform);
        this.setViewMatrix(this.matrixObj.transform(0, 0, transform.depth), transform);
        this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.turn(-this.toRadial * transform.rotation)), transform);
        this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.tilt(-this.toRadial * transform.tilt)), transform);
        this.updatePerspective(transform.perspectiveAngle, transform);
        transform.needUpdate = true;
    };
    /**
     * Updates the perspective matrix based on the specified angle.
     *
     * @param {number} angle - The perspective angle.
     * @param {Chart3DBasicTransform} transform - The 3D transformation.
     * @returns {void}
     */
    ChartTransform3D.prototype.updatePerspective = function (angle, transform) {
        var width = (((transform.viewingArea.width + transform.viewingArea.height) *
            Math.tan(this.degreeToRadianConverter((180 - Math.abs(angle % 181)) / 2.0))) + (transform.depth * 2) / 2);
        transform.perspective[0][0] = width;
        transform.perspective[1][1] = width;
        transform.perspective[2][3] = 1;
        transform.perspective[3][3] = width;
    };
    /**
     * Converts degrees to radians.
     *
     * @param {number} angle - The angle in degrees.
     * @returns {number} - The angle in radians.
     * @private
     */
    ChartTransform3D.prototype.degreeToRadianConverter = function (angle) {
        return angle * Math.PI / 180;
    };
    /**
     * Transforms a 3D vector to screen coordinates based on the current state.
     *
     * @param {Chart3DVector} vector3D - The 3D vector to transform.
     * @param {Chart3DBasicTransform} transform - The 3D transformation.
     * @param {Matrix3D} chartObj - Optional custom matrix object for transformation.
     * @returns {Chart3DLocation} - The screen coordinates.
     */
    ChartTransform3D.prototype.toScreen = function (vector3D, transform, chartObj) {
        if (!chartObj) {
            transform.chartObj = this.matrixObj;
            vector3D = this.matrixObj.getMatrixVectorMultiple(this.result(transform), vector3D);
        }
        else {
            this.matrixObj = chartObj;
            vector3D = chartObj.getMatrixVectorMultiple(this.result(transform, chartObj), vector3D);
        }
        return { x: vector3D.x, y: vector3D.y };
    };
    /**
     * Sets the view matrix in the transformation state.
     *
     * @param {number[][]} matrix - The new view matrix.
     * @param {Chart3DBasicTransform} transform - The 3D transformation.
     * @returns {void}
     */
    ChartTransform3D.prototype.setViewMatrix = function (matrix, transform) {
        if (transform.viewMatrix === matrix) {
            return;
        }
        transform.viewMatrix = matrix;
        transform.needUpdate = true;
    };
    /**
     * Calculates the final result matrix based on the current state.
     *
     * @param {Chart3DBasicTransform} transform - The 3D transformation.
     * @param {Matrix3D} matrixobj - Optional custom matrix object for transformation.
     * @returns {number[][]} - The final result matrix.
     */
    ChartTransform3D.prototype.result = function (transform, matrixobj) {
        var chartObj = transform.chartObj ? transform.chartObj : this.matrixObj;
        if (!chartObj) {
            chartObj = matrixobj;
        }
        if (!transform.needUpdate) {
            return transform.resultMatrix;
        }
        var matrixObj = this.matrixObj ? this.matrixObj : matrixobj;
        transform.resultMatrix = chartObj.getMatrixMultiplication(matrixObj.getInterval(transform.centeredMatrix), transform.perspective);
        transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.viewMatrix);
        transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.centeredMatrix);
        transform.needUpdate = false;
        return transform.resultMatrix;
    };
    /**
     * Sets the center in the transformation state.
     *
     * @param {Chart3DVector} center - The new center vector.
     * @param {Chart3DBasicTransform} transform - The 3D transformation.
     * @returns {void}
     */
    ChartTransform3D.prototype.setCenter = function (center, transform) {
        transform.centeredMatrix = this.matrixObj.transform(-center.x, -center.y, -center.z);
        transform.needUpdate = true;
    };
    return ChartTransform3D;
}());
/**
 * Represents a 3D graphics rendering utility for drawing and managing 3D elements in a chart.
 *
 * @__PURE__ @class
 */
var Graphics3D = /** @__PURE__ @class */ (function () {
    function Graphics3D() {
        /** The vector class. */
        this.vector = new Vector3D(0, 0, 0);
    }
    /**
     * Adds a visual polygon to the 3D chart and returns its identifier.
     *
     * @param {Polygon} polygon - The polygon to add.
     * @param {Chart3D} chart - The 3D chart.
     * @returns {number} - The identifier of the added polygon.
     */
    Graphics3D.prototype.addVisual = function (polygon, chart) {
        if (polygon == null || polygonObj.test()) {
            return -1;
        }
        return bspTreeObj.add(polygon, chart);
    };
    /**
     * Prepares the view for rendering based on specified parameters.
     *
     * @param {number} perspectiveAngle - The perspective angle.
     * @param {number} depth - The depth of the view.
     * @param {number} rotation - The rotation angle.
     * @param {number} tilt - The tilt angle.
     * @param {Size} size - The size of the viewing area.
     * @param {Chart3D} chart - The 3D chart.
     * @returns {void}
     */
    Graphics3D.prototype.prepareView = function (perspectiveAngle, depth, rotation, tilt, size, chart) {
        if (arguments.length === 0) {
            bspTreeObj.build();
        }
        else {
            if (chart3DRender.transform == null) {
                chart3DRender.transform = chart.transform3D.transform3D(size);
            }
            else {
                chart3DRender.transform.viewingArea = size;
            }
            if (!chart3DRender.tree) {
                chart3DRender.tree = [];
            }
            chart3DRender.transform.rotation = rotation;
            chart3DRender.transform.tilt = tilt;
            chart3DRender.transform.depth = depth;
            chart3DRender.transform.perspectiveAngle = perspectiveAngle;
            chart.transform3D.transform(chart3DRender.transform);
            chart3DRender.tree[chart.chart3D.id] = bspTreeObj.build();
        }
    };
    /**
     * Renders the 3D view on the specified panel element.
     *
     * @param {Element} panel - The panel element to render the view on.
     * @param {Chart3D} chart - The 3D chart.
     * @param {number} rotation - The rotation angle.
     * @param {number} tilt - The tilt angle.
     * @param {Size} size - The size of the viewing area.
     * @param {number} perspectiveAngle - The perspective angle.
     * @param {number} depth - The depth of the view.
     * @returns {void}
     */
    Graphics3D.prototype.view = function (panel, chart, rotation, tilt, size, perspectiveAngle, depth) {
        var MaxValue = 32767;
        if (arguments.length === 2) {
            if (panel == null) {
                return;
            }
            var eyeVector = this.vector.vector3D(0, 0, MaxValue);
            this.drawNode3D(chart3DRender.tree[chart.chart3D.id], eyeVector, panel, chart);
        }
        else {
            if (panel == null) {
                return;
            }
            if (chart3DRender.transform == null) {
                chart3DRender.transform = chart.transform3D.transform3D(size);
            }
            else {
                chart3DRender.transform.viewingArea = size;
            }
            chart3DRender.transform.rotation = rotation;
            chart3DRender.transform.tilt = tilt;
            chart3DRender.transform.depth = depth;
            chart3DRender.transform.perspectiveAngle = perspectiveAngle;
            chart.transform3D.transform(chart3DRender.transform);
            var eye = this.vector.vector3D(0, 0, MaxValue);
            this.drawNode3D(chart3DRender.tree[chart.chart3D.id], eye, panel, chart);
        }
    };
    /**
     * Draws a 3D element based on the specified Binary Space Partitioning Node.
     *
     * @param {Chart3DBspNode} bspElement - The Binary Space Partitioning Node representing the 3D element.
     * @param {Chart3D} chart - The 3D chart.
     * @returns {void}
     */
    Graphics3D.prototype.draw3DElement = function (bspElement, chart) {
        if (bspElement.plane.element) {
            if (bspElement.plane.element.tag === 'text' || bspElement.plane.element.tag === 'dataLabel') {
                polygonObj.drawText(bspElement.plane, chart);
            }
            else if (bspElement.plane.element.tag === 'template') {
                polygonObj.drawTemplate(bspElement.plane, chart);
            }
            else {
                polygonObj.drawLine(bspElement.plane, chart);
            }
        }
        else {
            polygonObj.draw(bspElement.plane, chart);
        }
    };
    /**
     * Draws the 3D nodes starting from the root based on the eye vector.
     *
     * @param {Chart3DBspNode} bspElement - The root Binary Space Partitioning Node.
     * @param {Chart3DVector} eyeVector - The eye vector.
     * @param {Element} panel - The panel element to render the view on.
     * @param {Chart3D} chart - The 3D chart.
     * @returns {void}
     */
    Graphics3D.prototype.drawNode3D = function (bspElement, eyeVector, panel, chart) {
        if (bspElement === null || chart3DRender.transform == null) {
            return;
        }
        while (true) {
            var r = vector.vector3DAdd(polygonObj.getNormal(chart.transform3D.result(chart3DRender.transform), bspElement.plane.vectorPoints), eyeVector);
            if (r > bspElement.plane.d) {
                if (bspElement.front != null) {
                    this.drawNode3D(bspElement.front, eyeVector, panel, chart);
                }
                this.draw3DElement(bspElement, chart);
                if (bspElement.back != null) {
                    bspElement = bspElement.back;
                    continue;
                }
            }
            else {
                if (bspElement.back != null) {
                    this.drawNode3D(bspElement.back, eyeVector, panel, chart);
                }
                this.draw3DElement(bspElement, chart);
                if (bspElement.front != null) {
                    bspElement = bspElement.front;
                    continue;
                }
            }
            break;
        }
    };
    return Graphics3D;
}());
/**
 * Represents a binary tree builder for 3D polygons in a chart.
 *
 */
var BinaryTreeBuilder = /** @__PURE__ @class */ (function () {
    function BinaryTreeBuilder(chart) {
        /** A small value used for epsilon comparisons to handle floating-point inaccuracies.*/
        this.epsilon = 0.0005;
        this.chart = chart;
    }
    /**
     * Adds a polygon to the binary tree and returns its index.
     *
     * @param {Polygon} polygon - The polygon to add.
     * @param {Chart3D} chart - The 3D chart.
     * @returns {number} - The index of the added polygon.
     */
    BinaryTreeBuilder.prototype.add = function (polygon, chart) {
        this.chart = chart;
        chart.polygons.push(polygon);
        return chart.polygons.length - 1;
    };
    /**
     * Gets the next index considering the array length and the current index.
     *
     * @param {number} index - The current index.
     * @param {number} count - The length of the array.
     * @returns {number} - The next index.
     */
    BinaryTreeBuilder.prototype.getNext = function (index, count) {
        if (index >= count) {
            return index - count;
        }
        if (index < 0) {
            return index + count;
        }
        return index;
    };
    /**
     * Creates a PolyAttributes object based on the vector, index, and result.
     *
     * @param {Vector} point - The vector representing the point.
     * @param {number} index - The index of the point.
     * @param {string} result - The result classification.
     * @returns {Chart3DPolyAttributes} - The created PolyAttributes object.
     */
    BinaryTreeBuilder.prototype.vector3DIndexClassification = function (point, index, result) {
        return {
            index: index,
            result: result,
            vector: point,
            isCuttingBackPoint: false,
            cuttingBackPairIndex: null,
            alreadyCutBack: false,
            isCuttingFrontPoint: false,
            cuttingFrontPairIndex: null,
            alreadyCutFront: false
        };
    };
    /**
     * Classifies a point relative to a polygon.
     *
     * @param {Chart3DVector} point - The point to classify.
     * @param {Chart3DPolygon} polygon - The polygon for classification.
     * @returns {string} - The classification result ('OnPlane', 'OnBack', 'OnFront').
     */
    BinaryTreeBuilder.prototype.classifyPoint = function (point, polygon) {
        var result = 'OnPlane';
        var signedDistance = -polygon.d - vector.vector3DAdd(point, polygon.normal);
        if (signedDistance > this.epsilon) {
            result = 'OnBack';
        }
        else if (signedDistance < -this.epsilon) {
            result = 'OnFront';
        }
        return result;
    };
    /**
     * Classifies a polygon relative to another polygon.
     *
     * @param {Chart3DPolygon} refPolygon - The reference polygon.
     * @param {Chart3DPolygon} classPolygon - The polygon to classify.
     * @returns {string} - The classification result ('OnPlane', 'ToRight', 'ToLeft', 'Unknown').
     */
    BinaryTreeBuilder.prototype.classifyPolygon = function (refPolygon, classPolygon) {
        var result = 'Unknown';
        var points = classPolygon.points;
        if (points == null) {
            return result;
        }
        var onBack = 0;
        var onFront = 0;
        var onPlane = 0;
        var normal = refPolygon.normal;
        var polygonValue = refPolygon.d;
        for (var i = 0, len = points.length; i < len; i++) {
            var value = -polygonValue - vector.vector3DAdd(points[i], normal);
            if (value > this.epsilon) {
                onBack++;
            }
            else if (value < -this.epsilon) {
                onFront++;
            }
            else {
                onPlane++;
            }
            if (onBack > 0 && onFront > 0) {
                break;
            }
        }
        if (onPlane === points.length) {
            result = 'OnPlane';
        }
        else if (onFront + onPlane === points.length) {
            result = 'ToRight';
        }
        else if (onBack + onPlane === points.length) {
            result = 'ToLeft';
        }
        else {
            result = 'Unknown';
        }
        return result;
    };
    /**
     * Splits a polygon into two parts based on another polygon.
     *
     * @param {Chart3DPolygon} splitPolygon - The polygon to split.
     * @param {Chart3DPolygon} refPolygon - The reference polygon for splitting.
     * @returns {PolyCollections} - The resulting back and front parts.
     */
    BinaryTreeBuilder.prototype.splitPolygon = function (splitPolygon, refPolygon) {
        var backPoint = [];
        var frontPoint = [];
        if (splitPolygon.points != null) {
            var polyPoints = [];
            var backPartPoints = [];
            var frontPartPoints = [];
            var outputs = void 0;
            var inputs = void 0;
            var count = splitPolygon.points.length;
            for (var i = 0; i < count; i++) {
                var pointB = splitPolygon.points[i];
                var pointC = splitPolygon.points[this.getNext(i + 1, count)];
                var sideB = this.classifyPoint(pointB, refPolygon);
                var sideC = this.classifyPoint(pointC, refPolygon);
                var attributeB = this.vector3DIndexClassification(pointB, polyPoints.length, sideB);
                polyPoints.push(attributeB);
                if (sideB !== sideC && sideB !== 'OnPlane' && sideC !== 'OnPlane') {
                    var vectorValue = vector.vector3DMinus(pointB, pointC);
                    var direction = vector.vector3DMinus(vector.vector3DStarMultiply(refPolygon.normal, -refPolygon.d), pointC);
                    var signedDistance = vector.vector3DAdd(direction, refPolygon.normal);
                    var intersectionParameter = signedDistance / vector.vector3DAdd(refPolygon.normal, vectorValue);
                    var intersectionPoint = vector.vector3DPlus(pointC, vector.vector3DStarMultiply(vectorValue, intersectionParameter));
                    var attributeIntersection = this.vector3DIndexClassification(intersectionPoint, polyPoints.length, 'OnPlane');
                    polyPoints.push(attributeIntersection);
                    backPartPoints.push(attributeIntersection);
                    frontPartPoints.push(attributeIntersection);
                }
                else if (sideB === 'OnPlane') {
                    var pointA = splitPolygon.points[this.getNext(i - 1, count)];
                    var sideA = this.classifyPoint(pointA, refPolygon);
                    if (sideA === sideC) {
                        continue;
                    }
                    if (sideA !== 'OnPlane' && sideC !== 'OnPlane') {
                        backPartPoints.push(attributeB);
                        frontPartPoints.push(attributeB);
                    }
                    else if (sideA === 'OnPlane') {
                        switch (sideC) {
                            case 'OnBack':
                                backPartPoints.push(attributeB);
                                break;
                            case 'OnFront':
                                frontPartPoints.push(attributeB);
                                break;
                        }
                    }
                    else if (sideC === 'OnPlane') {
                        switch (sideA) {
                            case 'OnBack':
                                backPartPoints.push(attributeB);
                                break;
                            case 'OnFront':
                                frontPartPoints.push(attributeB);
                                break;
                        }
                    }
                }
            }
            if (frontPartPoints.length !== 0 || backPartPoints.length !== 0) {
                for (var i = 0; i < backPartPoints.length - 1; i += 2) {
                    var backAttribute1 = backPartPoints[i];
                    var backAttribute2 = backPartPoints[i + 1];
                    backAttribute1.cuttingBackPoint = true;
                    backAttribute2.cuttingBackPoint = true;
                    backAttribute1.alterCuttingBackPairIndex = backAttribute2.index;
                    backAttribute2.alterCuttingBackPairIndex = backAttribute1.index;
                }
                for (var i = 0; i < frontPartPoints.length - 1; i += 2) {
                    var frontAttribute1 = frontPartPoints[i];
                    var frontAttribute2 = frontPartPoints[i + 1];
                    frontAttribute1.cuttingFrontPoint = true;
                    frontAttribute2.cuttingFrontPoint = true;
                    frontAttribute1.alterCuttingFrontPairIndex = frontAttribute2.index;
                    frontAttribute2.alterCuttingFrontPairIndex = frontAttribute1.index;
                }
                for (var i = 0; i < backPartPoints.length - 1; i++) {
                    var backAttribute1 = backPartPoints[i];
                    if (backAttribute1.alreadyCutBack) {
                        continue;
                    }
                    outputs = this.cutOutBackPolygon(polyPoints, backAttribute1);
                    if (outputs.length > 2) {
                        var polygon1 = polygonObj.polygon3D(outputs, splitPolygon);
                        backPoint.push(__assign({}, polygon1));
                    }
                }
                for (var i = 0; i < frontPartPoints.length - 1; i++) {
                    var backAttribute2 = frontPartPoints[i];
                    if (backAttribute2.alreadyCutFront) {
                        continue;
                    }
                    inputs = this.cutOutFrontPolygon(polyPoints, backAttribute2);
                    if (inputs.length > 2) {
                        var polygon2 = polygonObj.polygon3D(inputs, splitPolygon);
                        frontPoint.push(__assign({}, polygon2));
                    }
                }
            }
        }
        else {
            backPoint.push(splitPolygon);
            frontPoint.push(splitPolygon);
        }
        return { backPolygon: backPoint, frontPolygon: frontPoint };
    };
    /**
     * Cuts out the front part of a polygon based on the PolyAttributes.
     *
     * @param {Chart3DPolyAttributes[]} polyPoints - The PolyAttributes array of the polygon.
     * @param {Chart3DPolyAttributes} initialVertex - The PolyAttributes representing the cutting point.
     * @returns {Chart3DVector[]} - The resulting points of the front part.
     */
    BinaryTreeBuilder.prototype.cutOutFrontPolygon = function (polyPoints, initialVertex) {
        var points = [];
        var currentVertex = initialVertex;
        while (true) {
            currentVertex.alreadyCutFront = true;
            points.push(currentVertex.vector);
            var currentVertexPair = polyPoints[currentVertex.alterCuttingFrontPairIndex];
            if (currentVertex.cuttingFrontPoint) {
                if (!currentVertexPair.alreadyCutFront) {
                    currentVertex = currentVertexPair;
                }
                else {
                    var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];
                    var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];
                    if (previousVertexOnBack.result === 'OnFront' && !previousVertexOnBack.alreadyCutFront) {
                        currentVertex = previousVertexOnBack;
                    }
                    else if (nextVertexOnBack.result === 'OnFront' && !nextVertexOnBack.alreadyCutFront) {
                        currentVertex = nextVertexOnBack;
                    }
                    else {
                        return points;
                    }
                }
            }
            else {
                var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];
                var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];
                if (previousVertexOnBack.result !== 'OnBack' && !previousVertexOnBack.alreadyCutFront) {
                    currentVertex = previousVertexOnBack;
                }
                else if (nextVertexOnBack.result !== 'OnBack' && !nextVertexOnBack.alreadyCutFront) {
                    currentVertex = nextVertexOnBack;
                }
                else {
                    return points;
                }
            }
        }
    };
    /**
     * Cuts out the back part of a polygon based on the PolyAttributes.
     *
     * @param {Chart3DPolyAttributes[]} polyPoints - The PolyAttributes array of the polygon.
     * @param {PChart3DPolyAttributes} initialVertex - The PolyAttributes representing the cutting point.
     * @returns {Chart3DVector[]} - The resulting points of the back part.
     */
    BinaryTreeBuilder.prototype.cutOutBackPolygon = function (polyPoints, initialVertex) {
        var points = [];
        var currentVertex = initialVertex;
        while (true) {
            currentVertex.alreadyCutBack = true;
            points.push(currentVertex.vector);
            var currentVertexPair = polyPoints[currentVertex.alterCuttingBackPairIndex];
            if (currentVertex.cuttingBackPoint) {
                if (!currentVertexPair.alreadyCutBack) {
                    currentVertex = currentVertexPair;
                }
                else {
                    var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];
                    var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];
                    if (previousVertexOnBack.result === 'OnBack' && !previousVertexOnBack.alreadyCutBack) {
                        currentVertex = previousVertexOnBack;
                    }
                    else if (nextVertexOnBack.result === 'OnBack' && !nextVertexOnBack.alreadyCutBack) {
                        currentVertex = nextVertexOnBack;
                    }
                    else {
                        return points;
                    }
                }
            }
            else {
                var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];
                var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];
                if (previousVertexOnBack.result !== 'OnFront' && !previousVertexOnBack.alreadyCutBack) {
                    currentVertex = previousVertexOnBack;
                }
                else if (nextVertexOnBack.result !== 'OnFront' && !nextVertexOnBack.alreadyCutBack) {
                    currentVertex = nextVertexOnBack;
                }
                else {
                    return points;
                }
            }
        }
    };
    /**
     * Builds a Binary Space Partitioning from a list of polygons.
     *
     * @param {Chart3DPolygon[]} [points] - The list of polygons to build the tree from.
     * @returns {Chart3DBspNode} - The root node of the Binary Space Partitioning tree.
     */
    BinaryTreeBuilder.prototype.build = function (points) {
        if (!arguments[0]) {
            return this.build(this.chart.polygons);
        }
        else {
            var inputPolygons = arguments[0];
            if (inputPolygons.length < 1) {
                return null;
            }
            var bspNode = { back: null, front: null, plane: null };
            var plane = inputPolygons[0];
            bspNode.plane = plane;
            var polygonsToLeft = [];
            var polygonsToRight = [];
            for (var i = 1, len = inputPolygons.length; i < len; i++) {
                var currentPolygon = inputPolygons[i];
                if (currentPolygon === plane) {
                    continue;
                }
                var classificationResult = this.classifyPolygon(plane, currentPolygon);
                switch (classificationResult) {
                    case 'OnPlane':
                    case 'ToRight':
                        polygonsToRight.push(currentPolygon);
                        break;
                    case 'ToLeft':
                        polygonsToLeft.push(currentPolygon);
                        break;
                    case 'Unknown':
                        if (currentPolygon.element && (currentPolygon.element.tag === 'line' || currentPolygon.element.tag === 'text')) {
                            polygonsToLeft.push(currentPolygon);
                        }
                        else {
                            var result = this.splitPolygon(currentPolygon, plane);
                            for (var k = 0; k < result.backPolygon.length; k++) {
                                result.backPolygon[k].name = result.backPolygon[k].name + '-back';
                                polygonsToLeft.push(result.backPolygon[k]);
                            }
                            for (var j = 0; j < result.frontPolygon.length; j++) {
                                result.frontPolygon[j].name = result.frontPolygon[j].name + '-front';
                                polygonsToRight.push(result.frontPolygon[j]);
                            }
                        }
                        break;
                }
            }
            if (polygonsToLeft.length > 0) {
                bspNode.back = this.build(polygonsToLeft);
            }
            if (polygonsToRight.length > 0) {
                bspNode.front = this.build(polygonsToRight);
            }
            return bspNode;
        }
    };
    return BinaryTreeBuilder;
}());
/**
 * The Svg3DRenderer class provides methods for rendering SVG graphics in a 3D context.
 */
var Svg3DRenderer = /** @__PURE__ @class */ (function () {
    function Svg3DRenderer() {
    }
    /**
     * Gets a Chart3DStringBuilder instance for constructing strings.
     *
     * @returns {Chart3DStringBuilder} - The StringBuilder instance.
     */
    Svg3DRenderer.prototype.getStringBuilder = function () {
        var data = [];
        var counter = 0;
        return {
            append: function (text) {
                data[counter++] = text;
                return this;
            },
            remove: function (i, j) {
                data.splice(i, j || 1);
                return this;
            },
            insert: function (i, text) {
                data.splice(i, 0, text);
                return this;
            },
            toString: function (text) {
                return data.join(text || '');
            }
        };
    };
    /**
     * Parses a hex color code and returns its Red green Blue values.
     *
     * @param {string} hexColorCode - The hex color code.
     * @returns {Chart3DColorFormat | null} - The parsed color format (Red green Blue) or null if parsing fails.
     */
    Svg3DRenderer.prototype.hexToValue = function (hexColorCode) {
        var rgbRegex = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/.test(hexColorCode);
        var result;
        if (rgbRegex === true) {
            result = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/.exec(hexColorCode);
            return result
                ? {
                    red: parseInt(result[1], 10),
                    green: parseInt(result[2], 10),
                    blue: parseInt(result[3], 10),
                    alpha: result[4]
                }
                : null;
        }
        else {
            result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexColorCode);
            return result
                ? {
                    red: parseInt(result[1], 16),
                    green: parseInt(result[2], 16),
                    blue: parseInt(result[3], 16)
                }
                : null;
        }
    };
    /**
     * Converts a Chart3DColorFormat object to its corresponding color string.
     *
     * @param {Chart3DColorFormat} color - The color in Chart3DColorFormat.
     * @returns {string} - The color string representation.
     */
    Svg3DRenderer.prototype.hexColor = function (color) {
        var redValue = color.red;
        var greenValue = color.green;
        var blueValue = color.blue;
        if (color.alpha) {
            var returnColor = "rgba(" + redValue.toString() + "," + greenValue.toString() + "," + blueValue.toString() + "," + color.alpha + ")";
            return returnColor;
        }
        else {
            var hex_1 = [redValue.toString(16), greenValue.toString(16), blueValue.toString(16)];
            hex_1.forEach(function (val, nr) {
                if (val.length === 1) {
                    hex_1[nr] = '0' + val;
                }
            });
            return '#' + hex_1.join('').toUpperCase();
        }
    };
    /**
     * Checks if a given color string is in a valid format (hex or rgba).
     *
     * @param {string} color - The color string to check.
     * @returns {boolean} - True if the color string is valid, otherwise false.
     */
    Svg3DRenderer.prototype.checkColorFormat = function (color) {
        var regex = /(rgba?\((?:\d{1,3}[,\)]){3}(?:\d+\.\d+\))?)|(^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$)/gmi.test(color);
        return regex;
    };
    /**
     * Converts a color name to its corresponding hex color code.
     *
     * @param {string} colour - The color name.
     * @returns {string} - The hex color code.
     */
    Svg3DRenderer.prototype.colorNameToHex = function (colour) {
        var colors = {
            'aliceblue': '#f0f8ff', 'antiquewhite': '#faebd7', 'aqua': '#00ffff', 'aquamarine': '#7fffd4', 'azure': '#f0ffff',
            'beige': '#f5f5dc', 'bisque': '#ffe4c4', 'black': '#000000', 'blanchedalmond': '#ffebcd', 'blue': '#0000ff', 'blueviolet': '#8a2be2', 'brown': '#a52a2a', 'burlywood': '#deb887',
            'cadetblue': '#5f9ea0', 'chartreuse': '#7fff00', 'chocolate': '#d2691e', 'coral': '#ff7f50', 'cornflowerblue': '#6495ed', 'cornsilk': '#fff8dc', 'crimson': '#dc143c', 'cyan': '#00ffff',
            'darkblue': '#00008b', 'darkcyan': '#008b8b', 'darkgoldenrod': '#b8860b', 'darkgray': '#a9a9a9', 'darkgreen': '#006400', 'darkkhaki': '#bdb76b', 'darkmagenta': '#8b008b', 'darkolivegreen': '#556b2f',
            'darkorange': '#ff8c00', 'darkorchid': '#9932cc', 'darkred': '#8b0000', 'darksalmon': '#e9967a', 'darkseagreen': '#8fbc8f', 'darkslateblue': '#483d8b', 'darkslategray': '#2f4f4f', 'darkturquoise': '#00ced1',
            'darkviolet': '#9400d3', 'deeppink': '#ff1493', 'deepskyblue': '#00bfff', 'dimgray': '#696969', 'dodgerblue': '#1e90ff',
            'firebrick': '#b22222', 'floralwhite': '#fffaf0', 'forestgreen': '#228b22', 'fuchsia': '#ff00ff',
            'gainsboro': '#dcdcdc', 'ghostwhite': '#f8f8ff', 'gold': '#ffd700', 'goldenrod': '#daa520', 'gray': '#808080', 'green': '#008000', 'greenyellow': '#adff2f',
            'honeydew': '#f0fff0', 'hotpink': '#ff69b4',
            'indianred': '#cd5c5c', 'indigo': '#4b0082', 'ivory': '#fffff0', 'khaki': '#f0e68c',
            'lavender': '#e6e6fa', 'lavenderblush': '#fff0f5', 'lawngreen': '#7cfc00', 'lemonchiffon': '#fffacd', 'lightblue': '#add8e6', 'lightcoral': '#f08080', 'lightcyan': '#e0ffff', 'lightgoldenrodyellow': '#fafad2',
            'lightgrey': '#d3d3d3', 'lightgreen': '#90ee90', 'lightpink': '#ffb6c1', 'lightsalmon': '#ffa07a', 'lightseagreen': '#20b2aa', 'lightskyblue': '#87cefa', 'lightslategray': '#778899', 'lightsteelblue': '#b0c4de',
            'lightyellow': '#ffffe0', 'lime': '#00ff00', 'limegreen': '#32cd32', 'linen': '#faf0e6',
            'magenta': '#ff00ff', 'maroon': '#800000', 'mediumaquamarine': '#66cdaa', 'mediumblue': '#0000cd', 'mediumorchid': '#ba55d3', 'mediumpurple': '#9370d8', 'mediumseagreen': '#3cb371', 'mediumslateblue': '#7b68ee',
            'mediumspringgreen': '#00fa9a', 'mediumturquoise': '#48d1cc', 'mediumvioletred': '#c71585', 'midnightblue': '#191970', 'mintcream': '#f5fffa', 'mistyrose': '#ffe4e1', 'moccasin': '#ffe4b5',
            'navajowhite': '#ffdead', 'navy': '#000080',
            'oldlace': '#fdf5e6', 'olive': '#808000', 'olivedrab': '#6b8e23', 'orange': '#ffa500', 'orangered': '#ff4500', 'orchid': '#da70d6',
            'palegoldenrod': '#eee8aa', 'palegreen': '#98fb98', 'paleturquoise': '#afeeee', 'palevioletred': '#d87093', 'papayawhip': '#ffefd5', 'peachpuff': '#ffdab9', 'peru': '#cd853f', 'pink': '#ffc0cb', 'plum': '#dda0dd', 'powderblue': '#b0e0e6', 'purple': '#800080',
            'red': '#ff0000', 'rosybrown': '#bc8f8f', 'royalblue': '#4169e1',
            'saddlebrown': '#8b4513', 'salmon': '#fa8072', 'sandybrown': '#f4a460', 'seagreen': '#2e8b57', 'seashell': '#fff5ee', 'sienna': '#a0522d', 'silver': '#c0c0c0', 'skyblue': '#87ceeb', 'slateblue': '#6a5acd', 'slategray': '#708090', 'snow': '#fffafa', 'springgreen': '#00ff7f', 'steelblue': '#4682b4',
            'tan': '#d2b48c', 'teal': '#008080', 'thistle': '#d8bfd8', 'tomato': '#ff6347', 'turquoise': '#40e0d0',
            'violet': '#ee82ee',
            'wheat': '#f5deb3', 'white': '#ffffff', 'whitesmoke': '#f5f5f5',
            'yellow': '#ffff00', 'yellowgreen': '#9acd32'
        };
        if (Array.isArray(colour)) {
            return colour;
        }
        var lowerCaseColor = colour.toLowerCase();
        if (colors[lowerCaseColor]) {
            return colors[lowerCaseColor];
        }
        return colour;
    };
    /**
     * Draws text on an SVG element.
     *
     * @param {any} options - The options for drawing the text.
     * @param {string | string[]} label - The text label.
     * @param {FontModel} font - The font settings for the text.
     * @param {Chart3D} chart - The 3D chart instance.
     * @returns {Element} - The created SVG text element.
     */
    Svg3DRenderer.prototype.drawText = function (options, label, font, chart) {
        var text = document.getElementById(options.id);
        if (text === null) {
            text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        }
        if (label.length > 1 && typeof label !== 'string') {
            var dy = 0;
            for (var i = 0; i < label.length; i++) {
                var tspanElement = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                tspanElement.textContent = label[i];
                tspanElement.setAttribute('x', String(options.x));
                tspanElement.setAttribute('dy', String(dy));
                text.appendChild(tspanElement);
                dy = measureText(label[i], font, chart.themeStyle.axisLabelFont).height;
            }
        }
        else {
            text.textContent = label;
        }
        text = chart.svgRenderer.setElementAttributes(options, text);
        return text;
    };
    /**
     * Transforms 3D coordinates to visible 2D coordinates on the chart.
     *
     * @param {Chart3DSeries} currentSeries - The current 3D series.
     * @param {number} x - The x-coordinate in 3D space.
     * @param {number} y - The y-coordinate in 3D space.
     * @param {Chart3D} chart - The 3D chart instance.
     * @returns {Chart3DLocation} - The transformed 2D coordinates.
     */
    Svg3DRenderer.prototype.transform3DToVisible = function (currentSeries, x, y, chart) {
        if (currentSeries.xAxis != null && currentSeries.yAxis != null) {
            var valueType = currentSeries.xAxis.valueType;
            var xlogarithmicBase = 10; // Replace with the actual logarithmic base if needed
            var xIsLogarithmic = valueType === 'Logarithmic';
            // Apply logarithmic transformation if necessary
            if (xIsLogarithmic && x > 0) {
                x = Math.log(x) / Math.log(xlogarithmicBase);
            }
            var ylogarithmicBase = currentSeries.yAxis.logBase;
            var yIsLogarithmic = currentSeries.yAxis.valueType === 'Logarithmic';
            // Apply logarithmic transformation if necessary
            if (yIsLogarithmic && y > 0) {
                y = Math.log(y) / Math.log(ylogarithmicBase);
            }
            // Adjust the coordinates based on inverted axes
            if (chart.requireInvertedAxis) {
                var left = chart.chartAxisLayoutPanel.seriesClipRect.x;
                var top_1 = chart.chartAxisLayoutPanel.seriesClipRect.y;
                var pointX = left + currentSeries.yAxis.rect.width * valueToCoefficients(y, currentSeries.yAxis);
                var pointY = top_1 + currentSeries.xAxis.rect.height * (1 - valueToCoefficients(x, currentSeries.xAxis));
                return { x: pointX, y: pointY };
            }
            else {
                var left = currentSeries.xAxis.rect.x;
                var top_2 = currentSeries.yAxis.rect.y;
                var newX = left + Math.round(currentSeries.xAxis.rect.width * valueToCoefficients(x, currentSeries.xAxis));
                var newY = top_2 + Math.round(currentSeries.yAxis.rect.height * (1 - valueToCoefficients(y, currentSeries.yAxis)));
                return { x: newX, y: newY };
            }
        }
        // Return a default Point if xAxis and yAxis are null
        return { x: 0, y: 0 };
    };
    return Svg3DRenderer;
}());
/**
 * Represents a 3D polygon in a chart.
 *
 */
var Polygon3D = /** @__PURE__ @class */ (function () {
    function Polygon3D() {
        /** A small constant used for numerical comparisons. */
        this.epsilon = 0.00001;
        /** A small constant used for numerical comparisons. */
        this.normal = { x: 0, y: 0, z: 0 };
        /** A small constant used for numerical comparisons. */
        this.vector = new Vector3D(0, 0, 0);
        /** A small constant used for numerical comparisons. */
        this.vectorPoints = [];
        /** A small constant used for numerical comparisons. */
        this.matrixObj = new Matrix3D();
    }
    /**
     * Creates a 3D polygon.
     *
     * @param {Chart3DVector[]} [points] - An array of 3D vectors representing points on the polygon.
     * @param {any} [tag] - Additional information or metadata for the polygon.
     * @param {number} [index] - An index associated with the polygon.
     * @param {string} [stroke] - The stroke color of the polygon.
     * @param {number} [strokeThickness] - The thickness of the polygon's stroke.
     * @param {number} [opacity] - The opacity of the polygon.
     * @param {string} [fill] - The fill color of the polygon.
     * @param {string} [name] - The name or identifier of the polygon.
     * @param {Element} [parent] - The parent element to which the polygon belongs.
     * @param {string} [text] - Additional text associated with the polygon.
     * @returns {Chart3DPolygon} - Returns the created polygon.
     */
    Polygon3D.prototype.polygon3D = function (points, tag, index, stroke, strokeThickness, opacity, fill, name, parent, text) {
        if (arguments.length === 3) {
            this.calculateNormal(arguments[0], arguments[1], arguments[2]);
            return null;
        }
        else if (arguments.length === 2) {
            points = arguments[0];
            this.calculateNormal(points[0], points[1], points[2]);
            this.vectorPoints = points;
            this.calculateNormal(this.vectorPoints);
            var polygon = arguments[1];
            polygon.normal = this.normal;
            polygon.points = points;
            polygon.vectorPoints = this.vectorPoints;
            polygon.isSplit = true;
            polygon.d = this.d;
            return polygon;
        }
        else {
            this.calculateNormal(points[0], points[1], points[2]);
            this.vectorPoints = points;
            this.calculateNormal(this.vectorPoints);
            var element = { tag: 'path', parent: parent };
            var polygon = {
                normal: this.normal,
                points: points,
                vectorPoints: this.vectorPoints,
                index: index,
                tag: tag,
                name: name ? name : null,
                strokeThickness: strokeThickness,
                opacity: opacity,
                fill: fill,
                d: this.d,
                text: text ? text : '',
                polygonElement: element
            };
            if (arguments.length !== 1) {
                polygon.polygonElement = element;
            }
            return polygon;
        }
    };
    /**
     * Creates a 3D line.
     *
     * @param {Chart3DTickElement} line - The tick elements associated with the line.
     * @param {number} x1 - The x-coordinate of the starting point.
     * @param {number} y1 - The y-coordinate of the starting point.
     * @param {number} x2 - The x-coordinate of the ending point.
     * @param {number} y2 - The y-coordinate of the ending point.
     * @param {number} depth - The depth or z-coordinate of the line in 3D space.
     * @returns {Chart3DPolygon} - Returns the created 3D line as a polygon.
     */
    Polygon3D.prototype.createLine = function (line, x1, y1, x2, y2, depth) {
        var strokeThickness = line.width;
        var vectorCollection = [];
        vectorCollection[0] = this.vector.vector3D(x1, y1, depth);
        vectorCollection[1] = this.vector.vector3D(x1 + strokeThickness, y2 + strokeThickness, depth);
        vectorCollection[2] = this.vector.vector3D(x2, y2, depth);
        return this.line3D(line, vectorCollection);
    };
    /**
     *  Creates a 3D line polygon based on the given tick elements and points.
     *
     * @param {Chart3DTickElement} element - The tick elements associated with the line.
     * @param {Chart3DVector[]} points - The array of 3D vector points defining the line in 3D space.
     * @returns {Chart3DPolygon} - Returns the created 3D line polygon.
     */
    Polygon3D.prototype.line3D = function (element, points) {
        var plane = this.polygon3D(points);
        plane.element = element;
        return plane;
    };
    /**
     * Creates a 3D text polygon based on the given label element and points.
     *
     * @param {Chart3DLabelElement} element - The label element associated with the text.
     * @param {Chart3DVector[]} points - The array of 3D vector points defining the position of the text in 3D space.
     * @returns {Polygon} - Returns the created 3D text polygon.
     */
    Polygon3D.prototype.text3D = function (element, points) {
        var plane = this.polygon3D(points);
        plane.element = element;
        return plane;
    };
    /**
     * Creates a 3D cylinder based on the given vectors, chart, and styling parameters.
     *
     * @param {Chart3DVector} v1 - The start vector of the cylinder.
     * @param {Chart3DVector} v2 - The end vector of the cylinder.
     * @param {Chart3D} chart - The 3D chart to which the cylinder belongs.
     * @param {number} index - The index of the cylinder.
     * @param {string} type - The type of the cylinder.
     * @param {string} stroke - The stroke color of the cylinder.
     * @param {string} fill - The fill color of the cylinder.
     * @param {number} strokeThickness - The thickness of the stroke.
     * @param {number} opacity - The opacity of the cylinder.
     * @param {string} name - The name of the cylinder.
     * @param {Element} parent - The parent element of the cylinder.
     * @returns {Polygon[]} - Returns an array of polygons representing the 3D cylinder.
     */
    Polygon3D.prototype.createCylinder = function (v1, //top left front vecotr.
    v2, // bottom right back vector.
    chart, index, type, stroke, fill, strokeThickness, opacity, name, parent) {
        var i = 0; //cylinder path count.
        var offsetX;
        var offsetY;
        var offsetZ;
        var vectorCollection;
        var pathCount = 24;
        var theta = 360 / pathCount;
        var degreeToRadian$$1 = Math.PI / 180;
        var centerZ = (v1.z + v2.z) / 2;
        var result = [];
        var outPoints = [];
        var topVector = [];
        var bottomVector = [];
        var radiusB = (v2.y - v1.y) < (v2.z - v1.z) ? (v2.y - v1.y) / 2 : (v2.z - v1.z) / 2;
        var radiusC = (v2.x - v1.x) < (v2.z - v1.z) ? (v2.x - v1.x) / 2 : (v2.z - v1.z) / 2;
        var centerX = (v1.x + v2.x) / 2;
        var centerY = (v1.y + v2.y) / 2;
        switch (type) {
            case 'Bar':
            case 'StackingBar':
            case 'StackingBar100':
                pathCount++;
                while (pathCount--) {
                    offsetY = centerY + radiusB * Math.cos((i * theta) * degreeToRadian$$1);
                    offsetZ = centerZ + radiusB * Math.sin((i * theta) * degreeToRadian$$1);
                    outPoints[i] = { Y: offsetY, Z: offsetZ };
                    topVector.push(this.vector.vector3D(v1.x, outPoints[i].Y, outPoints[i].Z));
                    bottomVector.push(this.vector.vector3D(v2.x, outPoints[i].Y, outPoints[i].Z));
                    if (i > 0) {
                        vectorCollection = [
                            this.vector.vector3D(v1.x, outPoints[i - 1].Y, outPoints[i - 1].Z),
                            this.vector.vector3D(v2.x, outPoints[i - 1].Y, outPoints[i - 1].Z),
                            this.vector.vector3D(v2.x, outPoints[i].Y, outPoints[i].Z),
                            this.vector.vector3D(v1.x, outPoints[i].Y, outPoints[i].Z)
                        ];
                        result[i + 1] = this.polygon3D(vectorCollection, chart, index, fill, 0, opacity, fill, ('-' + (i + 1).toString() + '-' + name), parent);
                        graphics.addVisual(result[i + 1], chart);
                    }
                    i++;
                }
                break;
            case 'Column':
            case 'StackingColumn':
            case 'StackingColumn100':
                pathCount++;
                while (pathCount--) {
                    offsetX = centerX + radiusC * Math.cos((i * theta) * degreeToRadian$$1);
                    offsetZ = centerZ + radiusC * Math.sin((i * theta) * degreeToRadian$$1);
                    outPoints[i] = { Y: offsetX, Z: offsetZ };
                    topVector.push(this.vector.vector3D(outPoints[i].Y, v1.y, outPoints[i].Z));
                    bottomVector.push(this.vector.vector3D(outPoints[i].Y, v2.y, outPoints[i].Z));
                    if (i > 0) {
                        vectorCollection = [
                            this.vector.vector3D(outPoints[i - 1].Y, v1.y, outPoints[i - 1].Z),
                            this.vector.vector3D(outPoints[i - 1].Y, v2.y, outPoints[i - 1].Z),
                            this.vector.vector3D(outPoints[i].Y, v2.y, outPoints[i].Z),
                            this.vector.vector3D(outPoints[i].Y, v1.y, outPoints[i].Z)
                        ];
                        result[i + 1] = this.polygon3D(vectorCollection, chart, index, fill, 0, opacity, fill, '-' + (i + 1).toString() + '-' + name, parent);
                        graphics.addVisual(result[i + 1], chart);
                    }
                    i++;
                }
                break;
            default:
                break;
        }
        result[0] = this.polygon3D(bottomVector, chart, index, stroke, 0, opacity, fill, '-0-' + name, parent);
        result[1] = this.polygon3D(topVector, chart, index, stroke, strokeThickness, opacity, fill, '-1-' + name, parent);
        graphics.addVisual(result[0], chart);
        graphics.addVisual(result[1], chart);
        return result;
    };
    /**
     * Creates a 3D box based on the given vectors, chart, and styling parameters.
     *
     * @param {Vector} v1 - The start vector of the box.
     * @param {Vector} v2 - The end vector of the box.
     * @param {Chart3D} chart - The 3D chart to which the box belongs.
     * @param {number} index - The index of the box.
     * @param {string} stroke - The stroke color of the box.
     * @param {string} fill - The fill color of the box.
     * @param {number} strokeThickness - The thickness of the stroke.
     * @param {number} opacity - The opacity of the box.
     * @param {boolean} inverse - A boolean indicating whether to inverse the box.
     * @param {string} name - The name of the box.
     * @param {Element} parent - The parent element of the box.
     * @param {string} [text] - Optional text associated with the box.
     * @returns {Chart3DPolygon[]} - Returns an array of polygons representing the 3D box.
     *
     */
    Polygon3D.prototype.createBox = function (v1, //top left front vecotr.
    v2, // bottom right back vector.
    chart, index, stroke, fill, strokeThickness, opacity, inverse, name, parent, text) {
        var result = [];
        var point1 = [
            this.vector.vector3D(v1.x, v1.y, v1.z),
            this.vector.vector3D(v2.x, v1.y, v1.z),
            this.vector.vector3D(v2.x, v2.y, v1.z),
            this.vector.vector3D(v1.x, v2.y, v1.z)
        ];
        var point2 = [
            this.vector.vector3D(v1.x, v1.y, v2.z),
            this.vector.vector3D(v2.x, v1.y, v2.z),
            this.vector.vector3D(v2.x, v2.y, v2.z),
            this.vector.vector3D(v1.x, v2.y, v2.z)
        ];
        var point3 = [
            this.vector.vector3D(v1.x, v1.y, v2.z),
            this.vector.vector3D(v2.x, v1.y, v2.z),
            this.vector.vector3D(v2.x, v1.y, v1.z),
            this.vector.vector3D(v1.x, v1.y, v1.z)
        ];
        var point4 = [
            this.vector.vector3D(v1.x, v2.y, v2.z),
            this.vector.vector3D(v2.x, v2.y, v2.z),
            this.vector.vector3D(v2.x, v2.y, v1.z),
            this.vector.vector3D(v1.x, v2.y, v1.z)
        ];
        var point5 = [
            this.vector.vector3D(v1.x, v1.y, v1.z),
            this.vector.vector3D(v1.x, v1.y, v2.z),
            this.vector.vector3D(v1.x, v2.y, v2.z),
            this.vector.vector3D(v1.x, v2.y, v1.z)
        ];
        var point6 = [
            this.vector.vector3D(v2.x, v1.y, v1.z),
            this.vector.vector3D(v2.x, v1.y, v2.z),
            this.vector.vector3D(v2.x, v2.y, v2.z),
            this.vector.vector3D(v2.x, v2.y, v1.z)
        ];
        if (name) {
            result[0] = this.polygon3D(point1, chart, index, stroke, strokeThickness, opacity, fill, '-0-' + name, parent, text);
            result[1] = this.polygon3D(point2, chart, index, stroke, strokeThickness, opacity, fill, '-1-' + name, parent, text);
            result[2] = this.polygon3D(point3, chart, index, stroke, strokeThickness, opacity, fill, '-2-' + name, parent, text);
            result[3] = this.polygon3D(point4, chart, index, stroke, strokeThickness, opacity, fill, '-3-' + name, parent, text);
            result[4] = this.polygon3D(point5, chart, index, stroke, strokeThickness, opacity, fill, '-4-' + name, parent, text);
            result[5] = this.polygon3D(point6, chart, index, stroke, strokeThickness, opacity, fill, '-5-' + name, parent, text);
        }
        else {
            result[0] = this.polygon3D(point1, chart, index, stroke, strokeThickness, opacity, fill, '-0-' + index, parent, text);
            result[1] = this.polygon3D(point2, chart, index, stroke, strokeThickness, opacity, fill, '-1-' + index, parent, text);
            result[2] = this.polygon3D(point3, chart, index, stroke, strokeThickness, opacity, fill, '-2-' + index, parent, text);
            result[3] = this.polygon3D(point4, chart, index, stroke, strokeThickness, opacity, fill, '-3-' + index, parent, text);
            result[4] = this.polygon3D(point5, chart, index, stroke, strokeThickness, opacity, fill, '-4-' + index, parent, text);
            result[5] = this.polygon3D(point6, chart, index, stroke, strokeThickness, opacity, fill, '-5-' + index, parent, text);
        }
        if (inverse) {
            graphics.addVisual(result[0], chart);
            graphics.addVisual(result[1], chart);
            graphics.addVisual(result[2], chart);
            graphics.addVisual(result[3], chart);
            graphics.addVisual(result[4], chart);
            graphics.addVisual(result[5], chart);
        }
        else {
            graphics.addVisual(result[5], chart);
            graphics.addVisual(result[4], chart);
            graphics.addVisual(result[0], chart);
            graphics.addVisual(result[1], chart);
            graphics.addVisual(result[2], chart);
            graphics.addVisual(result[3], chart);
        }
        return result;
    };
    /**
     * Calculates the normal vector for a 3D polygon based on the provided points.
     *
     * @param {...Vector} args - Variable number of vector3d arguments representing points of the polygon.
     * @returns {void}
     */
    Polygon3D.prototype.calculateNormal = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length >= 3) {
            // Relative information of the points
            var vector1 = args[0];
            var vector2 = args[1];
            var vector3 = args[2];
            var vector4 = this.vector.vector3DMinus(vector1, vector2);
            var vector5 = this.vector.vector3DMinus(vector3, vector2);
            var normal = this.vector.vector3DMultiply(vector4, vector5);
            var length_1 = this.vector.getLength(normal); // Get length of the vector
            if (length_1 < this.epsilon) {
                length_1 = 1;
            }
            this.normal = this.vector.vector3D(normal.x / length_1, normal.y / length_1, normal.z / length_1); // Calculate normalization of the vector
            this.d = -(this.normal.x * vector1.x + this.normal.y * vector1.y + this.normal.z * vector1.z); // Normalized values * 1st coordinates Coordinates - Depth of the plan
            if (args[3]) {
                args[3].normal = this.normal;
                args[3].d = this.d;
            }
        }
        else {
            var Points = args[0];
            this.calculateNormal(Points[0], Points[1], Points[2], arguments[1]);
            for (var i = 3; (i < Points.length) && (this.test()); i++) {
                this.calculateNormal(Points[i], Points[0], Points[i / 2]);
            }
        }
    };
    /**
     * Tests whether the calculated normal vector is valid.
     *
     * @returns {boolean} - Returns true if the normal vector is valid, false otherwise.
     */
    Polygon3D.prototype.test = function () {
        return !this.vector.isValid(this.normal);
    };
    /**
     * Transforms the vector points of the specified polygon using the provided matrix.
     *
     * @param {number[][]} matrix - The transformation matrix.
     * @param {Chart3DPolygon} polygon - The polygon to transform.
     * @returns {void}
     */
    Polygon3D.prototype.transform = function (matrix, polygon) {
        if (polygon.points != null) {
            for (var i = 0; i < polygon.points.length; i++) {
                polygon.vectorPoints[i] = polygon.points[i] =
                    matrixObj.getMatrixVectorMultiple(matrix, polygon.points[i]);
            }
            this.calculateNormal(polygon.vectorPoints, polygon);
        }
    };
    /**
     *  Gets the normal vector based on the transformed points using the specified transformation matrix.
     *
     * @param {number[][]} transform - The transformation matrix.
     * @param {Chart3DVector[]} [vectorPoints] - The vector points.
     * @returns {Chart3DVector} - Returns the normal vector.
     * @private
     */
    Polygon3D.prototype.getNormal = function (transform, vectorPoints) {
        var normal;
        if (vectorPoints != null) {
            normal = this.vector.getNormal(this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]), matrixObj.getMatrixVectorMultiple(transform, vectorPoints[1]), this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[2]));
            for (var i = 3; (i < vectorPoints.length) && !this.vector.isValid(normal) && vectorPoints[i / 2]; i++) {
                var v1 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i]);
                var v2 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]);
                var v3 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i / 2]);
                normal = this.vector.getNormal(v1, v2, v3);
            }
        }
        else {
            normal = matrixObj.getMatrixVectorAnd(transform);
            this.vector.normalize();
        }
        return normal;
    };
    /**
     * A method for creating text element.
     *
     * @param {Vector} position - text position.
     * @param {Chart3DLabelElement} element - text element.
     * @param {number} xLength - text element x value.
     * @param {number} yLength - text element y value.
     * @returns {Chart3DPolygon} - Returns the polygon.
     */
    Polygon3D.prototype.createTextElement = function (position, element, xLength, yLength) {
        var vectorCollection = [];
        var x = position.x;
        var y = position.y;
        var desiredWidth = element.width;
        var desiredHeight = element.height;
        vectorCollection[0] = this.vector.vector3D(x, y, position.z);
        vectorCollection[1] = this.vector.vector3D(x + desiredWidth, y + desiredHeight + yLength, position.z);
        vectorCollection[2] = this.vector.vector3D(x + desiredWidth + xLength, y + desiredHeight + yLength, position.z);
        return this.text3D(element, vectorCollection);
    };
    /**
     * Draws a template on the specified 3D chart panel.
     *
     * @param {PChart3DPolygon} panel - The 3D polygon representing the panel on which the template will be drawn.
     * @param {Chart3D} chart - The 3D chart to which the panel belongs.
     * @returns {void}
     */
    Polygon3D.prototype.drawLine = function (panel, chart) {
        var transform = chart3DRender.transform;
        if (transform == null) {
            return;
        }
        var actual3DPosition1 = chart.transform3D.toScreen(panel.vectorPoints[0], transform);
        var actual3DPosition2 = chart.transform3D.toScreen(panel.vectorPoints[2], transform);
        var optionsLine = {
            'id': panel.element.id,
            'x1': actual3DPosition1.x,
            'y1': actual3DPosition1.y,
            'x2': actual3DPosition2.x,
            'y2': actual3DPosition2.y,
            'stroke-dasharray': '',
            'stroke-width': panel.element.width,
            'stroke': panel.element.stroke,
            'opacity': panel.element.opacity
        };
        chart.chart3D.appendChild(chart.svgRenderer.drawLine(optionsLine));
    };
    /**
     * Draws text on the specified 3D chart panel.
     *
     * @param {Chart3DPolygon} panel - The 3D polygon representing the panel on which the text will be drawn.
     * @param {Chart3D} chart - The 3D chart to which the panel belongs.
     * @returns {void}
     */
    Polygon3D.prototype.drawTemplate = function (panel, chart) {
        var element = panel.element;
        var transform = chart3DRender.transform;
        if (transform == null) {
            return;
        }
        var label = element.label;
        var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);
        chart.dataLabel3DModule.createDataLabelTemplate(label.series.dataLabelElement, label.series, label.series.dataLabel, label.series.visiblePoints[label.pointIndex], element.argsData, label.pointIndex, false, actual3DPosition);
    };
    /**
     * Draws a data label symbol for a specific data point in a three-dimensional series.
     *
     * @param {Chart3DPolygon} panel - The 3D polygon representing the panel on which the text will be drawn.
     * @param {Chart3D} chart - The 3D chart to which the panel belongs.
     * @returns {void}
     */
    Polygon3D.prototype.drawText = function (panel, chart) {
        var element = panel.element;
        var transform = chart3DRender.transform;
        if (transform == null) {
            return;
        }
        var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);
        var x = actual3DPosition.x;
        var y = actual3DPosition.y;
        if (element.tag === 'text') {
            var options = {
                'id': element.id,
                'x': x,
                'y': y,
                'fill': element.font.color || element.fill,
                'font-size': element.font.size,
                'font-family': element.font.fontFamily,
                'font-style': element.font.fontStyle,
                'font-weight': element.font.fontWeight,
                'opacity': element.font.opacity,
                'text-anchor': element.textAnchor,
                'cursor': 'default',
                'transform': element.angle ? 'rotate(' + element.angle + ',' + (x) + ',' + y + ')' : ''
            };
            var textElement$$1 = chart.svg3DRenderer.drawText(options, element.label.text, panel.element.font, chart);
            if (element.id.indexOf('-axis-title') > -1) {
                textElement$$1.setAttribute('aria-hidden', 'true');
            }
            chart.chart3D.append(textElement$$1);
        }
        else {
            var series = element.series;
            var labelFormat = (series.yAxis && series.yAxis.labelFormat) ? series.yAxis.labelFormat : '';
            var pointText = (element.point.text) ? element.point.text : element.point.y + labelFormat.substring(labelFormat.indexOf('}') + 1);
            var textOffset = measureText(pointText, series.dataLabel.font, chart.themeStyle.datalabelFont);
            var margin = series.dataLabel.margin;
            var width = textOffset.width + margin.left + margin.right;
            var height = textOffset.height + margin.top + margin.bottom;
            var location_1 = { x: actual3DPosition.x, y: actual3DPosition.y };
            var xXalue = location_1.x - (margin.left) / 2 + (margin.right) / 2;
            var yValue = location_1.y - (margin.top) / 2 - (height / margin.top) + (margin.bottom) / 2;
            var seriesIndex = series.index;
            this.dataLabelSymbol(seriesIndex, series, element.pointIndex, xXalue, yValue, width, height, chart);
        }
    };
    /**
     * Draws a data label symbol for a specific data point in a three-dimensional series.
     *
     * @param {number} seriesIndex - The index of the series to which the data point belongs.
     * @param {Chart3DSeries} series - The three-dimensional series containing the data point.
     * @param {number} pointIndex - The index of the data point within the series.
     * @param {number} x - The x-coordinate of the center of the symbol.
     * @param {number} y - The y-coordinate of the center of the symbol.
     * @param {number} width - The width of the symbol.
     * @param {number} height - The height of the symbol.
     * @param {Chart3D} chart - The three-dimensional chart containing the series.
     * @returns {void}
     */
    Polygon3D.prototype.dataLabelSymbol = function (seriesIndex, series, pointIndex, x, y, width, height, chart) {
        var path = 'M' + ' ' + (x + (-width / 2)) + ' ' +
            (y + (-height / 2)) + ' ' + 'L' + ' ' + (x + (width / 2)) +
            ' ' + (y + (-height / 2)) + ' ' + 'L' + ' ' + (x + (width / 2)) +
            ' ' + (y + (height / 2)) + ' ' + 'L' + ' ' + (x + (-width / 2)) +
            ' ' + (y + (height / 2)) + ' ' + 'L' + ' ' + (x + (-width / 2)) +
            ' ' + (y + (-height / 2)) + ' z';
        var Rectoptions = {
            id: chart.element.id + '-svg' + '-data-label-series-' + seriesIndex + '-point-' + pointIndex,
            fill: series.dataLabel.fill,
            'stroke-width': series.dataLabel.border.width,
            stroke: series.dataLabel.border.color,
            opacity: series.dataLabel.opacity,
            visibility: '',
            d: path
        };
        var element = chart.svgRenderer.drawPath(Rectoptions);
        chart.chart3D.append(element);
    };
    /**
     * Draws a three-dimensional polygon on the specified chart.
     *
     * @param {PChart3DPolygon} panel - The polygon to be drawn.
     * @param {Chart3D} chart - The three-dimensional chart on which the polygon is to be drawn.
     * @returns {void}
     */
    Polygon3D.prototype.draw = function (panel, chart) {
        if (panel.vectorPoints == null || panel.vectorPoints.length <= 0) {
            return;
        }
        var transform = chart3DRender.transform;
        var pathDirection = chart.svg3DRenderer.getStringBuilder();
        var color = panel.fill;
        var format = chart.svg3DRenderer.checkColorFormat(color);
        if (!format) {
            color = chart.svg3DRenderer.colorNameToHex(color);
        }
        var figure = { StartPoint: null };
        if (transform != null) {
            figure.StartPoint = chart.transform3D.toScreen(panel.vectorPoints[0], transform);
            pathDirection.append('M' + ' ' + (figure.StartPoint.x) + ' ' + (figure.StartPoint.y) + ' ');
            for (var i = 0; i < panel.vectorPoints.length; i++) {
                var lineSegment = chart.transform3D.toScreen(panel.vectorPoints[i], transform);
                pathDirection.append('L' + ' ' + (lineSegment.x) + ' ' + (lineSegment.y) + ' ');
            }
        }
        var direction = pathDirection.toString();
        var name = 'Light';
        var lightCoefficientZ = (2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 0, 1))) - 1));
        var lightCoefficientY = (2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 1, 0))) - 1));
        var lightCoefficientX = (2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(1, 0, 0))) - 1));
        if (panel.name && !(panel.name.indexOf('-wall-brush') > -1)) {
            if (lightCoefficientZ === lightCoefficientX) {
                name = 'ZLight';
                color = this.applyZLight(color, chart);
            }
            else if (((lightCoefficientY === lightCoefficientZ) || (lightCoefficientZ !== 0 && lightCoefficientY < lightCoefficientZ))) {
                name = 'XLight';
                color = this.applyXLight(color, chart);
            }
            else if (lightCoefficientZ < 0) {
                name = 'ZLight';
                color = this.applyZLight(color, chart);
            }
            else {
                name = 'Light';
            }
        }
        var options = {
            'id': chart.element.id + '-svg' + panel.name,
            'name': name,
            'fill': color,
            'stroke': '',
            'stroke-width': panel.strokeThickness,
            'opacity': panel.opacity,
            'd': direction
        };
        var element = chart.svgRenderer.drawPath(options);
        if (panel.text) {
            element.setAttribute('aria-label', panel.text);
            element.setAttribute('role', 'img');
        }
        if (panel.name && panel.name.indexOf('-wall-brush') > -1) {
            element.setAttribute('aria-hidden', 'true');
        }
        if (element.id.indexOf('0-region-series-0-point-0') > -1) {
            element.setAttribute('tabindex', '0');
        }
        appendChildElement(false, panel.polygonElement.parent, element, chart.redraw, true, 'x', 'y', null, direction);
    };
    /**
     * Applies a lightening effect to the given color by reducing its red, green and blue components.
     *
     * @param {string} color - The input color in hexadecimal format.
     * @param {Chart3D} chart - The three-dimensional chart associated with the color.
     * @returns {string} - The lightened color in hexadecimal format.
     */
    Polygon3D.prototype.applyXLight = function (color, chart) {
        var RGB = chart.svg3DRenderer.hexToValue(color);
        RGB.red = parseInt((RGB.red * 0.7).toString(), 10);
        RGB.green = parseInt((RGB.green * 0.7).toString(), 10);
        RGB.blue = parseInt((RGB.blue * 0.7).toString(), 10);
        return chart.svg3DRenderer.hexColor(RGB);
    };
    /**
     * Applies a lightening effect to the given color by reducing its red, green and blue components with a focus on the Z-axis.
     *
     * @param {string} color - The input color in hexadecimal format.
     * @param {Chart3D} chart - The three-dimensional chart associated with the color.
     * @returns {string} - The lightened color in hexadecimal format.
     */
    Polygon3D.prototype.applyZLight = function (color, chart) {
        var RGB = chart.svg3DRenderer.hexToValue(color);
        RGB.red = parseInt((RGB.red * 0.9).toString(), 10);
        RGB.green = parseInt((RGB.green * 0.9).toString(), 10);
        RGB.blue = parseInt((RGB.blue * 0.9).toString(), 10);
        return chart.svg3DRenderer.hexColor(RGB);
    };
    return Polygon3D;
}());
var vector = new Vector3D(0, 0, 0);
var matrixObj = new Matrix3D();
var bspTreeObj = new BinaryTreeBuilder();
var polygonObj = new Polygon3D();
var graphics = new Graphics3D();
/**
 * Gets the minimum delta value between adjacent data points on a given axis in a three-dimensional chart.
 *
 * @param {Chart3DAxis} axis - The three-dimensional axis for which the delta value is calculated.
 * @param {Chart3DSeries[]} seriesCollection - Collection of three-dimensional series in the chart.
 * @returns {number} - The minimum delta value between adjacent data points on the specified axis.
 */
function getMinPointsDeltaValue(axis, seriesCollection) {
    var minDelta = Number.MAX_VALUE;
    var xValues;
    var minVal;
    var seriesMin;
    for (var index = 0; index < seriesCollection.length; index++) {
        var series = seriesCollection[index];
        xValues = [];
        if (series.visible &&
            (axis.name === series.xAxisName || (axis.name === 'primaryXAxis' && series.xAxisName === null))) {
            xValues = series.points.map(function (point) {
                return point.xValue;
            });
            xValues.sort(function (first, second) { return first - second; });
            if (xValues.length === 1) {
                seriesMin = (axis.valueType === 'DateTime' && series.xMin === series.xMax) ? (series.xMin - 25920000) : series.xMin;
                minVal = xValues[0] - (!isNullOrUndefined(seriesMin) ?
                    seriesMin : axis.visibleRange.min);
                if (minVal !== 0) {
                    minDelta = Math.min(minDelta, minVal);
                }
            }
            else {
                for (var index_1 = 0; index_1 < xValues.length; index_1++) {
                    var value = xValues[index_1];
                    if (index_1 > 0 && value) {
                        minVal = value - xValues[index_1 - 1];
                        if (minVal !== 0) {
                            minDelta = Math.min(minDelta, minVal);
                        }
                    }
                }
            }
        }
    }
    if (minDelta === Number.MAX_VALUE) {
        minDelta = 1;
    }
    return minDelta;
}
/**
 * Converts a numeric value to a coefficient based on the given 3D axis.
 *
 * @param {number} value - The numeric value to be converted.
 * @param {Chart3DAxis} axis - The 3D axis for reference.
 * @returns {number} - The coefficient value.
 * @private
 */
function valueToCoefficients(value, axis) {
    var range = axis.visibleRange;
    var result = (value - range.min) / (range.delta);
    var isInverse = axis.isAxisInverse;
    return isInverse ? (1 - result) : result;
}

/**
 * The WallRenderer class provides methods to update the 3D wall of the chart.
 */
var WallRenderer = /** @__PURE__ @class */ (function () {
    function WallRenderer() {
    }
    /**
     * Updates the 3D wall of the chart based on the chart area type.
     *
     * @param {Chart3D} chart - The Chart3D instance to update the 3D wall for.
     * @returns {void}
     */
    WallRenderer.prototype.update3DWall = function (chart) {
        this.updateBackWall(chart);
        for (var i = 0; i < chart.axisCollections.length; i++) {
            var axis = chart.axisCollections[i];
            var opposedPosition = axis.opposedPosition || axis.isAxisOpposedPosition;
            if (axis.orientation.toLowerCase() === 'vertical') {
                if (!opposedPosition) {
                    this.updateLeftWall(chart);
                }
                else {
                    this.updateRightWall(chart);
                }
            }
            else {
                if (!opposedPosition) {
                    this.updateBottomWall(chart);
                }
                else {
                    this.updateTopWall(chart);
                }
            }
        }
    };
    /**
     * Updates the top wall of the 3D chart based on the specified chart and axis.
     *
     * @param {Chart3D} chart - The Chart3D instance for which the top wall is updated.
     * @returns {void}
     */
    WallRenderer.prototype.updateTopWall = function (chart) {
        var offset = 0;
        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
        var y = areaBounds.y;
        if (chart.wallSize < y) {
            offset = y - chart.wallSize;
        }
        else {
            offset = -(chart.wallSize - y);
        }
        var topLeftFrontVector = chart.vector.vector3D(areaBounds.x + areaBounds.width, -chart.depth, y - 0.1);
        var bottomRightBackVector = chart.vector.vector3D(areaBounds.x, -0.1, offset);
        var topSideWallPlans = chart.polygon.createBox(topLeftFrontVector, bottomRightBackVector, chart, 0, chart.wallColor || chart.themeStyle.leftWallColor, chart.wallColor || chart.themeStyle.leftWallColor, 0, 0.5, false, 'top-wall-brush', chart.chart3D);
        for (var i = 0; i < topSideWallPlans.length; i++) {
            chart.polygon.transform(chart.matrixObj.tilt(Math.PI / 2), topSideWallPlans[i]);
        }
    };
    /**
     * Updates the right wall of the 3D chart based on the specified chart and axis.
     *
     * @param {Chart3D} chart - The Chart3D instance for which the right wall is updated.
     * @returns {void}
     */
    WallRenderer.prototype.updateRightWall = function (chart) {
        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
        var x = areaBounds.x + areaBounds.width;
        var rightRect = { left: -chart.depth, top: areaBounds.y, bottom: areaBounds.height + areaBounds.y, right: 0 };
        var topLeftFrontVector = chart.vector.vector3D(rightRect.left, rightRect.top, x + 1.5);
        var bottomRightBackVector = chart.vector.vector3D(rightRect.right, rightRect.bottom, x + chart.wallSize);
        var rightSideWallPlans = chart.polygon.createBox(topLeftFrontVector, bottomRightBackVector, chart, 0, chart.wallColor || chart.themeStyle.leftWallColor, chart.wallColor || chart.themeStyle.leftWallColor, 0, 0.5, false, 'right-wall-brush', chart.chart3D);
        for (var i = 0; i < rightSideWallPlans.length; i++) {
            chart.polygon.transform(chart.matrixObj.turn(-Math.PI / 2), rightSideWallPlans[i]);
        }
    };
    /**
     * Updates the back wall of the 3D chart based on the specified chart.
     *
     * @param {Chart3D} chart - The Chart3D instance for which the back wall is updated.
     * @returns {void}
     */
    WallRenderer.prototype.updateBackWall = function (chart) {
        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
        var topLeftFrontVector = chart.vector.vector3D(areaBounds.x, areaBounds.y, chart.depth === 0 ? 1.5 : chart.depth + chart.wallSize);
        var bottomRightBackVector = chart.vector.vector3D((areaBounds.x + areaBounds.width), areaBounds.y + areaBounds.height, chart.depth === 0 ? 1.5 : chart.depth);
        chart.polygon.createBox(topLeftFrontVector, bottomRightBackVector, chart, 0, chart.wallColor || chart.themeStyle.backWallColor, chart.wallColor || chart.themeStyle.backWallColor, 0, 0.25, false, 'back-wall-brush', chart.chart3D);
    };
    /**
     * Updates the left wall of the 3D chart based on the specified chart.
     *
     * @param {Chart3D} chart - The Chart3D instance for which the left wall is updated.
     * @returns {void}
     */
    WallRenderer.prototype.updateLeftWall = function (chart) {
        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
        var leftRect = { left: -chart.depth, top: areaBounds.y, bottom: areaBounds.height + areaBounds.y, right: 0 };
        var offset = areaBounds.x;
        var topLeftFrontVector = chart.vector.vector3D(leftRect.left, leftRect.top, offset - 0.1);
        var bottomRightBackVector = chart.vector.vector3D(leftRect.right, leftRect.bottom, offset - chart.wallSize);
        var leftSideWallPlans = chart.polygon.createBox(topLeftFrontVector, bottomRightBackVector, chart, 0, chart.wallColor || chart.themeStyle.leftWallColor, chart.wallColor || chart.themeStyle.leftWallColor, 0, 0.5, false, 'left-wall-brush', chart.chart3D);
        for (var i = 0; i < leftSideWallPlans.length; i++) {
            chart.polygon.transform(chart.matrixObj.turn(-Math.PI / 2), leftSideWallPlans[i]);
        }
    };
    /**
     * Updates the bottom wall of the 3D chart based on the specified chart.
     *
     * @param {Chart3D} chart - The Chart3D instance for which the bottom wall is updated.
     * @returns {void}
     */
    WallRenderer.prototype.updateBottomWall = function (chart) {
        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
        var y = areaBounds.y + areaBounds.height;
        var topLeftFrontVector = chart.vector.vector3D((areaBounds.x + areaBounds.width), -chart.depth, chart.wallSize + y);
        var bottomRightBackVector = chart.vector.vector3D(areaBounds.x, -0.1, y + 1);
        var bottomSideWallPlans = chart.polygon.createBox(bottomRightBackVector, topLeftFrontVector, chart, 0, chart.wallColor || chart.themeStyle.leftWallColor, chart.wallColor || chart.themeStyle.leftWallColor, 0, 0.5, false, 'bottom-wall-brush', chart.chart3D);
        for (var i = 0; i < bottomSideWallPlans.length; i++) {
            chart.polygon.transform(chart.matrixObj.tilt(Math.PI / 2), bottomSideWallPlans[i]);
        }
    };
    return WallRenderer;
}());
/**
 * 3D chart axis render/
 */
var AxisRenderer = /** @__PURE__ @class */ (function () {
    function AxisRenderer() {
    }
    /**
     * Draws the 3D axes at the specified index for the given axis and chart.
     *
     * @param {number} index - The index of the axis.
     * @param {Chart3DAxis} axis - The Chart3DAxis instance to draw.
     * @param {Chart3D} chart - The Chart3D instance for which the axes are drawn.
     * @returns {void}
     */
    AxisRenderer.prototype.drawAxes = function (index, axis, chart) {
        if (axis.majorGridLines.width) {
            this.drawGridLines3D(axis, chart, index);
        }
        if (axis.visible && axis.internalVisibility && axis.majorTickLines.width) {
            this.renderTicks3D(axis, axis.majorTickLines.height, axis.majorTickLines.width, chart, index);
        }
        if (axis.visible && axis.internalVisibility) {
            this.drawAxisLabel(axis, chart, index);
            this.drawAxisTitle(axis, chart, index);
        }
    };
    /**
     * Draws the title for the specified 3D axis on the given chart.
     *
     * @param {Chart3DAxis} axis - The Chart3DAxis instance for which the title is drawn.
     * @param {Chart3D} chart - The Chart3D instance on which the title is drawn.
     * @param {number} index - The index of the axis.
     * @returns {void}
     */
    AxisRenderer.prototype.drawAxisTitle = function (axis, chart, index) {
        if (axis.title) {
            var font = {
                size: axis.titleStyle.size,
                fontWeight: axis.titleStyle.fontWeight,
                fontStyle: axis.titleStyle.fontStyle,
                fontFamily: axis.titleStyle.fontFamily,
                color: axis.titleStyle.color,
                opacity: axis.titleStyle.opacity
            };
            var opposedPosition = axis.opposedPosition || axis.isAxisOpposedPosition;
            var size = { width: chart.availableSize.width, height: chart.availableSize.height };
            var transform = chart.transform3D.transform3D(size);
            transform.viewingArea = size;
            transform.rotation = 0;
            transform.tilt = 0;
            transform.depth = 100;
            transform.perspectiveAngle = 90;
            chart.transform3D.transform(transform);
            var orientation_1 = axis.orientation.toLowerCase();
            var elementSpacing = 10;
            if (orientation_1 === 'horizontal') {
                var padding = 0;
                var titlesize = (measureText(axis.title, axis.titleStyle, chart.themeStyle.axisLabelFont).height / 2);
                if (axis.titleRotation) {
                    padding = axis.titlePadding + (elementSpacing) + axis.labelPadding + (axis.titleSize.height / 2);
                }
                else {
                    padding = axis.titlePadding + titlesize + axis.labelPadding + elementSpacing;
                }
                var xtitleLocation = axis.maxLabelSize.height + padding;
                var data = {
                    text: axis.title,
                    location: {
                        x: (axis.rect.width) / 2,
                        y: (xtitleLocation + axis.majorTickLines.height + chart.wallSize)
                    }
                };
                var x1 = data.location.x + axis.rect.x;
                var y1 = (opposedPosition) ? (axis.rect.y - data.location.y) : (data.location.y + axis.rect.y);
                var element = { width: 0, height: 0, angle: axis.titleRotation ? axis.titleRotation : 0, label: data, textAnchor: 'middle', tag: 'text', font: font, id: chart.element.id + '-svg-axis-title-' + index, child: chart.chart3D };
                element.font.color = element.font.color ? element.font.color : chart.themeStyle.axisTitle;
                element.font.fontFamily = element.font.fontFamily ? element.font.fontFamily : chart.themeStyle.axisTitleFont.fontFamily;
                chart.graphics.addVisual(chart.polygon.createTextElement(chart.vector.vector3D(x1, y1, 0), element, 10, 10), chart);
            }
            else {
                var titleSize = measureText(axis.title, axis.titleStyle, chart.themeStyle.axisLabelFont);
                var padding = 0;
                if (axis.titleRotation) {
                    padding = axis.labelPadding + axis.titlePadding + axis.titleSize.width / 2;
                }
                else {
                    padding = axis.titlePadding + axis.labelPadding;
                }
                var x1 = (opposedPosition) ? axis.rect.x + ((elementSpacing) + axis.maxLabelSize.width +
                    axis.majorTickLines.height + chart.wallSize + padding) : axis.rect.x - ((elementSpacing) +
                    axis.maxLabelSize.width + axis.majorTickLines.height + chart.wallSize + padding);
                var angle = (axis.titleRotation == null ? (opposedPosition ? 90 : -90) : axis.titleRotation) % 360;
                var data = {
                    text: axis.title,
                    location: {
                        x: titleSize.width / 2,
                        y: 0
                    }
                };
                var y1 = data.location.y + (axis.rect.y + axis.rect.height) + (((axis.rect.height) / 2) * -1);
                var element = { width: titleSize.width, height: titleSize.height, angle: angle, label: data, textAnchor: 'middle', tag: 'text', font: font, id: chart.element.id + '-svg-axis-title-' + index, child: chart.chart3D };
                element.font.color = element.font.color ? element.font.color : chart.themeStyle.axisTitle;
                element.font.fontFamily = element.font.fontFamily ? element.font.fontFamily : chart.themeStyle.axisTitleFont.fontFamily;
                chart.graphics.addVisual(chart.polygon.createTextElement(chart.vector.vector3D(x1, y1, 0), element, 10, 10), chart);
            }
        }
    };
    /**
     * Trims the specified text to fit within the maximum width, applying the provided labelStyle and font settings.
     *
     * @param {number} maxWidth - The maximum width to fit the text within.
     * @param {string} text - The text to be trimmed.
     * @param {Chart3DFontModel} labelStyle - The label style settings to be applied.
     * @param {Chart3DFontModel} font - The font settings to be applied.
     * @returns {string} - The trimmed text.
     */
    AxisRenderer.prototype.textTrim = function (maxWidth, text, labelStyle, font) {
        var textLength = text.length;
        var trimmedSize;
        var label;
        var textSize = measureText(text, labelStyle, font);
        if (textSize.width > maxWidth) {
            for (var k = textLength - 1; k >= 0; --k) {
                label = text.substring(0, k) + '...';
                trimmedSize = measureText(label, labelStyle, font);
                if (trimmedSize.width <= maxWidth) {
                    return label;
                }
            }
            return '';
        }
        else {
            return text;
        }
    };
    /**
     * Distributes labels into multiple rows based on the specified length, currentX, currentLabel, axis, and font settings.
     *
     * @param {number} length - The length of the labels.
     * @param {number} currentX - The current X-coordinate.
     * @param {Visible3DLabels} currentLabel - The current label settings.
     * @param {Chart3DAxis} axis - The Chart3DAxis instance.
     * @param {Chart3DFontModel} font - The font settings to be applied.
     * @returns {void}
     */
    AxisRenderer.prototype.multipleRows = function (length, currentX, currentLabel, axis, font) {
        var label;
        var pointX;
        var labelSize;
        var store = [];
        var isMultiRows;
        for (var i = length - 1; i >= 0; i--) {
            label = axis.visibleLabels[i];
            labelSize = measureText(label.text, axis.labelStyle, font);
            pointX = valueToCoefficients(i, axis) * axis.rect.width + axis.rect.x;
            isMultiRows = currentX < (pointX + labelSize.width / 2);
            if (isMultiRows) {
                label.index = label.index ? label.index : 0;
                store.push(label.index);
                currentLabel.index = (currentLabel.index > label.index) ? currentLabel.index : label.index + 1;
            }
            else {
                currentLabel.index = store.indexOf(label.index) > -1 ? currentLabel.index : label.index;
            }
        }
    };
    /**
     * Draws the labels for the specified 3D axis on the given chart.
     *
     * @param {Chart3DAxis} axis - The Chart3DAxis instance for which the labels are drawn.
     * @param {Chart3D} chart - The Chart3D instance on which the labels are drawn.
     * @param {number} index - The index of the axis.
     * @returns {void}
     */
    AxisRenderer.prototype.drawAxisLabel = function (axis, chart, index) {
        var labels = [];
        var angleValue;
        var labelsCount = axis.visibleLabels.length;
        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
        var opposedPosition = axis.opposedPosition || axis.isAxisOpposedPosition;
        var elementSpacing = axis.angle ? 5 : 10;
        var y = areaBounds.y + (!opposedPosition && areaBounds.height);
        var x = areaBounds.x + (opposedPosition && areaBounds.width);
        for (var i = 0; i < labelsCount; i++) {
            if (!isNullOrUndefined(axis.visibleLabels[i].text)) {
                var x1 = 0;
                var y1 = 0;
                var pointX = void 0;
                axis.visibleLabels[i].originalText = axis.visibleLabels[i].text;
                var textAnchor = void 0;
                var textSize = measureText(axis.visibleLabels[i].text, axis.labelStyle, chart.themeStyle.axisLabelFont);
                var value = (axis.visibleLabels[i].value - axis.visibleRange.min) / axis.visibleRange.delta;
                value = axis.isInversed || axis.isAxisInverse ? 1 - value : value;
                value = isNaN(value) ? 0 : value;
                if (axis.orientation.toLowerCase() === 'horizontal') {
                    x1 = Math.round(axis.rect.width * value) + areaBounds.x + axis.plotOffset;
                    y1 = opposedPosition ? (y - chart.wallSize - axis.majorTickLines.height - axis.labelPadding - elementSpacing / 2) :
                        y + chart.wallSize + axis.majorTickLines.height + elementSpacing + axis.labelPadding;
                    textAnchor = 'middle';
                }
                else {
                    y1 = Math.round(axis.plotOffset + axis.rect.y + (textSize.height / 4) + (axis.rect.height * (1 - value)));
                    var padding = 0;
                    if (axis.labelRotation == 90 || axis.labelRotation == -90 || axis.labelRotation == 270 || axis.labelRotation == -270) {
                        padding = elementSpacing * 2;
                    }
                    else {
                        padding = elementSpacing;
                    }
                    x1 = opposedPosition ? (axis.rect.x + axis.majorTickLines.height + padding + axis.labelPadding) :
                        (x - chart.wallSize - axis.majorTickLines.height - padding + axis.labelPadding);
                    textAnchor = opposedPosition ? (axis.isRTLEnabled ? 'end' : 'start') : (axis.isRTLEnabled ? 'start' : 'end');
                }
                labels.push({ x: x1, y: y1, size: textSize });
                var maxWidth = axis.rect.width / axis.visibleLabels.length - 5;
                var label = labels[i];
                if (((label.x - label.size.width / 2 < axis.rect.x && i === 0) ||
                    (label.x + label.size.width / 2 > axis.rect.x + axis.rect.width && i === axis.visibleLabels.length - 1)) &&
                    axis.labelIntersectAction !== 'Trim' && axis.labelIntersectAction.indexOf('wrap') < 0) {
                    if (axis.edgeLabelPlacement === 'Hide') {
                        continue;
                    }
                    else if (axis.edgeLabelPlacement === 'Shift') {
                        if (i === 0) {
                            label.x = x1 = axis.rect.x + label.size.width / 2;
                        }
                        else if (i === axis.visibleLabels.length - 1) {
                            label.x = x1 = axis.rect.x + axis.rect.width - label.size.width / 2;
                        }
                    }
                }
                if (axis.orientation.toLowerCase() === 'horizontal') {
                    if (axis.labelRotation) {
                        angleValue = axis.labelRotation;
                        var rotatedSize = rotateTextSize(axis.labelStyle, axis.visibleLabels[i].text, angleValue, chart);
                        y1 += rotatedSize.height / 2;
                    }
                    else {
                        if (axis.labelIntersectAction === 'Trim') {
                            axis.visibleLabels[i].text = this.textTrim(maxWidth, axis.visibleLabels[i].text, axis.labelStyle, chart.themeStyle.axisLabelFont);
                        }
                        else if (axis.angle && (axis.labelIntersectAction === 'Rotate45' || axis.labelIntersectAction === 'Rotate90')) {
                            var rotatedSize = rotateTextSize(axis.labelStyle, axis.visibleLabels[i].text, axis.angle, chart);
                            y1 += rotatedSize.height / 2;
                        }
                        else if (axis.labelIntersectAction === 'MultipleRows') {
                            pointX = label.x;
                            pointX -= textSize.width / 2;
                            this.multipleRows(i, pointX, axis.visibleLabels[i], axis, chart.themeStyle.axisLabelFont);
                            y1 = axis.visibleLabels[i].index ?
                                y1 + axis.visibleLabels[i].index * (textSize.height + 5) : y1;
                        }
                        else if (axis.labelIntersectAction === 'Hide') {
                            var isAxisLabelHidden = false;
                            for (var j = 0; j < i; j++) {
                                if (labels[j].x + (labels[j].size.width / 2) >= labels[i].x - (labels[i].size.width / 2)) {
                                    isAxisLabelHidden = true;
                                    break;
                                }
                            }
                            if (isAxisLabelHidden) {
                                continue;
                            }
                        }
                    }
                }
                var font = {
                    size: axis.visibleLabels[i].labelStyle.size,
                    fontWeight: axis.visibleLabels[i].labelStyle.fontWeight,
                    fontStyle: axis.visibleLabels[i].labelStyle.fontStyle,
                    fontFamily: axis.visibleLabels[i].labelStyle.fontFamily,
                    color: axis.visibleLabels[i].labelStyle.color,
                    opacity: axis.visibleLabels[i].labelStyle.opacity
                };
                var element = {
                    width: textSize.width, height: textSize.height, label: axis.visibleLabels[i], textAnchor: textAnchor,
                    tag: 'text', font: font, id: chart.element.id + '-' + index + '-axis-label-' + i, child: chart.chart3D, angle: axis.angle
                };
                element.font.color = element.font.color ? element.font.color : chart.themeStyle.axisLabel;
                element.font.fontFamily = element.font.fontFamily ? element.font.fontFamily : chart.themeStyle.axisLabelFont.fontFamily;
                chart.graphics.addVisual(chart.polygon.createTextElement(chart.vector.vector3D(x1, y1, 0), element, 10, 10), chart);
            }
        }
    };
    /**
     * Renders the 3D ticks for the specified axis with the given size, width, and on the provided chart.
     *
     * @param {Chart3DAxis} axis - The Chart3DAxis instance for which the ticks are rendered.
     * @param {number} size - The size of the ticks.
     * @param {number} width - The width of the ticks.
     * @param {Chart3D} chart - The Chart3D instance on which the ticks are rendered.
     * @param {number} index - The index of the axis.
     * @returns {void}
     */
    AxisRenderer.prototype.renderTicks3D = function (axis, size, width, chart, index) {
        var labelsCount = axis.visibleLabels.length;
        var minorTicks;
        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
        var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ? 0.5 : 0;
        labelsCount += (axis.valueType === 'Category' && labelsCount > 0 && axis.labelPlacement === 'BetweenTicks') ? 1 : 0;
        var labelValue;
        for (var i = 0; i < labelsCount; i++) {
            if (axis.valueType !== 'DateTimeCategory') {
                labelValue = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel :
                    (axis.visibleLabels[i - 1].value + axis.visibleRange.interval) - ticksbwtLabel;
            }
            else {
                labelValue = axis.visibleLabels[i].value ? axis.visibleLabels[i].value - ticksbwtLabel
                    : axis.visibleRange.max;
            }
            var x1 = 0;
            var x2 = 0;
            var y1 = 0;
            var y2 = 0;
            var value = (labelValue - axis.visibleRange.min) / axis.visibleRange.delta;
            value = axis.isInversed || axis.isAxisInverse ? 1 - value : value;
            value = isNaN(value) ? 0 : value;
            if (axis.orientation.toLowerCase() === 'horizontal') {
                x2 = x1 = (Math.round(axis.rect.width * value)) + areaBounds.x + axis.plotOffset;
            }
            else {
                y1 = y2 = Math.round(axis.plotOffset + (axis.rect.height * (1 - value))) + axis.rect.y;
            }
            var position = this.calculatePosition3D(axis, size, width, x1, y1, x2, y2, chart);
            var line = { width: axis.majorTickLines.width, opacity: 1, stroke: axis.majorTickLines.color || chart.themeStyle.majorTickLine, child: chart.chart3D, tag: 'line', id: '' };
            line.id = chart.element.id + '-' + index + '-major-tick-lines-' + i;
            chart.graphics.addVisual(chart.polygon.createLine(line, position.x1, position.y1, position.x2, position.y2, 0), chart);
            if (axis.minorGridLines.width && axis.minorTicksPerInterval > 0 && i < labelsCount - 1) {
                minorTicks = axis.visibleRange.interval / (axis.minorTicksPerInterval + 1);
                for (var k = 0; k < axis.minorTicksPerInterval; k++) {
                    value = valueToCoefficients(axis.visibleLabels[i].value + (minorTicks * (k + 1)), axis);
                    value = isNaN(value) ? 0 : value;
                    if (axis.orientation.toLowerCase() === 'horizontal') {
                        x1 = x2 = Math.round(axis.plotOffset + (areaBounds.width * value) + areaBounds.x);
                    }
                    else {
                        y1 = y2 = Math.round(axis.plotOffset + ((areaBounds.height) * (1 - value))) + axis.rect.y;
                    }
                    var position_1 = this.calculatePosition3D(axis, size, width, x1, y1, x2, y2, chart);
                    var line_1 = { width: axis.minorTickLines.width, opacity: 0.6, stroke: axis.minorTickLines.color || chart.themeStyle.minorTickLine, child: chart.chart3D, tag: 'line', id: '' };
                    line_1.id = chart.element.id + '-' + index + '-minor-tick-lines-' + i + '-' + k;
                    chart.graphics.addVisual(chart.polygon.createLine(line_1, position_1.x1, position_1.y1, position_1.x2, position_1.y2, 0), chart);
                }
            }
        }
    };
    /**
     * Calculates the 3D position for ticks on the specified axis with the given tickSize, width, and chart dimensions.
     *
     * @param {Chart3DAxis} axis - The Chart3DAxis instance for which the tick position is calculated.
     * @param {number} tickSize - The size of the ticks.
     * @param {number} width - The width of the ticks.
     * @param {number} x1 - The X-coordinate of the starting point.
     * @param {number} y1 - The Y-coordinate of the starting point.
     * @param {number} x2 - The X-coordinate of the ending point.
     * @param {number} y2 - The Y-coordinate of the ending point.
     * @param {Chart3D} chart - The Chart3D instance.
     * @returns {Chart3DTickPosition} - The calculated 3D tick position.
     */
    AxisRenderer.prototype.calculatePosition3D = function (axis, tickSize, width, x1, y1, x2, y2, chart) {
        var isOpposed = axis.opposedPosition || axis.isAxisOpposedPosition;
        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
        var y = areaBounds.y + (!isOpposed && areaBounds.height);
        var x = areaBounds.x + (isOpposed && areaBounds.width);
        if (axis.orientation.toLowerCase() === 'horizontal') {
            y1 = 0;
            y2 = isOpposed ? tickSize : y1 + tickSize;
            var screenPositionTop = isOpposed ? y - chart.wallSize - tickSize : y + chart.wallSize - (tickSize / 2);
            y1 += screenPositionTop;
            y2 += screenPositionTop;
            x1 = x2 = x1;
        }
        else {
            x1 = 0;
            x2 = isOpposed ? x1 + tickSize : tickSize;
            var screenPositionLeft = isOpposed ? x + chart.wallSize : (x - chart.wallSize - tickSize);
            x1 += screenPositionLeft;
            x2 += screenPositionLeft;
            y1 = y2 = y1;
        }
        return { x1: x1, y1: y1, x2: x2, y2: y2 };
    };
    /**
     * Draws the 3D grid lines for the specified axis on the given chart.
     *
     * @param {Chart3DAxis} axis - The Chart3DAxis instance for which the grid lines are drawn.
     * @param {Chart3D} chart - The Chart3D instance on which the grid lines are drawn.
     * @param {number} index - The index of the axis.
     * @returns {void}
     */
    AxisRenderer.prototype.drawGridLines3D = function (axis, chart, index) {
        if (axis == null) {
            return;
        }
        var labelsCount = axis.visibleLabels.length;
        var minorTicks;
        var opposedPosition = axis.opposedPosition || axis.isAxisOpposedPosition;
        var orientation = axis.orientation;
        var x1;
        var x2;
        var y1;
        var y2;
        var labelValue;
        var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ? 0.5 : 0;
        labelsCount += (axis.valueType === 'Category' && labelsCount > 0 && axis.labelPlacement === 'BetweenTicks') ? 1 : 0;
        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
        if (orientation.toLowerCase() === 'horizontal') {
            var i = void 0;
            for (i = 0; i < labelsCount; i++) {
                if (axis.valueType !== 'DateTimeCategory') {
                    labelValue = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel :
                        (axis.visibleLabels[i - 1].value + axis.visibleRange.interval) - ticksbwtLabel;
                }
                else {
                    labelValue = axis.visibleLabels[i].value ? axis.visibleLabels[i].value - ticksbwtLabel
                        : axis.visibleRange.max;
                }
                var value = valueToCoefficients(labelValue, axis);
                value = isNaN(value) ? 0 : value;
                x2 = x1 = (Math.round(axis.rect.width * value)) + areaBounds.x + axis.plotOffset;
                y1 = areaBounds.y;
                y2 = areaBounds.y + areaBounds.height;
                var depth = chart.depth > 2 ? chart.depth - 2 : 1;
                var bottom = areaBounds.y + (!opposedPosition && areaBounds.height);
                var line = { opacity: 1, width: axis.majorGridLines.width, stroke: axis.majorGridLines.color || chart.themeStyle.majorGridLine, child: chart.chart3D, tag: 'line', id: '' };
                line.id = chart.element.id + '-' + index + '-grid-lines-' + i;
                chart.graphics.addVisual(chart.polygon.createLine(line, x1, y1, x2, y2, depth), chart);
                var parallelLine = { opacity: line.opacity, width: line.width, stroke: line.stroke, child: line.child, tag: line.tag, id: '' };
                parallelLine.id = line.id + '-parallel';
                parallelLine.id = chart.element.id + '-' + index + '-parallel-grid-lines-' + i;
                var line3D = chart.polygon.createLine(parallelLine, x2, 0, x2, -depth, bottom);
                // To fold the gridline alone the wall(bottom)
                chart.polygon.transform(chart.matrixObj.tilt(Math.PI / 2), line3D);
                chart.graphics.addVisual(line3D, chart);
                if (axis.minorGridLines.width && axis.minorTicksPerInterval > 0 && i < labelsCount - 1) {
                    minorTicks = axis.visibleRange.interval / (axis.minorTicksPerInterval + 1);
                    for (var k = 0; k < axis.minorTicksPerInterval; k++) {
                        value = valueToCoefficients(axis.visibleLabels[i].value + (minorTicks * (k + 1)), axis);
                        value = isNaN(value) ? 0 : value;
                        x2 = x1 = (Math.round(areaBounds.width * value) + areaBounds.x);
                        y1 = areaBounds.y;
                        y2 = areaBounds.y + areaBounds.height;
                        var line_2 = { opacity: 0.6, width: axis.minorGridLines.width, stroke: axis.minorGridLines.color || chart.themeStyle.minorGridLine, child: chart.chart3D, tag: 'line', id: '' };
                        line_2.id = chart.element.id + '-' + index + '-minor-grid-lines-' + i + '-' + k;
                        chart.graphics.addVisual(chart.polygon.createLine(line_2, x1, y1, x2, y2, depth), chart);
                        var parallelLine_1 = { opacity: line_2.opacity, width: line_2.width, stroke: line_2.stroke, child: line_2.child, tag: line_2.tag, id: '' };
                        parallelLine_1.id = chart.element.id + '-' + index + '-parallel-minor-grid-lines-' + i + '-' + k;
                        var line3D_1 = chart.polygon.createLine(parallelLine_1, x2, 0, x2, -depth, bottom);
                        // To fold the gridline alone the wall(bottom)
                        chart.polygon.transform(chart.matrixObj.tilt(Math.PI / 2), line3D_1);
                        chart.graphics.addVisual(line3D_1, chart);
                    }
                }
            }
        }
        else {
            for (var i = 0; i < labelsCount; i++) {
                labelValue = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel :
                    (axis.visibleLabels[i - 1].value + axis.visibleRange.interval) - ticksbwtLabel;
                var value = (labelValue - axis.visibleRange.min) / axis.visibleRange.delta;
                x1 = areaBounds.x;
                y1 = Math.round((axis.rect.height) * (1 - value)) + 0.5;
                y1 += axis.rect.y;
                x2 = x1 + areaBounds.width;
                y2 = y1;
                var depth = chart.depth > 2 ? chart.depth - 2 : 1;
                var line = { opacity: 1, width: axis.majorGridLines.width, stroke: axis.majorGridLines.color || chart.themeStyle.majorGridLine, axisName: axis.name, child: chart.chart3D, tag: 'line', id: '' };
                line.id = chart.element.id + '-' + index + '-grid-lines-' + i;
                chart.graphics.addVisual(chart.polygon.createLine(line, x1, y1, x2, y2, depth), chart);
                var depthD = areaBounds.x + (opposedPosition && areaBounds.width + 1);
                var sideLine = { opacity: line.opacity, width: line.width, stroke: line.stroke, child: line.child, tag: line.tag, id: '' };
                sideLine.id = chart.element.id + '-' + index + '-parallel-grid-lines-' + i;
                var line3D = chart.polygon.createLine(sideLine, -depth, y2, 0, y2, depthD);
                // To fold the gridline alone the wall(right of vertical)
                chart.polygon.transform(chart.matrixObj.turn(-Math.PI / 2), line3D);
                chart.graphics.addVisual(line3D, chart);
                if (axis.minorGridLines.width && axis.minorTicksPerInterval > 0 && i < labelsCount - 1) {
                    minorTicks = axis.visibleRange.interval / (axis.minorTicksPerInterval + 1);
                    for (var k = 0; k < axis.minorTicksPerInterval; k++) {
                        var value_1 = valueToCoefficients(axis.visibleLabels[i].value + (minorTicks * (k + 1)), axis);
                        x1 = areaBounds.x;
                        y1 = Math.round((axis.rect.height) * (1 - value_1)) + 0.5;
                        y1 += axis.rect.y;
                        x2 = x1 + areaBounds.width;
                        y2 = y1;
                        var line_3 = { opacity: 0.6, width: axis.minorGridLines.width, stroke: axis.minorGridLines.color || chart.themeStyle.minorGridLine, axisName: axis.name, child: chart.chart3D, tag: 'line', id: '' };
                        line_3.id = chart.element.id + '-' + index + '-minor-grid-lines-' + i + '-' + k;
                        chart.graphics.addVisual(chart.polygon.createLine(line_3, x1, y1, x2, y2, depth), chart);
                        var sideLine_1 = { opacity: line_3.opacity, width: line_3.width, stroke: line_3.stroke, child: line_3.child, tag: line_3.tag, id: '' };
                        sideLine_1.id = chart.element.id + '-' + index + '-parallel-minor-grid-lines-' + i + k;
                        var line3D_2 = chart.polygon.createLine(sideLine_1, -depth, y2, 0, y2, depthD);
                        // To fold the gridline alone the wall(right of vertical)
                        chart.polygon.transform(chart.matrixObj.turn(-Math.PI / 2), line3D_2);
                        chart.graphics.addVisual(line3D_2, chart);
                    }
                }
            }
        }
    };
    return AxisRenderer;
}());

/* eslint-disable jsdoc/require-returns */
/**
 * Numeric Range.
 *
 * @private
 */
var DoubleRange$1 = /** @__PURE__ @class */ (function () {
    function DoubleRange(start, end) {
        if (start < end) {
            this.mStart = start;
            this.mEnd = end;
        }
        else {
            this.mStart = end;
            this.mEnd = start;
        }
    }
    Object.defineProperty(DoubleRange.prototype, "start", {
        /** @private */
        get: function () {
            return this.mStart;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DoubleRange.prototype, "end", {
        /** @private */
        get: function () {
            return this.mEnd;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DoubleRange.prototype, "delta", {
        /** @private */
        get: function () {
            return (this.mEnd - this.mStart);
        },
        enumerable: true,
        configurable: true
    });
    return DoubleRange;
}());

/**
 * The numeric module is used to render numeric axis.
 */
var Double3D = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for the dateTime module.
     *
     * @param {Chart3D} chart - Chart3D instance.
     * @private
     */
    function Double3D(chart) {
        this.isColumn = 0;
        this.isStacking = false;
        this.chart = chart;
    }
    /**
     * Calculates a numeric nice interval for the specified axis based on the provided delta and size.
     *
     * @param {Chart3DAxis} axis - The axis for which the numeric nice interval is calculated.
     * @param {number} delta - The delta value to consider in the interval calculation.
     * @param {Size} size - The size of the chart area used in the calculation.
     * @returns {number} - The calculated numeric nice interval.
     * @protected
     */
    Double3D.prototype.calculateNumericNiceInterval = function (axis, delta, size) {
        var actualDesiredIntervalsCount = getActualDesiredIntervalsCount(size, axis);
        var niceInterval = delta / actualDesiredIntervalsCount;
        if (!isNullOrUndefined(axis.desiredIntervals)) {
            return niceInterval;
        }
        var minInterval = Math.pow(10, Math.floor(logBase(niceInterval, 10)));
        for (var _i = 0, _a = axis.intervalDivs; _i < _a.length; _i++) {
            var interval = _a[_i];
            var currentInterval = minInterval * interval;
            if (actualDesiredIntervalsCount < (delta / currentInterval)) {
                break;
            }
            niceInterval = currentInterval;
        }
        return niceInterval;
    };
    /**
     * Retrieves the actual range for the specified axis based on the provided size.
     *
     * @param {Chart3DAxis} axis - The axis for which the actual range is retrieved.
     * @param {Size} size - The size of the chart area used in the range calculation.
     * @returns {void}
     */
    Double3D.prototype.getActualRange = function (axis, size) {
        this.initializeDoubleRange(axis);
        if ((!axis.startFromZero) && (this.isColumn > 0)) {
            axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);
            axis.actualRange.max = axis.doubleRange.end + axis.actualRange.interval;
            if ((axis.doubleRange.start - axis.actualRange.interval < 0 && axis.doubleRange.start > 0)) {
                axis.actualRange.min = 0;
            }
            else {
                axis.actualRange.min = axis.doubleRange.start - (this.isStacking ? 0 : axis.actualRange.interval);
            }
        }
        else {
            axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);
            axis.actualRange.min = axis.doubleRange.start;
            axis.actualRange.max = axis.doubleRange.end;
        }
    };
    /**
     * Range for the axis.
     *
     * @param {Chart3DAxis} axis - Specifies the instance of the axis.
     * @returns {void}
     * @private
     */
    Double3D.prototype.initializeDoubleRange = function (axis) {
        //Axis Min
        if (axis.minimum !== null) {
            this.min = axis.minimum;
        }
        else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {
            this.min = 0;
        }
        // Axis Max
        if (axis.maximum !== null) {
            this.max = axis.maximum;
        }
        else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {
            this.max = 5;
        }
        if (this.min === this.max) {
            this.max = axis.valueType.indexOf('Category') > -1 ? this.max : this.min + 1;
        }
        axis.doubleRange = new DoubleRange$1(this.min, this.max);
        axis.actualRange = {};
    };
    /**
     * Calculates the range and interval for the specified axis based on the provided size.
     *
     * @param {Size} size - The size of the chart area used for range and interval calculation.
     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.
     * @returns {void}
     */
    Double3D.prototype.calculateRangeAndInterval = function (size, axis) {
        this.calculateRange(axis);
        this.getActualRange(axis, size);
        this.applyRangePadding(axis, size);
        this.calculateVisibleLabels(axis, this.chart);
    };
    /**
     * Calculates range for the axis.
     *
     * @param {Chart3DAxis} axis - Specifies the instance of the axis.
     * @returns {void}
     * @private
     */
    Double3D.prototype.calculateRange = function (axis) {
        /*! Generate axis range */
        this.min = null;
        this.max = null;
        if (!setRange(axis)) {
            for (var _i = 0, _a = axis.series; _i < _a.length; _i++) {
                var series = _a[_i];
                if (!series.visible) {
                    continue;
                }
                this.paddingInterval = 0;
                if (!isNullOrUndefined(series.points)) {
                    axis.maxPointLength = series.points.length;
                }
                axis.maxPointLength = series.points.length;
                if (((series.type.indexOf('Column') > -1) && axis.orientation === 'Horizontal')
                    || (series.type.indexOf('Bar') > -1 && axis.orientation === 'Vertical')) {
                    if ((series.xAxis.valueType === 'Double' || series.xAxis.valueType === 'DateTime')
                        && series.xAxis.rangePadding === 'Auto') {
                        this.paddingInterval = getMinPointsDeltaValue(series.xAxis, axis.series) * 0.5;
                    }
                }
                //For xRange
                if (axis.orientation === 'Horizontal') {
                    if (this.chart.requireInvertedAxis) {
                        this.yAxisRange(axis, series);
                    }
                    else {
                        this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);
                    }
                }
                // For yRange
                if (axis.orientation === 'Vertical') {
                    this.isColumn += (series.type.indexOf('Column') !== -1 || series.type.indexOf('Bar') !== -1) ? 1 : 0;
                    this.isStacking = series.type.indexOf('Stacking') !== -1;
                    if (this.chart.requireInvertedAxis) {
                        this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);
                    }
                    else {
                        this.yAxisRange(axis, series);
                    }
                }
            }
        }
    };
    /**
     * Sets the range for the Y-axis based on the minimum and maximum values of the series.
     *
     * @param {Chart3DAxis} axis - The Y-axis of the 3D chart.
     * @param {Chart3DSeries} series - The 3D series for which to determine the range.
     * @returns {void}
     */
    Double3D.prototype.yAxisRange = function (axis, series) {
        this.findMinMax(series.yMin, series.yMax);
    };
    /**
     * Finds and updates the minimum and maximum values within a given range.
     *
     * @param {Object} min - The minimum value to compare.
     * @param {Object} max - The maximum value to compare.
     * @returns {void}
     */
    Double3D.prototype.findMinMax = function (min, max) {
        if (this.min === null || this.min > min) {
            this.min = min;
        }
        if (this.max === null || this.max < max) {
            this.max = max;
        }
        if ((this.max === this.min) && this.max < 0 && this.min < 0) { // max == min
            this.max = 0;
        }
    };
    /**
     * Apply padding for the range.
     *
     * @param {Chart3DAxis} axis - Specifies the instance of the axis.
     * @param {Size} size - Specifies the size of the axis.
     * @returns {void}
     * @private
     */
    Double3D.prototype.applyRangePadding = function (axis, size) {
        var start = axis.actualRange.min;
        var end = axis.actualRange.max;
        if (!setRange(axis)) {
            var interval = axis.actualRange.interval;
            var padding = axis.getRangePadding(this.chart);
            if (padding === 'Additional' || padding === 'Round') {
                this.findAdditional(axis, start, end, interval, size);
            }
            else if (padding === 'Normal') {
                this.findNormal(axis, start, end, interval, size);
            }
            else {
                this.updateActualRange(axis, start, end, interval);
            }
        }
        axis.actualRange.delta = axis.actualRange.max - axis.actualRange.min;
        this.calculateVisibleRange(size, axis);
    };
    /**
     * Updates the actual range of the 3D axis with specified minimum, maximum, and interval values.
     *
     * @param {Chart3DAxis} axis - The 3D axis to update.
     * @param {number} minimum - The minimum value for the axis.
     * @param {number} maximum - The maximum value for the axis.
     * @param {number} interval - The interval value for the axis.
     * @returns {void}
     */
    Double3D.prototype.updateActualRange = function (axis, minimum, maximum, interval) {
        axis.actualRange = {
            min: axis.minimum != null ? axis.minimum : minimum,
            max: axis.maximum != null ? axis.maximum : maximum,
            interval: axis.interval != null ? axis.interval : interval,
            delta: axis.actualRange.delta
        };
    };
    /**
     * Finds additional range for the 3D axis based on specified start, end, interval, and size values.
     *
     * @param {Chart3DAxis} axis - The 3D axis to find additional range for.
     * @param {number} start - The start value for the axis range.
     * @param {number} end - The end value for the axis range.
     * @param {number} interval - The interval value for the axis.
     * @param {Size} size - The size of the chart area.
     * @returns {void}
     */
    Double3D.prototype.findAdditional = function (axis, start, end, interval, size) {
        var minimum;
        var maximum;
        minimum = Math.floor(start / interval) * interval;
        maximum = Math.ceil(end / interval) * interval;
        if (axis.rangePadding === 'Additional') {
            minimum -= interval;
            maximum += interval;
        }
        if (!isNullOrUndefined(axis.desiredIntervals)) {
            var delta = maximum - minimum;
            interval = this.calculateNumericNiceInterval(axis, delta, size);
        }
        this.updateActualRange(axis, minimum, maximum, interval);
    };
    /**
     * Finds normal range for the 3D axis based on specified start, end, interval, and size values.
     *
     * @param {Chart3DAxis} axis - The 3D axis to find normal range for.
     * @param {number} start - The start value for the axis range.
     * @param {number} end - The end value for the axis range.
     * @param {number} interval - The interval value for the axis.
     * @param {Size} size - The size of the chart area.
     * @returns {void}
     */
    Double3D.prototype.findNormal = function (axis, start, end, interval, size) {
        var remaining;
        var minimum;
        var maximum;
        var startValue = start;
        if (start < 0) {
            startValue = 0;
            minimum = start + (start * 0.05);
            remaining = interval + (minimum % interval);
            if ((0.365 * interval) >= remaining) {
                minimum -= interval;
            }
            if (minimum % interval < 0) {
                minimum = (minimum - interval) - (minimum % interval);
            }
        }
        else {
            minimum = start < ((5.0 / 6.0) * end) ? 0 : (start - (end - start) * 0.5);
            if (minimum % interval > 0) {
                minimum -= (minimum % interval);
            }
        }
        maximum = (end > 0) ? (end + (end - startValue) * 0.05) : (end - (end - startValue) * 0.05);
        remaining = interval - (maximum % interval);
        if ((0.365 * interval) >= remaining) {
            maximum += interval;
        }
        if (maximum % interval > 0) {
            maximum = (maximum + interval) - (maximum % interval);
        }
        axis.doubleRange = new DoubleRange$1(minimum, maximum);
        if (minimum === 0 || (minimum < 0 && maximum < 0)) {
            interval = this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);
            maximum = Math.ceil(maximum / interval) * interval;
        }
        this.updateActualRange(axis, minimum, maximum, interval);
    };
    /**
     * Calculate visible range for axis.
     *
     * @param {Size} size - Specifies the size of the axis.
     * @param {Chart3DAxis} axis - Specifies the instance of the axis.
     * @returns {void}
     * @private
     */
    Double3D.prototype.calculateVisibleRange = function (size, axis) {
        axis.visibleRange = {
            max: axis.actualRange.max, min: axis.actualRange.min,
            delta: axis.actualRange.delta, interval: axis.actualRange.interval
        };
        if (axis.maximum && axis.orientation === 'Vertical' && axis.rangePadding === 'Auto') {
            var duplicateTempInterval = void 0;
            var tempInterval = axis.visibleRange.min;
            for (; (tempInterval <= axis.visibleRange.max) && (duplicateTempInterval !== tempInterval); tempInterval += axis.visibleRange.interval) {
                duplicateTempInterval = tempInterval;
            }
            if (duplicateTempInterval < axis.visibleRange.max) {
                axis.visibleRange.max = duplicateTempInterval + axis.visibleRange.interval;
            }
        }
        axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);
    };
    /**
     * Calculates the visible label for the axis.
     *
     * @param {Chart3DAxis} axis - Specifies the instance of the axis.
     * @param {Chart3D} chart - Specifies the instance of the chart.
     * @returns {void}
     * @private
     */
    Double3D.prototype.calculateVisibleLabels = function (axis, chart) {
        /*! Generate axis labels */
        axis.visibleLabels = [];
        var tempInterval = axis.visibleRange.min;
        var labelStyle;
        var format = this.getFormat(axis);
        var isCustom = format.match('{value}') !== null;
        var intervalDigits = 0;
        var formatDigits = 0;
        if (axis.labelFormat && axis.labelFormat.indexOf('n') > -1) {
            formatDigits = parseInt(axis.labelFormat.substring(1, axis.labelFormat.length), 10);
        }
        axis.format = chart.intl.getNumberFormat({
            format: isCustom ? '' : format,
            useGrouping: chart.useGroupingSeparator
        });
        axis.startLabel = axis.format(axis.visibleRange.min);
        axis.endLabel = axis.format(axis.visibleRange.max);
        if (axis.visibleRange.interval && (axis.visibleRange.interval + '').indexOf('.') >= 0) {
            intervalDigits = (axis.visibleRange.interval + '').split('.')[1].length;
        }
        var duplicateTempInterval;
        for (; (tempInterval <= axis.visibleRange.max) && (duplicateTempInterval !== tempInterval); tempInterval += axis.visibleRange.interval) {
            duplicateTempInterval = tempInterval;
            labelStyle = (extend({}, getValue('properties', axis.labelStyle), null, true));
            if (withIn(tempInterval, axis.visibleRange)) {
                triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);
            }
        }
        if (tempInterval && (tempInterval + '').indexOf('.') >= 0 && (tempInterval + '').split('.')[1].length > 10) {
            tempInterval = (tempInterval + '').split('.')[1].length > (formatDigits || intervalDigits) ?
                +tempInterval.toFixed(formatDigits || intervalDigits) : tempInterval;
            if (tempInterval <= axis.visibleRange.max) {
                triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);
            }
        }
        if (axis.getMaxLabelWidth) {
            axis.getMaxLabelWidth(this.chart);
        }
    };
    /**
     * Gets the format for the axis label.
     *
     * @param {Chart3DAxis} axis - Specifies the instance of the axis.
     * @returns {string} - Returns the string value.
     * @private
     */
    Double3D.prototype.getFormat = function (axis) {
        if (axis.labelFormat) {
            if (axis.labelFormat.indexOf('p') === 0 && axis.labelFormat.indexOf('{value}') === -1 && axis.isStack100) {
                return '{value}%';
            }
            return axis.labelFormat;
        }
        return axis.isStack100 ? '{value}%' : '';
    };
    /**
     * Formats the axis label.
     *
     * @param {Chart3DAxis} axis - Specifies the instance of the axis.
     * @param {boolean} isCustom - Specifies whether the format is custom.
     * @param {string} format - Specifies the format of the axis label.
     * @param {number} tempInterval - Specifies the interval of the axis label.
     * @returns {string} - Returns the string value.
     * @private
     */
    Double3D.prototype.formatValue = function (axis, isCustom, format, tempInterval) {
        var labelValue = !(tempInterval % 1) ? tempInterval : Number(tempInterval.toLocaleString().split(',').join(''));
        return isCustom ? format.replace('{value}', axis.format(labelValue))
            : format ? axis.format(tempInterval) : axis.format(labelValue);
    };
    /**
     * Gets the module name.
     *
     * @returns {string} - the module name.
     */
    Double3D.prototype.getModuleName = function () {
        /**
         * Returns the module name.
         */
        return 'Double3D';
    };
    return Double3D;
}());

var __extends$99 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$26 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Configures the fonts in charts.
 */
var Chart3DFont = /** @__PURE__ @class */ (function (_super) {
    __extends$99(Chart3DFont, _super);
    function Chart3DFont() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$26([
        Property('Normal')
    ], Chart3DFont.prototype, "fontStyle", void 0);
    __decorate$26([
        Property('16px')
    ], Chart3DFont.prototype, "size", void 0);
    __decorate$26([
        Property('Normal')
    ], Chart3DFont.prototype, "fontWeight", void 0);
    __decorate$26([
        Property('')
    ], Chart3DFont.prototype, "color", void 0);
    __decorate$26([
        Property('Segoe UI')
    ], Chart3DFont.prototype, "fontFamily", void 0);
    __decorate$26([
        Property(1)
    ], Chart3DFont.prototype, "opacity", void 0);
    return Chart3DFont;
}(ChildProperty));

var __extends$98 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$25 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Configures the `rows` of the chart.
 */
var Chart3DRow = /** @__PURE__ @class */ (function (_super) {
    __extends$98(Chart3DRow, _super);
    function Chart3DRow() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** @private */
        _this.axes = [];
        /** @private */
        _this.nearSizes = [];
        /** @private */
        _this.farSizes = [];
        return _this;
    }
    /**
     * Computes the size for a three-dimensional axis, row, or column within the 3D chart.
     *
     * @param {Chart3DAxis} axis - The three-dimensional axis to compute the size for.
     * @param {Chart3D} chart - The 3D chart containing the axis and data definitions.
     * @returns {void}
     */
    Chart3DRow.prototype.computeSize = function (axis, chart) {
        var width = 0;
        var innerPadding = 5;
        if (axis.visible && axis.internalVisibility) {
            width += (axis.majorTickLines.height +
                axis.findLabelSize(innerPadding, chart));
        }
        if (axis.isAxisOpposedPosition) {
            this.farSizes.push(width);
        }
        else {
            this.nearSizes.push(width);
        }
    };
    __decorate$25([
        Property('100%')
    ], Chart3DRow.prototype, "height", void 0);
    return Chart3DRow;
}(ChildProperty));
/**
 * Configures the `columns` of the chart.
 */
var Chart3DColumn = /** @__PURE__ @class */ (function (_super) {
    __extends$98(Chart3DColumn, _super);
    function Chart3DColumn() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** @private */
        _this.axes = [];
        /** @private */
        _this.nearSizes = [];
        /** @private */
        _this.farSizes = [];
        return _this;
    }
    /**
     * Computes the size for a three-dimensional axis, row, or column within the 3D chart.
     *
     * @param {Chart3DAxis} axis - The three-dimensional axis to compute the size for.
     * @param {Chart3D} chart - The 3D chart containing the axis and data definitions.
     * @returns {void}
     */
    Chart3DColumn.prototype.computeSize = function (axis, chart) {
        var height = 0;
        var innerPadding = 5;
        if (axis.visible && axis.internalVisibility) {
            height += (axis.majorTickLines.height +
                axis.findLabelSize(innerPadding, chart));
        }
        if (axis.isAxisOpposedPosition) {
            this.farSizes.push(height);
        }
        else {
            this.nearSizes.push(height);
        }
    };
    __decorate$25([
        Property('100%')
    ], Chart3DColumn.prototype, "width", void 0);
    return Chart3DColumn;
}(ChildProperty));
/**
 * Configures the major grid lines in the `axis`.
 */
var Chart3DMajorGridLines = /** @__PURE__ @class */ (function (_super) {
    __extends$98(Chart3DMajorGridLines, _super);
    function Chart3DMajorGridLines() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$25([
        Property(1)
    ], Chart3DMajorGridLines.prototype, "width", void 0);
    __decorate$25([
        Property(null)
    ], Chart3DMajorGridLines.prototype, "color", void 0);
    return Chart3DMajorGridLines;
}(ChildProperty));
/**
 * Configures the minor grid lines in the `axis`.
 */
var Chart3DMinorGridLines = /** @__PURE__ @class */ (function (_super) {
    __extends$98(Chart3DMinorGridLines, _super);
    function Chart3DMinorGridLines() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$25([
        Property(0.7)
    ], Chart3DMinorGridLines.prototype, "width", void 0);
    __decorate$25([
        Property(null)
    ], Chart3DMinorGridLines.prototype, "color", void 0);
    return Chart3DMinorGridLines;
}(ChildProperty));
/**
 * Configures the major tick lines.
 */
var Chart3DMajorTickLines = /** @__PURE__ @class */ (function (_super) {
    __extends$98(Chart3DMajorTickLines, _super);
    function Chart3DMajorTickLines() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$25([
        Property(0)
    ], Chart3DMajorTickLines.prototype, "width", void 0);
    __decorate$25([
        Property(5)
    ], Chart3DMajorTickLines.prototype, "height", void 0);
    __decorate$25([
        Property(null)
    ], Chart3DMajorTickLines.prototype, "color", void 0);
    return Chart3DMajorTickLines;
}(ChildProperty));
/**
 * Configures the minor tick lines.
 */
var Chart3DMinorTickLines = /** @__PURE__ @class */ (function (_super) {
    __extends$98(Chart3DMinorTickLines, _super);
    function Chart3DMinorTickLines() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$25([
        Property(0)
    ], Chart3DMinorTickLines.prototype, "width", void 0);
    __decorate$25([
        Property(5)
    ], Chart3DMinorTickLines.prototype, "height", void 0);
    __decorate$25([
        Property(null)
    ], Chart3DMinorTickLines.prototype, "color", void 0);
    return Chart3DMinorTickLines;
}(ChildProperty));
/**
 * Configures the axes in the chart.
 *
 * @public
 */
var Chart3DAxis = /** @__PURE__ @class */ (function (_super) {
    __extends$98(Chart3DAxis, _super);
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    function Chart3DAxis(parent, propName, defaultValue, isArray) {
        var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;
        /** @private */
        _this.visibleLabels = [];
        /** @private */
        _this.series = [];
        /** @private */
        _this.rect = new Rect(undefined, undefined, 0, 0);
        /** @private */
        _this.isStack100 = false;
        /** @private */
        _this.updatedRect = null;
        /** @private */
        _this.isIntervalInDecimal = true;
        /** @private */
        _this.intervalDivs = [10, 5, 2, 1];
        /** @private */
        _this.titleCollection = [];
        /** @private */
        _this.titleSize = new Size(0, 0);
        /**
         * This property used to hide the axis when series hide from legend click.
         *
         * @private
         */
        _this.internalVisibility = true;
        /**
         * This property is used to place the vertical axis in opposed position and horizontal axis in inversed.
         * when RTL is enabled in chart
         *
         * @private */
        _this.isRTLEnabled = false;
        _this.angle = _this.labelRotation;
        return _this;
    }
    /**
     * Finds the size of labels with specified inner padding within the 3D chart.
     *
     * @param {number} innerPadding - The inner padding value for labels.
     * @param {Chart3D} chart - The 3D chart for which label size is calculated.
     * @returns {number} - The size of labels accounting for the inner padding.
     */
    Chart3DAxis.prototype.findLabelSize = function (innerPadding, chart) {
        var titleSize = 0;
        var isHorizontal = this.orientation === 'Horizontal';
        if (this.title) {
            var angle = this.titleRotation;
            if ((isNullOrUndefined(angle))) {
                this.titleSize = measureText(this.title, this.titleStyle, chart.themeStyle.axisTitleFont);
                titleSize = this.titleSize.height + innerPadding;
            }
            else {
                this.titleSize = rotateTextSize(this.titleStyle, this.title, angle, chart);
                titleSize = (this.orientation === 'Vertical' ? this.titleSize.width : this.titleSize.height) + innerPadding;
            }
            if (this.rect.width || this.rect.height) {
                var length_1 = isHorizontal ? this.rect.width : this.rect.height;
                this.titleCollection = getTitle(this.title, this.titleStyle, length_1, chart.enableRtl, chart.themeStyle.legendLabelFont);
                titleSize = (titleSize * this.titleCollection.length);
            }
        }
        var labelSize = titleSize + innerPadding + this.titlePadding + this.labelPadding +
            ((this.orientation === 'Vertical') ? this.maxLabelSize.width : this.maxLabelSize.height);
        return labelSize;
    };
    /**
     * Triggers the axis range calculated event with specified minimum, maximum, and interval values.
     *
     * @param {Chart3D} chart - The 3D chart for which the range is being calculated.
     * @param {number} minimum - The minimum value of the range.
     * @param {number} maximum - The maximum value of the range.
     * @param {number} interval - The interval value for the range.
     * @returns {void}
     */
    Chart3DAxis.prototype.triggerRangeRender = function (chart, minimum, maximum, interval) {
        var argsData = {
            cancel: false, axis: this,
            minimum: minimum, maximum: maximum, interval: interval
        };
        chart.trigger(axisRangeCalculated, argsData);
        if (!argsData.cancel) {
            this.visibleRange = {
                min: argsData.minimum, max: argsData.maximum, interval: argsData.interval,
                delta: argsData.maximum - argsData.minimum
            };
        }
    };
    /**
     * Calculate padding for the axis.
     *
     * @param {Chart3D} chart - Chart instance.
     * @returns {string} - Padding value.
     * @private
     */
    Chart3DAxis.prototype.getRangePadding = function (chart) {
        var padding = this.rangePadding;
        if (padding !== 'Auto') {
            return padding;
        }
        switch (this.orientation) {
            case 'Horizontal':
                if (chart.requireInvertedAxis) {
                    padding = (this.isStack100 ? 'Round' : 'Normal');
                }
                else {
                    padding = 'None';
                }
                break;
            case 'Vertical':
                if (!chart.requireInvertedAxis) {
                    padding = (this.isStack100 ? 'Round' : 'Normal');
                }
                else {
                    padding = 'None';
                }
                break;
        }
        return padding;
    };
    /**
     * Calculate maximum label width for the axis.
     *
     * @param {Chart3D} chart - Chart instance.
     * @returns {void}
     * @private
     */
    Chart3DAxis.prototype.getMaxLabelWidth = function (chart) {
        var pointX;
        var previousEnd = 0;
        var isIntersect = false;
        var isAxisLabelBreak;
        this.angle = this.labelRotation;
        this.maxLabelSize = new Size(0, 0);
        var action = this.labelIntersectAction;
        var label;
        for (var i = 0, len = this.visibleLabels.length; i < len; i++) {
            label = this.visibleLabels[i];
            isAxisLabelBreak = isBreakLabel(label.originalText);
            if (isAxisLabelBreak) {
                label.size = measureText(label.originalText.replace(/<br>/g, ' '), this.labelStyle, chart.themeStyle.axisLabelFont);
                label.breakLabelSize = measureText(this.enableTrim ? label.text.join('<br>') : label.originalText, this.labelStyle, chart.themeStyle.axisLabelFont);
            }
            else {
                label.size = measureText(label.text, this.labelStyle, chart.themeStyle.axisLabelFont);
            }
            var width = isAxisLabelBreak ? label.breakLabelSize.width : label.size.width;
            if (width > this.maxLabelSize.width) {
                this.maxLabelSize.width = width;
                this.rotatedLabel = label.text;
            }
            var height = isAxisLabelBreak ? label.breakLabelSize.height : label.size.height;
            if (height > this.maxLabelSize.height) {
                this.maxLabelSize.height = height;
            }
            if (isAxisLabelBreak) {
                label.text = this.enableTrim ? label.text : label.originalText.split('<br>');
            }
            if (action === 'None' || action === 'Hide' || action === 'Trim') {
                continue;
            }
            if ((action !== 'None' || this.angle % 360 === 0) && this.orientation === 'Horizontal' &&
                this.rect.width > 0 && !isIntersect) {
                var width1 = isAxisLabelBreak ? label.breakLabelSize.width : label.size.width;
                pointX = (valueToCoefficients(label.value, this) * this.rect.width) + this.rect.x;
                pointX -= width1 / 2;
                if (this.edgeLabelPlacement === 'Shift') {
                    if (i === 0 && pointX < this.rect.x) {
                        pointX = this.rect.x;
                    }
                    if (i === this.visibleLabels.length - 1 && ((pointX + width1) > (this.rect.x + this.rect.width))) {
                        pointX = this.rect.x + this.rect.width - width1;
                    }
                }
                switch (action) {
                    case 'MultipleRows':
                        if (i > 0) {
                            this.findMultiRows(i, pointX, label, isAxisLabelBreak);
                        }
                        break;
                    case 'Rotate45':
                    case 'Rotate90':
                        if (i > 0 && (!this.isAxisInverse ? pointX <= previousEnd : pointX + width1 >= previousEnd)) {
                            this.angle = (action === 'Rotate45') ? 45 : 90;
                            isIntersect = true;
                        }
                        break;
                    default:
                        if (isAxisLabelBreak) {
                            var result = void 0;
                            var result1 = [];
                            var str = void 0;
                            for (var index = 0; index < label.text.length; index++) {
                                result = textWrap(label.text[index], this.rect.width / this.visibleLabels.length, this.labelStyle, chart.enableRtl, null, null, chart.themeStyle.axisLabelFont);
                                if (result.length > 1) {
                                    for (var j = 0; j < result.length; j++) {
                                        str = result[j];
                                        result1.push(str);
                                    }
                                }
                                else {
                                    result1.push(result[0]);
                                }
                            }
                            label.text = result1;
                        }
                        else {
                            label.text = textWrap(label.text, this.rect.width / this.visibleLabels.length, this.labelStyle, chart.enableRtl, null, null, chart.themeStyle.axisLabelFont);
                        }
                        // eslint-disable-next-line no-case-declarations
                        var height_1 = (label.size.height * label.text.length);
                        if (height_1 > this.maxLabelSize.height) {
                            this.maxLabelSize.height = height_1;
                        }
                        break;
                }
                previousEnd = this.isAxisInverse ? pointX : pointX + width1;
            }
        }
        if (this.angle !== 0 && this.orientation === 'Horizontal') {
            this.rotatedLabel = isNullOrUndefined(this.rotatedLabel) ? '' : this.rotatedLabel;
            var isHorizontalAngle = this.angle === -360 || this.angle === 0 || this.angle === -180 ||
                this.angle === 180 || this.angle === 360;
            if (!isHorizontalAngle && isBreakLabel(this.rotatedLabel)) {
                this.maxLabelSize = new Size(this.maxLabelSize.height, this.maxLabelSize.width);
            }
            this.maxLabelSize = rotateTextSize(this.labelStyle, this.rotatedLabel, this.angle, chart);
        }
        else if (this.angle !== 0 && this.orientation === 'Vertical') {
            this.rotatedLabel = isNullOrUndefined(this.rotatedLabel) ? '' : this.rotatedLabel;
            var isHorizontalAngle = this.angle === -360 || this.angle === 0 || this.angle === -180 ||
                this.angle === 180 || this.angle === 360;
            // To avoid overlap axis label with chart title or chart legend when it is outside.
            if (!isHorizontalAngle && isBreakLabel(this.rotatedLabel)) {
                this.maxLabelSize = new Size(this.maxLabelSize.height, this.maxLabelSize.width);
            }
            this.maxLabelSize = rotateTextSize(this.labelStyle, this.rotatedLabel, this.angle, chart);
        }
    };
    /**
     * Finds and manages multiple rows for labels within the 3D chart axis.
     *
     * @param {number} length - The length of the labels to be considered.
     * @param {number} currentX - The current X position.
     * @param {Visible3DLabels} currentLabel - The label for which multiple rows are being determined.
     * @param {boolean} isBreakLabels - Indicates whether the labels are break labels.
     * @returns {void}
     */
    Chart3DAxis.prototype.findMultiRows = function (length, currentX, currentLabel, isBreakLabels) {
        var label;
        var pointX;
        var width2;
        var store = [];
        var isMultiRows;
        for (var i = length - 1; i >= 0; i--) {
            label = this.visibleLabels[i];
            width2 = isBreakLabels ? label.breakLabelSize.width : label.size.width;
            pointX = (valueToCoefficients(label.value, this) * this.rect.width) + this.rect.x;
            isMultiRows = !this.isAxisInverse ? currentX < (pointX + width2 * 0.5) :
                currentX + currentLabel.size.width > (pointX - width2 * 0.5);
            if (isMultiRows) {
                store.push(label.index);
                currentLabel.index = (currentLabel.index > label.index) ? currentLabel.index : label.index + 1;
            }
            else {
                currentLabel.index = store.indexOf(label.index) > -1 ? currentLabel.index : label.index;
            }
        }
        var height = ((isBreakLabels ? currentLabel.breakLabelSize.height : currentLabel.size.height) * currentLabel.index) +
            (5 * (currentLabel.index - 1));
        if (height > this.maxLabelSize.height) {
            this.maxLabelSize.height = height;
        }
    };
    /**
     * Finds the default module for axis.
     *
     * @param {Chart3D} chart - Chart instance.
     * @returns {void}
     * @private
     */
    Chart3DAxis.prototype.getModule = function (chart) {
        if (this.valueType === 'Double') {
            this.baseModule = new Double3D(chart);
        }
        else {
            this.baseModule = chart[firstToLowerCase(this.valueType) + '3DModule'];
        }
    };
    /**
     * Set the axis `opposedPosition` and `isInversed` properties.
     *
     * @returns {void}
     * @private
     */
    Chart3DAxis.prototype.setIsInversedAndOpposedPosition = function () {
        this.isAxisOpposedPosition = this.opposedPosition || (this.isRTLEnabled && this.orientation === 'Vertical');
        this.isAxisInverse = this.isInversed || (this.isRTLEnabled && this.orientation === 'Horizontal');
    };
    __decorate$25([
        Complex({ fontFamily: null, size: '12px', fontStyle: 'Normal', fontWeight: '400', color: null }, Chart3DFont)
    ], Chart3DAxis.prototype, "labelStyle", void 0);
    __decorate$25([
        Property('')
    ], Chart3DAxis.prototype, "title", void 0);
    __decorate$25([
        Complex({ fontFamily: null, size: '14px', fontStyle: 'Normal', fontWeight: '600', color: null }, Chart3DFont)
    ], Chart3DAxis.prototype, "titleStyle", void 0);
    __decorate$25([
        Property('')
    ], Chart3DAxis.prototype, "labelFormat", void 0);
    __decorate$25([
        Property('')
    ], Chart3DAxis.prototype, "skeleton", void 0);
    __decorate$25([
        Property('DateTime')
    ], Chart3DAxis.prototype, "skeletonType", void 0);
    __decorate$25([
        Property(0)
    ], Chart3DAxis.prototype, "plotOffset", void 0);
    __decorate$25([
        Property(null)
    ], Chart3DAxis.prototype, "plotOffsetLeft", void 0);
    __decorate$25([
        Property(null)
    ], Chart3DAxis.prototype, "plotOffsetTop", void 0);
    __decorate$25([
        Property(null)
    ], Chart3DAxis.prototype, "plotOffsetRight", void 0);
    __decorate$25([
        Property(null)
    ], Chart3DAxis.prototype, "plotOffsetBottom", void 0);
    __decorate$25([
        Property(false)
    ], Chart3DAxis.prototype, "isIndexed", void 0);
    __decorate$25([
        Property(10)
    ], Chart3DAxis.prototype, "logBase", void 0);
    __decorate$25([
        Property(0)
    ], Chart3DAxis.prototype, "columnIndex", void 0);
    __decorate$25([
        Property(0)
    ], Chart3DAxis.prototype, "rowIndex", void 0);
    __decorate$25([
        Property(1)
    ], Chart3DAxis.prototype, "span", void 0);
    __decorate$25([
        Property(null)
    ], Chart3DAxis.prototype, "desiredIntervals", void 0);
    __decorate$25([
        Property(3)
    ], Chart3DAxis.prototype, "maximumLabels", void 0);
    __decorate$25([
        Property(false)
    ], Chart3DAxis.prototype, "opposedPosition", void 0);
    __decorate$25([
        Property('Auto')
    ], Chart3DAxis.prototype, "rangePadding", void 0);
    __decorate$25([
        Property('Double')
    ], Chart3DAxis.prototype, "valueType", void 0);
    __decorate$25([
        Property('None')
    ], Chart3DAxis.prototype, "edgeLabelPlacement", void 0);
    __decorate$25([
        Property('Auto')
    ], Chart3DAxis.prototype, "intervalType", void 0);
    __decorate$25([
        Property('OnTicks')
    ], Chart3DAxis.prototype, "labelPlacement", void 0);
    __decorate$25([
        Property('')
    ], Chart3DAxis.prototype, "name", void 0);
    __decorate$25([
        Property(true)
    ], Chart3DAxis.prototype, "visible", void 0);
    __decorate$25([
        Property(0)
    ], Chart3DAxis.prototype, "minorTicksPerInterval", void 0);
    __decorate$25([
        Property(0)
    ], Chart3DAxis.prototype, "labelRotation", void 0);
    __decorate$25([
        Property(null)
    ], Chart3DAxis.prototype, "titleRotation", void 0);
    __decorate$25([
        Property(null)
    ], Chart3DAxis.prototype, "minimum", void 0);
    __decorate$25([
        Property(null)
    ], Chart3DAxis.prototype, "maximum", void 0);
    __decorate$25([
        Property(null)
    ], Chart3DAxis.prototype, "interval", void 0);
    __decorate$25([
        Property(34)
    ], Chart3DAxis.prototype, "maximumLabelWidth", void 0);
    __decorate$25([
        Property(false)
    ], Chart3DAxis.prototype, "enableTrim", void 0);
    __decorate$25([
        Property(5)
    ], Chart3DAxis.prototype, "labelPadding", void 0);
    __decorate$25([
        Property(5)
    ], Chart3DAxis.prototype, "titlePadding", void 0);
    __decorate$25([
        Complex({}, Chart3DMajorTickLines)
    ], Chart3DAxis.prototype, "majorTickLines", void 0);
    __decorate$25([
        Complex({}, Chart3DMinorTickLines)
    ], Chart3DAxis.prototype, "minorTickLines", void 0);
    __decorate$25([
        Complex({}, Chart3DMajorGridLines)
    ], Chart3DAxis.prototype, "majorGridLines", void 0);
    __decorate$25([
        Complex({}, Chart3DMinorGridLines)
    ], Chart3DAxis.prototype, "minorGridLines", void 0);
    __decorate$25([
        Property(Browser.isDevice ? 'Rotate45' : 'Trim')
    ], Chart3DAxis.prototype, "labelIntersectAction", void 0);
    __decorate$25([
        Property(false)
    ], Chart3DAxis.prototype, "isInversed", void 0);
    __decorate$25([
        Property(true)
    ], Chart3DAxis.prototype, "startFromZero", void 0);
    return Chart3DAxis;
}(ChildProperty));
/**
 * Calculates the axis visible labels.
 *
 * @private
 */
var Visible3DLabels = /** @__PURE__ @class */ (function () {
    function Visible3DLabels(text, value, labelStyle, originalText, size, breakLabelSize, index) {
        if (size === void 0) { size = new Size(0, 0); }
        if (breakLabelSize === void 0) { breakLabelSize = new Size(0, 0); }
        if (index === void 0) { index = 1; }
        this.text = text;
        this.originalText = originalText;
        this.value = value;
        this.labelStyle = labelStyle;
        this.size = size;
        this.breakLabelSize = breakLabelSize;
        this.index = index;
    }
    return Visible3DLabels;
}());

var __extends$100 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$27 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Configures the data label in the series.
 */
var Chart3DDataLabelSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$100(Chart3DDataLabelSettings, _super);
    function Chart3DDataLabelSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$27([
        Property(false)
    ], Chart3DDataLabelSettings.prototype, "visible", void 0);
    __decorate$27([
        Property(null)
    ], Chart3DDataLabelSettings.prototype, "name", void 0);
    __decorate$27([
        Property('transparent')
    ], Chart3DDataLabelSettings.prototype, "fill", void 0);
    __decorate$27([
        Property(null)
    ], Chart3DDataLabelSettings.prototype, "format", void 0);
    __decorate$27([
        Property(1)
    ], Chart3DDataLabelSettings.prototype, "opacity", void 0);
    __decorate$27([
        Property(0)
    ], Chart3DDataLabelSettings.prototype, "angle", void 0);
    __decorate$27([
        Property(false)
    ], Chart3DDataLabelSettings.prototype, "enableRotation", void 0);
    __decorate$27([
        Property('Middle')
    ], Chart3DDataLabelSettings.prototype, "position", void 0);
    __decorate$27([
        Complex({ width: null, color: null }, Border)
    ], Chart3DDataLabelSettings.prototype, "border", void 0);
    __decorate$27([
        Complex({ left: 5, right: 5, top: 5, bottom: 5 }, Margin)
    ], Chart3DDataLabelSettings.prototype, "margin", void 0);
    __decorate$27([
        Complex({ size: '12px', color: null, fontStyle: 'Normal', fontWeight: '400', fontFamily: null }, Chart3DFont)
    ], Chart3DDataLabelSettings.prototype, "font", void 0);
    __decorate$27([
        Property(null)
    ], Chart3DDataLabelSettings.prototype, "template", void 0);
    return Chart3DDataLabelSettings;
}(ChildProperty));
/**
 * Configures the Empty Points of series
 */
var Chart3DEmptyPointSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$100(Chart3DEmptyPointSettings, _super);
    function Chart3DEmptyPointSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$27([
        Property(null)
    ], Chart3DEmptyPointSettings.prototype, "fill", void 0);
    __decorate$27([
        Property('Gap')
    ], Chart3DEmptyPointSettings.prototype, "mode", void 0);
    return Chart3DEmptyPointSettings;
}(ChildProperty));
/**
 * Points model for the series.
 *
 * @public
 */
var Chart3DPoint = /** @__PURE__ @class */ (function () {
    function Chart3DPoint() {
        /** Point symbol location. */
        this.symbolLocations = null;
        /** Point percentage value. */
        this.percentage = null;
        /** To know the point is selected. */
        this.isSelect = false;
    }
    return Chart3DPoint;
}());
/**
 * Configures the series in charts.
 *
 * @public
 */
var Chart3DSeries = /** @__PURE__ @class */ (function (_super) {
    __extends$100(Chart3DSeries, _super);
    function Chart3DSeries(parent, propName, defaultValue, isArray) {
        var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;
        /** @private */
        _this.currentViewData = [];
        /** @private */
        _this.clipRect = new Rect(0, 0, 0, 0);
        _this.visibleSeriesCount = 0;
        /** @private */
        _this.category = 'Series';
        /** @private */
        _this.isRectSeries = false;
        /** @private */
        _this.all = false;
        return _this;
    }
    /**
     * This method is responsible for handling and processing JSON data.
     *
     * @returns {void}
     * @hidden
     */
    Chart3DSeries.prototype.processJsonData = function () {
        var i = 0;
        var point = new Chart3DPoint();
        var xName = this.xName;
        var textMappingName = this instanceof Chart3DSeries && this.dataLabel.name ?
            this.dataLabel.name : '';
        var len = (this.currentViewData || []).length;
        this.points = [];
        this.xMin = Infinity;
        this.xMax = -Infinity;
        this.yMin = Infinity;
        this.yMax = -Infinity;
        this.sizeMax = -Infinity;
        if (this.xAxis.valueType === 'Category') {
            while (i < len) {
                point = this.dataPoint(i, textMappingName, xName);
                this.pushCategoryData(point, i, point.x);
                this.pushData(point, i);
                this.setEmptyPoint(point, i);
                i++;
            }
        }
        else if (this.xAxis.valueType.indexOf('DateTime') > -1) {
            var option = {
                skeleton: 'full',
                type: 'dateTime'
            };
            var dateParser = this.chart.intl.getDateParser(option);
            var dateFormatter = this.chart.intl.getDateFormat(option);
            while (i < len) {
                point = this.dataPoint(i, textMappingName, xName);
                if (!isNullOrUndefined(point.x) && point.x !== '') {
                    point.x = new Date(DataUtil.parse.parseJson({ val: point.x }).val);
                    if (this.xAxis.valueType === 'DateTime') {
                        point.xValue = Date.parse(point.x.toString());
                    }
                    else {
                        this.pushCategoryData(point, i, Date.parse(dateParser(dateFormatter(point.x))).toString());
                    }
                    this.pushData(point, i);
                    this.setEmptyPoint(point, i);
                }
                else {
                    point.visible = false;
                }
                i++;
            }
        }
        else {
            while (i < len) {
                point = this.dataPoint(i, textMappingName, xName);
                point.xValue = point.x;
                this.pushData(point, i);
                this.setEmptyPoint(point, i);
                i++;
            }
        }
    };
    /**
     * Pushes data into a collection at a specified index.
     *
     * @param {Chart3DPoint} point - The Chart3DPoint object representing the data to be pushed.
     * @param {number} i - The index at which the data should be pushed.
     * @returns {void}
     */
    Chart3DSeries.prototype.pushData = function (point, i) {
        point.index = i;
        point.yValue = point.y;
        point.series = this;
        // To find the min, max for the axis range.
        this.xMin = Math.min(this.xMin, point.xValue);
        this.xMax = Math.max(this.xMax, point.xValue);
        this.xData.push(point.xValue);
    };
    /**
     * Creates and returns a Chart3DPoint object representing a data point at the specified index.
     *
     * @param {number} i - The index of the data point.
     * @param {string} textMappingName - The name of the property containing text information for the data point.
     * @param {string} xName - The name of the property containing X-axis information for the data point.
     * @returns {Chart3DPoint} - The Chart3DPoint object representing the data point.
     */
    Chart3DSeries.prototype.dataPoint = function (i, textMappingName, xName) {
        this.points[i] = new Chart3DPoint();
        var point = this.points[i];
        var currentViewData = this.currentViewData[i];
        var getObjectValueByMappingString = this.get3DObjectValue;
        point.x = getObjectValueByMappingString(xName, currentViewData);
        point.interior = getObjectValueByMappingString(this.pointColorMapping, currentViewData);
        if (this instanceof Chart3DSeries) {
            point.y = getObjectValueByMappingString(this.yName, currentViewData);
            point.size = getObjectValueByMappingString(this.size, currentViewData);
            point.text = getObjectValueByMappingString(textMappingName, currentViewData);
            point.tooltip = getObjectValueByMappingString(this.tooltipMappingName, currentViewData);
        }
        return point;
    };
    /**
     * Retrieves the value associated with a specified mapping name from a given data object.
     *
     * @param {string} mappingName - The mapping name used to retrieve the value from the data object.
     * @param {Object} data - The data object from which the value is retrieved.
     * @returns {Object} - The value associated with the specified mapping name in the data object.
     */
    Chart3DSeries.prototype.get3DObjectValue = function (mappingName, data) {
        return data[mappingName];
    };
    /**
     * Sets values for an empty data point at the specified index.
     *
     * @param {Chart3DPoint} point - The Chart3DPoint object representing the empty data point.
     * @param {number} i - The index of the empty data point.
     * @returns {void}
     */
    Chart3DSeries.prototype.setEmptyPoint = function (point, i) {
        if (!this.findVisibility(point)) {
            point.visible = true;
            return null;
        }
        point.isEmpty = true;
        var series = this instanceof Chart3DSeries && this;
        var mode = series.emptyPointSettings.mode;
        switch (mode) {
            case 'Zero':
                point.visible = true;
                point.y = point.yValue = this.yData[i] = 0;
                break;
            case 'Average':
                if (this instanceof Chart3DSeries) {
                    point.y = point.yValue = this.yData[i] = this.getAverage(this.yName, i);
                }
                point.visible = true;
                break;
            case 'Drop':
            case 'Gap':
                this.yData[i] = null;
                point.visible = false;
                break;
        }
    };
    /**
     * Determines the visibility status of a Chart3DPoint.
     *
     * @param {Chart3DPoint} point - The Chart3DPoint object for which visibility is determined.
     * @returns {boolean} - A boolean indicating the visibility status of the Chart3DPoint.
     */
    Chart3DSeries.prototype.findVisibility = function (point) {
        this.setXYMinMax(point.yValue);
        this.yData.push(point.yValue);
        return isNullOrUndefined(point.x) || (isNullOrUndefined(point.y) || isNaN(+point.y));
    };
    /**
     * Sets the minimum and maximum values for the X and Y dimensions based on the provided Y value.
     *
     * @param {number} yValue - The Y value used to set the minimum and maximum values for the X and Y dimensions.
     * @returns {void}
     */
    Chart3DSeries.prototype.setXYMinMax = function (yValue) {
        var isLogAxis = (this.yAxis.valueType === 'Logarithmic' || this.xAxis.valueType === 'Logarithmic');
        var isNegativeValue = yValue < 0 || this.yAxis.rangePadding === 'None';
        var seriesMinY;
        if (!setRange(this.yAxis)) {
            seriesMinY = ((isLogAxis ? (yValue) : isNegativeValue ? yValue : 0));
        }
        else {
            seriesMinY = yValue;
        }
        this.yMin = isLogAxis ?
            Math.min(this.yMin, (isNullOrUndefined(seriesMinY) || isNaN(seriesMinY) || (seriesMinY === 0) ||
                (seriesMinY.toString() === '0') || (seriesMinY.toString() === '')) ? this.yMin : seriesMinY) :
            Math.min(this.yMin, (isNullOrUndefined(seriesMinY) || isNaN(seriesMinY)) ? this.yMin : seriesMinY);
        this.yMax = Math.max(this.yMax, (isNullOrUndefined(yValue) || isNaN(yValue)) ? this.yMax : yValue);
    };
    /**
     * Pushes category data to the Chart3DPoint object at the specified index.
     *
     * @param {Chart3DPoint} point - The Chart3DPoint object to which category data is pushed.
     * @param {number} index - The index at which the category data is pushed.
     * @param {string} pointX - The X value of the category data to be pushed.
     * @returns {void}
     */
    Chart3DSeries.prototype.pushCategoryData = function (point, index, pointX) {
        if (this.chart.tooltip) {
            if (!this.visible) {
                return null;
            }
        }
        if (!this.xAxis.isIndexed) {
            if (this.xAxis.indexLabels[pointX] === undefined) {
                this.xAxis.indexLabels[pointX] = this.xAxis.labels.length;
                this.xAxis.labels.push(pointX);
            }
            point.xValue = this.xAxis.indexLabels[pointX];
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
            this.xAxis.labels[index] ? this.xAxis.labels[index] += ', ' + pointX :
                this.xAxis.labels.push(pointX);
            point.xValue = index;
        }
    };
    /**
     * Calculates the average value of a specified member in the data object.
     *
     * @param {string} member - The member for which the average is calculated.
     * @param {number} i - The index used for the calculation.
     * @param {Object} data - The data object from which the average is calculated. Defaults to the current view data.
     * @returns {number} - The calculated average value.
     */
    Chart3DSeries.prototype.getAverage = function (member, i, data) {
        if (data === void 0) { data = this.currentViewData; }
        var previous = data[i - 1] ? (data[i - 1][member] || 0) : 0;
        var next = data[i + 1] ? (data[i + 1][member] || 0) : 0;
        return (previous + next) / 2;
    };
    /**
     * Refreshes the data manager for the 3D chart.
     *
     * @param {Chart3D} chart - The 3D chart for which the data manager is refreshed.
     * @returns {void}
     */
    Chart3DSeries.prototype.refreshDataManager = function (chart) {
        var _this = this;
        this.chart = chart;
        var dataSource;
        var isAngular = 'isAngular';
        if (chart[isAngular]) {
            dataSource = Object.keys(this.dataSource).length ? this.dataSource : chart.dataSource;
        }
        else {
            dataSource = this.dataSource || chart.dataSource;
        }
        if (!(dataSource instanceof DataManager) && isNullOrUndefined(this.query)) {
            this.dataManagerSuccess({ result: dataSource, count: dataSource.length }, false);
            return;
        }
        var dataManager = this.dataModule.getData(this.dataModule.generateQuery().requiresCount());
        dataManager.then(function (e) { return _this.dataManagerSuccess(e); });
    };
    // eslint-disable-next-line jsdoc/require-param
    /**
     * Handles the success callback for the data manager operation.
     *
     * @param {{ result: Object, count: number }} e - The success callback parameters containing the result and count.
     * @param {boolean} isRemoteData - Indicates whether the data is fetched remotely. Defaults to true.
     * @returns {void}
     */
    Chart3DSeries.prototype.dataManagerSuccess = function (e, isRemoteData) {
        if (isRemoteData === void 0) { isRemoteData = true; }
        this.currentViewData = e.count ? e.result : [];
        this.chart.allowServerDataBinding = false;
        if (this instanceof Chart3DSeries) {
            var argsData = {
                series: this, data: this.currentViewData, fill: this.interior
            };
            this.chart.trigger(seriesRender, argsData);
            this.interior = argsData.fill;
            this.currentViewData = argsData.data;
        }
        this.processJsonData();
        this.refreshChart(isRemoteData);
        this.currentViewData = null;
    };
    /**
     * Refreshes the chart, updating its data and appearance.
     *
     * @param {boolean} isRemoteData - Indicates whether the data is fetched remotely.
     * @returns {void}
     */
    Chart3DSeries.prototype.refreshChart = function (isRemoteData) {
        var chart = this.chart;
        if (this instanceof Chart3DSeries) {
            chart.visibleSeriesCount += isRemoteData ? 1 : 0;
        }
        if (chart.visibleSeries.length === (chart.visibleSeriesCount)) {
            chart.refreshBound();
            chart.trigger('loaded', { chart: chart });
        }
        if (this instanceof Chart3DSeries) {
            chart.visibleSeriesCount += isRemoteData ? 0 : 1;
        }
    };
    /**
     * Refreshes the axis labels in the chart.
     * This method is responsible for updating and rendering the axis labels based on the chart's current state.
     *
     * @returns {void}
     * @public
     */
    Chart3DSeries.prototype.refreshAxisLabel = function () {
        if (this.xAxis.valueType !== 'Category') {
            return null;
        }
        this.xAxis.labels = [];
        this.xAxis.indexLabels = {};
        for (var _i = 0, _a = this.xAxis.series; _i < _a.length; _i++) {
            var item = _a[_i];
            if (item.visible) {
                item.xMin = Infinity;
                item.xMax = -Infinity;
                for (var _b = 0, _c = item.points; _b < _c.length; _b++) {
                    var point = _c[_b];
                    item.pushCategoryData(point, point.index, point.x);
                    item.xMin = Math.min(item.xMin, point.xValue);
                    item.xMax = Math.max(item.xMax, point.xValue);
                }
            }
        }
    };
    /**
     * Finds the collection of Chart3DSeries associated with the given Chart3DColumn and Chart3DRow in the 3D chart.
     *
     * @param {Chart3DColumn} column - The Chart3DColumn object representing the column in the 3D chart.
     * @param {Chart3DRow} row - The Chart3DRow object representing the row in the 3D chart.
     * @param {boolean} isStack - Indicates whether the series should be stacked.
     * @returns {Chart3DSeries[]} - An array of Chart3DSeries associated with the specified column and row.
     * @public
     */
    Chart3DSeries.prototype.findSeriesCollection = function (column, row, isStack) {
        var seriesCollection = [];
        for (var _i = 0, _a = row.axes; _i < _a.length; _i++) {
            var rowAxis = _a[_i];
            for (var _b = 0, _c = rowAxis.series; _b < _c.length; _b++) {
                var rowSeries = _c[_b];
                for (var _d = 0, _e = column.axes; _d < _e.length; _d++) {
                    var axis = _e[_d];
                    for (var _f = 0, _g = axis.series; _f < _g.length; _f++) {
                        var series = _g[_f];
                        if (series === rowSeries && series.visible && this.rectSeriesInChart(series, isStack)) {
                            seriesCollection.push(series);
                        }
                    }
                }
            }
        }
        return seriesCollection;
    };
    /**
     * Checks whether the given Chart3DSeries with rectangular data is present in the 3D chart.
     *
     * @param {Chart3DSeries} series - The Chart3DSeries object to check for presence in the chart.
     * @param {boolean} isStack - Indicates whether the series should be stacked.
     * @returns {boolean} - A boolean value indicating whether the series is present in the 3D chart.
     * @private
     */
    Chart3DSeries.prototype.rectSeriesInChart = function (series, isStack) {
        var type = (series.type).toLowerCase();
        return type.indexOf('column') !== -1 || type.indexOf('bar') !== -1 || isStack;
    };
    /**
     * Calculates the stacked values for the Chart3DSeries based on stacking type and chart context.
     *
     * @param {boolean} isStacking100 - Indicates whether the stacking type is 100% stacking.
     * @param {Chart3D} chart - The parent Chart3D object providing context for the calculation.
     * @returns {void}
     * @private
     */
    Chart3DSeries.prototype.calculateStackedValue = function (isStacking100, chart) {
        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {
            var columnItem = _a[_i];
            for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {
                var item = _c[_b];
                this.calculateStackingValues(this.findSeriesCollection(columnItem, item, true), isStacking100);
            }
        }
    };
    /**
     * Calculates stacking values for the given Chart3DSeries collection based on the stacking type.
     *
     * @param {Chart3DSeries[]} seriesCollection - The collection of Chart3DSeries to calculate stacking values for.
     * @param {boolean} isStacking100 - Indicates whether the stacking type is 100% stacking.
     * @returns {void}
     * @private
     */
    Chart3DSeries.prototype.calculateStackingValues = function (seriesCollection, isStacking100) {
        var startValues;
        var endValues;
        var yValues = [];
        var lastPositive = [];
        var lastNegative = [];
        var stackingGroup;
        var lastValue;
        var value;
        var frequencies = [];
        if (isStacking100) {
            frequencies = this.findFrequencies(seriesCollection);
        }
        var groupingValues = [];
        var visiblePoints = [];
        for (var i = 0; i < seriesCollection.length; i++) {
            var series = seriesCollection[i];
            if (!groupingValues[series.stackingGroup]) {
                groupingValues[series.stackingGroup] = [];
                groupingValues[series.stackingGroup].push(series);
            }
            else if (groupingValues[series.stackingGroup] !== undefined) {
                groupingValues[series.stackingGroup].push(series);
            }
        }
        var keys = Object.keys(groupingValues);
        for (var k = 0; k < keys.length; k++) {
            var stackingSeies = [];
            var stackedValues = [];
            var seriesCollection_2 = groupingValues[keys[k]];
            for (var _i = 0, seriesCollection_1 = seriesCollection_2; _i < seriesCollection_1.length; _i++) {
                var series = seriesCollection_1[_i];
                if (series.type.indexOf('Stacking') !== -1) {
                    stackingGroup = series.stackingGroup;
                    if (!lastPositive[stackingGroup]) {
                        lastPositive[stackingGroup] = [];
                        lastNegative[stackingGroup] = [];
                    }
                    yValues = series.yData;
                    startValues = [];
                    endValues = [];
                    stackingSeies.push(series);
                    visiblePoints = getVisiblePoints(series);
                    for (var j = 0, pointsLength = visiblePoints.length; j < pointsLength; j++) {
                        lastValue = 0;
                        value = +yValues[j]; // Fix for chart not rendering while y value is given as string issue
                        if (lastPositive[stackingGroup][visiblePoints[j].xValue] === undefined) {
                            lastPositive[stackingGroup][visiblePoints[j].xValue] = 0;
                        }
                        if (lastNegative[stackingGroup][visiblePoints[j].xValue] === undefined) {
                            lastNegative[stackingGroup][visiblePoints[j].xValue] = 0;
                        }
                        if (isStacking100) {
                            value = value / frequencies[stackingGroup][visiblePoints[j].xValue] * 100;
                            value = !isNaN(value) ? value : 0;
                            visiblePoints[j].percentage = +(value.toFixed(2));
                        }
                        else {
                            stackedValues[j] = stackedValues[j] ?
                                stackedValues[j] + Math.abs(value) : Math.abs(value);
                        }
                        if (value >= 0) {
                            lastValue = lastPositive[stackingGroup][visiblePoints[j].xValue];
                            lastPositive[stackingGroup][visiblePoints[j].xValue] += value;
                        }
                        else {
                            lastValue = lastNegative[stackingGroup][visiblePoints[j].xValue];
                            lastNegative[stackingGroup][visiblePoints[j].xValue] += value;
                        }
                        startValues.push(lastValue);
                        endValues.push(value + lastValue);
                        if (isStacking100 && (endValues[j] > 100)) {
                            endValues[j] = 100;
                        }
                    }
                    series.stackedValues = new StackValues(startValues, endValues);
                    var isLogAxis = series.yAxis.valueType === 'Logarithmic';
                    var isColumnBarType = (series.type.indexOf('Column') !== -1 || series.type.indexOf('Bar') !== -1);
                    series.yMin = isLogAxis && isColumnBarType && series.yMin < 1 ? series.yMin :
                        Math.min.apply(0, isStacking100 ? startValues : endValues);
                    series.yMax = Math.max.apply(0, endValues);
                    if (series.yMin > Math.min.apply(0, endValues)) {
                        series.yMin = (isStacking100) ? -100 :
                            isLogAxis && isColumnBarType && series.yMin < 1 ? series.yMin : Math.min.apply(0, endValues);
                    }
                    if (series.yMax < Math.max.apply(0, startValues)) {
                        series.yMax = 0;
                    }
                }
            }
            this.findPercentageOfStacking(stackingSeies, stackedValues, isStacking100);
        }
    };
    /**
     * Finds the percentage of stacking for the given Chart3DSeries collection and values.
     *
     * @param {Chart3DSeries[]} stackingSeries - The collection of Chart3DSeries to find the percentage of stacking for.
     * @param {number[]} values - The values to calculate the percentage of stacking.
     * @param {boolean} isStacking100 - Indicates whether the stacking type is 100% stacking.
     * @returns {void}
     */
    Chart3DSeries.prototype.findPercentageOfStacking = function (stackingSeries, values, isStacking100) {
        for (var _i = 0, stackingSeries_1 = stackingSeries; _i < stackingSeries_1.length; _i++) {
            var item = stackingSeries_1[_i];
            if (isStacking100) {
                return null;
            }
            for (var _a = 0, _b = getVisiblePoints(item); _a < _b.length; _a++) {
                var point = _b[_a];
                point.percentage = Math.abs(+(point.y / values[point.index] * 100).toFixed(2));
            }
        }
    };
    /**
     * Finds the frequencies for the given Chart3DSeries collection.
     *
     * @param {Chart3DSeries[]} seriesCollection - The collection of Chart3DSeries to find frequencies for.
     * @returns {number[]} An array of frequencies for each series in the collection.
     * @private
     */
    Chart3DSeries.prototype.findFrequencies = function (seriesCollection) {
        var frequencies = [];
        var stackingGroup;
        var visiblePoints = [];
        for (var _i = 0, seriesCollection_3 = seriesCollection; _i < seriesCollection_3.length; _i++) {
            var series = seriesCollection_3[_i];
            series.yAxis.isStack100 = series.type.indexOf('100') !== -1 ? true : false;
            visiblePoints = this.getVisiblePoints();
            if (series.type.indexOf('Stacking') !== -1) {
                stackingGroup = series.stackingGroup;
                if (!frequencies[stackingGroup]) {
                    frequencies[stackingGroup] = [];
                }
                for (var j = 0, pointsLength = visiblePoints.length; j < pointsLength; j++) {
                    if (frequencies[stackingGroup][visiblePoints[j].xValue] === undefined) {
                        frequencies[stackingGroup][visiblePoints[j].xValue] = 0;
                    }
                    if (series.yData[j] > 0) {
                        frequencies[stackingGroup][visiblePoints[j].xValue] += series.yData[j];
                    }
                    else {
                        frequencies[stackingGroup][visiblePoints[j].xValue] -= series.yData[j];
                    }
                }
            }
        }
        return frequencies;
    };
    /**
     * Renders the Chart3DSeries on the given 3D chart.
     *
     * @param {Chart3D} chart - The 3D chart on which to render the series.
     * @returns {void}
     * @private
     */
    Chart3DSeries.prototype.renderSeries = function (chart) {
        var seriesType = firstToLowerCase(this.type);
        seriesType = seriesType.replace('100', '');
        if (chart[seriesType + 'Series3DModule']) {
            this.visiblePoints = this.getVisiblePoints();
            chart[seriesType + 'Series3DModule'].draw(this, chart);
            if (this.dataLabel.visible && this.visible) {
                chart.dataLabel3DModule.render(this, this.chart, this.dataLabel);
            }
        }
    };
    /**
     * Retrieves the visible data points for the Chart3DSeries.
     * The visibility of points may be influenced by factors such as data filtering or chart settings.
     *
     * @returns {Chart3DPoint[]} An array of Chart3DPoint objects representing the visible data points.
     * @private
     */
    Chart3DSeries.prototype.getVisiblePoints = function () {
        var points = extend([], this.points, null, true);
        var tempPoints = [];
        var tempPoint;
        var pointIndex = 0;
        for (var i = 0; i < points.length; i++) {
            tempPoint = points[i];
            if (isNullOrUndefined(tempPoint.x)) {
                continue;
            }
            else {
                tempPoint.index = pointIndex++;
                tempPoints.push(tempPoint);
            }
        }
        return tempPoints;
    };
    /**
     * Sets the color for a specific Chart3DPoint in the series.
     * This method allows you to customize the color of an individual data point.
     *
     * @param {Chart3DPoint} point - The Chart3DPoint for which to set the color.
     * @param {string} color - The color value to be applied to the data point.
     * @returns {string} The updated color value after applying any modifications or validations.
     * @private
     */
    Chart3DSeries.prototype.setPointColor = function (point, color) {
        color = point.interior || color;
        return point.isEmpty ? (this.emptyPointSettings.fill || color) : color;
    };
    /**
     * Gets the Y values from an array of Chart3DPoint objects.
     *
     * @param {Chart3DPoint[]} points - An array of Chart3DPoint objects.
     * @returns {number[]} An array containing the Y values extracted from the provided data points.
     * @private
     */
    Chart3DSeries.prototype.getYValues = function (points) {
        var values = [];
        var length = points.length;
        for (var i = 0; i < length; i++) {
            values.push(points[i].yValue);
        }
        return values;
    };
    /**
     * Gets the X values from an array of Chart3DPoint objects.
     * This method extracts the X values from a collection of data points.
     *
     * @param {Chart3DPoint[]} points - An array of Chart3DPoint objects.
     * @returns {number[]} An array containing the X values extracted from the provided data points.
     * @private
     */
    Chart3DSeries.prototype.getXValues = function (points) {
        var values = [];
        var length = points.length;
        for (var i = 0; i < length; i++) {
            values.push(points[i].xValue);
        }
        return values;
    };
    /**
     * Gets the segment depth information for a Chart3DSeries.
     * This method retrieves the depth information for the segments of a Chart3DSeries.
     *
     * @param {Chart3DSeries} series - The Chart3DSeries for which segment depth is obtained.
     * @returns {Chart3DDepthInfoType} The depth information for the segments of the specified series.
     * @private
     */
    Chart3DSeries.prototype.getSegmentDepth = function (series) {
        var actualDepth = this.chart.depth;
        var start;
        var end;
        if (this.chart.enableSideBySidePlacement) {
            var space = actualDepth / 4;
            start = space;
            end = space * (series.columnFacet === 'Rectangle' ? 2.5 : 3);
        }
        else {
            var index = series.position - 1;
            var count = series.rectCount;
            var space = actualDepth / ((count * 2) + count + 1);
            start = space + (space * index * 3);
            end = start + space * (series.columnFacet === 'Rectangle' ? 1.5 : 2);
        }
        return { start: start, end: end, delta: end - start };
    };
    /**
     * Calculates the side-by-side positions for segments in a Chart3DSeries.
     * This method determines the positions of segments when they are arranged side-by-side.
     *
     * @param {Chart3DSeries} series - The Chart3DSeries for which side-by-side positions are calculated.
     * @returns {void}
     * @private
     */
    Chart3DSeries.prototype.getSideBySidePositions = function (series) {
        var chart = series.chart;
        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {
            var columnItem = _a[_i];
            for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {
                var item = _c[_b];
                this.findRectPosition(series.findSeriesCollection(columnItem, item, false));
            }
        }
    };
    /**
     * Finds the position of rectangles for a collection of Chart3DSeries.
     * This method determines the position of rectangles based on the given series collection.
     *
     * @param {Chart3DSeries[]} seriesCollection - The collection of Chart3DSeries for which rectangle positions are determined.
     * @returns {void}
     * @private
     */
    Chart3DSeries.prototype.findRectPosition = function (seriesCollection) {
        var groupingValues = [];
        var vSeries = { rectCount: 0, position: null };
        for (var i = 0; i < seriesCollection.length; i++) {
            var value = seriesCollection[i];
            if (value.type.indexOf('Stacking') !== -1 || value.groupName !== '') {
                var groupName = value.type.indexOf('Stacking') !== -1 ? value.stackingGroup : value.type + value.groupName;
                if (groupName) {
                    if (groupingValues[groupName] === undefined) {
                        value.position = vSeries.rectCount;
                        groupingValues[groupName] = vSeries.rectCount++;
                    }
                    else {
                        value.position = groupingValues[groupName];
                    }
                }
                else {
                    if (vSeries.position === null) {
                        vSeries.rectCount++;
                        value.position = vSeries.rectCount;
                        vSeries.position = vSeries.rectCount;
                    }
                    else {
                        value.position = vSeries.position;
                    }
                }
            }
            else {
                vSeries.rectCount++;
                value.position = vSeries.rectCount;
            }
        }
        for (var i = 0; i < seriesCollection.length; i++) {
            var value = seriesCollection[i];
            value.rectCount = vSeries.rectCount;
        }
    };
    /**
     * Gets a range of values between the specified start and end points.
     * This method returns a Chart3DRangeValues object representing the range of values between the given start and end points.
     *
     * @param {number} start - The starting point of the range.
     * @param {number} end - The ending point of the range.
     * @returns {Chart3DRangeValues} - An object representing the range of values between the start and end points.
     */
    Chart3DSeries.prototype.getDoubleRange = function (start, end) {
        var mstart;
        var mend;
        if (start > end) {
            mstart = end;
            mend = start;
        }
        else {
            mstart = start;
            mend = end;
        }
        var mdelta = mend - mstart;
        var mmedian = (mstart + mend) / 2;
        var misEmpty = isNaN(mstart) || isNaN(mend);
        return { start: mstart, end: mend, delta: mdelta, median: mmedian, isEmpty: misEmpty };
    };
    /**
     * Sets the style options for the specified Chart3DSeries.
     * This method applies the style options to customize the appearance of the specified series.
     *
     * @param {Chart3DSeries} series - The Chart3DSeries for which the style options should be set.
     * @returns {Chart3DStyleOptions} - An object representing the style options applied to the series.
     */
    Chart3DSeries.prototype.setStyle = function (series) {
        var options = {
            interior: series.interior,
            opacity: series.opacity,
            dashArray: ''
        };
        return options;
    };
    /**
     * Gets the side-by-side positioning information for the specified Chart3DSeries.
     * This method calculates and returns the range values that define the position of the series in a side-by-side arrangement.
     *
     * @param {Chart3DSeries} series - The Chart3DSeries for which side-by-side positioning information is needed.
     * @returns {Chart3DRangeValues} - An object representing the range values that define the position of the series in a side-by-side arrangement.
     */
    Chart3DSeries.prototype.getSideBySideInfo = function (series) {
        this.chart.currentSeries = series;
        var minimumPointDelta = getMinPointsDeltaValue(series.xAxis, this.chart.visibleSeries);
        var spacing = series.columnSpacing;
        var columnWidth = (series.columnWidth === null || isNaN(+series.columnWidth)) ? 0.7 : Math.min(series.columnWidth, 1);
        this.getSideBySidePositions(series);
        var pos = series.position;
        var all = series.rectCount;
        var width = minimumPointDelta * columnWidth;
        var loc = (pos - (series.stackingGroup === '' ? 1 : 0)) / all - 0.5;
        var range = this.getDoubleRange(loc, loc + (1 / all));
        if (!this.chart.enableSideBySidePlacement) {
            return this.getDoubleRange(-width / 2, width / 2);
        }
        if (!range.isEmpty) {
            range = this.getDoubleRange(range.start * width, range.end * width);
            var radius = spacing * range.delta;
            range = this.getDoubleRange(range.start + radius / 2, range.end - radius / 2);
        }
        return range;
    };
    __decorate$27([
        Property('')
    ], Chart3DSeries.prototype, "xName", void 0);
    __decorate$27([
        Property('')
    ], Chart3DSeries.prototype, "pointColorMapping", void 0);
    __decorate$27([
        Property(true)
    ], Chart3DSeries.prototype, "visible", void 0);
    __decorate$27([
        Property(null)
    ], Chart3DSeries.prototype, "xAxisName", void 0);
    __decorate$27([
        Property(null)
    ], Chart3DSeries.prototype, "yAxisName", void 0);
    __decorate$27([
        Complex({ duration: 2000 }, Animation$1)
    ], Chart3DSeries.prototype, "animation", void 0);
    __decorate$27([
        Property(null)
    ], Chart3DSeries.prototype, "fill", void 0);
    __decorate$27([
        Property('')
    ], Chart3DSeries.prototype, "dataSource", void 0);
    __decorate$27([
        Property()
    ], Chart3DSeries.prototype, "query", void 0);
    __decorate$27([
        Complex({}, Chart3DDataLabelSettings)
    ], Chart3DSeries.prototype, "dataLabel", void 0);
    __decorate$27([
        Property('')
    ], Chart3DSeries.prototype, "name", void 0);
    __decorate$27([
        Property('')
    ], Chart3DSeries.prototype, "yName", void 0);
    __decorate$27([
        Property('')
    ], Chart3DSeries.prototype, "size", void 0);
    __decorate$27([
        Property('')
    ], Chart3DSeries.prototype, "stackingGroup", void 0);
    __decorate$27([
        Property(1)
    ], Chart3DSeries.prototype, "opacity", void 0);
    __decorate$27([
        Property('')
    ], Chart3DSeries.prototype, "groupName", void 0);
    __decorate$27([
        Property('Column')
    ], Chart3DSeries.prototype, "type", void 0);
    __decorate$27([
        Property(true)
    ], Chart3DSeries.prototype, "enableTooltip", void 0);
    __decorate$27([
        Property('')
    ], Chart3DSeries.prototype, "tooltipFormat", void 0);
    __decorate$27([
        Property('')
    ], Chart3DSeries.prototype, "tooltipMappingName", void 0);
    __decorate$27([
        Property('SeriesType')
    ], Chart3DSeries.prototype, "legendShape", void 0);
    __decorate$27([
        Property('')
    ], Chart3DSeries.prototype, "legendImageUrl", void 0);
    __decorate$27([
        Complex(null, Chart3DEmptyPointSettings)
    ], Chart3DSeries.prototype, "emptyPointSettings", void 0);
    __decorate$27([
        Property(null)
    ], Chart3DSeries.prototype, "columnWidth", void 0);
    __decorate$27([
        Property('Rectangle')
    ], Chart3DSeries.prototype, "columnFacet", void 0);
    __decorate$27([
        Property(0.1)
    ], Chart3DSeries.prototype, "columnSpacing", void 0);
    return Chart3DSeries;
}(ChildProperty));

var __extends$101 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$28 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Configures the ToolTips in the chart.
 *
 * @public
 */
var Chart3DTooltipSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$101(Chart3DTooltipSettings, _super);
    function Chart3DTooltipSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$28([
        Property(false)
    ], Chart3DTooltipSettings.prototype, "enable", void 0);
    __decorate$28([
        Property(true)
    ], Chart3DTooltipSettings.prototype, "enableMarker", void 0);
    __decorate$28([
        Property(null)
    ], Chart3DTooltipSettings.prototype, "fill", void 0);
    __decorate$28([
        Property(null)
    ], Chart3DTooltipSettings.prototype, "header", void 0);
    __decorate$28([
        Property(null)
    ], Chart3DTooltipSettings.prototype, "opacity", void 0);
    __decorate$28([
        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: null, color: null }, Font)
    ], Chart3DTooltipSettings.prototype, "textStyle", void 0);
    __decorate$28([
        Property(null)
    ], Chart3DTooltipSettings.prototype, "format", void 0);
    __decorate$28([
        Property(null)
    ], Chart3DTooltipSettings.prototype, "template", void 0);
    __decorate$28([
        Property(true)
    ], Chart3DTooltipSettings.prototype, "enableAnimation", void 0);
    __decorate$28([
        Property(300)
    ], Chart3DTooltipSettings.prototype, "duration", void 0);
    __decorate$28([
        Property(1000)
    ], Chart3DTooltipSettings.prototype, "fadeOutDuration", void 0);
    __decorate$28([
        Property('Move')
    ], Chart3DTooltipSettings.prototype, "fadeOutMode", void 0);
    __decorate$28([
        Property(false)
    ], Chart3DTooltipSettings.prototype, "enableTextWrap", void 0);
    __decorate$28([
        Complex({ color: null, width: null }, Border)
    ], Chart3DTooltipSettings.prototype, "border", void 0);
    __decorate$28([
        Complex({ x: null, y: null }, Location)
    ], Chart3DTooltipSettings.prototype, "location", void 0);
    return Chart3DTooltipSettings;
}(ChildProperty));
/**
 * The `Tooltip` module is used to render the tooltip for chart series.
 */
var Tooltip3D = /** @__PURE__ @class */ (function (_super) {
    __extends$101(Tooltip3D, _super);
    /**
     * Constructor for tooltip module.
     *
     * @param {Chart3D} chart - Specifies the chart instance
     * @private
     */
    function Tooltip3D(chart) {
        var _this = _super.call(this, chart) || this;
        _this.chart3D = chart;
        _this.commonXvalues = [];
        _this.addEventListener();
        return _this;
    }
    /**
     * Adds event listeners for handling mouse and touch events on the chart.
     *
     * @returns {void}
     * @private
     */
    Tooltip3D.prototype.addEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        this.chart.on(cancelEvent, this.mouseLeaveHandler, this);
        this.chart.on('tapHold', this.longPress, this);
        this.chart.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
        this.chart.on(Browser.touchEndEvent, this.mouseUpHandler, this);
    };
    /**
     * Unbinding events for selection module.
     *
     * @returns {void}
     */
    Tooltip3D.prototype.removeEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.off('pointerleave' || 'mouseleave', this.mouseLeaveHandler);
        this.chart.off('tapHold', this.longPress);
        this.chart.off(Browser.touchMoveEvent, this.mouseLeaveHandler);
        this.chart.off(Browser.touchMoveEvent, this.mouseMoveHandler);
        this.chart.off(Browser.touchEndEvent, this.mouseUpHandler);
    };
    /**
     * Handles the mouse up event for the 3D chart.
     *
     * @param {MouseEvent | PointerEvent | TouchEvent} event - The mouse or touch event.
     * @returns {void}
     * @private
     */
    Tooltip3D.prototype.mouseUpHandler = function (event) {
        var _this = this;
        var chart = this.control;
        var data = this.get3dData(event);
        if (chart.isTouch) {
            this.tooltip(event);
            if (chart.tooltip.fadeOutMode === 'Move') {
                this.removeTooltip(chart.tooltip.fadeOutDuration);
                clearTimeout(this.timerId);
                this.timerId = +setTimeout(function () {
                    _this.removeBlurEffect();
                }, 500);
            }
            if (chart.startMove && chart.tooltip.fadeOutMode === 'Move') {
                this.removeTooltip(2000);
                this.removeBlurEffect();
            }
        }
        else if (!this.findData(data, this.previousPoints[0]) && chart.tooltip.fadeOutMode === 'Click') {
            this.removeTooltip(0);
            this.removeBlurEffect();
        }
    };
    /**
     * Handles the mouse leave event for the 3D chart.
     *
     * @returns {void}
     * @private
     */
    Tooltip3D.prototype.mouseLeaveHandler = function () {
        this.removeTooltip(this.chart.tooltip.fadeOutDuration);
        this.removeBlurEffect();
    };
    /**
     * Handles the mouse move event for the 3D chart.
     *
     * @param {MouseEvent | PointerEvent | TouchEvent} event - The mouse move event.
     * @returns {void}
     * @public
     */
    Tooltip3D.prototype.mouseMoveHandler = function (event) {
        var chart = this.chart3D;
        chart.mouseX = chart.mouseX / chart.scaleX;
        chart.mouseY = chart.mouseY / chart.scaleY;
        // Tooltip for chart series.
        if (!chart.disableTrackTooltip && !chart.rotateActivate) {
            if (!chart.isTouch || (chart.startMove)) {
                this.tooltip(event);
            }
        }
    };
    /**
     * Handles the long press on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Tooltip3D.prototype.longPress = function () {
        return false;
    };
    /**
     * To create Tooltip styles for series
     *
     * @returns {void}
     */
    Tooltip3D.prototype.seriesStyles = function () {
        if (!this.styleAdded) {
            var style = document.createElement('style');
            style.setAttribute('id', this.element.id + '_ej2_chart_tooltip');
            style.innerText += ' .' + this.element.id + '_ej2_tooltipDeselected { opacity:' + (0.2) + ';} ';
            document.body.appendChild(style);
            this.styleAdded = true;
        }
    };
    /**
     * Handles the tooltip display for the 3D chart.
     *
     * @param {MouseEvent | PointerEvent | TouchEvent | KeyboardEvent} e - The event triggering the tooltip display.
     * @returns {void}
     * @public
     */
    Tooltip3D.prototype.tooltip = function (e) {
        var elementId = this.element.id + '_tooltip_svg';
        var svgElement = this.getElement(elementId);
        var isTooltip = (svgElement && parseInt(svgElement.getAttribute('opacity'), 10) > 0);
        var tooltipDiv = this.getTooltipElement(isTooltip);
        if (this.chart3D.tooltip3DModule) {
            this.renderSeriesTooltip(this.chart3D, !isTooltip, tooltipDiv, e);
        }
    };
    /**
     * Finds the header for the tooltip based on the provided Point3D.
     *
     * @param {Point3D} data - The Point3D used to find the header.
     * @returns {string} - The header for the tooltip.
     * @private
     */
    Tooltip3D.prototype.findHeader = function (data) {
        if (this.header === '') {
            return '';
        }
        this.header = this.parseTemplate(data.point, data.series, this.header, data.series.xAxis, data.series.yAxis);
        if (this.header.replace(/<b>/g, '').replace(/<\/b>/g, '').trim() !== '') {
            return this.header;
        }
        return '';
    };
    /**
     * Renders the tooltip for the series in the 3D chart.
     *
     * @param {Chart3D} chart - The 3D chart instance.
     * @param {boolean} isFirst - A boolean indicating whether it is the first series.
     * @param {HTMLDivElement} tooltipDiv - The tooltip div element.
     * @param {MouseEvent | PointerEvent | TouchEvent | KeyboardEvent} e - The event that triggered the tooltip.
     * @returns {void}
     * @private
     */
    Tooltip3D.prototype.renderSeriesTooltip = function (chart, isFirst, tooltipDiv, e) {
        var data = this.get3dData(e);
        this.currentPoints = [];
        if (this.findData(data, this.previousPoints[0]) &&
            ((this.previousPoints[0] && !((this.previousPoints[0].point.index === data.point.index && this.previousPoints[0].series.index
                === data.series.index) && this.chart3D.isRemove)) || !this.previousPoints[0])) {
            if (this.pushData(data, isFirst, tooltipDiv, true)) {
                this.triggerTooltipRender(data, isFirst, this.getTooltipText(data), this.findHeader(data));
            }
        }
        else if (!data.point && this.chart3D.isRemove && chart.tooltip.fadeOutMode === 'Move') {
            this.removeTooltip(this.chart.tooltip.fadeOutDuration);
            this.removeBlurEffect();
            this.chart3D.isRemove = false;
        }
        if (data && data.point) {
            this.findMouseValue(data, chart);
        }
    };
    /**
     * Triggers the rendering of the tooltip with the specified point and text information.
     *
     * @param {Point3D} point - The data point for which the tooltip is triggered.
     * @param {boolean} isFirst - A boolean indicating whether it is the first series.
     * @param {string} textCollection - The text information to be displayed in the tooltip.
     * @param {string} headerText - The header text for the tooltip.
     * @returns {void}
     * @private
     */
    Tooltip3D.prototype.triggerTooltipRender = function (point, isFirst, textCollection, headerText) {
        var _this = this;
        var tooltipTemplate;
        var argsData = {
            cancel: false, text: textCollection, headerText: headerText, template: tooltipTemplate,
            textStyle: this.textStyle,
            data: {
                pointX: point.point.x, pointY: point.point.y, seriesIndex: point.series.index, seriesName: point.series.name,
                pointIndex: point.point.index, pointText: point.point.text
            }
        };
        var borderWidth = this.chart.border.width;
        var padding = 3;
        var chartTooltipSuccess = function (argsData) {
            if (!argsData.cancel) {
                _this.headerText = argsData.headerText;
                _this.formattedText = _this.formattedText.concat(argsData.text);
                _this.text = _this.formattedText;
                _this.createTooltip(_this.chart, isFirst, _this.getSymbolLocation(point), point.series.clipRect, point.point, _this.chart3D.tooltip.enableMarker ? ['Circle'] : [], 0, new Rect(borderWidth, borderWidth, _this.chart.availableSize.width - padding - borderWidth * 2, _this.chart.availableSize.height - padding - borderWidth * 2), false, null, _this.getTemplateText(point), _this.template ? argsData.template : '');
                _this.blurEffect(_this.chart3D.visibleSeries, point.series);
            }
            else {
                _this.removeHighlight();
                remove(_this.getElement(_this.element.id + '_tooltip'));
            }
            _this.chart3D.isRemove = true;
        };
        chartTooltipSuccess.bind(this, point);
        this.chart.trigger(tooltipRender, argsData, chartTooltipSuccess);
    };
    /**
     * Applies a blur effect to the specified series while removing the effect from others.
     *
     * @param {Chart3DSeries[]} visibleSeries - The array of visible series in the 3D chart.
     * @param {Chart3DSeries} tooltipSeries - The series associated with the tooltip.
     * @returns {void}
     * @private
     */
    Tooltip3D.prototype.blurEffect = function (visibleSeries, tooltipSeries) {
        if (!this.chart3D.highlight3DModule || (this.chart3D.legendSettings.enableHighlight && this.chart3D.highlightMode === 'None')) {
            var pointElements_1 = [];
            for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
                var series = visibleSeries_1[_i];
                if (series.visible && series.index !== tooltipSeries.index) {
                    var elements = document.querySelectorAll("[id*=\"region-series-" + series.index + "\"]");
                    elements.forEach(function (el) {
                        pointElements_1.push(el);
                    });
                }
                else if (series.visible) {
                    var tooltipElements = document.querySelectorAll("[id*=\"region-series-" + series.index + "\"]");
                    for (var i = 0; i < tooltipElements.length; i++) {
                        var element = tooltipElements[i];
                        var elementClassName = element.getAttribute('class') || '';
                        if (elementClassName.indexOf(this.element.id + '_ej2_tooltipDeselected') > -1) {
                            element.setAttribute('class', elementClassName.replace(this.element.id + '_ej2_tooltipDeselected', ''));
                        }
                        this.chart3D.stopElementAnimation(element, series.index);
                    }
                }
            }
            for (var i = 0; i < pointElements_1.length; i++) {
                if (pointElements_1[i]) {
                    var elementClassName = pointElements_1[i].getAttribute('class') || '';
                    elementClassName += ((elementClassName !== '') ? ' ' : '');
                    if (elementClassName.indexOf('_selection_') === -1 && elementClassName.indexOf(this.element.id + '_ej2_tooltipDeselected') === -1) {
                        pointElements_1[i].setAttribute('class', elementClassName + this.element.id + '_ej2_tooltipDeselected');
                    }
                }
            }
        }
    };
    Tooltip3D.prototype.removeBlurEffect = function () {
        if (!this.chart3D.highlight3DModule || (this.chart3D.legendSettings.enableHighlight && this.chart3D.highlightMode === 'None')) {
            var elements = document.getElementsByClassName(this.element.id + '_ej2_tooltipDeselected');
            while (elements.length > 0) {
                var element = elements[0];
                var elementClassName = element.getAttribute('class') || '';
                if (elementClassName.indexOf(this.element.id + '_ej2_tooltipDeselected') > -1) {
                    element.setAttribute('class', elementClassName.replace(this.element.id + '_ej2_tooltipDeselected', ''));
                    var index = parseFloat(element.id.split('-series-')[1].split('-point-')[0]);
                    this.chart3D.highlightAnimation(element, index, 700, 0.2);
                }
            }
        }
    };
    /**
     * Gets the location of the symbol based on the current mouse position in the chart.
     *
     * @param {Point3D} point - The tooltip point.
     * @returns {ChartLocation} - The location of the tooltip.
     * @private
     */
    Tooltip3D.prototype.getSymbolLocation = function (point) {
        var rect = document.getElementById(this.element.id + '_svg').getBoundingClientRect();
        var upperElement;
        if (point.series.columnFacet === 'Cylinder') {
            upperElement = document.querySelectorAll('[id*="' + this.element.id + '-svg-' + (point.series.type.indexOf('Column') === -1 ? '0' : '1') + '-region-series-' + point.series.index + '-point-' + point.point.index + '"]');
        }
        else {
            upperElement = document.querySelectorAll('[id*="' + this.element.id + '-svg-' + (point.series.type.indexOf('Column') === -1 ? '5' : '2') + '-region-series-' + point.series.index + '-point-' + point.point.index + '"]');
        }
        var tooltipElement;
        if (upperElement) {
            if (upperElement.length === 1) {
                tooltipElement = upperElement[0].getBoundingClientRect();
            }
            else {
                for (var i = 0; i < upperElement.length; i++) {
                    var element = upperElement[i];
                    if (element.id.indexOf('-' + point.point.index + '-back-front') !== -1 || element.id.indexOf('-' + point.point.index + '-front-back') !== -1) {
                        tooltipElement = element.getBoundingClientRect();
                        break;
                    }
                }
            }
            if (!tooltipElement && upperElement.length !== 0) {
                tooltipElement = upperElement[0].getBoundingClientRect();
            }
        }
        var location = new ChartLocation((this.chart3D.tooltip.location.x !== null) ? this.chart3D.tooltip.location.x :
            tooltipElement.left - rect.left + (tooltipElement.width / 2), (this.chart3D.tooltip.location.y !== null) ?
            this.chart3D.tooltip.location.y : tooltipElement.top - rect.top + (tooltipElement.height / 2));
        return location;
    };
    /**
     * Gets the tooltip text based on the provided point data.
     *
     * @param {Point3D} pointData - The data of the point for which the tooltip is generated.
     * @returns {string} - The tooltip text.
     * @private
     */
    Tooltip3D.prototype.getTooltipText = function (pointData) {
        return this.parseTemplate(pointData.point, pointData.series, this.getFormat(this.chart3D, pointData.series), pointData.series.xAxis, pointData.series.yAxis);
    };
    /**
     * Gets the template text based on the provided data.
     *
     * @param {any} data - The data object for which the template text is generated.
     * @returns {Chart3DPoint | Chart3DPoint[]} - The template text.
     * @private
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Tooltip3D.prototype.getTemplateText = function (data) {
        if (this.template) {
            var point = extend({}, data.point);
            point.x = this.formatPointValue(data.point, data.series.xAxis, 'x', true, false);
            point.y = this.formatPointValue(data.point, data.series.yAxis, 'y', false, true);
            return point;
        }
        else {
            return data.point;
        }
    };
    /**
     * Finds the mouse value based on the provided data and chart.
     *
     * @param {Point3D} data - The data object containing information about the point.
     * @param {Chart3D} chart - The Chart3D instance.
     * @returns {void}
     * @private
     */
    Tooltip3D.prototype.findMouseValue = function (data, chart) {
        if (!chart.requireInvertedAxis) {
            this.valueX = valueToCoefficients(data.point.xValue, data.series.xAxis) *
                data.series.xAxis.rect.width + data.series.xAxis.rect.x;
            this.valueY = chart.mouseY;
        }
        else {
            this.valueY = (1 - valueToCoefficients(data.point.xValue, data.series.xAxis)) * data.series.xAxis.rect.height
                + data.series.xAxis.rect.y;
            this.valueX = chart.mouseX;
        }
    };
    /**
     * Parses the template using the provided point, series, format, xAxis, and yAxis information.
     *
     * @param {Chart3DPoint} point - The point for which the template needs to be parsed.
     * @param {Chart3DSeries} series - The series associated with the point.
     * @param {string} format - The format string.
     * @param {Chart3DAxis} xAxis - The X-axis of the chart.
     * @param {Chart3DAxis} yAxis - The Y-axis of the chart.
     * @returns {string} - The parsed template string.
     * @private
     */
    Tooltip3D.prototype.parseTemplate = function (point, series, format, xAxis, yAxis) {
        var val;
        var textValue;
        for (var _i = 0, _a = Object.keys(point); _i < _a.length; _i++) {
            var dataValue = _a[_i];
            // eslint-disable-next-line security/detect-non-literal-regexp
            val = new RegExp('${point' + '.' + dataValue + '}', 'gm');
            format = format.replace(val.source, this.formatPointValue(point, val.source === '${point.x}' ? xAxis : yAxis, dataValue, val.source === '${point.x}', (val.source === '${point.y}')));
        }
        for (var _b = 0, _c = Object.keys(Object.getPrototypeOf(series)); _b < _c.length; _b++) {
            var dataValue = _c[_b];
            // eslint-disable-next-line security/detect-non-literal-regexp
            val = new RegExp('${series' + '.' + dataValue + '}', 'gm');
            textValue = series[dataValue];
            format = format.replace(val.source, textValue);
        }
        return format;
    };
    /**
     * Formats the point value based on the provided point, axis, dataValue, and other flags.
     *
     * @param {Chart3DPoint} point - The point for which the value needs to be formatted.
     * @param {Chart3DAxis} axis - The axis associated with the point.
     * @param {string} dataValue - The data value to be formatted.
     * @param {boolean} isXPoint - Indicates whether the point is on the X-axis.
     * @param {boolean} isYPoint - Indicates whether the point is on the Y-axis.
     * @returns {string} - The formatted point value.
     * @private
     */
    Tooltip3D.prototype.formatPointValue = function (point, axis, dataValue, isXPoint, isYPoint) {
        var textValue;
        var customLabelFormat;
        var value;
        if (axis.valueType !== 'Category' && isXPoint) {
            customLabelFormat = axis.labelFormat && axis.labelFormat.match('{value}') !== null;
            textValue = customLabelFormat ? axis.labelFormat.replace('{value}', axis.format(point[dataValue])) :
                axis.format(point[dataValue]);
        }
        else if (isYPoint && !isNullOrUndefined(point[dataValue])) {
            customLabelFormat = axis.labelFormat && axis.labelFormat.match('{value}') !== null;
            value = axis.format(point[dataValue]);
            textValue = customLabelFormat ? axis.labelFormat.replace('{value}', value) : value;
        }
        else {
            textValue = point[dataValue];
        }
        return textValue;
    };
    /**
     * Gets the format for the tooltip based on the provided chart and series.
     *
     * @param {Chart3D} chart - The 3D chart instance.
     * @param {Chart3DSeries} series - The 3D series for which the tooltip format is needed.
     * @returns {string} - The tooltip format.
     * @private
     */
    Tooltip3D.prototype.getFormat = function (chart, series) {
        if (series.tooltipFormat) {
            return series.tooltipFormat;
        }
        if (!series.tooltipFormat && chart.tooltip.format) {
            return chart.tooltip.format;
        }
        var textX = '${point.x}';
        var format = textX;
        return format + ' : ' + ('<b>${point.y}</b>');
    };
    /**
     * Gets the 3D data (point and series) associated with the provided event in the chart.
     *
     * @param {MouseEvent | PointerEvent | TouchEvent | KeyboardEvent} event - The event for which to retrieve 3D data.
     * @returns {Point3D} - The 3D data object containing the point and series information.
     * @private
     */
    Tooltip3D.prototype.get3dData = function (event) {
        var chart = this.chart3D;
        var point = null;
        var series = null;
        var currentX = this.chart3D.mouseX;
        var currentY = this.chart3D.mouseY;
        var rect = this.chart3D.chartAxisLayoutPanel.seriesClipRect;
        var index;
        var pointIndex;
        var seriesIndex;
        var targetElement = event.target;
        if (targetElement && currentX > rect.x && currentX < (rect.x + rect.width) &&
            currentY > rect.y && currentY < (rect.y + rect.height)) {
            var nodeName = targetElement.nodeName;
            if ((nodeName === 'path' || nodeName === 'shape') && targetElement.id.indexOf('region') > 1) {
                index = targetElement.id.match(/(\d+)/g);
                pointIndex = parseInt(index[index.length - 1].toString(), 10);
                seriesIndex = parseInt(index[index.length - 2].toString(), 10);
            }
        }
        if (!isNullOrUndefined(seriesIndex)) {
            series = chart.visibleSeries[seriesIndex];
        }
        if (series) {
            if (series.visible) {
                point = series.points[pointIndex];
            }
            if (point) {
                return new Point3D(point, series);
            }
        }
        return new Point3D(point, series);
    };
    /**
     * Finds data based on the provided 3D data and the previous 3D data.
     *
     * @param {Point3D} data - The current 3D data.
     * @param {Point3D} previous - The previous 3D data.
     * @returns {boolean} - Returns true if the data is found based on the conditions.
     * @private
     */
    Tooltip3D.prototype.findData = function (data, previous) {
        return data.point && ((!previous || (previous.point !== data.point)) || (previous.point === data.point));
    };
    /**
     * Gets the module name.
     *
     * @returns {string} - The module name.
     */
    Tooltip3D.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'Tooltip3D';
    };
    /**
     * To destroy the tooltip.
     *
     * @returns {void}
     * @private
     */
    Tooltip3D.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
        this.removeEventListener();
    };
    return Tooltip3D;
}(BaseTooltip));

var __extends$102 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$29 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Chart legend
 */
/**
 * Configures the legends in charts.
 */
var Chart3DLegendSettings = /** @__PURE__ @class */ (function (_super) {
    __extends$102(Chart3DLegendSettings, _super);
    function Chart3DLegendSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$29([
        Property(true)
    ], Chart3DLegendSettings.prototype, "visible", void 0);
    __decorate$29([
        Property(null)
    ], Chart3DLegendSettings.prototype, "height", void 0);
    __decorate$29([
        Property(null)
    ], Chart3DLegendSettings.prototype, "width", void 0);
    __decorate$29([
        Complex({ x: 0, y: 0 }, Location)
    ], Chart3DLegendSettings.prototype, "location", void 0);
    __decorate$29([
        Property('Auto')
    ], Chart3DLegendSettings.prototype, "position", void 0);
    __decorate$29([
        Property('Series')
    ], Chart3DLegendSettings.prototype, "mode", void 0);
    __decorate$29([
        Property(8)
    ], Chart3DLegendSettings.prototype, "padding", void 0);
    __decorate$29([
        Property(null)
    ], Chart3DLegendSettings.prototype, "itemPadding", void 0);
    __decorate$29([
        Property('Center')
    ], Chart3DLegendSettings.prototype, "alignment", void 0);
    __decorate$29([
        Complex({ fontFamily: null, size: "14px", fontStyle: 'Normal', fontWeight: '400', color: null }, Font)
    ], Chart3DLegendSettings.prototype, "textStyle", void 0);
    __decorate$29([
        Property(10)
    ], Chart3DLegendSettings.prototype, "shapeHeight", void 0);
    __decorate$29([
        Property(10)
    ], Chart3DLegendSettings.prototype, "shapeWidth", void 0);
    __decorate$29([
        Complex({}, Border)
    ], Chart3DLegendSettings.prototype, "border", void 0);
    __decorate$29([
        Complex({ left: 0, right: 0, top: 0, bottom: 0 }, Margin)
    ], Chart3DLegendSettings.prototype, "margin", void 0);
    __decorate$29([
        Complex({ left: 0, right: 0, top: 0, bottom: 0 }, ContainerPadding)
    ], Chart3DLegendSettings.prototype, "containerPadding", void 0);
    __decorate$29([
        Property(8)
    ], Chart3DLegendSettings.prototype, "shapePadding", void 0);
    __decorate$29([
        Property('transparent')
    ], Chart3DLegendSettings.prototype, "background", void 0);
    __decorate$29([
        Property(1)
    ], Chart3DLegendSettings.prototype, "opacity", void 0);
    __decorate$29([
        Property(true)
    ], Chart3DLegendSettings.prototype, "toggleVisibility", void 0);
    __decorate$29([
        Property(false)
    ], Chart3DLegendSettings.prototype, "enableHighlight", void 0);
    __decorate$29([
        Property(null)
    ], Chart3DLegendSettings.prototype, "description", void 0);
    __decorate$29([
        Property(3)
    ], Chart3DLegendSettings.prototype, "tabIndex", void 0);
    __decorate$29([
        Property(null)
    ], Chart3DLegendSettings.prototype, "title", void 0);
    __decorate$29([
        Complex({ fontFamily: null, size: "14px", fontStyle: 'Normal', fontWeight: '600', color: null }, Font)
    ], Chart3DLegendSettings.prototype, "titleStyle", void 0);
    __decorate$29([
        Property('Top')
    ], Chart3DLegendSettings.prototype, "titlePosition", void 0);
    __decorate$29([
        Property('Normal')
    ], Chart3DLegendSettings.prototype, "textWrap", void 0);
    __decorate$29([
        Property('Ellipsis')
    ], Chart3DLegendSettings.prototype, "textOverflow", void 0);
    __decorate$29([
        Property(100)
    ], Chart3DLegendSettings.prototype, "maximumTitleWidth", void 0);
    __decorate$29([
        Property(null)
    ], Chart3DLegendSettings.prototype, "maximumLabelWidth", void 0);
    __decorate$29([
        Property(true)
    ], Chart3DLegendSettings.prototype, "enablePages", void 0);
    __decorate$29([
        Property(false)
    ], Chart3DLegendSettings.prototype, "isInversed", void 0);
    __decorate$29([
        Property(false)
    ], Chart3DLegendSettings.prototype, "reverse", void 0);
    return Chart3DLegendSettings;
}(ChildProperty));
/**
 * The `Legend` module is used to render legend for the chart.
 */
var Legend3D = /** @__PURE__ @class */ (function (_super) {
    __extends$102(Legend3D, _super);
    function Legend3D(chart) {
        var _this = _super.call(this, chart) || this;
        _this.library = _this;
        _this.addEventListener();
        return _this;
    }
    /**
     * Binding events for legend module.
     *
     * @returns {void}
     */
    Legend3D.prototype.addEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
        this.chart.on('click', this.click, this);
        this.chart.on(Browser.touchEndEvent, this.mouseEnd, this);
    };
    /**
     * Unbinding events for legend module.
     *
     * @returns {void}
     */
    Legend3D.prototype.removeEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.off(Browser.touchMoveEvent, this.mouseMove);
        this.chart.off('click', this.click);
        this.chart.off(Browser.touchEndEvent, this.mouseEnd);
    };
    /**
     * To handle mosue move for legend module
     *
     * @param {MouseEvent} e - Specifies the mouse event.
     * @returns {void}
     */
    Legend3D.prototype.mouseMove = function (e) {
        if (this.chart.legendSettings.visible && !this.chart.isTouch) {
            this.move(e);
            if (this.chart.highlight3DModule && (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight)) {
                var legendItemsId = [this.legendID + '_text_', this.legendID + '_shape_marker_',
                    this.legendID + '_shape_', this.legendID + '_g_'];
                var targetId = e.target.id;
                var index = void 0;
                for (var _i = 0, legendItemsId_1 = legendItemsId; _i < legendItemsId_1.length; _i++) {
                    var id = legendItemsId_1[_i];
                    if (targetId.indexOf(id) > -1) {
                        index = parseInt(targetId.split(id)[1], 10);
                        this.chart.highlight3DModule.legendSelection(this.chart, index, e.target, e.type);
                        break;
                    }
                }
            }
        }
    };
    /**
     * To handle mouse end for legend module
     *
     * @param {MouseEvent} e - Specifies the mouse event.
     * @returns {void}
     */
    Legend3D.prototype.mouseEnd = function (e) {
        if (this.chart.legendSettings.visible && this.chart.isTouch) {
            this.move(e);
        }
    };
    /**
     * Retrieves and returns legend options for the visible series within a 3D chart.
     *
     * @param {Chart3DSeries[]} visibleSeriesCollection - The collection of visible series to extract legend options from.
     * @param {Chart3D} chart - The 3D chart containing the series and legend.
     * @returns {void}
     */
    Legend3D.prototype.getLegendOptions = function (visibleSeriesCollection, chart) {
        this.legendCollections = [];
        var seriesType;
        var fill;
        this.isRtlEnable = chart.enableRtl;
        this.isReverse = !this.isRtlEnable && chart.legendSettings.reverse;
        if (visibleSeriesCollection.length > 1) {
            this.legend.mode = 'Series';
        }
        for (var _i = 0, visibleSeriesCollection_1 = visibleSeriesCollection; _i < visibleSeriesCollection_1.length; _i++) {
            var series = visibleSeriesCollection_1[_i];
            if (this.legend.mode === 'Series') {
                seriesType = series.type;
                // To set legend color when use pointColorMapping
                fill = (series.pointColorMapping && series.points.length > 0) ?
                    (series.points[0].interior ? series.points[0].interior : series.interior) : series.interior;
                this.legendCollections.push(new LegendOptions(series.name, fill, series.legendShape, series.visible, seriesType, series.legendImageUrl ? series.legendImageUrl : '', 'None', false, null, null));
            }
            else if (this.legend.mode === 'Point') {
                var _loop_1 = function (points) {
                    seriesType = series.type;
                    fill = points.interior ? points.interior : series.interior;
                    if (this_1.legendCollections.filter(function (i) { return i.text === points.x.toString(); }).length === 0) {
                        this_1.legendCollections.push(new LegendOptions(points.x.toString(), fill, series.legendShape, points.visible, seriesType, '', 'None', false));
                    }
                };
                var this_1 = this;
                for (var _a = 0, _b = series.points; _a < _b.length; _a++) {
                    var points = _b[_a];
                    _loop_1(points);
                }
            }
        }
        if (this.isReverse) {
            this.legendCollections.reverse();
        }
    };
    /**
     * Calculates and retrieves the legend bounds within the available size for the provided legend settings.
     *
     * @param {Size} availableSize - The available size for positioning the legend.
     * @param {Rect} legendBounds - The initial bounds of the legend.
     * @param {Chart3DLegendSettingsModel} legend - The customization option for the legend.
     * @returns {void}
     */
    Legend3D.prototype.get3DLegendBounds = function (availableSize, legendBounds, legend) {
        this.calculateLegendTitle(legend, legendBounds);
        this.isTitle = legend.title ? true : false;
        this.chartRowCount = 1;
        this.rowHeights = [];
        this.columnHeights = [];
        this.pageHeights = [];
        var padding = legend.padding;
        var titlePosition = legend.titlePosition;
        var extraHeight = 0;
        var legendOption;
        var extraWidth = 0;
        var arrowWidth = this.arrowWidth;
        var arrowHeight = this.arrowHeight;
        var verticalArrowSpace = this.isVertical && !legend.enablePages ? arrowHeight : 0;
        var titleSpace = this.isTitle && titlePosition === 'Top' ? this.legendTitleSize.height + this.fivePixel : 0;
        titleSpace = this.isTitle && this.isVertical && titlePosition !== 'Top' ? this.legendTitleSize.height + this.fivePixel : titleSpace;
        if (!this.isVertical) {
            extraHeight = !legend.height ? ((availableSize.height / 100) * 5) : 0;
        }
        else {
            extraWidth = !legend.width ? ((availableSize.width / 100) * 5) : 0;
        }
        legendBounds.height += (extraHeight);
        legendBounds.width += extraWidth;
        var shapeWidth = legend.shapeWidth;
        var shapePadding = legend.shapePadding;
        var maximumWidth = 0;
        var rowWidth = 0;
        var legendWidth = 0;
        var columnHeight = 0;
        var columnCount = 0;
        var rowCount = 0;
        var titlePlusArrowSpace = 0;
        var legendEventArgs;
        var render = false;
        this.maxItemHeight = Math.max(measureText('MeasureText', legend.textStyle, this.chart.themeStyle.legendLabelFont).height, legend.shapeHeight);
        for (var i = 0; i < this.legendCollections.length; i++) {
            legendOption = this.legendCollections[i];
            if (regSub.test(legendOption.text)) {
                legendOption.text = getUnicodeText(legendOption.text, regSub);
            }
            if (regSup.test(legendOption.text)) {
                legendOption.text = getUnicodeText(legendOption.text, regSup);
            }
            legendEventArgs = {
                fill: legendOption.fill, text: legendOption.text, shape: legendOption.shape,
                cancel: false
            };
            this.chart.trigger(legendRender, legendEventArgs);
            legendOption.render = !legendEventArgs.cancel;
            legendOption.text = legendEventArgs.text;
            legendOption.fill = legendEventArgs.fill;
            legendOption.shape = legendEventArgs.shape;
            legendOption.markerShape = 'None';
            legendOption.textSize = measureText(legendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont);
            shapeWidth = legendOption.text ? legend.shapeWidth : 0;
            shapePadding = legendOption.text ? legend.shapePadding : 0;
            if (legendOption.render && legendOption.text) {
                render = true;
                legendWidth = shapeWidth + shapePadding + (legend.maximumLabelWidth ? legend.maximumLabelWidth :
                    legendOption.textSize.width) + (!this.isVertical ? (i === 0) ? padding : this.itemPadding : padding);
                rowWidth = rowWidth + legendWidth;
                if (!legend.enablePages && !this.isVertical) {
                    titlePlusArrowSpace = this.isTitle && titlePosition !== 'Top' ? this.legendTitleSize.width + this.fivePixel : 0;
                    titlePlusArrowSpace += arrowWidth;
                }
                this.getLegendHeight(legendOption, legend, legendBounds, rowWidth, this.maxItemHeight, padding);
                if (legendBounds.width < (padding + rowWidth + titlePlusArrowSpace) || this.isVertical) {
                    maximumWidth = Math.max(maximumWidth, (rowWidth + padding + titlePlusArrowSpace - (this.isVertical ? 0 : legendWidth)));
                    if (rowCount === 0 && (legendWidth !== rowWidth)) {
                        rowCount = 1;
                    }
                    rowWidth = this.isVertical ? 0 : legendWidth;
                    rowCount++;
                    columnCount = 0;
                    columnHeight = verticalArrowSpace;
                }
                var len = (rowCount > 0 ? (rowCount - 1) : 0);
                this.rowHeights[len] = Math.max((this.rowHeights[len] ? this.rowHeights[len] : 0), legendOption.textSize.height);
                this.columnHeights[columnCount] = (this.columnHeights[columnCount] ?
                    this.columnHeights[columnCount] : 0) +
                    legendOption.textSize.height + (this.isVertical ? (i === 0) ? padding : this.itemPadding : padding);
                columnCount++;
            }
        }
        columnHeight = Math.max.apply(null, this.columnHeights) + padding + titleSpace;
        columnHeight = Math.max(columnHeight, (this.maxItemHeight + padding) + padding + titleSpace);
        this.isPaging = legendBounds.height < columnHeight;
        if (this.isPaging && !legend.enablePages) {
            if (this.isVertical) {
                // eslint-disable-next-line no-self-assign
                columnHeight = columnHeight;
            }
            else {
                columnHeight = (this.maxItemHeight + padding) + padding + (titlePosition === 'Top' ? titleSpace : 0);
            }
        }
        this.totalPages = rowCount;
        if (!this.isPaging && !this.isVertical) {
            rowWidth += this.isTitle && titlePosition !== 'Top' ? (this.fivePixel + this.legendTitleSize.width + this.fivePixel) : 0;
        }
        if (render) {
            this.setBounds(Math.max((rowWidth + padding), maximumWidth), columnHeight, legend, legendBounds);
        }
        else {
            this.setBounds(0, 0, legend, legendBounds);
        }
    };
    /**
     * Calculates and retrieves the height of the legend within the specified legend bounds and based on the provided options and settings.
     *
     * @param {LegendOptions} legendOption - The options and data for the legend.
     * @param {Chart3DLegendSettingsModel} legend - The customization options for the legend.
     * @param {Rect} legendBounds - The bounds of the legend.
     * @param {number} rowWidth - The width of a row within the legend.
     * @param {number} legendHeight - The initial height of the legend.
     * @param {number} padding - The padding applied to the legend.
     * @returns {void}
     * @private
     */
    Legend3D.prototype.getLegendHeight = function (legendOption, legend, legendBounds, rowWidth, legendHeight, padding) {
        var legendWidth = legendOption.textSize.width;
        var textPadding = legend.shapePadding + (padding * 2) + legend.shapeWidth;
        switch (legend.textWrap) {
            case 'Wrap':
            case 'AnyWhere':
                if (legendWidth > legend.maximumLabelWidth || legendWidth + rowWidth > legendBounds.width) {
                    legendOption.textCollection = textWrap(legendOption.text, (legend.maximumLabelWidth ? Math.min(legend.maximumLabelWidth, (legendBounds.width - textPadding)) :
                        (legendBounds.width - textPadding)), legend.textStyle, this.chart.enableRtl, null, null, this.chart.themeStyle.legendLabelFont);
                }
                else {
                    legendOption.textCollection.push(legendOption.text);
                }
                legendOption.textSize.height = (legendHeight * legendOption.textCollection.length);
                break;
        }
    };
    /**
     * Calculates and retrieves the render point (position) for the legend item within the legend area.
     *
     * @param {LegendOptions} legendOption - The options and data for the legend item.
     * @param {ChartLocation} start - The starting point for positioning the legend item.
     * @param {number} textPadding - The padding applied to the legend text.
     * @param {LegendOptions} prevLegend - The previous legend item for reference.
     * @param {Rect} rect - The bounding rectangle of the legend area.
     * @param {number} count - The index of the legend item within the legend.
     * @param {number} firstLegend - The index of the first legend item.
     * @returns {void}
     * @private
     */
    Legend3D.prototype.getRenderPoint = function (legendOption, start, textPadding, prevLegend, rect, count, firstLegend) {
        var padding = this.legend.padding;
        var textWidth = textPadding + (this.legend.maximumLabelWidth ?
            this.legend.maximumLabelWidth : prevLegend.textSize.width);
        var previousBound = prevLegend.location.x + ((!this.isRtlEnable) ? textWidth : -textWidth);
        if (this.isWithinBounds(previousBound, (this.legend.maximumLabelWidth ?
            this.legend.maximumLabelWidth : legendOption.textSize.width) + textPadding - this.itemPadding, rect) || this.isVertical) {
            legendOption.location.x = start.x;
            if (count !== firstLegend) {
                this.chartRowCount++;
            }
            legendOption.location.y = (count === firstLegend) ? prevLegend.location.y :
                prevLegend.location.y + (this.isVertical ? prevLegend.textSize.height :
                    this.rowHeights[(this.chartRowCount - 2)]) + (this.isVertical ? this.itemPadding : padding);
        }
        else {
            legendOption.location.x = (count === firstLegend) ? prevLegend.location.x : previousBound;
            legendOption.location.y = prevLegend.location.y;
        }
        var availwidth = (!this.isRtlEnable) ? (this.legendBounds.x + this.legendBounds.width) - (legendOption.location.x +
            textPadding - this.itemPadding - this.legend.shapeWidth / 2) :
            (legendOption.location.x - textPadding + this.itemPadding + (this.legend.shapeWidth / 2)) - this.legendBounds.x;
        if (!this.isVertical && this.isPaging && !this.legend.enablePages) {
            availwidth = this.legendBounds.width - legendOption.location.x - this.fivePixel;
        }
        availwidth = this.legend.maximumLabelWidth ? Math.min(this.legend.maximumLabelWidth, availwidth) : availwidth;
        if (this.legend.textOverflow === 'Ellipsis' && this.legend.textWrap === 'Normal') {
            legendOption.text = textTrim(+availwidth.toFixed(4), legendOption.text, this.legend.textStyle, this.chart.enableRtl, this.chart.themeStyle.legendLabelFont);
        }
    };
    /**
     * Checks whether the previous bound  width is within the given rectangular bounds.
     *
     * @param {number} previousBound - The previous bound (position) of an element.
     * @param {number} textWidth - The width of the text or element to be positioned.
     * @param {Rect} rect - The rectangular bounds to check against.
     * @returns {boolean} - True if the element is within the bounds; otherwise, false.
     * @private
     */
    Legend3D.prototype.isWithinBounds = function (previousBound, textWidth, rect) {
        if (!this.isRtlEnable) {
            return (previousBound + textWidth) > (rect.x + rect.width + (this.legend.shapeWidth / 2));
        }
        else {
            return (previousBound - textWidth) < (rect.x - (this.legend.shapeWidth / 2));
        }
    };
    /**
     * Handles the click event on a legend item at the specified index.
     *
     * @param {number} index - The index of the legend item clicked.
     * @param {Event | PointerEvent} event - The click or pointer event.
     * @returns {void}
     * @private
     */
    Legend3D.prototype.LegendClick = function (index, event) {
        var chart = this.chart;
        var seriesIndex = chart.legendSettings.mode === 'Series' ? index : 0;
        var legendIndex = !this.isReverse ? index : (this.legendCollections.length - 1) - index;
        var series = chart.visibleSeries[seriesIndex];
        var legend = this.legendCollections[legendIndex];
        var changeDetection = 'isProtectedOnChange';
        if (chart.legendSettings.mode === 'Series') {
            var legendClickArgs = {
                legendText: legend.text, legendShape: legend.shape,
                series: series, cancel: false
            };
            this.chart.trigger(legendClick, legendClickArgs);
            series.legendShape = legendClickArgs.legendShape;
            if (!legendClickArgs.cancel) {
                if (series.fill !== null) {
                    chart.visibleSeries[index].interior = series.fill;
                }
                if (chart.legendSettings.toggleVisibility) {
                    series.chart[changeDetection] = true;
                    this.changeSeriesVisiblity(series, series.visible);
                    legend.visible = series.visible;
                    this.refreshLegendToggle(chart, series);
                }
                else if (chart.highlight3DModule) {
                    chart.highlight3DModule.legendSelection(chart, index, event.target, event.type);
                }
                else if (chart.selection3DModule) {
                    chart.selection3DModule.legendSelection(chart, index, event.target, event.type);
                }
                series.chart[changeDetection] = false;
            }
        }
        else if (chart.legendSettings.mode === 'Point') {
            var point = series.points[index];
            var legendClickArgs = {
                legendText: legend.text, legendShape: legend.shape,
                series: series, cancel: false
            };
            this.chart.trigger(legendClick, legendClickArgs);
            if (chart.legendSettings.toggleVisibility && !legendClickArgs.cancel) {
                point.visible = !point.visible;
                var legendOption = this.legendCollections[index];
                legendOption.visible = point.visible;
                this.refreshLegendToggle(chart, series);
            }
        }
    };
    /**
     * Refreshes the legend toggle behavior for the specified series in a 3D chart.
     *
     * @param {Chart3D} chart - The 3D chart containing the legend and series.
     * @param {Chart3DSeries} series - The series for which the legend toggle behavior is refreshed.
     * @returns {void}
     * @private
     */
    Legend3D.prototype.refreshLegendToggle = function (chart, series) {
        var selectedDataIndexes = [];
        if (chart.selection3DModule) {
            selectedDataIndexes = extend([], chart.selection3DModule.selectedDataIndexes, null, true);
        }
        if ((chart.svgObject.childNodes.length > 0)) {
            while (chart.svgObject.lastChild) {
                chart.svgObject.removeChild(chart.svgObject.lastChild);
            }
            remove(chart.svgObject);
        }
        chart.animateSeries = false;
        removeElement$1(getElement(chart.element.id + '_Secondary_Element').querySelectorAll('.ejSVGTooltip')[0]);
        this.redrawSeriesElements(series, chart);
        chart.removeSvg();
        chart.refreshAxis();
        series.refreshAxisLabel();
        this.refreshSeries(chart.visibleSeries);
        chart.polygons = [];
        chart.refreshBound();
        chart.trigger('loaded', { chart: chart });
        if (selectedDataIndexes.length > 0) {
            chart.selection3DModule.selectedDataIndexes = selectedDataIndexes;
            chart.selection3DModule.redrawSelection(chart, chart.selectionMode);
        }
        if (chart.highlight3DModule && chart.highlightMode !== 'None' || chart.legendSettings.enableHighlight) {
            chart.highlight3DModule.redrawSelection(chart, chart.highlightMode);
        }
        chart.redraw = false;
    };
    /**
     * Changes the visibility of the specified series in a 3D chart.
     *
     * @param {Chart3DSeries} series - The series whose visibility is being changed.
     * @param {boolean} visibility - The new visibility state for the series (true for visible, false for hidden).
     * @returns {void}
     * @private
     */
    Legend3D.prototype.changeSeriesVisiblity = function (series, visibility) {
        series.visible = !visibility;
        if (this.isSecondaryAxis(series.xAxis)) {
            series.xAxis.internalVisibility = series.xAxis.series.some(function (value) { return (value.visible); });
        }
        if (this.isSecondaryAxis(series.yAxis)) {
            series.yAxis.internalVisibility = series.yAxis.series.some(function (value) { return (value.visible); });
        }
    };
    /**
     * Checks whether the specified axis is a secondary axis within the 3D chart.
     *
     * @param {Chart3DAxis} axis - The axis to be checked.
     * @returns {boolean} - True if the axis is a secondary axis, otherwise, false.
     * @private
     */
    Legend3D.prototype.isSecondaryAxis = function (axis) {
        return (this.chart.axes.indexOf(axis) > -1);
    };
    /**
     * Redraws the elements of a 3D series on the chart.
     *
     * @param {Chart3DSeries} series - The 3D series to redraw.
     * @param {Chart3D} chart - The 3D chart instance.
     * @returns {void}
     * @private
     */
    Legend3D.prototype.redrawSeriesElements = function (series, chart) {
        if (!chart.redraw) {
            return null;
        }
        removeElement$1(chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) +
            '_DataLabelCollections');
    };
    /**
     * Refreshes the position information of each series in a collection.
     *
     * @param {Chart3DSeries[]} seriesCollection - The collection of 3D series to refresh.
     * @returns {void}
     * @private
     */
    Legend3D.prototype.refreshSeries = function (seriesCollection) {
        for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {
            var series = seriesCollection_1[_i];
            series.position = undefined;
        }
    };
    /**
     * To show the tooltip for the trimmed text in legend.
     *
     * @param {Event | PointerEvent} event - Specifies the event.
     * @returns {void}
     * @private
     */
    Legend3D.prototype.click = function (event) {
        if (!this.chart.legendSettings.visible) {
            return;
        }
        var targetId = event.target.id.indexOf('_chart_legend_g_') > -1 ?
            event.target.firstChild['id'] : event.target.id;
        var legendItemsId = [this.legendID + '_text_', this.legendID + '_shape_marker_',
            this.legendID + '_shape_'];
        var seriesIndex;
        for (var _i = 0, legendItemsId_2 = legendItemsId; _i < legendItemsId_2.length; _i++) {
            var id = legendItemsId_2[_i];
            if (targetId.indexOf(id) > -1) {
                seriesIndex = parseInt(targetId.split(id)[1], 10);
                this.LegendClick(seriesIndex, event);
                break;
            }
        }
        if (targetId.indexOf(this.legendID + '_pageup') > -1) {
            this.changePage(event, true);
        }
        else if (targetId.indexOf(this.legendID + '_pagedown') > -1) {
            this.changePage(event, false);
        }
    };
    /**
     * Get module name
     *
     * @returns {string} - Returns the module name
     */
    Legend3D.prototype.getModuleName = function () {
        return 'Legend3D';
    };
    /**
     * To destroy the legend module.
     *
     * @returns {void}
     * @private
     */
    Legend3D.prototype.destroy = function () {
        this.removeEventListener();
    };
    return Legend3D;
}(BaseLegend));

var __extends$97 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$24 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * The Chart3D class represents a 3D chart component that extends the Component class
 * and implements the INotifyPropertyChanged interface.
 *
 * @public
 * @__PURE__ @class
 * @extends Component<HTMLElement>
 * @implements {INotifyPropertyChanged} INotifyPropertyChanged
 */
var Chart3D = /** @__PURE__ @class */ (function (_super) {
    __extends$97(Chart3D, _super);
    /**
     * Constructor for creating the 3D chart
     *
     * @param {Chart3DModel} options - Specifies the 3D chart model.
     * @param {string | HTMLElement} element - Specifies the element for the 3D chart.
     * @hidden
     */
    function Chart3D(options, element) {
        var _this = _super.call(this, options, element) || this;
        _this.previousTargetId = '';
        _this.currentPointIndex = 0;
        _this.currentSeriesIndex = 0;
        _this.currentLegendIndex = 0;
        /** @public */
        _this.animated = false;
        /** @private */
        _this.isPointMouseDown = false;
        /** @private */
        _this.visible = 0;
        /** @private */
        _this.clickCount = 0;
        /** @private */
        _this.maxPointCount = 0;
        /** @private */
        _this.singleClickTimer = 0;
        /** @private */
        _this.isRtlEnabled = false;
        /** @private */
        _this.scaleX = 1;
        /** @private */
        _this.scaleY = 1;
        _this.chartId = 57723;
        /** @private */
        _this.isLegendClicked = false;
        /** @private */
        _this.rotateActivate = false;
        /** @private */
        _this.isRemove = false;
        /** @private */
        _this.polygons = [];
        return _this;
    }
    /**
     * Checks if the given elementId has special characters and modifies it if necessary.
     *
     * @param {string} elementId - The input elementId to be checked.
     * @returns {string} - The modified elementId.
     */
    Chart3D.prototype.isIdHasSpecialCharacter = function (elementId) {
        var regex = /^[A-Za-z ]+$/;
        var numberRegex = /^[0-9 ]+$/;
        var childElementId = '';
        if (!regex.test(elementId)) {
            var start = 0;
            if (numberRegex.test(elementId[0])) {
                childElementId += ('\\3' + elementId[0]);
                start = 1;
            }
            for (var i = start; i < elementId.length; i++) {
                if (!regex.test(elementId[i]) && elementId.indexOf('-') === -1 &&
                    elementId.indexOf('_') === -1 && elementId.indexOf('\\') === -1 && !numberRegex.test(elementId[i])) {
                    childElementId += ('\\' + elementId[i]);
                }
                else {
                    childElementId += elementId[i];
                }
            }
            return childElementId;
        }
        else {
            return elementId;
        }
    };
    /**
     * For internal use only - Initialize the event handler;
     *
     * @returns {void}
     */
    Chart3D.prototype.preRender = function () {
        this.element.id = this.isIdHasSpecialCharacter(this.element.id);
        this.allowServerDataBinding = false;
        this.unWireEvents();
        this.initPrivateVariable();
        this.setCulture();
        this.wireEvents();
        this.element.setAttribute('dir', this.enableRtl ? 'rtl' : '');
    };
    /**
     * Initializes private variables and prepares the chart component for rendering.
     *
     * @returns {void}
     */
    Chart3D.prototype.initPrivateVariable = function () {
        this.delayRedraw = false;
        this.animateSeries = true;
        this.horizontalAxes = [];
        this.verticalAxes = [];
        this.polygons = [];
        this.vector = new Vector3D(0, 0, 0);
        this.wallRender = new WallRenderer();
        this.matrixObj = new Matrix3D();
        this.bspTreeObj = new BinaryTreeBuilder();
        this.polygon = new Polygon3D();
        this.graphics = new Graphics3D();
        this.transform3D = new ChartTransform3D();
        this.svg3DRenderer = new Svg3DRenderer();
        this.axisRender = new AxisRenderer();
        this.chart3DRender = new Chart3DRender();
        this.chartAxisLayoutPanel = new CartesianAxisLayoutPanel$1(this);
        this.refreshAxis();
        this.refreshDefinition(this.rows);
        this.refreshDefinition(this.columns);
        if (this.tooltip3DModule) {
            this.tooltip3DModule.previousPoints = [];
        }
        this.element.setAttribute('role', 'region');
        this.element.setAttribute('tabindex', '0');
        this.element.setAttribute('aria-label', this.description || this.title + '. Syncfusion interactive chart.');
        if (!(this.element.classList.contains('e-chart-focused'))) {
            this.element.setAttribute('class', this.element.getAttribute('class') + ' e-chart-focused');
        }
        if (this.element.id === '') {
            var collection = document.getElementsByClassName('e-chart').length;
            this.element.id = 'chart_' + this.chartId + '_' + collection;
        }
        this.svgId = this.element.id + '_svg';
    };
    /**
     * Method to set culture for chart.
     *
     * @returns {void}
     */
    Chart3D.prototype.setCulture = function () {
        this.intl = new Internationalization();
        this.localeObject = new L10n(this.getModuleName(), this.defaultLocalConstants, this.locale);
    };
    /**
     * To Initialize the 3D chart rendering.
     *
     * @returns {void}
     */
    Chart3D.prototype.render = function () {
        var _this = this;
        this.svgRenderer = new SvgRenderer(this.element.id);
        var loadEventData = {
            chart: this, theme: this.theme, cancel: false
        };
        /**
         * Load event for the 3D chart componet.
         */
        this.trigger(load, loadEventData, function () {
            if (!loadEventData.cancel) {
                _this.cartesianChartRendering();
            }
        });
    };
    /**
     * Renders the chart using a Cartesian coordinate system.
     *
     * This function is responsible for rendering the chart's graphical elements and data points using a Cartesian coordinate system.
     * It may include actions such as drawing axes, plotting data, and applying visual styles.
     *
     * @returns {void}
     */
    Chart3D.prototype.cartesianChartRendering = function () {
        this.setTheme();
        this.createChartSvg();
        this.calculateVisibleSeries();
        this.calculateVisibleAxis();
        this.processData();
        this.renderComplete();
        this.allowServerDataBinding = true;
    };
    /**
     * Method to create SVG element.
     *
     * @returns {void}
     */
    Chart3D.prototype.createChartSvg = function () {
        this.removeSvg();
        createSvg(this);
    };
    /**
     * Method to remove the SVG.
     *
     * @returns {void}
     * @private
     */
    Chart3D.prototype.removeSvg = function () {
        if (this.redraw) {
            return null;
        }
        removeElement(this.element.id + '_Secondary_Element');
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (this.isReact) {
            this.clearTemplate();
        }
        var removeLength = 0;
        if (this.svgObject) {
            while (this.svgObject.childNodes.length > removeLength) {
                this.svgObject.removeChild(this.svgObject.firstChild);
            }
            if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode) {
                remove(this.svgObject);
            }
        }
    };
    /**
     * Processes and prepares data for rendering.
     *
     * @param {boolean} render - (Optional) Indicates whether to trigger rendering after data processing.
     * @returns {void}
     */
    Chart3D.prototype.processData = function (render) {
        if (render === void 0) { render = true; }
        this.visibleSeriesCount = 0;
        var check = true;
        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            if (!series.visible && !this.legendSettings.visible) {
                this.visibleSeriesCount++;
                continue;
            }
            this.initializeDataModule(series);
        }
        if (render && (!this.visibleSeries.length || this.visibleSeriesCount === this.visibleSeries.length && check)) {
            this.refreshBound();
            this.trigger('loaded', { chart: this });
        }
    };
    /**
     * Initializes the data module for a three-dimensional series.
     *
     * @param {Chart3DSeries} series - The series for which data module is initialized.
     * @returns {void}
     */
    Chart3D.prototype.initializeDataModule = function (series) {
        series.xData = [];
        series.yData = [];
        var dataSource;
        var isAngular = 'isAngular';
        if (this[isAngular]) {
            dataSource = Object.keys(series.dataSource).length ? series.dataSource : this.dataSource;
        }
        else {
            dataSource = series.dataSource || this.dataSource;
        }
        series.dataModule = new Data(dataSource, series.query);
        series.points = [];
        series.refreshDataManager(this);
    };
    /**
     * Animate the series bounds.
     *
     * @private
     */
    Chart3D.prototype.animate = function (duration) {
        this.redraw = true;
        this.animated = true; //used to set duration as 1000 for animation at default 300
        this.duration = duration ? duration : 1000;
    };
    /**
     * Refresh the chart bounds.
     *
     * @private
     * @returns {void}
     */
    Chart3D.prototype.refreshBound = function () {
        if (this.legend3DModule && this.legendSettings.visible) {
            this.legend3DModule.getLegendOptions(this.visibleSeries, this);
        }
        if (this.tooltip.enable && this.tooltip3DModule) {
            this.tooltip3DModule.previousPoints = [];
        }
        this.calculateStackValues();
        this.calculateBounds();
        this.renderElements();
        removeElement('chartmeasuretext');
        this.removeSelection();
    };
    /**
     * Clears the selection state in the chart.
     *
     * @returns {void}
     */
    Chart3D.prototype.removeSelection = function () {
        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            if (series.visible) {
                for (var _b = 0, _c = series.points; _b < _c.length; _b++) {
                    var point = _c[_b];
                    point.isSelect = false;
                }
            }
        }
    };
    /**
     * Calculates stacked values for three-dimensional series in the chart.
     *
     * @returns {void}
     */
    Chart3D.prototype.calculateStackValues = function () {
        var series;
        var isCalculateStacking = false;
        for (var i = 0, len = this.visibleSeries.length; i < len; i++) {
            series = this.visibleSeries[i];
            series.position = series.rectCount = undefined;
            if (((series.type.indexOf('Stacking') !== -1)) && !isCalculateStacking) {
                series.calculateStackedValue(series.type.indexOf('100') > -1, this);
                isCalculateStacking = true;
            }
        }
    };
    /**
     * Calculates the bounds and dimensions for the chart area.
     *
     * @returns {void}
     */
    Chart3D.prototype.calculateBounds = function () {
        var margin = this.margin;
        // Title Height;
        var titleHeight = 0;
        var subTitleHeight = 0;
        var titleWidth = 0;
        var padding = this.titleStyle.position === 'Top' || (this.titleStyle.position === 'Bottom') ? 15 : 5;
        var left = margin.left + this.border.width;
        var width = this.availableSize.width - left - margin.right - this.border.width;
        var elementSpacing = 0;
        var top = margin.top + this.border.width;
        var height = this.availableSize.height - top - this.border.width - margin.bottom;
        this.titleCollection = [];
        this.subTitleCollection = [];
        if (this.title) {
            this.titleCollection = getTitle(this.title, this.titleStyle, (this.titleStyle.position === 'Left' || this.titleStyle.position === 'Right' ? height : width), this.enableRtl, this.themeStyle.chartTitleFont);
            titleHeight = (measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont).height * this.titleCollection.length) + padding;
            if (this.subTitle) {
                var maxWidth = 0;
                for (var _i = 0, _a = this.titleCollection; _i < _a.length; _i++) {
                    var titleText = _a[_i];
                    titleWidth = measureText(titleText, this.titleStyle, this.themeStyle.chartSubTitleFont).width;
                    maxWidth = titleWidth > maxWidth ? titleWidth : maxWidth;
                }
                this.subTitleCollection = getTitle(this.subTitle, this.subTitleStyle, maxWidth, this.enableRtl, this.themeStyle.chartSubTitleFont);
                subTitleHeight = (measureText(this.subTitle, this.subTitleStyle, this.themeStyle.chartSubTitleFont).height * this.subTitleCollection.length) +
                    padding;
            }
        }
        else if (this.legendSettings.position !== 'Top' && this.border.width) {
            elementSpacing = 10;
        }
        top = margin.top + elementSpacing + this.border.width;
        height = this.availableSize.height - top - this.border.width - margin.bottom;
        var marginTotal = subTitleHeight + titleHeight + this.titleStyle.border.width + this.subTitleStyle.border.width;
        switch (this.titleStyle.position) {
            case 'Top':
                top += marginTotal;
                height -= marginTotal;
                break;
            case 'Bottom':
                height -= marginTotal;
                break;
            case 'Left':
                left += marginTotal;
                width -= marginTotal;
                break;
            case 'Right':
                left -= (this.titleStyle.border.width + this.subTitleStyle.border.width);
                width -= marginTotal;
                break;
        }
        this.initialClipRect = new Rect(left, top, width, height);
        if (this.legend3DModule && this.legendSettings.visible) {
            this.legend3DModule.calculateLegendBounds(this.initialClipRect, this.availableSize, null);
        }
        this.chartAxisLayoutPanel.measureAxis(this.initialClipRect);
    };
    /**
     * Renders various chart elements, including the border, title, series, legend, and datalabel etc.
     *
     * @returns {void}
     */
    Chart3D.prototype.renderElements = function () {
        this.renderBorder();
        this.renderTitle();
        this.createSeriesElements();
        this.render3DChart();
        this.renderLegend();
        this.performSelection();
        this.setSecondaryElementPosition();
        this.doAnimation();
    };
    /**
     * Animates the height of an SVG element.
     *
     * @param {HTMLElement} element - The SVG element to animate.
     * @param {Chart3DSeries} series - The series related to the animation.
     * @param {Chart3DPoint} point - The point related to the animation.
     * @param {HTMLElement} dataLabelElement - The data label element related to the animation.
     * @param {HTMLElement} shapeElement - The shape element related to the animation.
     * @param {HTMLElement} templateElement - The template element related to the animation.
     * @returns {void}
     */
    Chart3D.prototype.animateRect = function (element, series, point, dataLabelElement, shapeElement, templateElement) {
        var option = series.animation;
        var duration = series.chart.animated ? series.chart.duration : option.duration;
        var effect = getAnimationFunction('Linear');
        var elementHeight = element.getAttribute('height') ? +element.getAttribute('height') : 0;
        var elementWidth = element.getAttribute('width') ? +element.getAttribute('width') : 0;
        var isPlot = point.yValue < 0;
        var centerX;
        var centerY;
        var x = +element.getAttribute('x');
        var y = +element.getAttribute('y');
        if (!series.chart.requireInvertedAxis) {
            centerY = (isPlot !== series.yAxis.isAxisInverse) ? y : y + elementHeight;
            centerX = isPlot ? x : x + elementWidth;
        }
        else {
            if (series.type.indexOf('Stacking') > -1) {
                centerX = x;
                centerY = y;
            }
            else {
                centerY = isPlot ? y : y + elementHeight;
                centerX = (isPlot !== series.yAxis.isAxisInverse) ? x + elementWidth : x;
            }
        }
        var value;
        if (!isNullOrUndefined(element)) {
            element.style.visibility = 'hidden';
            if (dataLabelElement) {
                dataLabelElement.style.visibility = 'hidden';
            }
            if (shapeElement) {
                shapeElement.style.visibility = 'hidden';
            }
            if (templateElement) {
                templateElement.style.visibility = 'hidden';
            }
            new Animation({}).animate(element, {
                duration: (duration === 0 && animationMode === 'Enable') ? 1000 : duration,
                delay: option.delay,
                progress: function (args) {
                    if (args.timeStamp >= args.delay) {
                        element.style.visibility = 'visible';
                        if (!series.chart.requireInvertedAxis) {
                            elementHeight = elementHeight ? elementHeight : 1;
                            value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);
                            element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY +
                                ') scale(1,' + (value / elementHeight) + ') translate(' + (-centerX) + ' ' + (-centerY) + ')');
                        }
                        else {
                            elementWidth = elementWidth ? elementWidth : 1;
                            value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);
                            element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY +
                                ') scale(' + (value / elementWidth) + ', 1) translate(' + (-centerX) + ' ' + (-centerY) + ')');
                        }
                    }
                },
                end: function () {
                    element.setAttribute('transform', 'translate(0,0)');
                    if (dataLabelElement) {
                        dataLabelElement.style.visibility = 'visible';
                    }
                    if (shapeElement) {
                        shapeElement.style.visibility = 'visible';
                    }
                    if (templateElement) {
                        templateElement.style.visibility = 'visible';
                    }
                    series.chart.trigger('animationComplete', { series: series });
                }
            });
        }
    };
    /**
     * Animates the series.
     *
     * @returns {void}
     */
    Chart3D.prototype.doAnimation = function () {
        var _this = this;
        var _loop_1 = function (i) {
            var series = this_1.visibleSeries[i];
            if (series.visible && series.animation.enable && this_1.animateSeries && !this_1.rotateActivate) {
                var dataLabelElement = void 0;
                var shapeElement = void 0;
                var templateElement = void 0;
                var options = new RectOption(this_1.element.id + '_ChartSeriesClipRect_' + i, 'transparent', { width: 1, color: 'Gray' }, 1, {
                    x: 0, y: 0,
                    width: this_1.availableSize.width,
                    height: this_1.availableSize.height
                });
                var clipRectElement = appendClipElement(this_1.redraw, options, this_1.svgRenderer);
                appendChildElement(false, this_1.chart3D, clipRectElement.children[0], this_1.redraw);
                for (var k = 0; series.visiblePoints && k < series.visiblePoints.length; k++) {
                    var point = series.visiblePoints[k];
                    var elements = document.querySelectorAll("[id*=\"region-series-" + i + "\"]");
                    elements.forEach(function (element) {
                        element.setAttribute('clip-path', 'url(#' + _this.element.id + '_ChartSeriesClipRect_' + i + ')');
                    });
                    if (series.dataLabel.visible) {
                        dataLabelElement = getElement$1(this_1.element.id + '-svg-series-' + series.index + '-point-' + k + '-data-label');
                        shapeElement = getElement$1(this_1.element.id + '-svg-data-label-series-' + series.index + '-point-' + k);
                        templateElement = getElement$1(this_1.element.id + '-series-' + series.index + '-data-label-' + k);
                    }
                    this_1.animateRect(document.getElementById(this_1.element.id + '_ChartSeriesClipRect_' + i).children[0], series, point, dataLabelElement, shapeElement, templateElement);
                }
            }
        };
        var this_1 = this;
        for (var i = 0; i < this.visibleSeries.length; i++) {
            _loop_1(i);
        }
    };
    /**
     * Performs data selection based on selected data indexes.
     *
     * @returns {void}
     */
    Chart3D.prototype.performSelection = function () {
        var selectedDataIndexes = [];
        if (this.selection3DModule) {
            selectedDataIndexes = extend([], this.selection3DModule.selectedDataIndexes, null, true);
            this.selection3DModule.invokeSelection(this);
        }
        if (this.highlight3DModule) {
            this.highlight3DModule.invokeHighlight(this);
        }
        if ((!this.highlight3DModule || (this.legendSettings.enableHighlight && this.highlightMode === 'None')) && this.tooltip3DModule) {
            this.tooltip3DModule.seriesStyles();
        }
        if (selectedDataIndexes.length > 0) {
            this.selection3DModule.selectedDataIndexes = selectedDataIndexes;
            this.selection3DModule.redrawSelection(this, this.selectionMode);
        }
    };
    /**
     * To render the legend.
     *
     * @returns {void}
     */
    Chart3D.prototype.renderLegend = function () {
        if (this.legend3DModule && this.legend3DModule.legendCollections.length && this.legendSettings.visible) {
            this.legend3DModule.calTotalPage = true;
            var bounds = this.legend3DModule.legendBounds;
            this.legend3DModule.renderLegend(this, this.legendSettings, bounds);
        }
        if (!this.redraw) {
            this.element.appendChild(this.svgObject);
        }
    };
    /**
     * To set the left and top position for secondary element in chart.
     *
     * @returns {void}
     */
    Chart3D.prototype.setSecondaryElementPosition = function () {
        var element = getElement$1(this.element.id + '_Secondary_Element');
        if (!element) {
            return;
        }
        var rect = this.element.getBoundingClientRect();
        var svgRect = getElement$1(this.svgId).getBoundingClientRect();
        element.style.left = Math.max(svgRect.left - rect.left, 0) + 'px';
        element.style.top = Math.max(svgRect.top - rect.top, 0) + 'px';
    };
    /**
     * Initializes module-specific elements and settings for the chart.
     *
     * @returns {void}
     */
    Chart3D.prototype.initializeModuleElements = function () {
        this.dataLabelCollections = [];
        var elementId = this.element.id;
        if (this.series.length) {
            this.seriesElements = this.svgRenderer.createGroup({ id: elementId + 'SeriesCollection' });
        }
        this.dataLabelElements = this.renderer.createGroup({ id: elementId + 'DataLabelCollection' });
    };
    /**
     * Renders elements specific to chart series.
     *
     * @returns {void}
     */
    Chart3D.prototype.createSeriesElements = function () {
        // Initialize the series elements values
        this.initializeModuleElements();
        var elementId = this.element.id;
        var tooltipDiv = redrawElement(this.redraw, elementId + '_Secondary_Element') ||
            this.createElement('div');
        tooltipDiv.id = elementId + '_Secondary_Element';
        tooltipDiv.style.cssText = 'position: relative';
        appendChildElement(false, this.element, tooltipDiv, this.redraw);
        // For userInteraction
        if (this.tooltip.enable) {
            appendChildElement(false, this.svgObject, this.renderer.createGroup({ id: elementId + '_UserInteraction', style: 'pointer-events:none;' }), this.redraw);
        }
    };
    /**
     * Renders the chart title.
     *
     * @returns {void}
     */
    Chart3D.prototype.renderTitle = function () {
        var rect;
        var margin = this.margin;
        var elementSpacing = 5;
        if (this.title) {
            var getAnchor = getTextAnchor(this.titleStyle.textAlignment, this.enableRtl);
            var elementSize = measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont);
            rect = new Rect(margin.left, 0, this.availableSize.width - margin.left - margin.right, 0);
            var borderWidth = this.titleStyle.border.width;
            var positionY = this.margin.top + ((elementSize.height) * 3 / 4);
            var positionX = titlePositionX(rect, this.titleStyle || this.themeStyle.chartTitleFont) + borderWidth;
            var rotation = void 0;
            var alignment = this.titleStyle.textAlignment;
            var subtitleSize = measureText(this.subTitle, this.subTitleStyle, this.themeStyle.chartSubTitleFont);
            switch (this.titleStyle.position) {
                case 'Top':
                    positionY += borderWidth * 0.5;
                    positionX += getAnchor === 'start' ? borderWidth * 0.5 + this.border.width :
                        getAnchor === 'end' ? ((-borderWidth * 2) - this.border.width) : 0;
                    break;
                case 'Bottom':
                    positionX += getAnchor === 'start' ? (borderWidth * 0.5) + this.border.width :
                        getAnchor === 'end' ? (-borderWidth * 2) - this.border.width : 0;
                    positionY = this.availableSize.height - this.margin.bottom - subtitleSize.height - (elementSize.height / 2) -
                        (borderWidth * 0.5) - (this.subTitleStyle.border.width * 0.5);
                    break;
                case 'Left':
                    positionX = this.margin.left + ((elementSize.height) * 3 / 4) + (borderWidth * 0.5);
                    positionY = alignment === 'Near' ? margin.bottom + (borderWidth * 0.5) + this.border.width :
                        alignment === 'Far' ? this.availableSize.height - margin.bottom - (borderWidth * 0.5) - this.border.width : this.availableSize.height / 2;
                    getAnchor = alignment === 'Near' ? 'end' : alignment === 'Far' ? 'start' : 'middle';
                    getAnchor = this.enableRtl ? (getAnchor === 'end' ? 'start' : getAnchor === 'start' ? 'end' : getAnchor) : getAnchor;
                    rotation = 'rotate(' + -90 + ',' + positionX + ',' + positionY + ')';
                    break;
                case 'Right':
                    positionX = this.availableSize.width - this.margin.right - ((elementSize.height) * 3 / 4) - (borderWidth * 0.5);
                    positionY = alignment === 'Near' ? margin.bottom + (borderWidth * 0.5) + this.border.width :
                        alignment === 'Far' ? this.availableSize.height - margin.bottom - (borderWidth * 0.5) - this.border.width : this.availableSize.height / 2;
                    getAnchor = alignment === 'Near' ? 'start' : alignment === 'Far' ? 'end' : 'middle';
                    getAnchor = this.enableRtl ? (getAnchor === 'end' ? 'start' : getAnchor === 'start' ? 'end' : getAnchor) : getAnchor;
                    rotation = 'rotate(' + 90 + ',' + positionX + ',' + positionY + ')';
                    break;
                case 'Custom':
                    positionX = this.titleStyle.x;
                    positionY = this.titleStyle.y;
                    getAnchor = 'middle';
                    break;
            }
            var borderOptions = {
                'id': this.element.id + '-chart-title-border',
                'x': positionX - (getAnchor === 'middle' ? (elementSize.width / 2) + elementSpacing : getAnchor === 'end' ? elementSize.width + elementSpacing : elementSpacing),
                'y': positionY - elementSize.height + (elementSize.height / 4),
                'rx': this.titleStyle.border.cornerRadius,
                'ry': this.titleStyle.border.cornerRadius,
                'width': elementSize.width + (elementSpacing * 2),
                'height': elementSize.height * this.titleCollection.length,
                'fill': this.titleStyle.background,
                'stroke-width': borderWidth,
                'stroke': this.titleStyle.border.color,
                'transform': rotation ? rotation : ''
            };
            var htmlObject = redrawElement(this.redraw, this.element.id + '-chart-title-border', borderOptions, this.renderer)
                || this.renderer.drawRectangle(borderOptions);
            appendChildElement(false, this.svgObject, htmlObject, this.redraw);
            var options = new TextOption(this.element.id + '-chart-title', positionX, positionY, getAnchor, this.titleCollection, rotation, 'auto');
            var element = redrawElement(this.redraw, this.element.id + '-chart-title', options, this.renderer) ||
                textElement$1(this.renderer, options, this.titleStyle, this.titleStyle.color || this.themeStyle.chartTitleFont.color, this.svgObject, null, null, null, null, null, null, null, null, false, null, this.themeStyle.chartTitleFont);
            if (element) {
                element.setAttribute('tabindex', '0');
                element.setAttribute('class', 'e-chart-focused');
            }
            if (this.subTitle) {
                this.renderSubTitle(options);
            }
        }
    };
    /**
     * Renders the chart sub title.
     *
     * @param {TextOption} options - Specifies the text option.
     * @returns {void}
     */
    Chart3D.prototype.renderSubTitle = function (options) {
        var maxWidth = 0;
        var titleWidth = 0;
        var padding = 10;
        var alignment = this.titleStyle.textAlignment;
        for (var _i = 0, _a = this.titleCollection; _i < _a.length; _i++) {
            var titleText = _a[_i];
            titleWidth = measureText(titleText, this.titleStyle, this.themeStyle.chartSubTitleFont).width;
            maxWidth = titleWidth > maxWidth ? titleWidth : maxWidth;
        }
        var subTitleElementSize = measureText(this.subTitleCollection.
            reduce(function (a, b) { return (a.length > b.length ? a : b); }), this.subTitleStyle, this.themeStyle.chartSubTitleFont);
        var getAnchor = getTextAnchor(this.subTitleStyle.textAlignment, this.enableRtl);
        var rect = new Rect(alignment === 'Center' ? (options.x - maxWidth * 0.5) : alignment === 'Far' ? options.x - maxWidth : options.x, 0, maxWidth, 0);
        if (this.titleStyle.position === 'Left') {
            rect.x = alignment === 'Center' ? (options.x - maxWidth * 0.5) : alignment === 'Far' ? this.margin.left + ((subTitleElementSize.height) * 3 / 4) : (options.x - maxWidth);
        }
        var elementSize = measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont);
        var positionY = options.y * options.text.length + subTitleElementSize.height + (padding / 2) +
            this.titleStyle.border.width + (this.subTitleStyle.border.width * 0.5);
        if (this.titleStyle.position === 'Bottom') {
            positionY = options.y * options.text.length + (padding / 2) + (elementSize.height / 2) + (subTitleElementSize.height / 2);
        }
        var borderOptions = {
            'id': this.element.id + '-chart-sub-title-border',
            'x': titlePositionX(rect, this.subTitleStyle) - (getAnchor === 'middle' ? (subTitleElementSize.width / 2) + padding / 2 : getAnchor === 'end' ? subTitleElementSize.width + padding / 2 : padding / 2),
            'y': positionY - subTitleElementSize.height + (subTitleElementSize.height / 4),
            'rx': this.subTitleStyle.border.cornerRadius,
            'ry': this.subTitleStyle.border.cornerRadius,
            'width': subTitleElementSize.width + padding,
            'height': subTitleElementSize.height * this.subTitleCollection.length,
            'fill': this.subTitleStyle.background,
            'stroke-width': this.subTitleStyle.border.width,
            'stroke': this.subTitleStyle.border.color,
            'transform': options.transform
        };
        var htmlObject = redrawElement(this.redraw, this.element.id + '-chart-sub-title-border', borderOptions, this.renderer)
            || this.renderer.drawRectangle(borderOptions);
        appendChildElement(false, this.svgObject, htmlObject, this.redraw);
        var subTitleOptions = new TextOption(this.element.id + '-chart-sub-title', titlePositionX(rect, this.subTitleStyle), positionY, getTextAnchor(this.subTitleStyle.textAlignment, this.enableRtl), this.subTitleCollection, options.transform, 'auto');
        var element = redrawElement(this.redraw, this.element.id + '-chart-sub-title', subTitleOptions, this.renderer) ||
            textElement$1(this.renderer, subTitleOptions, this.subTitleStyle, this.subTitleStyle.color || this.themeStyle.chartSubTitleFont.color, this.svgObject, null, null, null, null, null, null, null, null, false, null, this.themeStyle.chartSubTitleFont);
    };
    /**
     * Renders the chart border.
     *
     * @returns {void}
     */
    Chart3D.prototype.renderBorder = function () {
        var x = 0;
        var y = 0;
        var width = this.border.width;
        var backGroundImage = this.backgroundImage;
        var fillColor = backGroundImage ? 'transparent' : (this.background || this.themeStyle.background);
        var rect = new RectOption(this.element.id + '-chart-border', fillColor, this.border, 1, new Rect(width * 0.5 + x, width * 0.5 + y, this.availableSize.width - width, this.availableSize.height - width));
        this.htmlObject = redrawElement(this.redraw, this.element.id + '-chart-border', rect, this.renderer)
            || this.renderer.drawRectangle(rect);
        this.htmlObject.setAttribute('aria-hidden', 'true');
        appendChildElement(false, this.svgObject, this.htmlObject, this.redraw);
        // to draw back ground image for chart
        if (backGroundImage) {
            var image = new ImageOption(this.availableSize.height - width, this.availableSize.width - width, backGroundImage, 0, 0, this.element.id + '-chart-background', 'visible', 'none');
            this.htmlObject = redrawElement(this.redraw, this.element.id + '-chart-background', image, this.renderer)
                || this.renderer.drawImage(image);
            appendChildElement(false, this.svgObject, this.htmlObject, this.redraw);
        }
    };
    /**
     * To provide the array of modules needed for control rendering
     *
     * @returns {ModuleDeclaration[]}
     * @private
     */
    /* eslint-disable  */
    Chart3D.prototype.requiredModules = function () {
        var _this = this;
        var modules = [];
        var series = this.series;
        var moduleName;
        var dataLabelEnable = false;
        if (this.tooltip.enable) {
            modules.push({
                member: 'Tooltip3D',
                args: [this]
            });
        }
        series.map(function (value) {
            _this.isLegend = (_this.legendSettings.visible && ((value.name !== '') || !!_this.isLegend));
            moduleName = value.type.indexOf('100') !== -1 ? value.type.replace('100', '') + 'Series3D' : value.type + 'Series3D';
            dataLabelEnable = value.dataLabel.visible || dataLabelEnable;
            if (!modules.some(function (currentModule) {
                return currentModule.member === moduleName;
            })) {
                modules.push({
                    member: moduleName,
                    args: [_this, series]
                });
            }
        });
        if (dataLabelEnable) {
            modules.push({
                member: 'DataLabel3D',
                args: [this, series]
            });
        }
        modules = this.findAxisModule(modules);
        if (this.isLegend) {
            modules.push({
                member: 'Legend3D',
                args: [this]
            });
        }
        modules.push({
            member: 'Export3D',
            args: [this]
        });
        if (this.selectionMode !== 'None') {
            modules.push({
                member: 'Selection3D',
                args: [this]
            });
        }
        if (this.highlightMode !== 'None' || this.legendSettings.enableHighlight) {
            modules.push({
                member: 'Highlight3D',
                args: [this]
            });
        }
        return modules;
    };
    /**
     * Finds axis modules within a collection of module declarations.
     *
     * @param {ModuleDeclaration[]} modules - The collection of module declarations to search for axis modules.
     * @returns {ModuleDeclaration[]} - An array of module declarations representing axis modules.
     */
    Chart3D.prototype.findAxisModule = function (modules) {
        var axisCollections = [];
        axisCollections.push(this.primaryXAxis);
        axisCollections.push(this.primaryYAxis);
        axisCollections = axisCollections.concat(this.axes);
        var datetimeEnabled = false;
        var categoryEnabled = false;
        var logarithmicEnabled = false;
        var dateTimeCategoryEnabled = false;
        for (var _i = 0, axisCollections_1 = axisCollections; _i < axisCollections_1.length; _i++) {
            var axis = axisCollections_1[_i];
            datetimeEnabled = axis.valueType === 'DateTime' || datetimeEnabled;
            categoryEnabled = axis.valueType === 'Category' || categoryEnabled;
            logarithmicEnabled = axis.valueType === 'Logarithmic' || logarithmicEnabled;
            dateTimeCategoryEnabled = axis.valueType === 'DateTimeCategory' || dateTimeCategoryEnabled;
        }
        if (datetimeEnabled) {
            modules.push({
                member: 'DateTime3D',
                args: [this]
            });
        }
        if (categoryEnabled) {
            modules.push({
                member: 'Category3D',
                args: [this]
            });
        }
        if (logarithmicEnabled) {
            modules.push({
                member: 'Logarithmic3D',
                args: [this]
            });
        }
        if (dateTimeCategoryEnabled) {
            modules.push({
                member: 'DateTimeCategory3D',
                args: [this]
            });
        }
        return modules;
    };
    /**
     * Sets the theme for the chart.
     */
    Chart3D.prototype.setTheme = function () {
        /*! Set theme */
        this.themeStyle = get3DThemeColor(this.theme);
        if (!(document.getElementById(this.element.id + 'Keyboard_chart_focus'))) {
            var style = document.createElement('style');
            style.setAttribute('id', this.element.id + 'Keyboard_chart_focus');
            style.innerText = '.e-chart-focused:focus, path[class*=_ej2_chart_selection_series]:focus,' +
                'path[id*=-point-]:focus, text[id*=-chart-title]:focus {outline: none } .e-chart-focused:focus-visible, path[class*=_ej2_chart_selection_series]:focus-visible,' +
                'path[id*=-point-]:focus-visible, text[id*=-chart-title]:focus-visible {outline: 1.5px ' + this.themeStyle.tabColor + ' solid}';
            document.body.appendChild(style);
        }
    };
    /**
     * Renders the three-dimensional chart, creating a 3D visualization.
     *
     * The function sets up a 3D perspective, depth, rotation, and tilt to create a 3D visualization of the chart.
     */
    Chart3D.prototype.render3DChart = function () {
        var chart = this;
        this.chart3D = chart.svgRenderer.createGroup({ 'id': chart.element.id + '-svg-chart-3d' });
        this.chart3D.setAttribute('role', 'region');
        this.chart3D.setAttribute('aria-hidden', 'false');
        this.draw3DAxis();
        this.wallRender.update3DWall(chart);
        this.renderSeries();
        appendChildElement(false, chart.svgObject, chart.chart3D, chart.redraw);
        var size = new Size(chart.availableSize.width, chart.availableSize.height);
        this.graphics.prepareView(this.perspectiveAngle, this.depth, this.rotation, this.tilt, size, this);
        this.graphics.view(this.svgObject, this);
    };
    /**
     * Draws three-dimensional axes for the chart.
     *
     */
    Chart3D.prototype.draw3DAxis = function () {
        for (var i = 0; i < this.axisCollections.length; i++) {
            this.axisRender.drawAxes(i, this.axisCollections[i], this);
        }
    };
    /**
     * Renders chart series elements.
     *
     * @private
     */
    Chart3D.prototype.renderSeries = function () {
        var visibility;
        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
            var item = _a[_i];
            visibility = item.visible;
            if (visibility) {
                this.visible++;
                item.renderSeries(this);
            }
        }
        this.visible = 0;
    };
    /**
     * Initializes the configuration for an axis within a three-dimensional chart series.
     *
     * @param {Chart3DSeries} series - The series to which the axis belongs.
     * @param {Chart3DAxis} axis - The axis to be configured and initialized.
     * @param {boolean} isSeries - Indicates whether the axis configuration is for the series.
     */
    Chart3D.prototype.initAxis = function (series, axis, isSeries) {
        if (series.xAxisName === axis.name || (series.xAxisName == null && axis.name === 'primaryXAxis')) {
            axis.orientation = this.requireInvertedAxis ? 'Vertical' : 'Horizontal';
            series.xAxis = axis;
            if (isSeries) {
                axis.series.push(series);
            }
        }
        else if (series.yAxisName === axis.name || (series.yAxisName == null && axis.name === 'primaryYAxis')) {
            axis.orientation = this.requireInvertedAxis ? 'Horizontal' : 'Vertical';
            series.yAxis = axis;
            if (isSeries) {
                axis.series.push(series);
            }
        }
    };
    /**
     * Calculate the visible axis.
     *
     * @private
     */
    Chart3D.prototype.calculateVisibleAxis = function () {
        var axis;
        var axes = [this.primaryXAxis, this.primaryYAxis];
        axes = axes.concat(this.axes);
        this.axisCollections = [];
        for (var i = 0, len = axes.length; i < len; i++) {
            axis = axes[i];
            axis.series = [];
            axis.labels = [];
            axis.indexLabels = {};
            axis.orientation = (i === 0) ? (this.requireInvertedAxis ? 'Vertical' : 'Horizontal') :
                (i === 1) ? (this.requireInvertedAxis ? 'Horizontal' : 'Vertical') : axis.orientation;
            for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
                var series = _a[_i];
                this.initAxis(series, axis, true);
            }
            if (axis.orientation != null) {
                this.axisCollections.push(axis);
            }
        }
        if (this.rows.length > 0 && this.columns.length > 0) {
            this.chartAxisLayoutPanel.measure();
        }
    };
    /**
     * Unbinding events from the element while component destroy.
     *
     * @hidden
     * @returns {void}
     */
    Chart3D.prototype.unWireEvents = function () {
        var startEvent = Browser.touchStartEvent;
        var moveEvent = Browser.touchMoveEvent;
        var stopEvent = Browser.touchEndEvent;
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        /*! UnBind the Event handler */
        EventHandler.remove(this.element, startEvent, this.chartOnMouseDown);
        EventHandler.remove(this.element, moveEvent, this.mouseMove);
        EventHandler.remove(this.element, stopEvent, this.mouseEnd);
        EventHandler.remove(this.element, 'click', this.chartOnMouseClick);
        EventHandler.remove(this.element, cancelEvent, this.mouseLeave);
        EventHandler.remove(this.element, 'keydown', this.chartKeyDown);
        EventHandler.remove(document.body, 'keydown', this.documentKeyHandler);
        EventHandler.remove(this.element, 'keyup', this.chartKeyUp);
        window.removeEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.resizeBound);
        /**
         * To fix memory issue
         */
        if (this.touchObject) {
            this.touchObject.destroy();
            this.touchObject = null;
        }
    };
    /**
     * Binding events to the element while component creation.
     *
     * @hidden
     * @returns {void}
     */
    Chart3D.prototype.wireEvents = function () {
        /**
         * To fix react timeout destroy issue.
         */
        if (!this.element) {
            return;
        }
        /*! Find the Events type */
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        /*! Bind the Event handler */
        EventHandler.add(this.element, Browser.touchStartEvent, this.chartOnMouseDown, this);
        EventHandler.add(this.element, Browser.touchMoveEvent, this.mouseMove, this);
        EventHandler.add(this.element, Browser.touchEndEvent, this.mouseEnd, this);
        EventHandler.add(this.element, 'click', this.chartOnMouseClick, this);
        EventHandler.add(this.element, cancelEvent, this.mouseLeave, this);
        EventHandler.add(this.element, 'keydown', this.chartKeyDown, this);
        EventHandler.add(document.body, 'keydown', this.documentKeyHandler, this);
        EventHandler.add(this.element, 'keyup', this.chartKeyUp, this);
        this.resizeBound = this.chartResize.bind(this);
        window.addEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.resizeBound);
        this.longPressBound = this.longPress.bind(this);
        this.touchObject = new Touch(this.element, { tapHold: this.longPressBound, tapHoldThreshold: 500 });
        /*! Apply the style for chart */
        this.setStyle(this.element);
    };
    /**
     * Handles the long press on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Chart3D.prototype.longPress = function (e) {
        this.mouseX = (e && e.originalEvent.changedTouches) ? (e.originalEvent.changedTouches[0].clientX) : 0;
        this.mouseY = (e && e.originalEvent.changedTouches) ? (e.originalEvent.changedTouches[0].clientY) : 0;
        this.startMove = true;
        this.setMouseXY(this.mouseX, this.mouseY);
        this.notify('tapHold', e);
        return false;
    };
    /**
     * Handles the mouse click on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Chart3D.prototype.chartOnMouseClick = function (e) {
        var _this = this;
        var element = e.target;
        var chart = this;
        this.clickCount++;
        var timeInterval = 400;
        if (this.clickCount === 1) {
            this.singleClickTimer = +setTimeout(function () {
                chart.clickCount = 0;
                chart.trigger('chart3DMouseClick', { target: element.id, x: chart.mouseX, y: chart.mouseY });
            }, timeInterval);
        }
        else if (this.clickCount === 2) {
            clearTimeout(this.singleClickTimer);
            this.clickCount = 0;
        }
        var isAngular = 'isAngular';
        if (this[isAngular]) {
            timeInterval = 0;
        }
        else {
            timeInterval = 0;
        }
        if (this.clickCount === 1 && this.pointClick) {
            this.singleClickTimer = +setTimeout(function () {
                _this.clickCount = 0;
                _this.triggerPointEvent(pointClick, e);
            }, timeInterval);
        }
        this.notify('click', e);
        return false;
    };
    /**
     * Export method for the chart.
     */
    Chart3D.prototype.export = function (type, fileName) {
        if (this.export3DModule) {
            this.export3DModule.export(type, fileName);
            if (this.afterExport) {
                this.export3DModule.getDataUrl(this);
            }
        }
    };
    /**
     * Handles the chart resize.
     *
     * @returns {boolean} false
     * @private
     */
    Chart3D.prototype.chartResize = function () {
        var _this = this;
        this.animateSeries = false;
        var arg = {
            chart: this,
            currentSize: new Size(0, 0),
            previousSize: new Size(this.availableSize.width, this.availableSize.height)
        };
        var beforeResizeArgs = { cancel: false };
        if (this.resizeTo) {
            clearTimeout(this.resizeTo);
        }
        this.trigger(beforeResize, beforeResizeArgs);
        if (!beforeResizeArgs.cancel) {
            this.resizeTo = +setTimeout(function () {
                if (_this.isDestroyed) {
                    clearTimeout(_this.resizeTo);
                    return;
                }
                _this.createChartSvg();
                arg.currentSize = _this.availableSize;
                _this.trigger(resized, arg);
                _this.polygons = [];
                _this.refreshAxis();
                _this.refreshBound();
                _this.trigger('loaded', { chart: _this });
            }, 500);
        }
        return false;
    };
    /**
     * Triggers a point-specific event with the specified event type and event data.
     *
     * @param {string} event - The type of event to trigger.
     * @param {PointerEvent | TouchEvent} [e] - (Optional) The event data associated with the triggered event.
     */
    Chart3D.prototype.triggerPointEvent = function (event, e) {
        var evt = e;
        var series = null;
        var point = null;
        var index;
        var pointIndex;
        var seriesIndex;
        var targetElement = evt.target;
        if (targetElement) {
            var nodeName = targetElement.nodeName;
            if ((nodeName === 'path' || nodeName === 'shape') && targetElement.id.indexOf('-region-') > 1) {
                index = targetElement.id.match(/(\d+)/g);
                pointIndex = parseInt(index[index.length - 1].toString(), 10);
                seriesIndex = parseInt(index[index.length - 2].toString(), 10);
            }
            if (!isNullOrUndefined(seriesIndex)) {
                series = this.visibleSeries[seriesIndex];
            }
            if (series && series.visible) {
                point = series.points[pointIndex];
            }
        }
        if (series && point) {
            this.trigger(event, {
                series: series,
                point: point,
                seriesIndex: seriesIndex, pointIndex: pointIndex,
                x: this.mouseX, y: this.mouseY,
            });
        }
    };
    /**
     * Handles the mouse down on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Chart3D.prototype.chartOnMouseDown = function (e) {
        var pageX;
        var pageY;
        var target;
        var touchArg;
        var offset = Browser.isDevice ? 20 : 30;
        var rect = this.element.getBoundingClientRect();
        var element = e.target;
        this.trigger('chart3DMouseDown', { target: element.id, x: this.mouseX, y: this.mouseY });
        if (e.type === 'touchstart') {
            this.isTouch = true;
            touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            pageY = touchArg.changedTouches[0].clientY;
            target = touchArg.target;
        }
        else {
            this.isTouch = e.pointerType === 'touch';
            pageX = e.clientX;
            pageY = e.clientY;
            target = e.target;
        }
        var svgRect = getElement$1(this.svgId).getBoundingClientRect();
        this.mouseDownX = this.previousMouseMoveX = (pageX - rect.left) - Math.max(svgRect.left - rect.left, 0);
        this.mouseDownY = this.previousMouseMoveY = (pageY - rect.top) - Math.max(svgRect.top - rect.top, 0);
        if (this.enableRotation) {
            if (this.isTouch && this.tooltip3DModule && this.tooltip3DModule.svgTooltip) {
                this.tooltip3DModule.svgTooltip.fadeOut();
            }
            this.rotateActivate = true;
            this.previousCoords = { x: this.mouseDownX, y: this.mouseDownY };
        }
        this.notify(Browser.touchStartEvent, e);
        return false;
    };
    /**
     * Handles the mouse move on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Chart3D.prototype.mouseMove = function (e) {
        var pageX;
        var pageY;
        var touchArg;
        if (e.type === 'touchmove') {
            this.isTouch = true;
            touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            pageY = touchArg.changedTouches[0].clientY;
        }
        else {
            this.isTouch = e.pointerType === 'touch' || e.pointerType === '2' || this.isTouch;
            pageX = e.clientX;
            pageY = e.clientY;
        }
        if (getElement$1(this.svgId)) {
            this.setMouseXY(pageX, pageY);
            this.chartOnMouseMove(e);
        }
        return false;
    };
    /**
     * Handles the mouse leave on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Chart3D.prototype.mouseLeave = function (e) {
        var pageX;
        var pageY;
        var touchArg;
        if (e.type === 'touchleave') {
            this.isTouch = true;
            touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            pageY = touchArg.changedTouches[0].clientY;
        }
        else {
            this.isTouch = e.pointerType === 'touch' || e.pointerType === '2';
            pageX = e.clientX;
            pageY = e.clientY;
        }
        this.setMouseXY(pageX, pageY);
        this.chartOnMouseLeave(e);
        return false;
    };
    /**
     * Handles the mouse up on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Chart3D.prototype.mouseEnd = function (e) {
        var pageY;
        var pageX;
        var touchArg;
        if (e.type === 'touchend') {
            touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            this.isTouch = true;
            pageY = touchArg.changedTouches[0].clientY;
        }
        else {
            pageY = e.clientY;
            pageX = e.clientX;
            this.isTouch = e.pointerType === 'touch' || e.pointerType === '2';
        }
        this.setMouseXY(pageX, pageY);
        this.chartOnMouseUp(e);
        return false;
    };
    /**
     * Handles the mouse up on chart.
     *
     * @returns {boolean}
     * @private
     */
    Chart3D.prototype.chartOnMouseUp = function (e) {
        var element = e.target;
        this.trigger('chart3DMouseUp', { target: element.id, x: this.mouseX, y: this.mouseY });
        if (this.isTouch) {
            this.titleTooltip(e, this.mouseX, this.mouseY);
            this.axisTooltip(e, this.mouseX, this.mouseY, this.isTouch);
        }
        this.notify(Browser.touchEndEvent, e);
        this.rotateActivate = false;
        this.delayRedraw = false;
        return false;
    };
    /**
     * Prints the chart in the page.
     *
     * @param {string[] | string | Element} id - The id of the chart to be printed on the page.
     */
    Chart3D.prototype.print = function (id) {
        var printChart = new PrintUtils(this);
        printChart.print(id);
    };
    /**
     * Handles the mouse move on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Chart3D.prototype.chartOnMouseMove = function (e) {
        var element = e.target;
        this.trigger('chart3DMouseMove', { target: element.id, x: this.mouseX, y: this.mouseY });
        if (this.pointMove) {
            this.triggerPointEvent(pointMove, e);
        }
        if (!this.isTouch) {
            this.titleTooltip(e, this.mouseX, this.mouseY);
            this.axisTooltip(e, this.mouseX, this.mouseY);
        }
        if (this.rotateActivate && withInBounds(this.mouseX, this.mouseY, this.chartAxisLayoutPanel.seriesClipRect)) {
            var difX = this.previousCoords.x - this.mouseX;
            var difY = this.previousCoords.y - this.mouseY;
            if (difX || difY) {
                this.tilt -= difY;
                this.rotation += difX;
                if (!this.isTouch) {
                    var grpElement = document.getElementById(this.chart3D.id);
                    grpElement.innerHTML = '';
                    grpElement.remove();
                }
                else {
                    document.querySelectorAll("[id*=\"region-series-" + "\"]").forEach(function (element) { return element.remove(); });
                    document.querySelectorAll("[id*=\"axis-label-" + "\"]").forEach(function (axisElement) { return axisElement.remove(); });
                    this.delayRedraw = true;
                }
                var size = { width: this.availableSize.width, height: this.availableSize.height };
                this.graphics.view(this.svgObject, this, this.rotation, this.tilt, size, this.perspectiveAngle, this.depth);
                appendChildElement(false, this.svgObject, this.chart3D, this.redraw);
                this.previousCoords.y = this.mouseY;
                this.previousCoords.x = this.mouseX;
                this.isRemove = false;
            }
        }
        this.notify(Browser.touchMoveEvent, e);
        this.isTouch = false;
        return false;
    };
    /**
     * Displays a tooltip for a title or element at the specified coordinates.
     *
     * @param {Event} event - The event triggering the tooltip display.
     * @param {number} x - The X-coordinate for the tooltip.
     * @param {number} y - The Y-coordinate for the tooltip.
     * @param {boolean} [isTouch] - (Optional) Indicates whether the event was triggered by a touch input.
     */
    Chart3D.prototype.titleTooltip = function (event, x, y, isTouch) {
        var targetId = event.target.id;
        var id = (targetId === (this.element.id + '-chart-title') || targetId === (this.element.id + '-chart-sub-title') ||
            targetId.indexOf('-axis-title') > -1 || targetId.indexOf('_legend_title') > -1);
        var index = 0;
        if (targetId.indexOf('-axis-title') > -1) {
            index = parseInt(((targetId.replace(this.element.id + '-svg', '')).replace('-axis-title', '')).split('-')[1], 10);
        }
        if (id && (event.target.textContent.indexOf('...') > -1)) {
            var title = (targetId === (this.element.id + '-chart-title')) ? this.title :
                targetId.indexOf('-axis-title') > -1 ? this.axisCollections[index].title :
                    targetId.indexOf('-chart-sub-title') > -1 ? this.subTitle : this.legendSettings.title;
            showTooltip(title, x, y, this.element.offsetWidth, this.element.id + '-EJ2-title-tooltip', getElement$1(this.element.id + '_Secondary_Element'), isTouch);
        }
        else {
            removeElement(this.element.id + '-EJ2-title-tooltip');
        }
    };
    /**
     * To find mouse x, y coordinate for the chart.
     *
     * @param {number} pageX - Specifies the x value of the pageX.
     * @param {number} pageY - Specifies the y value of the pageY.
     * @returns {void}
     */
    Chart3D.prototype.setMouseXY = function (pageX, pageY) {
        if (getElement$1(this.svgId)) {
            var svgRect = getElement$1(this.svgId).getBoundingClientRect();
            var rect = this.element.getBoundingClientRect();
            this.mouseY = ((pageY - rect.top) - Math.max(svgRect.top - rect.top, 0) / this.scaleX);
            this.mouseX = ((pageX - rect.left) - Math.max(svgRect.left - rect.left, 0) / this.scaleY);
        }
    };
    /**
     * Handles the mouse leave on chart.
     *
     * @returns {boolean} false
     * @private
     */
    Chart3D.prototype.chartOnMouseLeave = function (e) {
        var element = e.target;
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        this.trigger('chart3DMouseLeave', { target: element.id, x: this.mouseX, y: this.mouseY });
        removeElement(this.element.id + '-EJ2-axis-label-tooltip');
        this.isPointMouseDown = false;
        this.notify(cancelEvent, e);
        this.rotateActivate = false;
        this.delayRedraw = false;
        return false;
    };
    /**
     * Handles the 'onkeydown' keyboard event on the chart.
     *
     * @param {KeyboardEvent} e - Specifies the keydown event arguments.
     * @returns {boolean}
     * @private
     */
    Chart3D.prototype.chartKeyDown = function (e) {
        var actionKey = '';
        if (e.code === 'Space') {
            e.preventDefault();
        }
        if (this.tooltip.enable && ((e.code === 'Tab' && this.previousTargetId.indexOf('-series') > -1) || e.code === 'Escape')) {
            actionKey = 'ESC';
        }
        if (this.highlightMode !== 'None' && e.code === 'Tab' && this.previousTargetId.indexOf('_chart_legend_') > -1) {
            if (this.highlight3DModule) {
                this.highlight3DModule.removeLegendHighlightStyles();
            }
        }
        if (e.ctrlKey && (e.key === 'p')) {
            e.preventDefault();
            actionKey = 'CtrlP';
        }
        if (actionKey !== '')
            this.chartKeyboardNavigations(e, e.target.id, actionKey);
        return false;
    };
    /**
     *Handles the 'onkeyup' keyboard event on the chart..
     *
     * @param {KeyboardEvent} e - Specifies the keyup event arguments.
     * @returns {boolean} false
     * @private
     */
    Chart3D.prototype.chartKeyUp = function (e) {
        var actionKey = '';
        var targetId = e.target['id'];
        var groupElement;
        var targetElement = e.target;
        var titleElement = getElement$1(this.element.id + '-chart-title');
        var seriesElement = getElement$1(this.element.id + '-svg-0-region-series-0-point-0');
        var legendElement = getElement$1(this.element.id + '_chart_legend_translate_g');
        var pagingElement = getElement$1(this.element.id + '_chart_legend_pageup');
        if (titleElement) {
            titleElement.setAttribute('class', 'e-chart-focused');
        }
        if (seriesElement) {
            var className = seriesElement.getAttribute('class');
            if (className && className.indexOf('e-chart-focused') === -1) {
                className = className + ' e-chart-focused';
            }
            else if (!className) {
                className = 'e-chart-focused';
            }
            seriesElement.setAttribute('class', className);
        }
        if (legendElement) {
            var firstChild = legendElement.firstElementChild;
            var className = firstChild.getAttribute('class');
            if (className && className.indexOf('e-chart-focused') === -1) {
                className = className + ' e-chart-focused';
            }
            else if (!className) {
                className = 'e-chart-focused';
            }
            firstChild.setAttribute('class', className);
        }
        if (pagingElement) {
            pagingElement.setAttribute('class', 'e-chart-focused');
        }
        if (e.code === 'Tab') {
            if (this.previousTargetId !== '') {
                if ((this.previousTargetId.indexOf('-series-') > -1 && targetId.indexOf('-series-') === -1)) {
                    var previousElement = getElement$1(this.element.id + '-svg-0-region-series-' + this.currentSeriesIndex + '-point-' + this.currentPointIndex);
                    this.setTabIndex(previousElement, seriesElement);
                    this.currentPointIndex = 0;
                    this.currentSeriesIndex = 0;
                }
                else if (this.previousTargetId.indexOf('_chart_legend_page') > -1 && targetId.indexOf('_chart_legend_page') === -1
                    && targetId.indexOf('_chart_legend_g_') === -1) {
                    this.setTabIndex(e.target, getElement$1(this.element.id + '_chart_legend_pageup'));
                }
                else if (this.previousTargetId.indexOf('_chart_legend_g_') > -1 && targetId.indexOf('_chart_legend_g_') === -1) {
                    groupElement = getElement$1(this.element.id + '_chart_legend_translate_g');
                    this.setTabIndex(groupElement.children[this.currentLegendIndex], groupElement.firstElementChild);
                }
            }
            this.previousTargetId = targetId;
            if (targetId.indexOf('-series-') > -1) {
                this.currentSeriesIndex = +(targetId.split('-series-')[1].split('-point-')[0]);
                targetElement.removeAttribute('tabindex');
                targetElement.blur();
                targetId = this.focusChild(targetElement);
            }
            actionKey = this.highlightMode !== 'None' || this.tooltip.enable ? 'Tab' : '';
        }
        else if (e.code.indexOf('Arrow') > -1) {
            e.preventDefault();
            this.previousTargetId = targetId;
            if (targetId.indexOf('_chart_legend_page') > -1) {
                if (e.code === 'ArrowLeft') {
                    getElement$1(this.element.id + '_chart_legend_pagedown').removeAttribute('tabindex');
                    this.focusChild(getElement$1(this.element.id + '_chart_legend_pageup'));
                }
                else if (e.code === 'ArrowRight') {
                    getElement$1(this.element.id + '_chart_legend_pageup').removeAttribute('tabindex');
                    this.focusChild(getElement$1(this.element.id + '_chart_legend_pagedown'));
                }
            }
            else if ((targetId.indexOf('_chart_legend_') > -1)) {
                var legendElement_1 = targetElement.parentElement.children;
                legendElement_1[this.currentLegendIndex].removeAttribute('tabindex');
                this.currentLegendIndex += (e.code === 'ArrowUp' || e.code === 'ArrowRight') ? +1 : -1;
                this.currentLegendIndex = this.getActualIndex(this.currentLegendIndex, legendElement_1.length);
                var currentLegend = legendElement_1[this.currentLegendIndex];
                this.focusChild(currentLegend);
                targetId = currentLegend.children[1].id;
                actionKey = this.highlightMode !== 'None' ? 'ArrowMove' : '';
            }
            else if (targetId.indexOf('-series-') > -1) {
                var currentPoint = e.target;
                targetElement.removeAttribute('tabindex');
                targetElement.blur();
                if (e.code === 'ArrowRight' || e.code === 'ArrowLeft') {
                    this.currentSeriesIndex = this.currentSeriesIndex + (e.code === 'ArrowRight' ? 1 : -1);
                    this.currentSeriesIndex = this.getActualIndex(this.currentSeriesIndex, this.series.length);
                }
                else {
                    this.currentPointIndex += e.code === 'ArrowUp' ? 1 : -1;
                }
                if (targetId.indexOf('-point-') > -1) {
                    this.currentPointIndex = this.getActualIndex(this.currentPointIndex, this.visibleSeries[this.currentSeriesIndex].points.length ? this.currentSeries.points.length : 1);
                    currentPoint = getElement$1(this.element.id + '-svg-0-region-series-' + this.currentSeriesIndex + '-point-' +
                        this.currentPointIndex);
                }
                targetId = this.focusChild(currentPoint);
                actionKey = this.tooltip.enable || this.highlightMode !== 'None' ? 'ArrowMove' : '';
            }
        }
        else if ((e.code === 'Enter' || e.code === 'Space') && ((targetId.indexOf('_chart_legend_') > -1) ||
            (targetId.indexOf('-point-') > -1))) {
            targetId = (targetId.indexOf('_chart_legend_page') > -1) ? targetId : ((targetId.indexOf('_chart_legend_') > -1) ?
                targetElement.children[1].id : targetId);
            actionKey = 'Enter';
        }
        if (actionKey !== '') {
            this.chartKeyboardNavigations(e, targetId, actionKey);
        }
        return false;
    };
    /**
     * Sets the tabindex for the current element and removes it from the previous element.
     *
     * @param {HTMLElement} previousElement - The element whose tabindex should be removed.
     * @param {HTMLElement} currentElement - The element to which tabindex should be set.
     */
    Chart3D.prototype.setTabIndex = function (previousElement, currentElement) {
        if (previousElement) {
            previousElement.removeAttribute('tabindex');
        }
        if (currentElement) {
            currentElement.setAttribute('tabindex', '0');
        }
    };
    /**
     * Calculates the actual index considering boundary conditions within a given range.
     *
     * @param {number} index - The index to be adjusted.
     * @param {number} totalLength - The total length or maximum allowed index value.
     * @returns {number} - The adjusted index within the valid range.
     */
    Chart3D.prototype.getActualIndex = function (index, totalLength) {
        return index > totalLength - 1 ? 0 : (index < 0 ? totalLength - 1 : index);
    };
    /**
     *  Used to configure tooltips for the chart's axes.
     *
     * @private
     * @param {Event} event - Specifies the event args.
     * @param {number} x - Specifies the x value.
     * @param {number} y - Specifies the y value.
     * @param {boolean} isTouch - Specifies the boolean value.
     * @description - Handles the axis tooltip.
     *
     */
    Chart3D.prototype.axisTooltip = function (event, x, y, isTouch) {
        var targetId = event.target.id;
        if ((targetId.indexOf('axis-label') > -1) &&
            (event.target.textContent.indexOf('...') > -1)) {
            var isTitleOrLegendEnabled = (this.legendSettings.visible || this.primaryXAxis.title === '');
            showTooltip(this.findAxisLabel(targetId), x, y, this.element.offsetWidth, this.element.id + '-EJ2-axis-label-tooltip', getElement$1(this.element.id + '_Secondary_Element'), isTouch, isTitleOrLegendEnabled);
        }
        else {
            removeElement(this.element.id + '-EJ2-axis-label-tooltip');
        }
    };
    /**
     * Searches for an axis label based on the provided text.
     *
     * @param {string} text - The text to search for within the axis label collection.
     * @returns {string} - The matching axis label, or an empty string if no match is found.
     */
    Chart3D.prototype.findAxisLabel = function (text) {
        var texts;
        texts = ((text.replace(this.element.id + '-', '')).replace('-axis-label', '')).split('-');
        return this.axisCollections[parseInt(texts[0], 10)].visibleLabels[parseInt(texts[1], 10)].originalText;
    };
    /**
     * Sets focus on a child element within the parent element.
     *
     * @param {HTMLElement} element - The parent element containing the child to be focused.
     * @returns {string} - A message indicating the result of the focus operation.
     */
    Chart3D.prototype.focusChild = function (element) {
        element.setAttribute('tabindex', '0');
        var className = element.getAttribute('class');
        element.setAttribute('tabindex', '0');
        if (className && className.indexOf('e-chart-focused') === -1) {
            className = 'e-chart-focused ' + className;
        }
        else if (!className) {
            className = 'e-chart-focused';
        }
        element.setAttribute('class', className);
        element.focus();
        return element.id;
    };
    /**
     * Handles the document onkey.
     *
     * @param {KeyboardEvent} e - The keyboard event triggering the navigation.
     * @private
     */
    Chart3D.prototype.documentKeyHandler = function (e) {
        if (e.altKey && e.keyCode === 74 && !isNullOrUndefined(this.element)) {
            this.element.focus();
        }
    };
    /**
     * Handles chart keyboard navigation events.
     *
     * @param {KeyboardEvent} e - The keyboard event triggering the navigation.
     * @param {string} targetId - The ID of the target element or chart component.
     * @param { string} actionKey - - The type of keyboard action (e.g., 'Tab' or 'ArrowMove').
     */
    Chart3D.prototype.chartKeyboardNavigations = function (e, targetId, actionKey) {
        this.isLegendClicked = false;
        switch (actionKey) {
            case 'Tab':
            case 'ArrowMove':
                if (this.highlight3DModule) {
                    this.highlight3DModule.removeLegendHighlightStyles();
                }
                if (targetId.indexOf('-point-') > -1) {
                    if (document.activeElement) {
                        var element = document.activeElement;
                        var rect = element.getBoundingClientRect();
                        // Client coordinates (relative to the viewport)
                        var clientX = rect.left + rect.width / 2;
                        var clientY = rect.top;
                        // Page coordinates (relative to the whole document)
                        var pageX = window.scrollX + clientX;
                        var pageY = window.scrollY + clientY;
                        this.mouseX = pageX;
                        this.mouseY = pageY;
                    }
                    if (this.highlight3DModule) {
                        this.highlight3DModule.highlightChart(document.getElementById(targetId), 'mousemove');
                        this.highlight3DModule.completeSelection(document.getElementById(targetId), 'mousemove');
                    }
                    if (this.tooltip3DModule) {
                        this.tooltip3DModule.tooltip(e);
                    }
                }
                if (this.highlight3DModule && this.highlightMode !== 'None') {
                    targetId = targetId.indexOf('_chart_legend_g_') > -1 ? document.getElementById(targetId).firstChild['id'] : targetId;
                    var legendID = this.element.id + '_chart_legend';
                    var legendItemsId = [legendID + '_text_', legendID + '_shape_marker_',
                        legendID + '_shape_'];
                    for (var i = 0; i < legendItemsId.length; i++) {
                        var id = legendItemsId[i];
                        if (targetId.indexOf(id) > -1) {
                            document.getElementById(targetId).setAttribute('class', '');
                            this.highlight3DModule.legendSelection(this, parseInt(targetId.split(id)[1], 10), document.getElementById(targetId), 'mousemove');
                            break;
                        }
                    }
                }
                break;
            case 'Enter':
            case 'Space':
                if (targetId.indexOf('_chart_legend_') > -1) {
                    this.isLegendClicked = true;
                    this.legend3DModule.click(e);
                    this.focusChild(document.getElementById(targetId).parentElement);
                }
                else {
                    this.selection3DModule.calculateSelectedElements(document.getElementById(targetId), 'click');
                }
                break;
            case 'CtrlP':
                this.print();
                break;
            case 'ESC':
                this.tooltip3DModule.removeTooltip(1);
                break;
        }
    };
    /**
     *  Applys the style for chart.
     *
     * @private
     * @param {HTMLElement} element - Specifies the element.
     */
    Chart3D.prototype.setStyle = function (element) {
        var disableScroll = this.selectionMode !== 'None' || this.highlightMode !== 'None';
        element.style.touchAction = this.enableRotation || disableScroll ? 'none' : 'element';
        element.style.msTouchAction = disableScroll ? 'none' : 'element';
        element.style.msContentZooming = 'none';
        element.style.msUserSelect = 'none';
        element.style.webkitUserSelect = 'none';
        element.style.position = 'relative';
        element.style.display = 'block';
        element.style.overflow = 'hidden';
        element.style.height = (element.style.height || (this.height && this.height.indexOf('%') === -1)) ? element.style.height : 'inherit';
    };
    /**
     * The method to determine whether it is a secondary axis or not.
     *
     * @private
     * @param  {Chart3DAxis} axis
     * @returns {boolean}
     *
     */
    Chart3D.prototype.isSecondaryAxis = function (axis) {
        return (this.axes.indexOf(axis) > -1);
    };
    /**
     * To refresh the rows and columns.
     *
     * @param {Chart3DRow[] | Chart3DColumn} definitions - Specifies the row or column definition.
     */
    Chart3D.prototype.refreshDefinition = function (definitions) {
        for (var _i = 0, definitions_1 = definitions; _i < definitions_1.length; _i++) {
            var item = definitions_1[_i];
            item.axes = [];
        }
    };
    /**
     * Adds new series to the chart
     *
     * @param {Chart3DSeriesModel[]} seriesCollection - The series collection to be added to the chart.
     */
    Chart3D.prototype.addSeries = function (seriesCollection) {
        this.animateSeries = false;
        for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {
            var series = seriesCollection_1[_i];
            series = new Chart3DSeries(this, 'series', series);
            this.series.push(series);
        }
        this.refresh();
    };
    /**
     * Removes a series from the chart
     *
     * @param {number} index - The index of the series to be removed from the chart.
     */
    Chart3D.prototype.removeSeries = function (index) {
        this.redraw = false;
        this.animateSeries = false;
        if (this.visibleSeries[index]) {
            this.visibleSeries[index].xAxis.orientation = null;
            this.visibleSeries[index].yAxis.orientation = null;
        }
        for (var i = 0; i < this.axes.length; i++) {
            if (this.axes[i].orientation === null) {
                this.axes.splice(i, 1);
            }
        }
        this.series.splice(index, 1);
        this.refresh();
    };
    /**
     * Refresh the axis default value.
     *
     * @private
     */
    Chart3D.prototype.refreshAxis = function () {
        var axis = this.primaryXAxis;
        axis.rect = new Rect(undefined, undefined, 0, 0);
        axis = this.primaryYAxis;
        axis.isStack100 = false;
        axis.rect = new Rect(undefined, undefined, 0, 0);
        for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {
            var item = _a[_i];
            axis = item;
            axis.rect = new Rect(undefined, undefined, 0, 0);
            axis.isStack100 = false;
        }
    };
    /**
     * Refresh the 3D chart axis.
     *
     * @param {Chart3DAxis} axis
     * @returns {boolean}
     * @private
     */
    Chart3D.prototype.axisChange = function (axis) {
        if (!axis.name && !axis.valueType) {
            return false;
        }
        this.refreshDefinition(this.columns);
        this.refreshDefinition(this.rows);
        this.calculateVisibleAxis();
        this.processData();
        return true;
    };
    /**
     * Get visible series by index.
     */
    Chart3D.prototype.getVisibleSeries = function (visibleSeries, index) {
        for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
            var series = visibleSeries_1[_i];
            if (index === series.index) {
                return series;
            }
        }
        return null;
    };
    /**
     * To remove style element.
     */
    Chart3D.prototype.removeStyles = function () {
        removeElement(this.element.id + '_ej2_chart_selection');
        removeElement(this.element.id + '_ej2_chart_highlight');
    };
    /**
     * To find the 3D chart visible series.
     *
     */
    Chart3D.prototype.calculateVisibleSeries = function () {
        var series;
        this.visibleSeries = [];
        var colors = this.palettes.length ? this.palettes : get3DSeriesColor(this.theme);
        var count = colors.length;
        var seriesCollection = this.series;
        var vibileSeries = this.series[0];
        if (vibileSeries) {
            this.requireInvertedAxis = ((vibileSeries.type.indexOf('Bar') !== -1) && !this.isTransposed) ||
                ((vibileSeries.type.indexOf('Bar') === -1) && this.isTransposed);
        }
        for (var i = 0, len = seriesCollection.length; i < len; i++) {
            series = seriesCollection[i];
            series.category = 'Series';
            series.index = i;
            series.interior = series.fill || colors[i % count];
            if (this.isSecondaryAxis(series.xAxis)) {
                series.xAxis.internalVisibility = series.xAxis.series.some(function (value) { return (value.visible); });
            }
            if (this.isSecondaryAxis(series.yAxis)) {
                series.yAxis.internalVisibility = series.yAxis.series.some(function (value) { return (value.visible); });
            }
            switch (series.type) {
                case 'Bar':
                case 'StackingBar':
                case 'StackingBar100':
                    if (seriesCollection[0].type.indexOf('Bar') === -1) {
                        continue;
                    }
                    break;
                default:
                    if (seriesCollection[0].type.indexOf('Bar') > -1) {
                        continue;
                    }
                    break;
            }
            this.visibleSeries.push(series);
            seriesCollection[i] = series;
        }
    };
    Chart3D.prototype.highlightAnimation = function (element, index, duration, startOpacity) {
        var endOpacity = parseFloat(this.visibleSeries[index].opacity.toString());
        if (endOpacity) {
            new Animation({}).animate(element, {
                duration: duration,
                progress: function (args) {
                    element.style.animation = '';
                    var progress = args.timeStamp / args.duration;
                    var currentOpacity = startOpacity + (endOpacity - startOpacity) * progress;
                    element.setAttribute('opacity', currentOpacity.toString());
                },
                end: function () {
                    element.setAttribute('opacity', endOpacity.toString());
                }
            });
        }
    };
    Chart3D.prototype.stopElementAnimation = function (element, index) {
        var endOpacity = parseFloat(this.visibleSeries[index].opacity.toString());
        var animation = element.getAttribute('e-animate');
        if (animation) {
            Animation.stop(element);
        }
        element.setAttribute('opacity', endOpacity.toString());
    };
    /**
      * To destroy the widget
      *
      * @function destroy
      * @member of Chart
      */
    Chart3D.prototype.destroy = function () {
        this.horizontalAxes = [];
        this.verticalAxes = [];
        this.visibleSeries = [];
        this.axisCollections = [];
        this.seriesElements = null;
        this.chartAxisLayoutPanel = null;
        this.dataLabelElements = null;
        this.dataLabelCollections = null;
        removeElement(this.element.id + 'Keyboard_chart_focus');
        removeElement(this.element.id + '_ej2_chart_highlight');
        removeElement('chartmeasuretext');
        /**
         * To fix react timeout destroy issue.
         */
        if (this.element) {
            this.unWireEvents();
            if (this.isReact) {
                this.clearTemplate();
            }
            _super.prototype.destroy.call(this);
            this.polygons = [];
            var grpElement = document.getElementById(this.chart3D.id);
            if (grpElement) {
                grpElement.innerHTML = '';
                grpElement.remove();
            }
            this.removeSvg();
            this.svgObject = null;
        }
    };
    /**
     * For internal use only - Get the module name.
     *
     * @returns {string} returns the module name
     * @private
     */
    Chart3D.prototype.getModuleName = function () {
        return 'chart3d';
    };
    /**
     * Get the properties to be maintained in the persisted state.
     *
     * @private
     */
    Chart3D.prototype.getPersistData = function () {
        var keyEntity = ['loaded'];
        return this.addOnPersist(keyEntity);
    };
    /**
     * Called internally if any of the property value changed.
     * @private
     */
    Chart3D.prototype.onPropertyChanged = function (newProp, oldProp) {
        var renderer = false;
        var refreshBounds = false;
        var axis;
        this.animateSeries = false;
        if (!this.delayRedraw) {
            for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
                var prop = _a[_i];
                switch (prop) {
                    case 'primaryXAxis':
                        axis = newProp.primaryXAxis;
                        refreshBounds = this.axisChange(axis);
                        if (newProp.primaryXAxis.edgeLabelPlacement) {
                            renderer = true;
                        }
                        refreshBounds = true;
                        if (!isNullOrUndefined(axis.isInversed) || !isNullOrUndefined(axis.opposedPosition)) {
                            this.primaryXAxis.setIsInversedAndOpposedPosition();
                        }
                        break;
                    case 'primaryYAxis':
                        axis = newProp.primaryYAxis;
                        refreshBounds = this.axisChange(axis);
                        if (newProp.primaryYAxis.edgeLabelPlacement) {
                            renderer = true;
                        }
                        refreshBounds = true;
                        if (!isNullOrUndefined(axis.isInversed) || !isNullOrUndefined(axis.opposedPosition)) {
                            this.primaryYAxis.setIsInversedAndOpposedPosition();
                        }
                        break;
                    case 'axes':
                        for (var _b = 0, _c = Object.keys(newProp.axes); _b < _c.length; _b++) {
                            var index = _c[_b];
                            axis = newProp.axes[index];
                            refreshBounds = refreshBounds || this.axisChange(axis);
                            refreshBounds = true;
                            if (!isNullOrUndefined(axis.isInversed) || !isNullOrUndefined(axis.opposedPosition)) {
                                this.axes[index].setIsInversedAndOpposedPosition();
                            }
                        }
                        break;
                    case 'height':
                    case 'width':
                        this.createChartSvg();
                        refreshBounds = true;
                        break;
                    case 'subTitle':
                    case 'title':
                        refreshBounds = true;
                        break;
                    case 'titleStyle':
                        if (newProp.titleStyle && (newProp.titleStyle.size || newProp.titleStyle.textOverflow)) {
                            refreshBounds = true;
                        }
                        else {
                            renderer = true;
                        }
                        break;
                    case 'subTitleStyle':
                        if (newProp.subTitleStyle && (newProp.subTitleStyle.size || newProp.subTitleStyle.textOverflow)) {
                            refreshBounds = true;
                        }
                        else {
                            renderer = true;
                        }
                        break;
                    case 'border':
                        renderer = true;
                        break;
                    case 'series':
                        var len = this.series.length;
                        var seriesRefresh = false;
                        var series = void 0;
                        for (var i = 0; i < len; i++) {
                            series = newProp.series[i];
                            if (series && (series.dataSource || series.query || series.xName ||
                                series.yName || series.size || series.fill || series.name || series.type)) {
                                extend(this.getVisibleSeries(this.visibleSeries, i), series, null, true);
                                seriesRefresh = true;
                            }
                        }
                        if (this.availableSize && this.element) {
                            this.element.style.height = (!this.element.style.height || this.element.style.height == 'inherit') ? (this.availableSize.height + 'px') : this.element.style.height;
                        }
                        if (seriesRefresh) {
                            this.calculateVisibleSeries();
                            this.refreshDefinition(this.columns);
                            this.refreshDefinition(this.rows);
                            this.calculateVisibleAxis();
                            this.processData(false);
                            refreshBounds = true;
                        }
                        break;
                    case 'background':
                        renderer = true;
                        break;
                    case 'dataSource':
                        this.processData(false);
                        refreshBounds = true;
                        break;
                    case 'legendSettings':
                        if (!newProp.legendSettings.background || !newProp.legendSettings.opacity) {
                            refreshBounds = true;
                        }
                        renderer = true;
                        break;
                    case 'palettes':
                        this.calculateVisibleSeries();
                        renderer = true;
                        break;
                    case 'selectedDataIndexes':
                        if (this.selection3DModule) {
                            this.selection3DModule.currentMode = this.selectionMode;
                            this.selection3DModule.selectedDataIndexes = this.selectedDataIndexes;
                            this.selection3DModule.styleId = this.element.id + '_ej2_chart_selection';
                            this.selection3DModule.redrawSelection(this, oldProp.selectionMode, true);
                        }
                        break;
                    case 'selectionMode':
                        if (this.selection3DModule && newProp.selectionMode && newProp.selectionMode.indexOf('Drag') === -1) {
                            this.selection3DModule.currentMode = this.selectionMode;
                            this.selection3DModule.styleId = this.element.id + '_ej2_chart_selection';
                            this.selection3DModule.redrawSelection(this, oldProp.selectionMode, true);
                        }
                        break;
                    case 'isMultiSelect':
                        if (this.selection3DModule && !newProp.isMultiSelect && this.selection3DModule.selectedDataIndexes.length > 1) {
                            this.selection3DModule.currentMode = this.selectionMode;
                            this.selection3DModule.styleId = this.element.id + '_ej2_chart_selection';
                            this.selection3DModule.redrawSelection(this, oldProp.selectionMode);
                        }
                        break;
                    case 'highlightMode':
                    case 'selectionPattern':
                    case 'highlightPattern':
                        this.removeStyles();
                        renderer = true;
                        break;
                    case 'theme':
                        this.animateSeries = true;
                        break;
                    case 'enableRtl':
                    case 'locale':
                    case 'currencyCode':
                        this.refresh();
                        break;
                    case 'tooltip':
                        if (this.tooltip3DModule) { // To check the tooltip enable is true.
                            this.tooltip3DModule.previousPoints = [];
                            if (this.tooltip.template) {
                                this.tooltip3DModule.template = this.tooltip.template;
                            }
                        }
                        break;
                    case 'enableRotation':
                    case 'tilt':
                    case 'depth':
                    case 'wallSize':
                    case 'rotation':
                    case 'perspectiveAngle':
                    case 'enableSideBySidePlacement':
                        renderer = true;
                        break;
                }
            }
            if (!refreshBounds && renderer) {
                this.removeSvg();
                this.polygons = [];
                this.renderElements();
                this.trigger('loaded', { chart: this });
            }
            if (refreshBounds) {
                this.removeSvg();
                if (this.isReact) {
                    this.clearTemplate();
                }
                this.polygons = [];
                this.refreshAxis();
                this.refreshBound();
                this.trigger('loaded', { chart: this });
                this.redraw = false;
                this.animated = false;
            }
        }
    };
    __decorate$24([
        Property('')
    ], Chart3D.prototype, "title", void 0);
    __decorate$24([
        Property('')
    ], Chart3D.prototype, "subTitle", void 0);
    __decorate$24([
        Property('Bootstrap5')
    ], Chart3D.prototype, "theme", void 0);
    __decorate$24([
        Property(null)
    ], Chart3D.prototype, "description", void 0);
    __decorate$24([
        Property(null)
    ], Chart3D.prototype, "width", void 0);
    __decorate$24([
        Property(null)
    ], Chart3D.prototype, "backgroundImage", void 0);
    __decorate$24([
        Property(null)
    ], Chart3D.prototype, "background", void 0);
    __decorate$24([
        Property('')
    ], Chart3D.prototype, "dataSource", void 0);
    __decorate$24([
        Property(null)
    ], Chart3D.prototype, "height", void 0);
    __decorate$24([
        Property(50)
    ], Chart3D.prototype, "depth", void 0);
    __decorate$24([
        Property(2)
    ], Chart3D.prototype, "wallSize", void 0);
    __decorate$24([
        Property(0)
    ], Chart3D.prototype, "tilt", void 0);
    __decorate$24([
        Property(false)
    ], Chart3D.prototype, "enableRotation", void 0);
    __decorate$24([
        Property(0)
    ], Chart3D.prototype, "rotation", void 0);
    __decorate$24([
        Property(true)
    ], Chart3D.prototype, "enableSideBySidePlacement", void 0);
    __decorate$24([
        Property(90)
    ], Chart3D.prototype, "perspectiveAngle", void 0);
    __decorate$24([
        Property(null)
    ], Chart3D.prototype, "wallColor", void 0);
    __decorate$24([
        Property(false)
    ], Chart3D.prototype, "isTransposed", void 0);
    __decorate$24([
        Property('USD')
    ], Chart3D.prototype, "currencyCode", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "load", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "loaded", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "pointClick", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "pointMove", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "pointRender", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "legendRender", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "legendClick", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "seriesRender", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "textRender", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "tooltipRender", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "beforeResize", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "resized", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "chart3DMouseMove", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "chart3DMouseClick", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "chart3DMouseDown", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "chart3DMouseLeave", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "chart3DMouseUp", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "axisLabelRender", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "selectionComplete", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "beforeExport", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "afterExport", void 0);
    __decorate$24([
        Event()
    ], Chart3D.prototype, "beforePrint", void 0);
    __decorate$24([
        Complex({}, Margin)
    ], Chart3D.prototype, "margin", void 0);
    __decorate$24([
        Complex({ fontFamily: null, size: '16px', fontStyle: 'Normal', fontWeight: '600', color: null }, titleSettings)
    ], Chart3D.prototype, "titleStyle", void 0);
    __decorate$24([
        Complex({ fontFamily: null, size: '14px', fontStyle: 'Normal', fontWeight: '400', color: null }, titleSettings)
    ], Chart3D.prototype, "subTitleStyle", void 0);
    __decorate$24([
        Complex({}, Chart3DLegendSettings)
    ], Chart3D.prototype, "legendSettings", void 0);
    __decorate$24([
        Complex({ color: '#DDDDDD', width: 0 }, Border)
    ], Chart3D.prototype, "border", void 0);
    __decorate$24([
        Complex({ name: 'primaryXAxis' }, Chart3DAxis)
    ], Chart3D.prototype, "primaryXAxis", void 0);
    __decorate$24([
        Complex({ name: 'primaryYAxis' }, Chart3DAxis)
    ], Chart3D.prototype, "primaryYAxis", void 0);
    __decorate$24([
        Complex({}, Chart3DTooltipSettings)
    ], Chart3D.prototype, "tooltip", void 0);
    __decorate$24([
        Collection([{}], Chart3DRow)
    ], Chart3D.prototype, "rows", void 0);
    __decorate$24([
        Collection([{}], Chart3DColumn)
    ], Chart3D.prototype, "columns", void 0);
    __decorate$24([
        Collection([{}], Chart3DAxis)
    ], Chart3D.prototype, "axes", void 0);
    __decorate$24([
        Collection([{}], Chart3DSeries)
    ], Chart3D.prototype, "series", void 0);
    __decorate$24([
        Property('')
    ], Chart3D.prototype, "highlightColor", void 0);
    __decorate$24([
        Property('None')
    ], Chart3D.prototype, "selectionMode", void 0);
    __decorate$24([
        Property('None')
    ], Chart3D.prototype, "highlightMode", void 0);
    __decorate$24([
        Property('None')
    ], Chart3D.prototype, "selectionPattern", void 0);
    __decorate$24([
        Property('None')
    ], Chart3D.prototype, "highlightPattern", void 0);
    __decorate$24([
        Property(false)
    ], Chart3D.prototype, "isMultiSelect", void 0);
    __decorate$24([
        Collection([], Indexes)
    ], Chart3D.prototype, "selectedDataIndexes", void 0);
    __decorate$24([
        Property(false)
    ], Chart3D.prototype, "useGroupingSeparator", void 0);
    __decorate$24([
        Property([])
    ], Chart3D.prototype, "palettes", void 0);
    Chart3D = __decorate$24([
        NotifyPropertyChanges
    ], Chart3D);
    return Chart3D;
}(Component));

var __extends$103 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Common axis classes
 *
 * @private
 */
var NiceIntervals = /** @__PURE__ @class */ (function (_super) {
    __extends$103(NiceIntervals, _super);
    function NiceIntervals() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Calculates a nice interval for a date-time axis based on the given size and data range.
     *
     * @param {Chart3DAxis} axis - The date-time axis for which the nice interval is calculated.
     * @param {Size} size - The size of the chart area.
     * @param {number} start - The start value of the data range.
     * @param {number} end - The end value of the data range.
     * @returns {number} - The calculated nice interval for the date-time axis.
     */
    NiceIntervals.prototype.calculateDateTimeNiceInterval = function (axis, size, start, end) {
        var oneDay = 24 * 60 * 60 * 1000;
        var startDate = new Date(start);
        var endDate = new Date(end);
        var totalDays = (Math.abs((startDate.getTime() - endDate.getTime()) / (oneDay)));
        var interval;
        axis.actualIntervalType = axis.intervalType;
        var type = axis.intervalType;
        switch (type) {
            case 'Years':
                interval = this.calculateNumericNiceInterval(axis, totalDays / 365, size);
                break;
            case 'Months':
                interval = this.calculateNumericNiceInterval(axis, totalDays / 30, size);
                break;
            case 'Days':
                interval = this.calculateNumericNiceInterval(axis, totalDays, size);
                break;
            case 'Hours':
                interval = this.calculateNumericNiceInterval(axis, totalDays * 24, size);
                break;
            case 'Minutes':
                interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60, size);
                break;
            case 'Seconds':
                interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60 * 60, size);
                break;
            case 'Auto':
                interval = this.calculateNumericNiceInterval(axis, totalDays / 365, size);
                if (interval >= 1) {
                    axis.actualIntervalType = 'Years';
                    return interval;
                }
                interval = this.calculateNumericNiceInterval(axis, totalDays / 30, size);
                if (interval >= 1) {
                    axis.actualIntervalType = 'Months';
                    return interval;
                }
                interval = this.calculateNumericNiceInterval(axis, totalDays, size);
                if (interval >= 1) {
                    axis.actualIntervalType = 'Days';
                    return interval;
                }
                interval = this.calculateNumericNiceInterval(axis, totalDays * 24, size);
                if (interval >= 1) {
                    axis.actualIntervalType = 'Hours';
                    return interval;
                }
                interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60, size);
                if (interval >= 1) {
                    axis.actualIntervalType = 'Minutes';
                    return interval;
                }
                interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60 * 60, size);
                axis.actualIntervalType = 'Seconds';
                return interval;
        }
        return interval;
    };
    /**
     * To get the skeleton for the DateTime axis.
     *
     * @param {Chart3DAxis} axis - The date-time axis for which the skeleton is calculated.
     * @returns {string} - Skeleton format.
     * @private
     */
    NiceIntervals.prototype.getSkeleton = function (axis) {
        var skeleton;
        var intervalType = axis.actualIntervalType;
        if (axis.skeleton) {
            return axis.skeleton;
        }
        if (intervalType === 'Years') {
            skeleton = ((axis.valueType === 'DateTime' && axis.isIntervalInDecimal) ? 'y' : 'yMMM');
        }
        else if (intervalType === 'Months') {
            skeleton = 'MMMd';
        }
        else if (intervalType === 'Days') {
            skeleton = (axis.valueType === 'DateTime' ? 'MMMd' : 'yMd');
        }
        else if (intervalType === 'Hours') {
            skeleton = (axis.valueType === 'DateTime' ? 'Hm' : 'EHm');
        }
        else if (intervalType === 'Minutes') {
            skeleton = 'Hms';
        }
        else {
            skeleton = 'Hms';
        }
        return skeleton;
    };
    /**
     * Find label format for axis
     *
     * @param {Chart3DAxis} axis - The  axis for which the label format is calculated.
     * @returns {string} - The axis label format.
     * @private
     */
    NiceIntervals.prototype.findCustomFormats = function (axis) {
        var labelFormat = axis.labelFormat ? axis.labelFormat : '';
        if (!axis.skeleton && axis.actualIntervalType === 'Months' && !labelFormat) {
            labelFormat = axis.valueType === 'DateTime' ? 'MMM yyyy' : 'yMMM';
        }
        return labelFormat;
    };
    return NiceIntervals;
}(Double3D));

var __extends$104 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * The `Category` module is used to render category axis.
 */
var Category3D = /** @__PURE__ @class */ (function (_super) {
    __extends$104(Category3D, _super);
    /**
     * Constructor for the category module.
     *
     * @param {Chart3D} chart - Chart instance.
     * @private
     */
    function Category3D(chart) {
        return _super.call(this, chart) || this;
    }
    /**
     * Calculates the range and interval for the specified axis based on the provided size.
     *
     * @param {Size} size - The size of the chart area used for range and interval calculation.
     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.
     * @returns {void}
     * @private
     */
    Category3D.prototype.calculateRangeAndInterval = function (size, axis) {
        this.calculateRange(axis);
        this.getActualRange(axis, size);
        this.applyRangePadding(axis, size);
        this.calculateVisibleLabels(axis);
    };
    /**
     * Retrieves the actual range for the specified axis based on the provided size.
     *
     * @param {Chart3DAxis} axis - The axis for which the actual range is calculated.
     * @param {Size} size - The size of the chart area used in the range calculation.
     * @returns {void}
     */
    Category3D.prototype.getActualRange = function (axis, size) {
        this.initializeDoubleRange(axis);
        axis.actualRange = {};
        if (!axis.interval) {
            axis.actualRange.interval = Math.max(1, Math.floor(axis.doubleRange.delta / getActualDesiredIntervalsCount(size, axis)));
        }
        else {
            axis.actualRange.interval = Math.ceil(axis.interval);
        }
        axis.actualRange.min = axis.doubleRange.start;
        axis.actualRange.max = axis.doubleRange.end;
        axis.actualRange.delta = axis.doubleRange.delta;
    };
    /**
     * Applies range padding to the specified axis based on the provided size.
     *
     * @param {Chart3DAxis} axis - The axis to which range padding is applied.
     * @param {Size} size - The size of the chart area used in the padding calculation.
     * @returns {void}
     */
    Category3D.prototype.applyRangePadding = function (axis, size) {
        var ticks = 0.5;
        axis.actualRange.min -= ticks;
        axis.actualRange.max += ticks;
        axis.doubleRange = new DoubleRange$1(axis.actualRange.min, axis.actualRange.max);
        axis.actualRange.delta = axis.doubleRange.delta;
        this.calculateVisibleRange(size, axis);
    };
    /**
     * Calculate visible labels for the axis based on the range calculated.
     *
     * @param {Chart3DAxis} axis - The axis for which the labels are calculated.
     * @returns {void}
     * @private
     */
    Category3D.prototype.calculateVisibleLabels = function (axis) {
        /*! Generate axis labels */
        axis.visibleLabels = [];
        axis.visibleRange.interval = axis.visibleRange.interval < 1 ? 1 : axis.visibleRange.interval;
        var tempInterval = Math.ceil(axis.visibleRange.min);
        var labelStyle;
        var position;
        axis.startLabel = axis.labels[Math.round(axis.visibleRange.min)];
        axis.endLabel = axis.labels[Math.floor(axis.visibleRange.max)];
        for (; tempInterval <= axis.visibleRange.max; tempInterval += axis.visibleRange.interval) {
            labelStyle = (extend({}, getValue('properties', axis.labelStyle), null, true));
            if (withIn(tempInterval, axis.visibleRange) && axis.labels.length > 0) {
                position = Math.round(tempInterval);
                triggerLabelRender(this.chart, position, axis.labels[position] ? axis.labels[position].toString() : position.toString(), labelStyle, axis);
            }
        }
        if (axis.getMaxLabelWidth) {
            axis.getMaxLabelWidth(this.chart);
        }
    };
    /**
     * Get module name
     *
     * @returns {string} - Returns the module name
     */
    Category3D.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'Category3D';
    };
    /**
     * To destroy the category axis.
     *
     * @returns {void}
     * @private
     */
    Category3D.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return Category3D;
}(NiceIntervals));

var __extends$105 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * The `DateTime` module is used to render datetime axis.
 */
var DateTime3D = /** @__PURE__ @class */ (function (_super) {
    __extends$105(DateTime3D, _super);
    /**
     * Constructor for the dateTime module.
     *
     * @param {Chart3D} chart - Chart3D instance.
     * @private
     */
    function DateTime3D(chart) {
        return _super.call(this, chart) || this;
    }
    /**
     * Calculates the range and interval for the specified axis based on the provided size.
     *
     * @param {Size} size - The size of the chart area used for range and interval calculation.
     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.
     * @returns {void}
     */
    DateTime3D.prototype.calculateRangeAndInterval = function (size, axis) {
        this.calculateRange(axis);
        this.getActualRange(axis, size);
        this.applyRangePadding(axis, size);
        this.calculateVisibleLabels(axis, this.chart);
    };
    /**
     * Retrieves the actual range for the specified axis based on the provided size.
     *
     * @param {Chart3DAxis} axis - The axis for which the actual range is calculated.
     * @param {Size} size - The size of the chart area used in the range calculation.
     * @returns {void}
     */
    DateTime3D.prototype.getActualRange = function (axis, size) {
        var option = {
            skeleton: 'full',
            type: 'dateTime'
        };
        var dateParser = this.chart.intl.getDateParser(option);
        var dateFormatter = this.chart.intl.getDateFormat(option);
        // Axis min
        if ((axis.minimum) !== null) {
            this.min = Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({ val: axis.minimum }).val))));
        }
        else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {
            this.min = Date.parse(dateParser(dateFormatter(new Date(1970, 1, 1))));
        }
        // Axis Max
        if ((axis.maximum) !== null) {
            this.max = Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({ val: axis.maximum }).val))));
        }
        else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {
            this.max = Date.parse(dateParser(dateFormatter(new Date(1970, 5, 1))));
        }
        if (this.min === this.max) {
            this.max = this.max + 2592000000;
            this.min = this.min - 2592000000;
        }
        axis.actualRange = {};
        axis.doubleRange = new DoubleRange$1(this.min, this.max);
        var datetimeInterval = this.calculateDateTimeNiceInterval(axis, size, axis.doubleRange.start, axis.doubleRange.end);
        if (!axis.interval) {
            axis.actualRange.interval = datetimeInterval;
        }
        else {
            axis.actualRange.interval = axis.interval;
        }
        axis.actualRange.min = axis.doubleRange.start;
        axis.actualRange.max = axis.doubleRange.end;
    };
    /**
     * Applies range padding to the specified axis based on the provided size.
     *
     * @param {Chart3DAxis} axis - The axis to which range padding is applied.
     * @param {Size} size - The size of the chart area used in the padding calculation.
     * @returns {void}
     */
    DateTime3D.prototype.applyRangePadding = function (axis, size) {
        this.min = (axis.actualRange.min);
        this.max = (axis.actualRange.max);
        var minimum;
        var maximum;
        var interval = axis.actualRange.interval;
        if (!setRange(axis)) {
            var rangePadding = axis.getRangePadding(this.chart);
            minimum = new Date(this.min);
            maximum = new Date(this.max);
            var intervalType = axis.actualIntervalType;
            if (rangePadding === 'None') {
                this.min = minimum.getTime();
                this.max = maximum.getTime();
            }
            else if (rangePadding === 'Additional' || rangePadding === 'Round') {
                switch (intervalType) {
                    case 'Years':
                        this.getYear(minimum, maximum, rangePadding, interval);
                        break;
                    case 'Months':
                        this.getMonth(minimum, maximum, rangePadding, interval);
                        break;
                    case 'Days':
                        this.getDay(minimum, maximum, rangePadding, interval);
                        break;
                    case 'Hours':
                        this.getHour(minimum, maximum, rangePadding, interval);
                        break;
                    case 'Minutes':
                        var minute = (minimum.getMinutes() / interval) * interval;
                        var endMinute = maximum.getMinutes() + (minimum.getMinutes() - minute);
                        if (rangePadding === 'Round') {
                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minute, 0)).getTime();
                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), endMinute, 59)).getTime();
                        }
                        else {
                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minute + (-interval), 0)).getTime();
                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), endMinute + (interval), 0)).getTime();
                        }
                        break;
                    case 'Seconds':
                        var second = (minimum.getSeconds() / interval) * interval;
                        var endSecond = maximum.getSeconds() + (minimum.getSeconds() - second);
                        if (rangePadding === 'Round') {
                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minimum.getMinutes(), second, 0)).getTime();
                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), maximum.getMinutes(), endSecond, 0)).getTime();
                        }
                        else {
                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minimum.getMinutes(), second + (-interval), 0)).getTime();
                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), maximum.getMinutes(), endSecond + (interval), 0)).getTime();
                        }
                        break;
                }
            }
        }
        axis.actualRange.min = (axis.minimum != null) ? this.min : this.min;
        axis.actualRange.max = (axis.maximum != null) ? this.max : this.max;
        axis.actualRange.delta = (axis.actualRange.max - axis.actualRange.min);
        axis.doubleRange = new DoubleRange$1(axis.actualRange.min, axis.actualRange.max);
        this.calculateVisibleRange(size, axis);
    };
    /**
     * Determines the year values within the specified date range with consideration for range padding and interval.
     *
     * @param {Date} minimum - The minimum date of the range.
     * @param {Date} maximum - The maximum date of the range.
     * @param {ChartRangePadding} rangePadding - The type of range padding to apply.
     * @param {number} interval - The desired interval between years.
     * @returns {void}
     */
    DateTime3D.prototype.getYear = function (minimum, maximum, rangePadding, interval) {
        var startYear = minimum.getFullYear();
        var endYear = maximum.getFullYear();
        if (rangePadding === 'Additional') {
            this.min = (new Date(startYear - interval, 1, 1, 0, 0, 0)).getTime();
            this.max = (new Date(endYear + interval, 1, 1, 0, 0, 0)).getTime();
        }
        else {
            this.min = new Date(startYear, 0, 0, 0, 0, 0).getTime();
            this.max = new Date(endYear, 11, 30, 23, 59, 59).getTime();
        }
    };
    /**
     * Determines the month values within the specified date range with consideration for range padding and interval.
     *
     * @param {Date} minimum - The minimum date of the range.
     * @param {Date} maximum - The maximum date of the range.
     * @param {ChartRangePadding} rangePadding - The type of range padding to apply.
     * @param {number} interval - The desired interval between months.
     * @returns {void}
     */
    DateTime3D.prototype.getMonth = function (minimum, maximum, rangePadding, interval) {
        var month = minimum.getMonth();
        var endMonth = maximum.getMonth();
        if (rangePadding === 'Round') {
            this.min = (new Date(minimum.getFullYear(), month, 0, 0, 0, 0)).getTime();
            this.max = (new Date(maximum.getFullYear(), endMonth, new Date(maximum.getFullYear(), maximum.getMonth(), 0).getDate(), 23, 59, 59)).getTime();
        }
        else {
            this.min = (new Date(minimum.getFullYear(), month + (-interval), 1, 0, 0, 0)).getTime();
            this.max = (new Date(maximum.getFullYear(), endMonth + (interval), endMonth === 2 ? 28 : 30, 0, 0, 0)).getTime();
        }
    };
    /**
     * Determines the day values within the specified date range with consideration for range padding and interval.
     *
     * @param {Date} minimum - The minimum date of the range.
     * @param {Date} maximum - The maximum date of the range.
     * @param {ChartRangePadding} rangePadding - The type of range padding to apply.
     * @param {number} interval - The desired interval between days.
     * @returns {void}
     */
    DateTime3D.prototype.getDay = function (minimum, maximum, rangePadding, interval) {
        var day = minimum.getDate();
        var endDay = maximum.getDate();
        if (rangePadding === 'Round') {
            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), day, 0, 0, 0)).getTime();
            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), endDay, 23, 59, 59)).getTime();
        }
        else {
            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), day + (-interval), 0, 0, 0)).getTime();
            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), endDay + (interval), 0, 0, 0)).getTime();
        }
    };
    /**
     * Determines the hour values within the specified date range with consideration for range padding and interval.
     *
     * @param {Date} minimum - The minimum date of the range.
     * @param {Date} maximum - The maximum date of the range.
     * @param {ChartRangePadding} rangePadding - The type of range padding to apply.
     * @param {number} interval - The desired interval between hours.
     * @returns {void}
     */
    DateTime3D.prototype.getHour = function (minimum, maximum, rangePadding, interval) {
        var hour = (minimum.getHours() / interval) * interval;
        var endHour = maximum.getHours() + (minimum.getHours() - hour);
        if (rangePadding === 'Round') {
            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), hour, 0, 0)).getTime();
            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), endHour, 59, 59)).getTime();
        }
        else {
            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), hour + (-interval), 0, 0)).getTime();
            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), endHour + (interval), 0, 0)).getTime();
        }
    };
    /**
     * Calculates the visible range for the specified axis based on the provided size.
     *
     * @param {Size} size - The size of the chart area used in the visible range calculation.
     * @param {Chart3DAxis} axis - The axis for which the visible range is calculated.
     * @returns {void}
     */
    DateTime3D.prototype.calculateVisibleRange = function (size, axis) {
        axis.visibleRange = {
            min: axis.actualRange.min,
            max: axis.actualRange.max,
            interval: axis.actualRange.interval,
            delta: axis.actualRange.delta
        };
        axis.dateTimeInterval = this.increaseDateTimeInterval(axis, axis.visibleRange.min, axis.visibleRange.interval).getTime()
            - axis.visibleRange.min;
        axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);
    };
    /**
     * Calculate visible labels for the axis.
     *
     * @param {Chart3DAxis} axis -  The axis for which the labels are calculated.
     * @param {Chart3D} chart chart
     * @returns {void}
     * @private
     */
    DateTime3D.prototype.calculateVisibleLabels = function (axis, chart) {
        axis.visibleLabels = [];
        var tempInterval = axis.visibleRange.min;
        var labelStyle;
        var axisLabels = axis.visibleLabels;
        if (!setRange(axis)) {
            tempInterval = this.alignRangeStart(axis, tempInterval, axis.visibleRange.interval).getTime();
        }
        while (tempInterval <= axis.visibleRange.max) {
            labelStyle = (extend({}, getValue('properties', axis.labelStyle), null, true));
            axis.format = chart.intl.getDateFormat({
                format: this.findCustomFormats(axis) || '',
                type: firstToLowerCase(axis.skeletonType),
                skeleton: this.getSkeleton(axis)
            });
            axis.startLabel = axis.format(new Date(axis.visibleRange.min));
            axis.endLabel = axis.format(new Date(axis.visibleRange.max));
            if (withIn(tempInterval, axis.visibleRange)) {
                var interval = this.increaseDateTimeInterval(axis, tempInterval, axis.visibleRange.interval).getTime();
                if (interval > axis.visibleRange.max) {
                    axis.endLabel = axis.format(new Date(tempInterval));
                }
                triggerLabelRender(chart, tempInterval, axis.format(new Date(tempInterval)), labelStyle, axis);
            }
            var actualInterval = tempInterval;
            tempInterval = this.increaseDateTimeInterval(axis, tempInterval, axis.visibleRange.interval).getTime();
            if (actualInterval === tempInterval) {
                break;
            }
        }
        if ((axis.actualIntervalType === 'Months' || axis.actualIntervalType === 'Days')) {
            axis.format = chart.intl.getDateFormat({
                format: axis.labelFormat || (axis.actualIntervalType === 'Months' && !axis.skeleton ? 'y MMM' : ''),
                type: firstToLowerCase(axis.skeletonType), skeleton: axis.skeleton || (axis.actualIntervalType === 'Days' ? 'MMMd' : '')
            });
        }
        if (axis.getMaxLabelWidth) {
            axis.getMaxLabelWidth(this.chart);
        }
    };
    /**
     * Increases a date-time interval by the specified value for the given axis.
     *
     * @param {Chart3DAxis} axis - The axis for which the date-time interval is increased.
     * @param {number} value - The value by which to increase the interval.
     * @param {number} interval - The original interval to be adjusted.
     * @returns {Date} - The adjusted date-time interval.
     * @private
     */
    DateTime3D.prototype.increaseDateTimeInterval = function (axis, value, interval) {
        var result = new Date(value);
        if (axis.interval) {
            axis.isIntervalInDecimal = (interval % 1) === 0;
            axis.visibleRange.interval = interval;
        }
        else {
            interval = Math.ceil(interval);
            axis.visibleRange.interval = interval;
        }
        var intervalType = axis.actualIntervalType;
        if (axis.isIntervalInDecimal) {
            switch (intervalType) {
                case 'Years':
                    result.setFullYear(result.getFullYear() + interval);
                    return result;
                case 'Months':
                    result.setMonth(result.getMonth() + interval);
                    return result;
                case 'Days':
                    result.setDate(result.getDate() + interval);
                    return result;
                case 'Hours':
                    result.setHours(result.getHours() + interval);
                    return result;
                case 'Minutes':
                    result.setMinutes(result.getMinutes() + interval);
                    return result;
                case 'Seconds':
                    result.setSeconds(result.getSeconds() + interval);
                    return result;
            }
        }
        return result;
    };
    /**
     * Aligns the starting date of the range for the specified axis based on the provided date and interval size.
     *
     * @param {Chart3DAxis} axis - The axis for which the range start is aligned.
     * @param {number} sDate - The date in numerical format to be aligned.
     * @param {number} intervalSize - The size of the interval used for alignment.
     * @returns {Date} - The aligned date for the range start.
     * @private
     */
    DateTime3D.prototype.alignRangeStart = function (axis, sDate, intervalSize) {
        var sResult = new Date(sDate);
        switch (axis.actualIntervalType) {
            case 'Years':
                var year = Math.floor(Math.floor(sResult.getFullYear() / intervalSize) * intervalSize);
                sResult = new Date(year, sResult.getMonth(), sResult.getDate(), 0, 0, 0);
                return sResult;
            case 'Months':
                var month = Math.floor(Math.floor((sResult.getMonth()) / intervalSize) * intervalSize);
                sResult = new Date(sResult.getFullYear(), month, sResult.getDate(), 0, 0, 0);
                return sResult;
            case 'Days':
                var day = Math.floor(Math.floor((sResult.getDate()) / intervalSize) * intervalSize);
                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), day, 0, 0, 0);
                return sResult;
            case 'Hours':
                var hour = Math.floor(Math.floor((sResult.getHours()) / intervalSize) * intervalSize);
                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), hour, 0, 0);
                return sResult;
            case 'Minutes':
                var minutes = Math.floor(Math.floor((sResult.getMinutes()) / intervalSize) * intervalSize);
                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), sResult.getHours(), minutes, 0, 0);
                return sResult;
            case 'Seconds':
                var seconds = Math.floor(Math.floor((sResult.getSeconds()) / intervalSize) * intervalSize);
                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), sResult.getHours(), sResult.getMinutes(), seconds, 0);
                return sResult;
        }
        return sResult;
    };
    /**
     * Get module name.
     *
     * @returns {string} - Returns the module name.
     */
    DateTime3D.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'DateTime3D';
    };
    /**
     * To destroy the date time axis.
     *
     * @returns {void}
     * @private
     */
    DateTime3D.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return DateTime3D;
}(NiceIntervals));

var __extends$106 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * The DatetimeCategory module is used to render date time category axis.
 */
var DateTimeCategory3D = /** @__PURE__ @class */ (function (_super) {
    __extends$106(DateTimeCategory3D, _super);
    /**
     * Constructor for the category module.
     *
     * @param {Chart3D} chart - Chart3D instance.
     * @private
     */
    function DateTimeCategory3D(chart) {
        return _super.call(this, chart) || this;
    }
    /**
     * Calculates the range and interval for the specified axis based on the provided size.
     *
     * @param {Size} size - The size of the chart area used for range and interval calculation.
     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.
     * @returns {void}
     */
    DateTimeCategory3D.prototype.calculateRangeAndInterval = function (size, axis) {
        this.axisSize = size;
        this.calculateRange(axis);
        this.getActualRange(axis, size);
        this.applyRangePadding(axis, size);
        this.calculateVisibleLabels(axis);
    };
    /**
     * Calculates and updates the visible labels for the specified axis.
     *
     * @param {Chart3DAxis} axis - The axis for which visible labels are calculated.
     * @returns {void}
     */
    DateTimeCategory3D.prototype.calculateVisibleLabels = function (axis) {
        /*! Generate axis labels */
        axis.visibleLabels = [];
        var labelStyle;
        var padding = 0;
        if (axis.intervalType === 'Auto') {
            this.calculateDateTimeNiceInterval(axis, this.axisSize, parseInt(axis.labels[0], 10), parseInt(axis.labels[axis.labels.length - 1], 10));
        }
        else {
            axis.actualIntervalType = axis.intervalType;
        }
        axis.format = this.chart.intl.getDateFormat({
            format: axis.labelFormat || '', type: firstToLowerCase(axis.skeletonType),
            skeleton: this.getSkeleton(axis)
        });
        var i = 0;
        for (; i < axis.labels.length; i++) {
            labelStyle = (extend({}, getValue('properties', axis.labelStyle), null, true));
            if (!this.sameInterval(axis.labels.map(Number)[i], axis.labels.map(Number)[i - 1], axis.actualIntervalType, i)
                || axis.isIndexed) {
                if (withIn(i - padding, axis.visibleRange)) {
                    triggerLabelRender(this.chart, i, (axis.isIndexed ? this.getIndexedAxisLabel(axis.labels[i], axis.format) :
                        axis.format(new Date(axis.labels.map(Number)[i]))), labelStyle, axis);
                }
            }
        }
        if (axis.getMaxLabelWidth) {
            axis.getMaxLabelWidth(this.chart);
        }
    };
    /**
     * To get the indexed axis label text with format for DateTimeCategory axis.
     *
     * @param {string} value value
     * @param {Function} format format
     * @returns {string} Indexed axis label text
     */
    DateTimeCategory3D.prototype.getIndexedAxisLabel = function (value, format) {
        var texts = value.split(',');
        for (var i = 0; i < texts.length; i++) {
            texts[i] = format(new Date(parseInt(texts[i], 10)));
        }
        return texts.join(', ');
    };
    /**
     * Checks whether two dates have the same interval value of the specified type at the given index.
     *
     * @param {number} currentDate - The current date to be compared.
     * @param {number} previousDate - The previous date to be compared.
     * @param {IntervalType} type - The type of interval (year, month, day, etc.).
     * @param {number} index - The index within the interval.
     * @returns {boolean} - True if the two dates have the same interval value; otherwise, false.
     */
    DateTimeCategory3D.prototype.sameInterval = function (currentDate, previousDate, type, index) {
        var sameValue;
        if (index === 0) {
            sameValue = false;
        }
        else {
            switch (type) {
                case 'Years':
                    sameValue = new Date(currentDate).getFullYear() === new Date(previousDate).getFullYear();
                    break;
                case 'Months':
                    sameValue = new Date(currentDate).getFullYear() === new Date(previousDate).getFullYear() &&
                        new Date(currentDate).getMonth() === new Date(previousDate).getMonth();
                    break;
                case 'Days':
                    sameValue = (Math.abs(currentDate - previousDate) < 24 * 60 * 60 * 1000 &&
                        new Date(currentDate).getDay() === new Date(previousDate).getDay());
                    break;
                case 'Hours':
                    sameValue = (Math.abs(currentDate - previousDate) < 60 * 60 * 1000 &&
                        new Date(currentDate).getDay() === new Date(previousDate).getDay());
                    break;
                case 'Minutes':
                    sameValue = (Math.abs(currentDate - previousDate) < 60 * 1000 &&
                        new Date(currentDate).getMinutes() === new Date(previousDate).getMinutes());
                    break;
                case 'Seconds':
                    sameValue = (Math.abs(currentDate - previousDate) < 1000 &&
                        new Date(currentDate).getDay() === new Date(previousDate).getDay());
                    break;
            }
        }
        return sameValue;
    };
    /**
     * Get module name.
     *
     * @returns {string} - Returns the module name
     */
    DateTimeCategory3D.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'DateTimeCategory3D';
    };
    /**
     * To destroy the datetime category axis.
     *
     * @returns {void}
     * @private
     */
    DateTimeCategory3D.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return DateTimeCategory3D;
}(Category3D));

var __extends$107 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * The `Logarithmic` module is used to render log axis.
 */
var Logarithmic3D = /** @__PURE__ @class */ (function (_super) {
    __extends$107(Logarithmic3D, _super);
    /**
     * Constructor for the logerithmic module.
     *
     * @param {Chart3D} chart - Chart3D instance.
     * @private
     */
    function Logarithmic3D(chart) {
        return _super.call(this, chart) || this;
    }
    /**
     * Calculates the range and interval for the specified axis based on the provided size.
     *
     * @param {Size} size - The size of the chart area used for range and interval calculation.
     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.
     * @returns {void}
     */
    Logarithmic3D.prototype.calculateRangeAndInterval = function (size, axis) {
        this.calculateRange(axis);
        this.getActualRange(axis, size);
        this.calculateVisibleRange(size, axis);
        this.calculateVisibleLabels(axis, this.chart);
    };
    /**
     * Calculates actual range for the axis.
     *
     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.
     * @param {Size} size - The size of the axis.
     * @returns {void}
     * @private
     */
    Logarithmic3D.prototype.getActualRange = function (axis, size) {
        this.initializeDoubleRange(axis);
        this.min = this.min < 0 ? 0 : this.min;
        var logStart = logBase(this.min, axis.logBase);
        logStart = isFinite(logStart) ? logStart : this.min;
        var logEnd = this.max === 1 ? 1 : logBase(this.max, axis.logBase);
        logEnd = isFinite(logStart) ? logEnd : this.max;
        this.min = Math.floor(logStart / 1);
        var isRectSeries = axis.series && axis.series.some(function (item) {
            return (item.type.indexOf('Column') !== -1 || item.type.indexOf('Bar') !== -1);
        });
        if (isRectSeries) {
            this.min = (this.min <= 0) ? (+this.min - 1) : this.min;
        }
        this.max = Math.ceil(logEnd / 1);
        this.max = this.max === this.min ? this.max + 1 : this.max;
        axis.actualRange.interval = axis.interval || this.calculateLogNiceInterval(this.max - this.min, size, axis);
        axis.actualRange.min = this.min;
        axis.actualRange.max = this.max;
        axis.actualRange.delta = this.max - this.min;
    };
    /**
     * Calculates visible range for the axis.
     *
     * @param {Size} size - The size of the axis.
     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.
     * @returns {void}
     * @private
     */
    Logarithmic3D.prototype.calculateVisibleRange = function (size, axis) {
        axis.visibleRange = {
            interval: axis.actualRange.interval, max: axis.actualRange.max,
            min: axis.actualRange.min, delta: axis.actualRange.delta
        };
    };
    /**
     * Calculates log inteval for the axis.
     *
     * @param {number} delta - The delta value.
     * @param {Size} size - The size of the axis.
     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.
     * @returns {number} - Returns the log interval.
     * @private
     */
    Logarithmic3D.prototype.calculateLogNiceInterval = function (delta, size, axis) {
        var actualDesiredIntervalsCount = getActualDesiredIntervalsCount(size, axis);
        var niceInterval = delta;
        var minInterval = Math.pow(axis.logBase, Math.floor(logBase(niceInterval, 10)));
        for (var j = 0, len = axis.intervalDivs.length; j < len; j++) {
            var currentInterval = minInterval * axis.intervalDivs[j];
            if (actualDesiredIntervalsCount < (delta / currentInterval)) {
                break;
            }
            niceInterval = currentInterval;
        }
        return niceInterval;
    };
    /**
     * Calculates labels for the axis.
     *
     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.
     * @param {Chart3D} chart - Specifies the instance of the chart.
     * @returns {void}
     * @private
     */
    Logarithmic3D.prototype.calculateVisibleLabels = function (axis, chart) {
        /*! Generate axis labels */
        var tempInterval = axis.visibleRange.min;
        axis.visibleLabels = [];
        var labelStyle;
        var value;
        var axisFormat = this.getFormat(axis);
        var isCustomFormat = axisFormat.match('{value}') !== null;
        var startValue = Math.pow(axis.logBase, axis.visibleRange.min);
        axis.format = chart.intl.getNumberFormat({
            format: isCustomFormat ? '' : axisFormat,
            useGrouping: chart.useGroupingSeparator,
            maximumFractionDigits: startValue < 1 ? 20 : 3
        });
        axis.startLabel = axis.format(startValue < 1 ? +startValue.toPrecision(1) : startValue);
        axis.endLabel = axis.format(Math.pow(axis.logBase, axis.visibleRange.max));
        for (; tempInterval <= axis.visibleRange.max; tempInterval += axis.visibleRange.interval) {
            labelStyle = (extend({}, getValue('properties', axis.labelStyle), null, true));
            if (withIn(tempInterval, axis.visibleRange)) {
                value = Math.pow(axis.logBase, tempInterval);
                triggerLabelRender(this.chart, tempInterval, this.formatValue(axis, isCustomFormat, axisFormat, value < 1 ? +value.toPrecision(1) : value), labelStyle, axis);
            }
        }
        if (axis.getMaxLabelWidth) {
            axis.getMaxLabelWidth(this.chart);
        }
    };
    /**
     * Get module name.
     *
     * @returns {string} - Returns the module name.
     */
    Logarithmic3D.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'Logarithmic3D';
    };
    /**
     * To destroy the category axis.
     *
     * @returns {void}
     * @private
     */
    Logarithmic3D.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    return Logarithmic3D;
}(Double3D));

var ColumnSeries3D = /** @__PURE__ @class */ (function () {
    function ColumnSeries3D() {
    }
    /**
     * Draws the column 3D series on a 3D chart.
     *
     * @param {Chart3DSeries} series - The 3D series to be drawn.
     * @param {Chart3D} chart - The 3D chart on which the series will be drawn.
     * @returns {void}
     */
    ColumnSeries3D.prototype.draw = function (series, chart) {
        this.createSegments(series);
        for (var i = 0; i < series.visiblePoints.length; i++) {
            var point = series.visiblePoints[i];
            if (point.visible) {
                var argsData = {
                    cancel: false, series: series, point: point,
                    fill: series.setPointColor(point, series.interior)
                };
                chart.trigger(pointRender, argsData);
                point.color = argsData.fill;
                point.plans = null;
                if (!argsData.cancel) {
                    this.update(argsData.series, argsData.point, i, chart);
                }
                else {
                    point.symbolLocations = null;
                }
            }
        }
    };
    /**
     * Updates a specific point in a column series on a 3D chart.
     *
     * @param {Chart3DSeries} series - The 3D series to which the point belongs.
     * @param {Chart3DPoint} point - The point to be updated.
     * @param {number} pointIndex - The index of the point within the series.
     * @param {Chart3D} chart - The 3D chart to which the series and point belong.
     * @returns {void}
     */
    ColumnSeries3D.prototype.update = function (series, point, pointIndex, chart) {
        var seriesIndex = series.index;
        var left = point.left;
        var right = point.right;
        var bottom = series.yAxis.valueType === 'Logarithmic' ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.min) : series.yAxis.visibleRange.min;
        var top = series.yAxis.valueType === 'Logarithmic' ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.max) : series.yAxis.visibleRange.max;
        var xStart = series.xAxis.visibleRange.min;
        var xEnd = series.xAxis.visibleRange.max;
        if (!((left >= xStart) && (left <= xEnd)) || !((right >= xStart) && (right <= xEnd))) {
            return;
        }
        var topValue;
        if (point.top < 0) {
            topValue = (point.top > bottom) ? point.top : bottom;
        }
        else {
            topValue = (series.yAxis.valueType && series.yAxis.valueType.toLowerCase() === 'logarithmic') ? point.top : (point.top < top) ? point.top : top;
        }
        var tlpoint = chart.svg3DRenderer.transform3DToVisible(series, (point.left > xStart)
            ? point.left : xStart, topValue, chart);
        var rbpoint = chart.svg3DRenderer.transform3DToVisible(series, (xEnd > point.right) ? point.right : xEnd, (bottom > point.bottom) ? bottom : point.bottom, chart);
        var tlfVector = chart.vector.vector3D(Math.min(tlpoint.x, rbpoint.x), Math.min(tlpoint.y, rbpoint.y), point.startDepth);
        var brbVector = chart.vector.vector3D(Math.max(tlpoint.x, rbpoint.x), Math.max(tlpoint.y, rbpoint.y), point.endDepth);
        var styleOptions = series.setStyle(series);
        var name = 'region' + '-series-' + seriesIndex + '-point-' + pointIndex;
        var accessibilityText = point.x + ':' + point.yValue + ', ' + series.name;
        if (series.columnFacet === 'Cylinder') {
            chart.polygon.createCylinder(tlfVector, brbVector, chart, pointIndex, series.type, '', point.color, null, styleOptions.opacity, name, chart.chart3D);
        }
        else if (series.columnFacet === 'Rectangle') {
            chart.polygon.createBox(tlfVector, brbVector, chart, pointIndex, '', point.color, null, styleOptions.opacity, chart.requireInvertedAxis, name, chart.chart3D, accessibilityText);
        }
    };
    /**
     * Creates segments for a column series within a 3D chart.
     *
     * @param {Chart3DSeries} series - The 3D series for which segments will be created.
     * @returns {void}
     */
    ColumnSeries3D.prototype.createSegments = function (series) {
        var xValues = series.getXValues(series.visiblePoints);
        var YValues = series.getYValues(series.visiblePoints);
        if (xValues == null || YValues == null) {
            return;
        }
        var sbsInfo = series.getSideBySideInfo(series);
        var depthInfo = series.getSegmentDepth(series);
        var crossValue = 0;
        var median = sbsInfo.delta / 2;
        var visiblePoints = series.visiblePoints;
        var cons = 0.2;
        for (var i = 0; i < visiblePoints.length; i++) {
            var x1 = xValues[i] + sbsInfo.start;
            var x2 = xValues[i] + sbsInfo.end;
            var y1 = YValues[i];
            var y2 = crossValue;
            this.setData(x1, y1, x2, y2, depthInfo.start, depthInfo.end, series, visiblePoints[i]);
            if (!series.dataLabel.visible) {
                continue;
            }
            visiblePoints[i].symbolLocations = { x: 0, y: 0, z: 0 };
            switch (series.dataLabel.position) {
                case 'Top':
                    visiblePoints[i].symbolLocations.x = x1 + median;
                    visiblePoints[i].symbolLocations.y = y1;
                    visiblePoints[i].symbolLocations.z = depthInfo.start;
                    break;
                case 'Bottom':
                    visiblePoints[i].symbolLocations.x = x1 + median;
                    visiblePoints[i].symbolLocations.y = y2 - cons + series.yAxis.visibleRange.min;
                    visiblePoints[i].symbolLocations.z = depthInfo.start + (depthInfo.end - depthInfo.start) / 2;
                    break;
                default:
                    visiblePoints[i].symbolLocations.x = x1 + median;
                    visiblePoints[i].symbolLocations.y = Math.abs(y2 - y1) / 2 + (series.yAxis.visibleRange.min / 2);
                    visiblePoints[i].symbolLocations.z = depthInfo.start;
                    break;
            }
        }
    };
    /**
     * Sets data for a column series in a 3D chart.
     *
     * @param {number} x1 - The x-coordinate of the starting point of the segment.
     * @param {number} y1 - The y-coordinate of the starting point of the segment.
     * @param {number} x2 - The x-coordinate of the ending point of the segment.
     * @param {number} y2 - The y-coordinate of the ending point of the segment.
     * @param {number} start - The starting value of the segment on the axis.
     * @param {number} end - The ending value of the segment on the axis.
     * @param {Chart3DSeries} series - The 3D series to which the segment belongs.
     * @param {Chart3DPoint} point - The point associated with the segment.
     * @returns {void}
     */
    ColumnSeries3D.prototype.setData = function (x1, y1, x2, y2, start, end, series, point) {
        point.left = x1;
        point.bottom = y2;
        point.top = y1;
        point.right = x2;
        point.startDepth = start;
        point.endDepth = end;
        point.xRange = series.getDoubleRange(point.left, point.right);
        if (!isNaN(point.top) && !isNaN(point.bottom)) {
            point.yRange = series.getDoubleRange(point.top, point.bottom);
        }
    };
    /**
     * To destroy the column series.
     *
     * @returns {void}
     * @private
     */
    ColumnSeries3D.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    /**
     * Gets the module name for the Column3D series.
     *
     * @returns {string} - Returns the module name for the Column3D series.
     */
    ColumnSeries3D.prototype.getModuleName = function () {
        return 'ColumnSeries3D';
        /**
         * return the module name
         */
    };
    return ColumnSeries3D;
}());

var StackingColumnSeries3D = /** @__PURE__ @class */ (function () {
    function StackingColumnSeries3D() {
    }
    /**
     * Draws the stacking column series on a 3D chart.
     *
     * @param {Chart3DSeries} series - The 3D series to be drawn.
     * @param {Chart3D} chart - The 3D chart on which the series will be drawn.
     * @returns {void}
     */
    StackingColumnSeries3D.prototype.draw = function (series, chart) {
        this.createSegments(series);
        for (var i = 0; i < series.visiblePoints.length; i++) {
            var point = series.visiblePoints[i];
            if (point.visible) {
                var argsData = {
                    cancel: false, series: series, point: point,
                    fill: series.setPointColor(point, series.interior)
                };
                chart.trigger(pointRender, argsData);
                point.color = argsData.fill;
                point.plans = null;
                if (!argsData.cancel) {
                    this.update(argsData.series, argsData.point, i, chart);
                }
                else {
                    point.symbolLocations = null;
                }
            }
        }
    };
    /**
     * Updates a specific point in a stacking column series on a 3D chart.
     *
     * @param {Chart3DSeries} series - The 3D series to which the point belongs.
     * @param {Chart3DPoint} point - The point to be updated.
     * @param {number} pointIndex - The index of the point within the series.
     * @param {Chart3D} chart - The 3D chart to which the series and point belong.
     * @returns {void}
     */
    StackingColumnSeries3D.prototype.update = function (series, point, pointIndex, chart) {
        var seriesIndex = series.index;
        var left = point.left;
        var right = point.right;
        var bottom = series.yAxis.valueType === 'Logarithmic' ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.min) : series.yAxis.visibleRange.min;
        var top = series.yAxis.valueType === 'Logarithmic' ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.max) : series.yAxis.visibleRange.max;
        var xStart = series.xAxis.visibleRange.min;
        var xEnd = series.xAxis.visibleRange.max;
        if (!((left >= xStart) && (left <= xEnd)) || !((right >= xStart) && (right <= xEnd))) {
            return;
        }
        var topValue;
        if (point.top < 0) {
            topValue = (point.top > bottom) ? point.top : bottom;
        }
        else {
            topValue = (series.yAxis.valueType && series.yAxis.valueType.toLowerCase() === 'logarithmic') ? point.top : (point.top < top) ? point.top : top;
        }
        var tlpoint = chart.svg3DRenderer.transform3DToVisible(series, (point.left > xStart) ?
            point.left : xStart, topValue, chart);
        var rbpoint = chart.svg3DRenderer.transform3DToVisible(series, (xEnd > point.right) ?
            point.right : xEnd, (bottom > point.bottom) ? bottom : point.bottom, chart);
        var tlfVector = chart.vector.vector3D(Math.min(tlpoint.x, rbpoint.x), Math.min(tlpoint.y, rbpoint.y), point.startDepth);
        var brbVector = chart.vector.vector3D(Math.max(tlpoint.x, rbpoint.x), Math.max(tlpoint.y, rbpoint.y), point.endDepth);
        var styleOptions = series.setStyle(series);
        var name = 'region' + '-series-' + seriesIndex + '-point-' + pointIndex;
        if (series.columnFacet === 'Cylinder') {
            chart.polygon.createCylinder(tlfVector, brbVector, chart, pointIndex, series.type, '', point.color, null, styleOptions.opacity, name, chart.chart3D);
        }
        else if (series.columnFacet === 'Rectangle') {
            chart.polygon.createBox(tlfVector, brbVector, chart, pointIndex, '', point.color, null, styleOptions.opacity, chart.requireInvertedAxis, name, chart.chart3D);
        }
    };
    /**
     * Creates segments for a stacking column series within a 3D chart.
     *
     * @param {Chart3DSeries} series - The 3D series for which segments will be created.
     * @returns {void}
     */
    StackingColumnSeries3D.prototype.createSegments = function (series) {
        var xValues = series.getXValues(series.visiblePoints);
        if (xValues == null) {
            return;
        }
        var sbsInfo = series.getSideBySideInfo(series);
        var depthInfo = series.getSegmentDepth(series);
        var median = sbsInfo.delta / 2;
        var visiblePoints = series.visiblePoints;
        var cons = 0.2;
        for (var i = 0; i < visiblePoints.length; i++) {
            var x1 = xValues[i] + sbsInfo.start;
            var x2 = xValues[i] + sbsInfo.end;
            var y1 = series.stackedValues.startValues[i];
            var y2 = series.stackedValues.endValues[i];
            this.setData(x1, y1, x2, y2, depthInfo.start, depthInfo.end, series, visiblePoints[i]);
            if (!series.dataLabel.visible) {
                continue;
            }
            visiblePoints[i].symbolLocations = { x: 0, y: 0, z: 0 };
            switch (series.dataLabel.position) {
                case 'Top':
                    visiblePoints[i].symbolLocations.x = x1 + median;
                    visiblePoints[i].symbolLocations.y = y1;
                    visiblePoints[i].symbolLocations.z = depthInfo.start + (depthInfo.delta / 2);
                    break;
                case 'Bottom':
                    visiblePoints[i].symbolLocations.x = x1 + median;
                    visiblePoints[i].symbolLocations.y = y2 - cons;
                    visiblePoints[i].symbolLocations.z = depthInfo.start + (depthInfo.end - depthInfo.start) / 2;
                    break;
                default:
                    visiblePoints[i].symbolLocations.x = x1 + median;
                    visiblePoints[i].symbolLocations.y = y1 + (y2 - y1) / 2;
                    visiblePoints[i].symbolLocations.z = depthInfo.start;
                    break;
            }
        }
    };
    /**
     * Sets data for a stacking column series in a 3D chart.
     *
     * @param {number} x1 - The x-coordinate of the starting point of the segment.
     * @param {number} y1 - The y-coordinate of the starting point of the segment.
     * @param {number} x2 - The x-coordinate of the ending point of the segment.
     * @param {number} y2 - The y-coordinate of the ending point of the segment.
     * @param {number} start - The starting value of the segment on the axis.
     * @param {number} end - The ending value of the segment on the axis.
     * @param {Chart3DSeries} series - The 3D series to which the segment belongs.
     * @param {Chart3DPoint} point - The point associated with the segment.
     * @returns {void}
     */
    StackingColumnSeries3D.prototype.setData = function (x1, y1, x2, y2, start, end, series, point) {
        point.left = x1;
        point.bottom = y2;
        point.top = y1;
        point.right = x2;
        point.startDepth = start;
        point.endDepth = end;
        point.xRange = series.getDoubleRange(point.left, point.right);
        if (!isNaN(point.top) && !isNaN(point.bottom)) {
            point.yRange = series.getDoubleRange(point.top, point.bottom);
        }
    };
    /**
     * To destroy the stacking column series.
     *
     * @returns {void}
     * @private
     */
    StackingColumnSeries3D.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    /**
     * Gets the module name for the Stacking Column3D series.
     *
     * @returns {void}
     */
    StackingColumnSeries3D.prototype.getModuleName = function () {
        return 'StackingColumnSeries3D';
        /**
         * return the module name
         */
    };
    return StackingColumnSeries3D;
}());

var StackingBarSeries3D = /** @__PURE__ @class */ (function () {
    function StackingBarSeries3D() {
    }
    /**
     * Draws the stacking bar series on a 3D chart.
     *
     * @param {Chart3DSeries} series - The 3D series to be drawn.
     * @param {Chart3D} chart - The 3D chart on which the series will be drawn.
     * @returns {void}
     */
    StackingBarSeries3D.prototype.draw = function (series, chart) {
        this.createSegments(series);
        series.isRectSeries = true;
        for (var i = 0; i < series.visiblePoints.length; i++) {
            var point = series.visiblePoints[i];
            if (point.visible) {
                var argsData = {
                    cancel: false, series: series, point: point,
                    fill: series.setPointColor(point, series.interior)
                };
                chart.trigger(pointRender, argsData);
                point.color = argsData.fill;
                point.plans = null;
                if (!argsData.cancel) {
                    this.update(argsData.series, argsData.point, i, chart);
                }
                else {
                    point.symbolLocations = null;
                }
            }
        }
    };
    /**
     * Updates a specific point in a stacking bar series on a 3D chart.
     *
     * @param {Chart3DSeries} series - The 3D series to which the point belongs.
     * @param {Chart3DPoint} point - The point to be updated.
     * @param {number} pointIndex - The index of the point within the series.
     * @param {Chart3D} chart - The 3D chart to which the series and point belong.
     * @returns {void}
     */
    StackingBarSeries3D.prototype.update = function (series, point, pointIndex, chart) {
        var seriesIndex = series.index;
        var left = point.left;
        var right = point.right;
        var bottom = series.yAxis.valueType === 'Logarithmic' ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.min) : series.yAxis.visibleRange.min;
        var top = series.yAxis.valueType === 'Logarithmic' ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.max) : series.yAxis.visibleRange.max;
        var xStart = series.xAxis.visibleRange.min;
        var xEnd = series.xAxis.visibleRange.max;
        if (!((left >= xStart) && (left <= xEnd)) || !((right >= xStart) && (right <= xEnd))) {
            return;
        }
        var topValue;
        if (point.top < 0) {
            topValue = (point.top > bottom) ? point.top : bottom;
        }
        else {
            topValue = (series.yAxis.valueType && series.yAxis.valueType.toLowerCase() === 'logarithmic') ? point.top : (point.top < top) ? point.top : top;
        }
        var tlpoint = chart.svg3DRenderer.transform3DToVisible(series, (point.left > xStart) ? point.left : xStart, topValue, chart);
        var rbpoint = chart.svg3DRenderer.transform3DToVisible(series, (xEnd > point.right) ? point.right : xEnd, (bottom > point.bottom) ? bottom : point.bottom, chart);
        var tlfVector = chart.vector.vector3D(Math.min(tlpoint.x, rbpoint.x), Math.min(tlpoint.y, rbpoint.y), point.startDepth);
        var brbVector = chart.vector.vector3D(Math.max(tlpoint.x, rbpoint.x), Math.max(tlpoint.y, rbpoint.y), point.endDepth);
        var styleOptions = series.setStyle(series);
        var name = 'region' + '-series-' + seriesIndex + '-point-' + pointIndex;
        if (series.columnFacet === 'Cylinder') {
            chart.polygon.createCylinder(tlfVector, brbVector, chart, pointIndex, series.type, '', point.color, null, styleOptions.opacity, name, chart.chart3D);
        }
        else if (series.columnFacet === 'Rectangle') {
            chart.polygon.createBox(tlfVector, brbVector, chart, pointIndex, '', point.color, null, styleOptions.opacity, chart.requireInvertedAxis, name, chart.chart3D);
        }
    };
    /**
     * Creates segments for a stacking bar series within a 3D chart.
     *
     * @param {Chart3DSeries} series - The 3D series for which segments will be created.
     * @returns {void}
     */
    StackingBarSeries3D.prototype.createSegments = function (series) {
        var xValues = series.getXValues(series.visiblePoints);
        if (xValues == null) {
            return;
        }
        var sbsInfo = series.getSideBySideInfo(series);
        var depthInfo = series.getSegmentDepth(series);
        var median = sbsInfo.delta / 2;
        var visiblePoints = series.visiblePoints;
        var cons = 0.2;
        for (var i = 0; i < visiblePoints.length; i++) {
            var x1 = xValues[i] + sbsInfo.start;
            var x2 = xValues[i] + sbsInfo.end;
            var y2 = series.stackedValues.startValues[i];
            var y1 = series.stackedValues.endValues[i];
            this.setData(x1, y1, x2, y2, depthInfo.start, depthInfo.end, series, visiblePoints[i]);
            if (!series.dataLabel.visible) {
                continue;
            }
            visiblePoints[i].symbolLocations = { x: 0, y: 0, z: 0 };
            switch (series.dataLabel.position) {
                case 'Top':
                    visiblePoints[i].symbolLocations.x = x1 + median;
                    visiblePoints[i].symbolLocations.y = y1;
                    visiblePoints[i].symbolLocations.z = depthInfo.start + (depthInfo.delta / 2);
                    break;
                case 'Bottom':
                    visiblePoints[i].symbolLocations.x = x1 + median;
                    visiblePoints[i].symbolLocations.y = y2 - cons;
                    visiblePoints[i].symbolLocations.z = depthInfo.start + (depthInfo.end - depthInfo.start) / 2;
                    break;
                default:
                    visiblePoints[i].symbolLocations.x = x1 + median;
                    visiblePoints[i].symbolLocations.y = y1 + (y2 - y1) / 2;
                    visiblePoints[i].symbolLocations.z = depthInfo.start;
                    break;
            }
        }
    };
    /**
     * Sets data for a stacking bar series in a 3D chart.
     *
     * @param {number} x1 - The x-coordinate of the starting point of the segment.
     * @param {number} y1 - The y-coordinate of the starting point of the segment.
     * @param {number} x2 - The x-coordinate of the ending point of the segment.
     * @param {number} y2 - The y-coordinate of the ending point of the segment.
     * @param {number} start - The starting value of the segment on the axis.
     * @param {number} end - The ending value of the segment on the axis.
     * @param {Chart3DSeries} series - The 3D series to which the segment belongs.
     * @param {Chart3DPoint} point - The point associated with the segment.
     * @returns {void}
     */
    StackingBarSeries3D.prototype.setData = function (x1, y1, x2, y2, start, end, series, point) {
        point.left = x1;
        point.bottom = y2;
        point.top = y1;
        point.right = x2;
        point.startDepth = start;
        point.endDepth = end;
        point.xRange = series.getDoubleRange(point.left, point.right);
        if (!isNaN(point.top) && !isNaN(point.bottom)) {
            point.yRange = series.getDoubleRange(point.top, point.bottom);
        }
    };
    /**
     * To destroy the stacking bar series.
     *
     * @returns {void}
     * @private
     */
    StackingBarSeries3D.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    /**
     * Gets the module name for the  Stacking Bar3D series.
     *
     * @returns {void}
     */
    StackingBarSeries3D.prototype.getModuleName = function () {
        return 'StackingBarSeries3D';
        /**
         * return the module name
         */
    };
    return StackingBarSeries3D;
}());

/**
 * `BarSeries` module is used to render the bar series.
 */
var BarSeries3D = /** @__PURE__ @class */ (function () {
    function BarSeries3D() {
    }
    /**
     * Draws the Bar series on a 3D chart.
     *
     * @param {Chart3DSeries} series - The 3D series to be drawn.
     * @param {Chart3D} chart - The 3D chart on which the series will be drawn.
     * @returns {void}
     */
    BarSeries3D.prototype.draw = function (series, chart) {
        this.createSegments(series);
        for (var i = 0; i < series.visiblePoints.length; i++) {
            var point = series.visiblePoints[i];
            if (point.visible) {
                var argsData = {
                    cancel: false, series: series, point: point,
                    fill: series.setPointColor(point, series.interior)
                };
                chart.trigger(pointRender, argsData);
                point.color = argsData.fill;
                point.plans = null;
                if (!argsData.cancel) {
                    this.update(argsData.series, argsData.point, i, chart);
                }
                else {
                    point.symbolLocations = null;
                }
            }
        }
    };
    /**
     * Updates a specific point in a bar series on a 3D chart.
     *
     * @param {Chart3DSeries} series - The 3D series to which the point belongs.
     * @param {Chart3DPoint} point - The point to be updated.
     * @param {number} pointIndex - The index of the point within the series.
     * @param {Chart3D} chart - The 3D chart to which the series and point belong.
     * @returns {void}
     */
    BarSeries3D.prototype.update = function (series, point, pointIndex, chart) {
        var seriesIndex = chart.visibleSeries.indexOf(series);
        var left = point.left;
        var right = point.right;
        var bottom = series.yAxis.valueType === 'Logarithmic' ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.min) : series.yAxis.visibleRange.min;
        var top = series.yAxis.valueType === 'Logarithmic' ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.max) : series.yAxis.visibleRange.max;
        var xStart = series.xAxis.visibleRange.min;
        var xEnd = series.xAxis.visibleRange.max;
        if (!((left >= xStart && left <= xEnd) || (right >= xStart && right <= xEnd))) {
            return;
        }
        var topValue;
        if (point.top < 0) {
            topValue = point.top > bottom ? point.top : bottom;
        }
        else {
            topValue = (series.yAxis.valueType && series.yAxis.valueType.toLowerCase() === 'logarithmic') ? point.top : point.top < top ? point.top : top;
        }
        var tlpoint = chart.svg3DRenderer.transform3DToVisible(series, point.left > xStart ?
            point.left : xStart, topValue, chart);
        var rbpoint = chart.svg3DRenderer.transform3DToVisible(series, xEnd > point.right ? point.right : xEnd, bottom > point.bottom ? bottom : point.bottom, chart);
        var tlfVector = chart.vector.vector3D(Math.min(tlpoint.x, rbpoint.x), Math.min(tlpoint.y, rbpoint.y), point.startDepth);
        var brbVector = chart.vector.vector3D(Math.max(tlpoint.x, rbpoint.x), Math.max(tlpoint.y, rbpoint.y), point.endDepth);
        var styleOptions = series.setStyle(series);
        var name = 'region' + '-series-' + seriesIndex + '-point-' + pointIndex;
        if (series.columnFacet === 'Cylinder') {
            chart.polygon.createCylinder(tlfVector, brbVector, chart, pointIndex, series.type, '', point.color, null, styleOptions.opacity, name, chart.chart3D);
        }
        else {
            chart.polygon.createBox(tlfVector, brbVector, chart, pointIndex, '', point.color, null, styleOptions.opacity, chart.requireInvertedAxis, name, chart.chart3D);
        }
    };
    /**
     * Creates segments for a bar series within a 3D chart.
     *
     * @param {Chart3DSeries} series - The 3D series for which segments will be created.
     * @returns {void}
     */
    BarSeries3D.prototype.createSegments = function (series) {
        var xValues = series.getXValues(series.visiblePoints);
        var YValues = series.getYValues(series.visiblePoints);
        if (xValues == null) {
            return;
        }
        series.isRectSeries = true;
        var sbsInfo = series.getSideBySideInfo(series);
        var depthInfo = series.getSegmentDepth(series);
        var crossValue = 0;
        var median = sbsInfo.delta / 2;
        var visiblePoints = series.visiblePoints;
        var cons = 0.2;
        for (var i = 0; i < visiblePoints.length; i++) {
            var x1 = xValues[i] + sbsInfo.start;
            var x2 = xValues[i] + sbsInfo.end;
            var y1 = YValues[i];
            var y2 = crossValue;
            this.setData(x1, y1, x2, y2, depthInfo.start, depthInfo.end, series, visiblePoints[i]);
            if (!series.dataLabel.visible) {
                continue;
            }
            visiblePoints[i].symbolLocations = { x: 0, y: 0, z: 0 };
            switch (series.dataLabel.position) {
                case 'Top':
                    visiblePoints[i].symbolLocations.x = x1 + median;
                    visiblePoints[i].symbolLocations.y = y1;
                    visiblePoints[i].symbolLocations.z = depthInfo.start;
                    break;
                case 'Bottom':
                    visiblePoints[i].symbolLocations.x = x1 + median;
                    visiblePoints[i].symbolLocations.y = y2 - cons + series.yAxis.visibleRange.min;
                    visiblePoints[i].symbolLocations.z = depthInfo.start + (depthInfo.end - depthInfo.start) / 2;
                    break;
                default:
                    visiblePoints[i].symbolLocations.x = x1 + median;
                    visiblePoints[i].symbolLocations.y = Math.abs(y2 - y1) / 2 + (series.yAxis.visibleRange.min / 2);
                    visiblePoints[i].symbolLocations.z = depthInfo.start;
                    break;
            }
        }
    };
    /**
     * Sets data for a bar series in a 3D chart.
     *
     * @param {number} x1 - The x-coordinate of the starting point of the segment.
     * @param {number} y1 - The y-coordinate of the starting point of the segment.
     * @param {number} x2 - The x-coordinate of the ending point of the segment.
     * @param {number} y2 - The y-coordinate of the ending point of the segment.
     * @param {number} start - The starting value of the segment on the axis.
     * @param {number} end - The ending value of the segment on the axis.
     * @param {Chart3DSeries} series - The 3D series to which the segment belongs.
     * @param {Chart3DPoint} point - The point associated with the segment.
     * @returns {void}
     */
    BarSeries3D.prototype.setData = function (x1, y1, x2, y2, start, end, series, point) {
        point.left = x1;
        point.bottom = y2;
        point.top = y1;
        point.right = x2;
        point.startDepth = start;
        point.endDepth = end;
        point.xRange = series.getDoubleRange(point.left, point.right);
        if (!isNaN(point.top) && !isNaN(point.bottom)) {
            point.yRange = series.getDoubleRange(point.top, point.bottom);
        }
    };
    /**
     * To destroy the bar series.
     *
     * @returns {void}
     * @private
     */
    BarSeries3D.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    /**
     * Gets the module name for the Bar 3D series.
     *
     * @returns {string} - Returns module name.
     */
    BarSeries3D.prototype.getModuleName = function () {
        return 'BarSeries3D';
        /**
         * return the module name
         */
    };
    return BarSeries3D;
}());

/**
 * The `DataLabel` module is used to render data label for the data point.
 */
var DataLabel3D = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for the data label module.
     *
     * @param {Chart3D} chart - Chart3D instance.
     * @private
     */
    function DataLabel3D(chart) {
        this.chart = chart;
    }
    /**
     * Renders a 3D series on a 3D chart with data labels.
     *
     * @param {Chart3DSeries} series - The 3D series to be rendered.
     * @param {Chart3D} chart - The 3D chart on which the series is rendered.
     * @param {Chart3DDataLabelSettingsModel} dataLabel - The data label style for the series.
     * @returns {void}
     */
    DataLabel3D.prototype.render = function (series, chart, dataLabel) {
        var point;
        var templateId = chart.element.id + '-series-' + series.index + '-data-label-collections';
        series.dataLabelElement = createElement('div', { id: templateId });
        for (var i = 0; i < series.visiblePoints.length; i++) {
            point = series.visiblePoints[i];
            if (point.visible) {
                this.draw3DDataLabel(series, point.index, point, chart, dataLabel);
            }
        }
        if (series.dataLabel.template) {
            appendChildElement(false, document.getElementById(this.chart.element.id + '_Secondary_Element'), series.dataLabelElement, chart.redraw, false, 'x', 'y', null, '', false, false, null);
        }
    };
    /**
     * Draws data labels for a specific data point in a 3D series on a 3D chart.
     *
     * @param {Chart3DSeries} series - The 3D series to which the data point belongs.
     * @param {number} pointIndex - The index of the data point within the series.
     * @param {Chart3DPoint} point - The data point for which data labels are drawn.
     * @param {Chart3D} chart - The 3D chart that contains the series and data point.
     * @param {Chart3DDataLabelSettingsModel} dataLabel - The style for data labels.
     * @returns {void}
     */
    DataLabel3D.prototype.draw3DDataLabel = function (series, pointIndex, point, chart, dataLabel) {
        var pointX;
        var pointY;
        var xOffset = 0;
        var yOffset = 0;
        var commonEventArgs = { data: null };
        var pointText = this.getLabelText(point, series, this.chart)[0];
        var size = measureText(pointText, dataLabel.font, this.chart.themeStyle.datalabelFont);
        var location = chart.svg3DRenderer.transform3DToVisible(series, point.symbolLocations.x, point.symbolLocations.y, chart);
        pointY = location.y;
        pointX = location.x;
        if (series.dataLabel.position === 'Bottom') {
            pointY = location.y + yOffset;
        }
        else {
            pointY = location.y - yOffset;
        }
        pointX = location.x + xOffset;
        commonEventArgs.data = {
            text: pointText,
            location: { x: pointX, y: pointY },
            series: series,
            pointIndex: pointIndex
        };
        commonEventArgs.data.Text = commonEventArgs.data.text;
        var argsData = {
            cancel: false, series: series,
            point: point, text: pointText, border: dataLabel.border,
            color: dataLabel.fill, template: dataLabel.template, textStyle: dataLabel.font
        };
        chart.trigger(textRender, argsData);
        this.fontBackground = series.dataLabel.position === 'Middle' ? argsData.color === 'transparent' ? point.color : argsData.color : argsData.color;
        commonEventArgs.data.text = argsData.text;
        if (!series.dataLabel.template && commonEventArgs.data.Text !== '' && !argsData.cancel) {
            /**
             * The element object for data label.
             */
            var element_1 = {
                tag: 'dataLabel',
                series: series,
                point: point,
                pointIndex: pointIndex,
                id: chart.svgObject.id + series.index + '-data-label' + pointIndex,
                child: chart.chart3D
            };
            chart.graphics.addVisual(chart.polygon.createTextElement(chart.vector.vector3D(pointX, pointY, point.symbolLocations.z), element_1, 0, -size.height), chart);
        }
        var tag = !(series.dataLabel && series.dataLabel.template) ? 'text' : 'template';
        var backgroundColor = this.fontBackground === 'transparent' ? ((this.chart.theme.indexOf('Dark') > -1 || this.chart.theme === 'HighContrast') ? '#000000' : '#FFFFFF') : this.fontBackground;
        var rgbValue = convertHexToColor(colorNameToHex(backgroundColor));
        var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);
        var font = {
            size: argsData.textStyle.size,
            fontWeight: argsData.textStyle.fontWeight,
            fontStyle: argsData.textStyle.fontStyle,
            fontFamily: argsData.textStyle.fontFamily || this.chart.themeStyle.datalabelFont.fontFamily,
            color: argsData.textStyle.color,
            opacity: argsData.textStyle.opacity,
        };
        var element = {
            width: size.width,
            height: size.height,
            label: commonEventArgs.data,
            textAnchor: 'middle',
            tag: tag,
            font: font,
            angle: series.dataLabel.angle,
            id: chart.element.id + '-svg' + '-series-' + series.index + '-point-' + pointIndex + '-data-label',
            child: chart.chart3D,
            argsData: argsData,
            fill: (contrast >= 128) ? '#000000' : '#FFFFFF'
        };
        if (!argsData.cancel) {
            chart.graphics.addVisual(chart.polygon.createTextElement(chart.vector.vector3D(pointX, pointY, point.symbolLocations.z), element, 0, -size.height), chart);
        }
    };
    /**
     * Gets the text for data labels associated with a specific data point in a 3D series.
     *
     * @param {Chart3DPoint} currentPoint - The data point for which data label text is generated.
     * @param {Chart3DSeries} series - The 3D series to which the data point belongs.
     * @param {Chart3D} chart - The 3D chart containing the series and data point.
     * @returns {string[]} An array of text for data labels.
     */
    DataLabel3D.prototype.getLabelText = function (currentPoint, series, chart) {
        var labelFormat = series.dataLabel.format ? series.dataLabel.format : series.yAxis.labelFormat;
        var text = [];
        var customLabelFormat = labelFormat.match('{value}') !== null;
        text.push(currentPoint.text || currentPoint.yValue.toString());
        if ((labelFormat || chart.useGroupingSeparator) && !currentPoint.text) {
            series.yAxis.format = chart.intl.getNumberFormat({
                format: customLabelFormat ? '' : labelFormat,
                useGrouping: chart.useGroupingSeparator
            });
            for (var i = 0; i < text.length; i++) {
                text[i] = customLabelFormat ? labelFormat.replace('{value}', series.yAxis.format(parseFloat(text[i]))) :
                    series.yAxis.format(parseFloat(text[i]));
            }
        }
        return text;
    };
    /**
     * Creates a data label template for a specific data point in a 3D series.
     *
     * @param {HTMLElement} parentElement - The parent HTML element to which the data label template is attached.
     * @param {Chart3DSeries} series - The 3D series to which the data point belongs.
     * @param {Chart3DDataLabelSettingsModel} dataLabel - The style settings for data labels.
     * @param {Chart3DPoint} point - The data point for which the data label template is created.
     * @param {I3DTextRenderEventArgs} data - The text render event arguments.
     * @param {number} labelIndex - The index of the data label.
     * @param {boolean} redraw - Indicates whether the template should be redrawn.
     * @param {Chart3DLocation} location - The location values for the data label.
     * @returns {void}
     */
    DataLabel3D.prototype.createDataLabelTemplate = function (parentElement, series, dataLabel, point, data, labelIndex, redraw, location) {
        this.margin = { left: 0, right: 0, bottom: 0, top: 0 };
        var clip = series.clipRect;
        var childElement = this.createTemplate(createElement('div', {
            id: this.chart.element.id + '-series-' + series.index + '-data-label-' + labelIndex,
            styles: 'position: absolute;background-color:' + data.color + ';' +
                getFontStyle(dataLabel.font) + ';border:' + data.border.width + 'px solid ' + data.border.color + ';'
        }), data.template, this.chart, point, series, this.chart.element.id + '-data-label-', labelIndex, location);
        this.calculateTemplateLabelSize(parentElement, childElement, point, series, dataLabel, clip, redraw, location);
    };
    /**
     * Calculates the size of a data label template for a specific data point in a 3D series.
     *
     * @param {HTMLElement} parentElement - The parent HTML element containing the data label template.
     * @param {HTMLElement} childElement - The child HTML element representing the data label template.
     * @param {Chart3DPoint} point - The data point for which the data label template size is calculated.
     * @param {Chart3DSeries} series - The 3D series to which the data point belongs.
     * @param {Chart3DDataLabelSettingsModel} dataLabel - The style for data labels.
     * @param {Rect} clip - The rectangular clipping area.
     * @param {boolean} redraw - Indicates whether the template should be redrawn.
     * @param {Chart3DLocation} location - The location values for the data label.
     * @param {boolean} isReactCallback - Indicates whether the callback is associated with React.
     * @returns {void}
     */
    DataLabel3D.prototype.calculateTemplateLabelSize = function (parentElement, childElement, point, series, dataLabel, clip, redraw, location, isReactCallback) {
        var elementRect = measureElementRect(childElement, redraw, isReactCallback);
        var rect = { x: 0, y: 0, width: 0, height: 0 };
        var rectPosition = this.calculateTextPosition(series, point, elementRect, location);
        var clipWidth = 0;
        var clipHeight = 0;
        var isOverlap$$1 = false;
        if (isReactCallback) {
            isOverlap$$1 = (elementRect.width === 0 || elementRect.height === 0); // To check the data label already overlap before react callback call
        }
        childElement.style.left = (rectPosition.left - clipWidth) + 'px';
        childElement.style.top = (rectPosition.top + clipHeight) + 'px';
        var backgroundColor = this.fontBackground === 'transparent' ? (this.chart.theme.indexOf('Dark') > -1 ? 'black' : 'white') : this.fontBackground;
        var rgbValue = convertHexToColor(colorNameToHex(backgroundColor));
        var vAxis = series.chart.requireInvertedAxis ? series.xAxis : series.yAxis;
        var hAxis = series.chart.requireInvertedAxis ? series.yAxis : series.xAxis;
        childElement.style.color = dataLabel.font.color ||
            ((Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000)) >= 128 ? 'black' : 'white');
        if (childElement.childElementCount && !isOverlap$$1 && (!isCollide(rect, this.chart.dataLabelCollections, clip))
            && (point.yValue === undefined ||
                withIn(point.yValue, series.yAxis.visibleRange) || (series.type.indexOf('Stacking') > -1) ||
                (series.type.indexOf('100') > -1 && withIn(series.stackedValues.endValues[point.index], series.yAxis.visibleRange))) &&
            withIn(point.xValue, series.xAxis.visibleRange) && parseFloat(childElement.style.top) >= vAxis.rect.y &&
            parseFloat(childElement.style.left) >= hAxis.rect.x &&
            parseFloat(childElement.style.top) <= vAxis.rect.y + vAxis.rect.height &&
            parseFloat(childElement.style.left) <= hAxis.rect.x + hAxis.rect.width) {
            this.chart.dataLabelCollections.push(new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));
            appendChildElement(false, parentElement, childElement, redraw, true, 'left', 'top');
        }
    };
    /**
     * Calculates the text position for a data label associated with a specific data point in a 3D series.
     *
     * @param {Chart3DSeries} series - The 3D series to which the data point belongs.
     * @param {Chart3DPoint} point - The data point for which the text position is calculated.
     * @param {ClientRect} elementSize - The size of the data label element.
     * @param {Chart3DLocation} location - The location values for the data label.
     * @returns {{ left: number, top: number, right: number }} An object representing the left, top, and right positions of the text.
     */
    DataLabel3D.prototype.calculateTextPosition = function (series, point, elementSize, location) {
        var width = elementSize.width / 2;
        var height = elementSize.height;
        var left;
        var top;
        var right;
        if (series.type.indexOf('Bar') !== -1) {
            left = location.x - width;
            top = location.y - height + series.xAxis.plotOffset;
            right = location.x + width;
        }
        else {
            left = location.x - width;
            top = location.y - height;
            right = location.x + width;
        }
        return { left: left, top: top, right: right };
    };
    /**
     * Renders a React template for a data label associated with a specific data point in a 3D series.
     *
     * @param {HTMLElement} childElement - The child HTML element for the React template.
     * @param {Chart3D} chart - The 3D chart that contains the series and data point.
     * @param {Chart3DPoint} point - The data point for which the React template is rendered.
     * @param {Chart3DSeries} series - The 3D series to which the data point belongs.
     * @param {number} labelIndex - The index of the data label.
     * @param {boolean} redraw - Indicates whether the template should be redrawn.
     * @param {Chart3DLocation} location - The location values for the data label.
     * @returns {void}
     */
    DataLabel3D.prototype.chartReactTemplate = function (childElement, chart, point, series, labelIndex, redraw, location) {
        var parentElement = document.getElementById(chart.element.id + '-series-' + series.index + '-data-label-collections');
        if (parentElement) {
            if (point.index === 0) {
                chart.dataLabelCollections = []; // clear old datalabel bounds for react callback
            }
            chart.dataLabel3DModule.calculateTemplateLabelSize(parentElement, childElement, point, series, series.dataLabel, series.clipRect, redraw, location, true);
        }
    };
    /**
     * Creates a template element for rendering data labels associated with a specific data point in a 3D series.
     *
     * @param {HTMLElement} childElement - The child HTML element to contain the template content.
     * @param {string | Function} content - The content or function for the data label template.
     * @param {Chart3D} chart - The 3D chart containing the series and data point.
     * @param {Chart3DPoint} point - The data point for which the template is created (optional).
     * @param {Chart3DSeries} series - The 3D series to which the data point belongs (optional).
     * @param {string} dataLabelId - The ID for the data label element (optional).
     * @param {number} labelIndex - The index of the data label (optional).
     * @param {LChart3DLocation} location - The location values for the data label (optional).
     * @param {boolean} redraw - Indicates whether the template should be redrawn (optional).
     * @returns {HTMLElement} The created template element.
     */
    DataLabel3D.prototype.createTemplate = function (childElement, content, chart, point, series, dataLabelId, labelIndex, location, redraw) {
        var templateFn = getTemplateFunction(content);
        var templateElement;
        try {
            var tempObject = { chart: chart, series: series, point: point };
            var templateId = dataLabelId + '-template';
            var elementData = templateFn ? templateFn(tempObject, chart, templateId, dataLabelId) : [];
            if (elementData.length) {
                templateElement = Array.prototype.slice.call(elementData);
                var len = templateElement.length;
                for (var i = 0; i < len; i++) {
                    childElement.appendChild(templateElement[i]);
                }
            }
            var reactCallback = void 0;
            if (chart.getModuleName() === 'chart3d') {
                reactCallback = (point && series) ? this.chartReactTemplate.bind(this, childElement, chart, point, series, labelIndex, redraw, location) : reactCallback;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (chart.isReact) {
                    chart.renderReactTemplates(reactCallback);
                }
            }
        }
        catch (e) {
            return childElement;
        }
        return childElement;
    };
    /**
     * Gets the name of the data label module.
     *
     * @returns {string} The name of the data label module.
     */
    DataLabel3D.prototype.getModuleName = function () {
        // Returns the module name
        return 'DataLabel3D';
    };
    /**
     * To destroy the dataLabel for series.
     *
     * @returns {void}
     * @private
     */
    DataLabel3D.prototype.destroy = function () {
        // Destroy method performed here
    };
    return DataLabel3D;
}());

var __extends$108 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Selection source file
 */
/**
 * The `Selection` module handles the selection for chart.
 *
 * @private
 */
var Selection3D = /** @__PURE__ @class */ (function (_super) {
    __extends$108(Selection3D, _super);
    /**
     * Constructor for selection module.
     *
     * @param {Chart3D} chart - Chart3D instance.
     * @private
     */
    function Selection3D(chart) {
        var _this = _super.call(this, chart) || this;
        _this.seriesIndex = 0;
        _this.chart = chart;
        _this.addEventListener();
        return _this;
    }
    /**
     * Binding events for selection module.
     *
     * @returns {void}
     */
    Selection3D.prototype.addEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
        this.chart.on(cancelEvent, this.mouseLeave, this);
        this.chart.on('click', this.mouseClick, this);
        this.chart.on(Browser.touchStartEvent, this.mousedown, this);
        this.chart.on(Browser.touchEndEvent, this.mouseLeave, this);
    };
    /**
     * Handles the mouse down event.
     *
     * @returns {void}
     */
    Selection3D.prototype.mousedown = function () {
        var chart = this.chart;
        if (chart.isPointMouseDown || chart.selectionMode === 'Point') {
            return;
        }
    };
    /**
     * Unbinding events for selection module.
     *
     * @returns {void}
     */
    Selection3D.prototype.removeEventListener = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.off(Browser.touchMoveEvent, this.mouseMove);
        this.chart.off('pointerleave' || 'mouseleave', this.mouseLeave);
        this.chart.off('click', this.mouseClick);
        this.chart.off(Browser.touchStartEvent, this.mousedown);
        this.chart.off(Browser.touchEndEvent, this.mouseLeave);
    };
    /**
     * To find private variable values
     *
     * @param {Chart3D} chart - Chart3D instance.
     * @returns {void}
     */
    Selection3D.prototype.initPrivateVariables = function (chart) {
        this.styleId = chart.element.id + '_ej2_chart_selection';
        this.unselected = chart.element.id + '_ej2_deselected';
        this.selectedDataIndexes = [];
        this.isSeriesMode = chart.selectionMode === 'Series';
    };
    /**
     * Method to select the point and series.
     *
     * @param {Chart3D} chart - Chart3D instance
     * @returns {void}
     */
    Selection3D.prototype.invokeSelection = function (chart) {
        this.initPrivateVariables(chart);
        this.series = extend({}, chart.visibleSeries, null, true);
        this.seriesStyles();
        this.currentMode = chart.selectionMode;
        this.selectDataIndex(chart, this.concatIndexes(chart.selectedDataIndexes, this.selectedDataIndexes));
    };
    /**
     * Generates the style for the series.
     *
     * @param {Chart3DSeriesModel} series - The series for which the style is generated.
     * @returns {string} - The generated style string.
     */
    Selection3D.prototype.generateStyle = function (series) {
        if (series) {
            return (this.styleId + '_series_' + series.index);
        }
        return 'undefined';
    };
    /**
     * Selects the specified data indexes in the Chart3D.
     * This method is responsible for handling the selection of specific data indexes in the Chart3D.
     *
     * @param {Chart3D} chart - The Chart3D instance in which the data indexes are selected.
     * @param {Index[]} indexes - An array of Index objects representing the data indexes to be selected.
     * @returns {void}
     */
    Selection3D.prototype.selectDataIndex = function (chart, indexes) {
        for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {
            var index = indexes_1[_i];
            this.performSelection(index, chart, this.getElementByIndex(chart, index)[0]);
        }
    };
    /**
     * Retrieves the elements in the Chart3D associated with the specified data index.
     *
     * This method is responsible for obtaining the elements in the Chart3D related to the specified data index.
     *
     * @param {Chart3D} chart - The Chart3D instance containing the elements.
     * @param {Index} index - An Index object representing the data index.
     * @returns {Element[]} An array of Element objects representing the elements associated with the specified data index.
     */
    Selection3D.prototype.getElementByIndex = function (chart, index) {
        var pointElements = [];
        var elements = document.querySelectorAll('[id*="-region-series-' + index.series + '-point-' + index.point + '"]');
        elements.forEach(function (pointElement) {
            pointElements.push(pointElement);
        });
        return pointElements;
    };
    /**
     * This method is responsible for obtaining the clustered elements in the Chart3D related to the specified data index.
     * Clustering typically involves obtaining a group of related elements for a specific data index.
     *
     * @param {Chart3D} chart - The Chart3D instance containing the clustered elements.
     * @param {Index} index - An Index object representing the data index.
     * @returns {Element[]} An array of Element objects representing the clustered elements associated with the specified data index.
     */
    Selection3D.prototype.getClusterElements = function (chart, index) {
        var clusters = [];
        var seriesStyle;
        var selectedElements;
        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            if (series.visible) {
                index = new Index(series.index, index.point);
                var pointElements = this.getElementByIndex(chart, index);
                for (var i = 0; i < pointElements.length; i++) {
                    clusters.push(pointElements[i]);
                }
                seriesStyle = this.generateStyle(chart.visibleSeries[index.series]);
                selectedElements = document.querySelectorAll('.' + seriesStyle);
            }
        }
        return clusters;
    };
    /**
     * Method to get the selected element.
     *
     * @param {Chart3D} chart - The Chart3D instance to which the series belongs.
     * @param {Chart3DSeriesModel} series - The series in which the data point is located.
     * @param {Index} index - The index or position of the data point within the series.
     * @returns {Element[]} An array of elements associated with the specified data point in the Chart3D.
     * @private
     */
    Selection3D.prototype.findElements = function (chart, series, index) {
        if (this.isSeriesMode) {
            return this.getSeriesElements(series);
        }
        else if (this.currentMode === 'Cluster') {
            return this.getClusterElements(chart, index);
        }
        else {
            return this.getElementByIndex(chart, index);
        }
    };
    /**
     * Checks whether the specified element is already selected in the Chart3D.
     *
     * @param {Element} targetElem - The target element to check for selection status.
     * @param {string} eventType - The type of event triggering the selection check (e.g., 'click', 'hover').
     * @param {Index} [index] - Optional. The index or position of the data point within the series.
     * @returns {boolean} A boolean indicating whether the specified element is already selected.
     */
    Selection3D.prototype.isAlreadySelected = function (targetElem, eventType, index) {
        if (eventType === 'click') {
            this.currentMode = this.chart.selectionMode;
            this.styleId = this.chart.element.id + '_ej2_chart_selection';
        }
        else if (eventType === 'mousemove' || eventType === 'pointermove') {
            this.currentMode = this.chart.highlightMode;
            this.highlightDataIndexes = [];
            this.styleId = this.chart.element.id + '_ej2_chart_highlight';
        }
        if (this.chart.highlightMode !== 'None' && this.chart.selectionMode === 'None') {
            if (eventType === 'click') {
                return false;
            }
        }
        if (((this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight) && this.previousSelectedEle && this.previousSelectedEle[0])) {
            var isElement = void 0;
            var nodeName = targetElem.nodeName;
            if (targetElem.parentNode) {
                isElement = ((nodeName === 'path' || nodeName === 'shape') && targetElem.id.indexOf('region') > 1) ? true : false;
            }
            var _loop_1 = function (i) {
                if (this_1.previousSelectedEle[i].hasAttribute('class')) {
                    if (this_1.previousSelectedEle[i].getAttribute('class').indexOf('highlight') > -1 &&
                        (isElement || eventType === 'click')) {
                        var selectionClass_1;
                        this_1.previousSelectedEle[i].classList.forEach(function (className) {
                            if (className.indexOf('selection') > -1) {
                                selectionClass_1 = className;
                            }
                        });
                        this_1.previousSelectedEle[i].removeAttribute('class');
                        if (selectionClass_1) {
                            this_1.addSvgClass(this_1.previousSelectedEle[i], selectionClass_1);
                        }
                        this_1.previousSelectedEle[i].classList.remove(this_1.styleId + '_series_' + index.series);
                        if (this_1.chart.highlightColor !== '' && !isNullOrUndefined(this_1.chart.highlightColor) && this_1.chart.highlightPattern === 'None') {
                            this_1.previousSelectedEle[i].setAttribute('fill', this_1.control.visibleSeries[this_1.indexFinder(this_1.previousSelectedEle[i].id).series].interior);
                        }
                        this_1.addOrRemoveIndex(this_1.highlightDataIndexes, this_1.indexFinder(this_1.previousSelectedEle[i].id));
                    }
                    else if (!isElement && this_1.previousSelectedEle[i].getAttribute('class').indexOf('highlight') > -1) {
                        this_1.performSelection(this_1.indexFinder(this_1.previousSelectedEle[i].id), this_1.chart, this_1.previousSelectedEle[i]);
                    }
                }
            };
            var this_1 = this;
            for (var i = 0; i < this.previousSelectedEle.length; i++) {
                _loop_1(i);
            }
        }
        return true;
    };
    /**
     * Handles the mouse click event in the Chart3D, triggering the calculation of selected elements.
     *
     * @param {Event} event - The mouse click event object.
     * @returns {void}
     */
    Selection3D.prototype.mouseClick = function (event) {
        if (!this.chart.rotateActivate) {
            this.calculateSelectedElements(event.target, event.type);
        }
    };
    /**
     * Calculates the selected elements based on the provided target element and event type.
     *
     * @param {HTMLElement} targetElement - The target HTML element that triggered the selection.
     * @param {string} eventType - The type of the event that triggered the selection (e.g., mouse click).
     * @returns {void}
     */
    Selection3D.prototype.calculateSelectedElements = function (targetElement, eventType) {
        if (isNullOrUndefined(targetElement)) {
            return;
        }
        if ((this.chart.selectionMode === 'None' && this.chart.highlightMode === 'None') ||
            targetElement.id && targetElement.id.indexOf(this.chart.element.id + '-') === -1) {
            return;
        }
        if (eventType === 'mousemove' || eventType === 'pointermove') {
            if (targetElement.hasAttribute('class') && (targetElement.getAttribute('class').indexOf('highlight') > -1 ||
                targetElement.getAttribute('class').indexOf('selection') > -1)) {
                return;
            }
        }
        this.isAlreadySelected(targetElement, eventType, this.indexFinder(targetElement.id));
        if (targetElement.id && targetElement.id.indexOf('-series-') > -1 && targetElement.id.indexOf('_Text_') === -1) {
            var element = void 0;
            this.performSelection(this.indexFinder(targetElement.id), this.chart, element || targetElement);
        }
    };
    /**
     * Performs selection based on the provided index, chart, and optional element.
     *
     * @param {Index} index - The index or indices specifying the data points or elements to be selected.
     * @param {Chart3D} chart - The Chart3D instance where the selection is being performed.
     * @param {Element} [element] - Optional. The specific HTML element that triggered the selection.
     * @returns {void}
     */
    Selection3D.prototype.performSelection = function (index, chart, element) {
        this.isSeriesMode = this.currentMode === 'Series';
        switch (this.currentMode) {
            case 'Series':
                this.selection(chart, index, this.getSeriesElements(chart.series[index.series]));
                this.selectionComplete(chart, index, this.currentMode);
                this.blurEffect(chart.element.id, chart.visibleSeries, false);
                break;
            case 'Point':
                if (!isNaN(index.point) && element) {
                    this.selection(chart, index, this.getElementByIndex(chart, index));
                    this.selectionComplete(chart, index, this.currentMode);
                    this.blurEffect(chart.element.id, chart.visibleSeries, false);
                }
                break;
            case 'Cluster':
                if (!isNaN(index.point)) {
                    this.clusterSelection(chart, index);
                    this.selectionComplete(chart, index, this.currentMode);
                    this.blurEffect(chart.element.id, chart.visibleSeries, false);
                }
                break;
        }
    };
    /**
     * Handles the completion of a selection process in the Chart3D.
     *
     * @param {Chart3D} chart - The Chart3D instance where the selection process is completed.
     * @param {Index} index - The selected index or indices representing the data points or elements.
     * @param {Chart3DSelectionMode  | HighlightMode} selectionMode - The mode of selection, either SelectionMode or HighlightMode.
     * @returns {void}
     */
    Selection3D.prototype.selectionComplete = function (chart, index, selectionMode) {
        var points;
        var pointIndex;
        var seriesIndex;
        var selectedPointValues = [];
        var yValue;
        var selectedPointX;
        if (selectionMode === 'Cluster') {
            for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
                var series = _a[_i];
                if (series.visible) {
                    for (var i = 0; i < this.selectedDataIndexes.length; i++) {
                        pointIndex = chart.isMultiSelect ? this.selectedDataIndexes[i].point : index.point;
                        seriesIndex = series.index;
                        points = series.points;
                        if (!isNaN(pointIndex)) {
                            yValue = points[pointIndex].yValue;
                            selectedPointX = points[pointIndex].xValue;
                            if (chart.primaryXAxis.valueType === 'Category') {
                                selectedPointX = points[pointIndex].x.toLocaleString();
                            }
                            else if (chart.primaryXAxis.valueType === 'DateTime') {
                                selectedPointX = new Date(points[pointIndex].xValue);
                            }
                            selectedPointValues.push({
                                x: selectedPointX, y: yValue, seriesIndex: seriesIndex,
                                pointIndex: pointIndex
                            });
                        }
                    }
                }
            }
        }
        else if (selectionMode === 'Series') {
            if (chart.isMultiSelect) {
                for (var i = 0; i < this.selectedDataIndexes.length; i++) {
                    seriesIndex = this.selectedDataIndexes[i].series;
                    if (this.selectedDataIndexes.length > 0) {
                        selectedPointValues.push({
                            seriesIndex: seriesIndex
                        });
                    }
                }
            }
            else {
                seriesIndex = (this.selectedDataIndexes.length > 0) ? this.selectedDataIndexes[0].series :
                    (this.highlightDataIndexes && this.highlightDataIndexes.length > 0) ? this.highlightDataIndexes[0].series : 0;
                if (this.selectedDataIndexes.length > 0 || (this.highlightDataIndexes && this.highlightDataIndexes.length > 0)) {
                    selectedPointValues.push({
                        seriesIndex: seriesIndex
                    });
                }
            }
        }
        else if (selectionMode === 'Point') {
            var selectedData = [];
            if (this.styleId.indexOf('highlight') > -1) {
                selectedData = this.highlightDataIndexes;
            }
            else {
                selectedData = this.selectedDataIndexes;
            }
            for (var i = 0; i < selectedData.length; i++) {
                pointIndex = selectedData[i].point;
                seriesIndex = selectedData[i].series;
                var series = chart.series[seriesIndex];
                points = series.points;
                if (!isNaN(pointIndex)) {
                    selectedPointX = points[pointIndex].xValue;
                    yValue = points[pointIndex].yValue;
                    if (chart.primaryXAxis.valueType === 'Category') {
                        selectedPointX = points[pointIndex].x.toLocaleString();
                    }
                    else if (chart.primaryXAxis.valueType === 'DateTime') {
                        selectedPointX = new Date(points[pointIndex].xValue);
                    }
                    selectedPointValues.push({
                        x: selectedPointX, y: yValue, seriesIndex: seriesIndex,
                        pointIndex: pointIndex
                    });
                }
            }
        }
        var args = {
            selectedDataValues: selectedPointValues,
            cancel: false,
            chart: chart
        };
        chart.trigger(selectionComplete, args);
    };
    /**
     * Handles the selection process in the Chart3D.
     *
     * @param {Chart3D} chart - The Chart3D instance where the selection is taking place.
     * @param {Index} index - The selected index or indices representing the data points or elements.
     * @param {Element[]} selectedElements - The corresponding elements that are selected during the process.
     * @returns {void}
     */
    Selection3D.prototype.selection = function (chart, index, selectedElements) {
        if (!chart.isMultiSelect && (this.styleId.indexOf('highlight') === -1 &&
            chart.selectionMode !== 'None')) {
            this.removeMultiSelectElements(chart, this.selectedDataIndexes, index, chart.series);
        }
        var indexValue = index.series;
        if (!isNullOrUndefined(selectedElements[0])) {
            if (chart.visibleSeries[indexValue].isRectSeries) {
                if (selectedElements[0].id) {
                    if (document.getElementById(selectedElements[0].id + '_Symbol')) {
                        selectedElements.push(getElement$1(selectedElements[0].id + '_Symbol'));
                    }
                }
            }
            var isAdd = void 0;
            var className = selectedElements[0] && (selectedElements[0].getAttribute('class') || '');
            var pClassName = selectedElements[0].parentNode &&
                (selectedElements[0].parentNode.getAttribute('class') || '');
            if (selectedElements[0] && className.indexOf(this.getSelectionClass(selectedElements[0].id)) > -1) {
                this.removeStyles(selectedElements);
            }
            else {
                this.previousSelectedEle = (chart.highlightMode !== 'None' || chart.legendSettings.enableHighlight) ? selectedElements : [];
                if (this.chart.selection3DModule) {
                    this.chart.selection3DModule.previousSelectedEle = selectedElements;
                }
                this.applyStyles(selectedElements);
                isAdd = true;
            }
            if (this.styleId.indexOf('highlight') > 0 && (chart.highlightMode !== 'None' || chart.legendSettings.enableHighlight)) {
                this.addOrRemoveIndex(this.highlightDataIndexes, index, isAdd);
            }
            else {
                this.addOrRemoveIndex(this.selectedDataIndexes, index, isAdd);
            }
        }
    };
    /**
     * Handles the cluster selection process in the Chart3D.
     *
     * @param {Chart3D} chart - The Chart3D instance where the cluster selection is taking place.
     * @param {Index} index - The selected index or indices representing the cluster.
     * @returns {void}
     */
    Selection3D.prototype.clusterSelection = function (chart, index) {
        this.selection(chart, index, this.getClusterElements(chart, new Index(index.series, index.point)));
    };
    /**
     * Removes the selected elements during a multi-select operation in the Chart3D.
     *
     * @param {Chart3D} chart - The Chart3D instance where the multi-select operation is taking place.
     * @param {Index[]} index - An array of selected indices to be removed.
     * @param {Index} currentIndex - The current index representing the selection.
     * @param {Chart3DSeriesModel[]} seriesCollection - The collection of series in the Chart3D.
     * @returns {void}
     */
    Selection3D.prototype.removeMultiSelectElements = function (chart, index, currentIndex, seriesCollection) {
        var series;
        for (var i = 0; i < index.length; i++) {
            series = seriesCollection[index[i].series];
            if ((this.isSeriesMode && !this.toEquals(index[i], currentIndex, this.isSeriesMode)) ||
                (this.currentMode === 'Cluster' && !this.toEquals(index[i], currentIndex, false)) ||
                (!this.isSeriesMode && this.toEquals(index[i], currentIndex, true) &&
                    !this.toEquals(index[i], currentIndex, false))) {
                this.removeStyles(this.findElements(chart, series, index[i]));
                index.splice(i, 1);
                i--;
            }
        }
    };
    /**
     * Applies a blur effect to the specified chart elements for visual emphasis.
     *
     * @param {string} chartId - The unique identifier of the target chart where the blur effect is applied.
     * @param {Chart3DSeries[]} visibleSeries - An array of visible series in the chart.
     * @param {boolean} [isLegend=false] - A boolean indicating whether the blur effect is applied to legends.
     * @returns {void}
     */
    Selection3D.prototype.blurEffect = function (chartId, visibleSeries, isLegend) {
        if (isLegend === void 0) { isLegend = false; }
        var visibility = (this.checkVisibility(this.highlightDataIndexes, this.chart) ||
            this.checkVisibility(this.selectedDataIndexes, this.chart));
        var _loop_2 = function (series) {
            var legendIndex = series.index;
            var legendStrokeColor = this_2.chart.visibleSeries[series.index].interior;
            var pointElements = [];
            if (series.visible) {
                var elements = document.querySelectorAll("[id*=\"region-series-" + series.index + "\"]");
                elements.forEach(function (el) {
                    pointElements.push(el);
                });
                this_2.checkSelectionElements(pointElements, this_2.generateStyle(series), visibility, isLegend, legendIndex, legendStrokeColor);
                if (!isNullOrUndefined(getElement$1(chartId + 'SymbolGroup' + series.index))) {
                    this_2.checkSelectionElements(pointElements, this_2.generateStyle(series), visibility, isLegend, legendIndex, legendStrokeColor);
                }
            }
        };
        var this_2 = this;
        for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
            var series = visibleSeries_1[_i];
            _loop_2(series);
        }
    };
    /**
     * Checks the selection status of specified chart elements and updates their appearance.
     *
     * @param {Element[] | Element} element - The chart elements or a single element to be checked for selection.
     * @param {string} className - The CSS class name used to identify selected elements.
     * @param {boolean} visibility - A boolean indicating whether the elements should be visible or hidden based on selection.
     * @param {boolean} [isLegend=true] - A boolean indicating whether the specified elements are legends.
     * @param {number} [series=0] - The index of the series if the specified elements are series.
     * @param {string} [legendStrokeColor='#D3D3D3'] - The stroke color used for legends when they are selected.
     * @returns {void}
     */
    Selection3D.prototype.checkSelectionElements = function (element, className, visibility, isLegend, series, legendStrokeColor) {
        if (isLegend === void 0) { isLegend = true; }
        if (series === void 0) { series = 0; }
        if (legendStrokeColor === void 0) { legendStrokeColor = '#D3D3D3'; }
        var children = (this.isSeriesMode ? element || [element] : element);
        if (this.chart.selectionMode !== 'None' && (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight)) {
            children = element;
        }
        var elementClassName;
        var parentClassName;
        var legendShape;
        var selectElement = element;
        for (var i = 0; i < children.length; i++) {
            elementClassName = children[i].getAttribute('class') || '';
            parentClassName = children[i].parentNode.getAttribute('class') || '';
            if (this.chart.selectionMode !== 'None' && (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight)) {
                className = elementClassName.indexOf('selection') > 0 ||
                    elementClassName.indexOf('highlight') > 0 ? elementClassName : className;
            }
            if (elementClassName.indexOf(className) === -1 &&
                parentClassName.indexOf(className) === -1 && visibility) {
                this.addSvgClass(children[i], this.unselected);
            }
            else {
                selectElement = children[i];
                if (elementClassName.indexOf(this.unselected) !== -1 && this.chart.tooltip3DModule && className.indexOf('highlight') > 0) {
                    this.chart.highlightAnimation(children[i], series, 700, 0.3);
                }
                this.removeSvgClass(children[i], this.unselected);
                this.removeSvgClass(children[i].parentNode, this.unselected);
            }
        }
        if (this.control.legend3DModule && this.control.legendSettings.visible) {
            legendShape = getElement$1(this.control.element.id + '_chart_legend_shape_' + series);
            if (legendShape) {
                if (legendShape.hasAttribute('class')) {
                    this.removeSvgClass(legendShape, legendShape.getAttribute('class'));
                    if (!isNullOrUndefined(this.chart.highlightColor && this.chart.highlightColor !== '') && !this.chart.legendSettings.enableHighlight) {
                        legendShape.setAttribute('stroke', legendStrokeColor);
                        if (this.chart.highlightPattern === 'None') {
                            legendShape.setAttribute('fill', legendStrokeColor);
                        }
                    }
                }
                if (selectElement.length > 0) {
                    elementClassName = selectElement[0].getAttribute('class');
                    parentClassName = selectElement[0].parentNode.getAttribute('class') || '';
                }
                else if (selectElement) {
                    elementClassName = selectElement.getAttribute('class') || '';
                    parentClassName = selectElement.parentNode.getAttribute('class') || '';
                }
                if (elementClassName.indexOf(className) === -1 && parentClassName.indexOf(className) === -1 && visibility) {
                    this.addSvgClass(legendShape, (this.chart.highlightMode === 'None' && this.chart.legendSettings.enableHighlight) ? className : this.unselected);
                    this.removeSvgClass(legendShape, className);
                    if (this.chart.highlightColor !== '' && !isNullOrUndefined(this.chart.highlightColor)) {
                        legendShape.setAttribute('stroke', this.control.visibleSeries[series].interior);
                        if (this.chart.highlightPattern === 'None') {
                            legendShape.setAttribute('fill', this.control.visibleSeries[series].interior);
                        }
                    }
                }
                else {
                    this.removeSvgClass(legendShape, this.unselected);
                    if (!isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightColor !== '') {
                        legendShape.setAttribute('stroke', this.control.visibleSeries[series].interior);
                        if (this.chart.highlightPattern === 'None') {
                            legendShape.setAttribute('fill', this.control.visibleSeries[series].interior);
                        }
                    }
                    if ((elementClassName === '' && parentClassName === '') || elementClassName.trim() === 'EJ2-Trackball') {
                        this.removeSvgClass(legendShape, className);
                    }
                    else {
                        this.addSvgClass(legendShape, className);
                        if (className.indexOf('highlight') > 0 && this.chart.highlightColor !== '' && this.chart.highlightColor !== 'transparent' && !isNullOrUndefined(this.chart.highlightColor)) {
                            legendShape.setAttribute('stroke', this.chart.highlightColor);
                            if (this.styleId.indexOf('highlight') > 0 && this.chart.highlightPattern === 'None') {
                                legendShape.setAttribute('fill', this.chart.highlightColor);
                            }
                        }
                    }
                }
            }
        }
    };
    /**
     * Applies custom styles to the specified chart elements.
     *
     * @param {Element[]} elements - An array of chart elements to which custom styles will be applied.
     * @returns {void}
     */
    Selection3D.prototype.applyStyles = function (elements) {
        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
            var element = elements_1[_i];
            if (element) {
                this.removeSvgClass(element.parentNode, this.unselected);
                this.removeSvgClass(element, this.unselected);
                if (this.chart.series[0].pointColorMapping === 'fill') {
                    var className = this.getSelectionClass(element.id);
                    var index = className.indexOf('highlight') > -1 ? parseInt(className.split(this.chart.element.id + '_ej2_chart_highlight_series_')[1], 10) : parseInt(className.split(this.chart.element.id + '_ej2_chart_selection_series_')[1], 10);
                    var patternName = this.styleId.indexOf('highlight') > 0 ? this.chart.highlightPattern : this.chart.selectionPattern;
                    var pattern = void 0;
                    if (className.indexOf('highlight') > -1 || className.indexOf('selection') > -1) {
                        pattern = document.getElementById(this.chart.element.id + '_' + patternName + '_' + 'Selection' + '_' + index);
                    }
                    if (element.id.indexOf('legend') === -1 && element.id.indexOf('Group') === -1 && pattern != null) {
                        for (var i = 1; i < pattern.children.length; i++) {
                            pattern.children[i].setAttribute('fill', element.getAttribute('fill'));
                            pattern.children[i].setAttribute('stroke', element.getAttribute('fill'));
                        }
                    }
                }
                this.addSvgClass(element, this.getSelectionClass(element.id));
                if (this.chart.tooltip3DModule && this.getSelectionClass(element.id).indexOf('highlight') > 0) {
                    var index = parseFloat(element.id.split('-series-')[1].split('-point-')[0]);
                    this.chart.stopElementAnimation(element, index);
                }
                if (this.styleId.indexOf('highlight') > 0 && this.chart.highlightColor !== '' && !isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightPattern === 'None' && this.chart.highlightColor !== 'transparent') {
                    element.setAttribute('fill', this.chart.highlightColor);
                }
            }
        }
    };
    /**
     * Gets the CSS class name associated with the selection for a specific chart element.
     *
     * @param {string} id - A unique identifier for the selected element.
     * @returns {string} The CSS class name associated with the selection for the selected element.
     */
    Selection3D.prototype.getSelectionClass = function (id) {
        return this.generateStyle(this.control.visibleSeries[this.indexFinder(id).series]);
    };
    /**
     * Removes styles associated with the selection from the selected elements.
     *
     *
     * @param {Element[]} elements - An array of chart elements from which selection styles should be removed.
     * @returns {void}
     */
    Selection3D.prototype.removeStyles = function (elements) {
        for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {
            var element = elements_2[_i];
            if (element) {
                this.removeSvgClass(element, this.getSelectionClass(element.id));
                if (this.chart.highlightPattern === 'None' && this.chart.highlightColor !== '' && !isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightColor !== 'transparent') {
                    var color = this.control.visibleSeries[this.indexFinder(element.id).series].interior;
                    if (element.getAttribute('name') === 'ZLight') {
                        color = this.chart.polygon.applyZLight(color, this.control);
                    }
                    if (element.getAttribute('name') === 'XLight') {
                        color = this.chart.polygon.applyXLight(color, this.control);
                    }
                    element.setAttribute('fill', color);
                }
            }
        }
    };
    /**
     * Adds or removes an index from the specified array based on the provided condition.
     *
     * @param {Index[]} indexes - The array of indexes to be modified.
     * @param {Index} index - The index to be added or removed.
     * @param {boolean} [isAdd=true] - A boolean flag indicating whether to add or remove the index.
     * @returns {void}
     * @private
     */
    Selection3D.prototype.addOrRemoveIndex = function (indexes, index, isAdd) {
        for (var i = 0; i < indexes.length; i++) {
            if (this.toEquals(indexes[i], index, this.isSeriesMode)) {
                indexes.splice(i, 1);
                i--;
            }
        }
        if (isAdd) {
            indexes.push(index);
        }
    };
    /**
     * Compares two Index objects for equality.
     *
     * @param {Index} first - The first Index object to compare.
     * @param {Index} second - The second Index object to compare.
     * @param {boolean} [checkSeriesOnly=false] - A boolean flag indicating whether to
     * @returns {boolean} - True if the Index objects are equal; otherwise, false.
     */
    Selection3D.prototype.toEquals = function (first, second, checkSeriesOnly) {
        return ((first.series === second.series || (this.currentMode === 'Cluster' && !checkSeriesOnly))
            && (checkSeriesOnly || (first.point === second.point)));
    };
    /**
     * Redraws the selection in the 3D chart.
     *
     * @param {Chart3D} chart - The 3D chart instance where the selection needs to be redrawn.
     * @param {Chart3DSelectionMode | HighlightMode} oldMode - The previous selection mode ('Series', 'Point', etc.).
     * @param {boolean} [chartRedraw=false] - A boolean flag indicating whether to trigger a chart redraw.
     * @returns {void}
     */
    Selection3D.prototype.redrawSelection = function (chart, oldMode, chartRedraw) {
        this.isSeriesMode = oldMode === 'Series';
        if (!isNullOrUndefined(oldMode)) {
            if (chartRedraw) {
                chart.isRedrawSelection = false;
            }
            else {
                chart.isRedrawSelection = true;
            }
        }
        var selectedDataIndexes = extend([], this.selectedDataIndexes, null, true);
        var highlightDataIndexes = extend([], this.highlightDataIndexes, null, true);
        if (this.styleId.indexOf('highlight') > 0 && highlightDataIndexes.length > 0) {
            this.removeSelectedElements(chart, this.highlightDataIndexes, chart.series);
            selectedDataIndexes = highlightDataIndexes;
        }
        else {
            this.removeSelectedElements(chart, this.selectedDataIndexes, chart.series);
        }
        this.blurEffect(chart.element.id, chart.visibleSeries, false);
        this.selectDataIndex(chart, selectedDataIndexes);
    };
    /**
     * Handles the selection in the legend for the 3D chart.
     *
     * @param {Chart3D} chart - The 3D chart instance associated with the legend.
     * @param {number} series - The index of the series in the legend.
     * @param {Element} targetElement - The HTML element that triggered the selection event.
     * @param {string} eventType - The type of event that triggered the selection.
     * @returns {void}
     */
    Selection3D.prototype.legendSelection = function (chart, series, targetElement, eventType) {
        if (eventType === 'mousemove') {
            if (targetElement.id.indexOf('text') > 1) {
                targetElement = getElement$1(targetElement.id.replace('text', 'shape'));
            }
            if (targetElement.id.indexOf('marker') > 1) {
                targetElement = getElement$1(targetElement.id.replace('_marker', ''));
            }
            if (targetElement.id.indexOf('g') > 1) {
                targetElement = getElement$1(targetElement.id.replace('_g_', '_shape_'));
            }
            if (targetElement.hasAttribute('class') && (targetElement.getAttribute('class').indexOf('highlight') > -1 ||
                targetElement.getAttribute('class').indexOf('selection') > -1)) {
                return;
            }
            this.currentMode = this.chart.highlightMode;
        }
        else if (eventType === 'click') {
            if (targetElement.id.indexOf('text') > 1) {
                targetElement = getElement$1(targetElement.id.replace('text', 'shape'));
            }
            if (targetElement.id.indexOf('g') > 1) {
                targetElement = getElement$1(targetElement.id.replace('_g_', '_shape_'));
            }
        }
        var index = this.indexFinder(targetElement.id);
        var isPreSelected = this.isAlreadySelected(targetElement, eventType, index);
        if (isPreSelected) {
            var seriesStyle = this.generateStyle(chart.visibleSeries[series]);
            var selectedElements = (document.querySelectorAll('.' + seriesStyle));
            this.isSeriesMode = this.currentMode === 'Series';
            var isBlurEffectNeeded = true;
            if (selectedElements.length > 0) {
                this.removeSelection(chart, series, selectedElements, seriesStyle, isBlurEffectNeeded, index);
            }
            else {
                for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
                    var element = _a[_i];
                    if (element.index !== series && !chart.isMultiSelect) {
                        seriesStyle = this.generateStyle(chart.visibleSeries[element.index]);
                        selectedElements = document.querySelectorAll('.' + seriesStyle);
                        this.removeSelection(chart, series, selectedElements, seriesStyle, isBlurEffectNeeded, index);
                    }
                }
                var seriesElements = [];
                if (this.chart.legendSettings.mode === 'Point') {
                    seriesElements = this.getElementByIndex(chart, index);
                }
                else {
                    seriesElements = this.getSeriesElements(chart.visibleSeries[series]);
                }
                if (seriesElements.length > 0) {
                    this.checkSelectionElements(seriesElements, seriesStyle, false, true, series, '');
                    this.isSeriesMode = true;
                    this.selection(chart, new Index(index.series, NaN), seriesElements);
                    this.isSeriesMode = chart.selectionMode === 'Series';
                    this.blurEffect(chart.element.id, chart.visibleSeries, true);
                }
            }
        }
    };
    /**
     * Handles the removal of selection in the 3D chart.
     *
     * @param {Chart3D} chart - The 3D chart instance where the selection needs to be removed.
     * @param {number} series - The index of the series for which the selection is being removed.
     * @param {NodeListOf<HTMLElement>} selectedElements - The HTML elements representing the selected items.
     * @param {string} seriesStyle - The style to be applied to the series after the removal of selection.
     * @param {boolean} isBlurEffectNeeded - A flag indicating whether a blur effect is needed after the removal of selection.
     * @param {Index} index - The index representing the specific data point for which selection is being removed (optional).
     * @returns {void}
     */
    Selection3D.prototype.removeSelection = function (chart, series, selectedElements, seriesStyle, isBlurEffectNeeded, index) {
        if (selectedElements.length > 0) {
            var elements = [];
            for (var i = 0; i < selectedElements.length; i++) {
                elements.push(selectedElements[i]);
            }
            this.removeStyles(elements);
            this.isSeriesMode = true;
            this.addOrRemoveIndex(this.selectedDataIndexes, new Index(series, NaN));
            for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
                var value = _a[_i];
                seriesStyle = this.generateStyle(value);
                if (document.querySelectorAll('.' + seriesStyle).length > 0) {
                    for (var _b = 0, elements_3 = elements; _b < elements_3.length; _b++) {
                        var element = elements_3[_b];
                        this.checkSelectionElements(element, seriesStyle, true, true, series, '');
                    }
                    isBlurEffectNeeded = false;
                    break;
                }
            }
            if (isBlurEffectNeeded) {
                this.isSeriesMode = chart.selectionMode === 'Series';
                this.blurEffect(chart.element.id, chart.visibleSeries, null);
            }
        }
    };
    /**
     * Retrieves the HTML elements associated with a specific 3D chart series.
     *
     * @param {Chart3DSeriesModel | Chart3DSeries} series - The 3D chart series for which HTML elements are to be retrieved.
     * @returns {Element[]} An array of HTML elements representing the graphical elements of the specified 3D chart series.
     * @private
     */
    Selection3D.prototype.getSeriesElements = function (series) {
        var seriesElements = [];
        if (series.visible) {
            var elements = document.querySelectorAll("[id*=\"region-series-" + series.index + "\"]");
            elements.forEach(function (seriesElement) {
                seriesElements.push(seriesElement);
            });
        }
        return seriesElements;
    };
    /**
     * Finds and returns the index associated with the specified identifier.
     *
     * @param {string} id - The identifier used to find the associated index.
     * @returns {Index} The index associated with the specified identifier.
     * @private
     */
    Selection3D.prototype.indexFinder = function (id) {
        var ids = ['NaN', 'NaN'];
        if (id.indexOf('-point-') > -1) {
            ids = id.split('-series-')[1].split('-point-');
        }
        else if (id.indexOf('-border-') > -1) {
            ids[0] = id.split('-border-')[1];
        }
        else if (id.indexOf('-series-') > -1) {
            ids[0] = id.split('-series-')[1];
        }
        else if (id.indexOf('_chart_legend_shape_') > -1) {
            ids = id.split('_chart_legend_shape_');
            ids[0] = ids[1];
        }
        return new Index(parseInt(ids[0], 10), parseInt(ids[1], 10));
    };
    /**
     * Removes the selected elements from the chart based on the specified indices.
     *
     * @param {Chart3D} chart - The 3D chart instance.
     * @param {Index[]} index - The array of indices representing the selected elements to be removed.
     * @param {Chart3DSeriesModel[]} seriesCollection - The collection of series models.
     * @returns {void}
     * @private
     */
    Selection3D.prototype.removeSelectedElements = function (chart, index, seriesCollection) {
        index = chart.isRedrawSelection ? index : index.splice(0, index.length);
        var seriesElements;
        for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {
            var series = seriesCollection_1[_i];
            if (series.visible) {
                seriesElements = this.getSeriesElements(series);
                this.removeStyles(seriesElements);
                for (var _a = 0, seriesElements_1 = seriesElements; _a < seriesElements_1.length; _a++) {
                    var seriesElement = seriesElements_1[_a];
                    this.removeStyles(this.getChildren(seriesElement));
                }
            }
        }
    };
    /**
     * Handles the mouse leave event for the 3D chart.
     *
     * @param {Event} event - The mouse leave event object.
     * @returns {void}
     * @private
     */
    Selection3D.prototype.mouseLeave = function (event) {
        this.completeSelection(event.target, event.type);
    };
    /**
     * Completes the selection process based on the specified target element and event type.
     *
     * @param {HTMLElement} target - The target HTML element involved in the selection.
     * @param {string} eventType - The type of event triggering the selection.
     * @returns {void}
     * @private
     */
    Selection3D.prototype.completeSelection = function (target, eventType) {
        var chart = this.chart;
        if (chart.selectionMode === 'None') {
            return;
        }
        this.currentMode = chart.selectionMode;
    };
    /**
     * Handles the mouse move event, typically used for tracking the movement of the mouse pointer.
     * This method is marked as private to indicate that it should not be used externally.
     *
     * @param {PointerEvent | TouchEvent} event - The event object representing the mouse move or touch event.
     * @returns {void}
     * @private
     */
    Selection3D.prototype.mouseMove = function (event) {
        var chart = this.chart;
        var target = event.target;
        var eventType = event.type;
        this.highlightChart(target, eventType);
        if (chart.selectionMode === 'None') {
            return;
        }
        if (eventType === 'touchmove' && (Browser.isIos || Browser.isIos7) && event.preventDefault) {
            event.preventDefault();
        }
    };
    /**
     * Highlights the series elements based on the specified target element and event type.
     *
     * @param {Element} target - The target element on which the highlight action is performed.
     * @param {string} eventType - The type of the event.
     * @returns {void}
     */
    Selection3D.prototype.highlightChart = function (target, eventType) {
        if (!this.chart.rotateActivate && (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight)) {
            if (!isNullOrUndefined(target)) {
                if (target.id.indexOf('_legend_text') > 1) {
                    target = getElement$1(target.id.replace('text', 'shape'));
                }
                if ((target).hasAttribute('class') && ((target).getAttribute('class').indexOf('highlight') > -1 ||
                    target.getAttribute('class').indexOf('selection') > -1)) {
                    return;
                }
                this.calculateSelectedElements(target, eventType);
                if (this.chart.highlight3DModule.highlightDataIndexes && this.chart.highlight3DModule.highlightDataIndexes.length > 0 &&
                    target.id.indexOf('_chart_legend_') === -1 && target.id.indexOf('-series-') === -1) {
                    this.removeLegendHighlightStyles();
                }
            }
            return;
        }
    };
    /**
     * remove highlighted legend when not focused.
     *
     * @returns {void}
     * @private
     */
    Selection3D.prototype.removeLegendHighlightStyles = function () {
        this.chart.highlight3DModule.highlightDataIndexes = [];
        var elementCollection;
        for (var i = 0; i < this.chart.visibleSeries.length; i++) {
            elementCollection = document.getElementsByClassName(this.generateStyle(this.chart.visibleSeries[i]));
            if (this.selectedDataIndexes.length === 0) {
                elementCollection = document.getElementsByClassName(this.generateStyle(this.chart.visibleSeries[i]));
                while (elementCollection.length > 0) {
                    var element = elementCollection[0];
                    if (element) {
                        this.removeSvgClass(element, element.getAttribute('class'));
                        if (this.chart.highlightPattern === 'None' && this.chart.highlightColor !== '' && !isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightColor !== 'transparent') {
                            var color = this.control.visibleSeries[i].interior;
                            if (element.getAttribute('name') === 'ZLight') {
                                color = this.chart.polygon.applyZLight(color, this.control);
                            }
                            if (element.getAttribute('name') === 'XLight') {
                                color = this.chart.polygon.applyXLight(color, this.control);
                            }
                            if (element.id.indexOf('_chart_legend_shape') !== -1 && element.getAttribute('stroke')) {
                                element.setAttribute('stroke', color);
                            }
                            element.setAttribute('fill', color);
                        }
                    }
                }
                elementCollection = document.getElementsByClassName(this.unselected);
                while (elementCollection.length > 0) {
                    var element = elementCollection[0];
                    if (element) {
                        this.removeSvgClass(element, element.getAttribute('class'));
                        if (this.chart.tooltip3DModule && this.generateStyle(this.chart.visibleSeries[i]).indexOf('highlight') > -1) {
                            this.chart.highlightAnimation(element, i, 700, 0.3);
                        }
                    }
                }
            }
            else {
                elementCollection = document.getElementsByClassName(this.generateStyle(this.chart.visibleSeries[i]));
                while (elementCollection.length > 0) {
                    var element = elementCollection[0];
                    if (element) {
                        this.removeSvgClass(element, element.getAttribute('class'));
                        this.addSvgClass(element, this.unselected);
                    }
                }
            }
        }
    };
    /**
     * Get module name.
     *
     * @returns {string} - Returns the module name.
     * @private
     */
    Selection3D.prototype.getModuleName = function () {
        return 'Selection3D';
    };
    /**
     * To destroy the selection.
     *
     * @returns {void}
     * @private
     */
    Selection3D.prototype.destroy = function () {
        this.removeEventListener();
        // Destroy method performed here
    };
    return Selection3D;
}(BaseSelection));

var __extends$109 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Highlight src file
 */
/**
 * The `Highlight` module handles the highlight for chart.
 *
 * @private
 */
var Highlight3D = /** @__PURE__ @class */ (function (_super) {
    __extends$109(Highlight3D, _super);
    /**
     * Constructor for selection module.
     *
     * @param {Chart3D} chart - Chart3D instance.
     */
    function Highlight3D(chart) {
        var _this = _super.call(this, chart) || this;
        _this.chart = chart;
        _this.wireEvents();
        return _this;
    }
    /**
     * Binding events for highlight module.
     *
     * @returns {void}
     */
    Highlight3D.prototype.wireEvents = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
    };
    /**
     * Unbinding events for highlight module.
     *
     * @returns {void}
     */
    Highlight3D.prototype.unWireEvents = function () {
        if (this.chart.isDestroyed) {
            return;
        }
        this.chart.off(Browser.touchMoveEvent, this.mouseMove);
    };
    /**
     * Declares private variables for the highlight modules.
     *
     * @param {Chart3D} chart - The 3D chart for which private variables are being declared.
     * @returns {void}
     */
    Highlight3D.prototype.declarePrivateVariables = function (chart) {
        this.styleId = chart.element.id + '_ej2_chart_highlight';
        this.unselected = chart.element.id + '_ej2_deselected';
        this.selectedDataIndexes = [];
        this.highlightDataIndexes = [];
        this.isSeriesMode = chart.highlightMode === 'Series';
    };
    /**
     * Invokes the highlighting functionality on a 3D chart.
     *
     * @param {Chart3D} chart - The 3D chart on which highlighting is being invoked.
     * @returns {void}
     */
    Highlight3D.prototype.invokeHighlight = function (chart) {
        this.declarePrivateVariables(chart);
        this.series = extend({}, chart.visibleSeries, null, true);
        this.seriesStyles();
        this.currentMode = chart.highlightMode;
    };
    /**
     * Gets the module name for the highlighting functionality.
     *
     * @returns {string} The module name.
     */
    Highlight3D.prototype.getModuleName = function () {
        return 'Highlight3D';
    };
    /**
     * To destroy the highlight module.
     *
     * @returns {void}
     * @private
     */
    Highlight3D.prototype.destroy = function () {
        this.unWireEvents();
        // Destroy method performed here
    };
    return Highlight3D;
}(Selection3D));

/**
 * The `Export3DModule` module is used to print and export the rendered chart.
 */
var Export3D = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for export module.
     *
     * @private
     */
    function Export3D(chart) {
        this.chart = chart;
    }
    /**
     * Export the chart on the page to PNG, JPEG, or SVG format.
     *
     * @param {number} type - The format in which the chart will be exported.
     * @param {string} fileName - The name of the exported file.
     * @returns {void}
     */
    Export3D.prototype.export = function (type, fileName) {
        var exportChart = new ExportUtils(this.chart);
        var argsData = {
            cancel: false, width: null, height: null
        };
        this.chart.trigger(beforeExport, argsData);
        if (!argsData.cancel) {
            exportChart.export(type, fileName, undefined, [this.chart]);
        }
    };
    /**
     * Export the chart on the page to a PDF document.
     *
     * @param {string} fileName - The name of the exported file.
     * @param {PdfPageOrientation} orientation - Page orientation (portrait or landscape).
     * @param {Chart3D[]} controls - Array of controls to be exported.
     * @param {number} width - The width of the exported chart.
     * @param {number} height - The height of the exported chart.
     * @param {boolean} isVertical - Export the chart vertically or horizontally.
     * @param {string} header - Text to appear at the top of the exported PDF document.
     * @param {string} footer - Text to appear at the bottom of the exported PDF document.
     * @param {boolean} exportToMultiplePage - Export the chart to multiple PDF pages.
     * @returns {void}
     */
    Export3D.prototype.pdfExport = function (fileName, orientation, controls, width, height, isVertical, header, footer, exportToMultiplePage) {
        var exportChart = new ExportUtils(this.chart);
        controls = controls ? controls : [this.chart];
        var argsData = {
            cancel: false, width: width, height: height
        };
        this.chart.trigger(beforeExport, argsData);
        if (!argsData.cancel) {
            exportChart.export('PDF', fileName, orientation, controls, width = argsData.width, height = argsData.height, isVertical, header, footer, exportToMultiplePage);
        }
    };
    /**
     * Gets a data URL for the rendered 3D chart as an HTML canvas element, including data URL and blob URL if available.
     *
     * @param {Chart3D} chart - The 3D chart for which the data URL is requested.
     * @returns {{ element: HTMLCanvasElement, dataUrl?: string, blobUrl?: string }} An object containing the HTML canvas element, data URL, and blob URL.
     */
    Export3D.prototype.getDataUrl = function (chart) {
        var exportUtil = new ExportUtils(chart);
        return exportUtil.getDataUrl(chart);
    };
    /**
     * Gets the module name for the current component.
     *
     * @returns {string} The module name.
     */
    Export3D.prototype.getModuleName = function () {
        // Returns the module name
        return 'Export3D';
    };
    /**
     * To destroy the export modules.
     *
     * @returns {void}
     * @private
     */
    Export3D.prototype.destroy = function () {
        // Destroy method performed here
    };
    return Export3D;
}());

/**
 * Chart components exported.
 */

export { RangeColorSetting, CrosshairSettings, ZoomSettings, Chart, Row, Column, MajorGridLines, MinorGridLines, AxisLine, MajorTickLines, MinorTickLines, CrosshairTooltip, Axis, VisibleLabels, Double, DateTime, Category, Logarithmic, DateTimeCategory, NiceInterval, StripLine, Connector, titleBorder, titleSettings, Location, Font, Border, Offset, ChartArea, Margin, ContainerPadding, Animation$1 as Animation, Indexes, CornerRadius, Index, EmptyPointSettings, DragSettings, CenterLabel, TooltipSettings, StockTooltipSettings, Periods, PeriodSelectorSettings, LineSeries, ColumnSeries, AreaSeries, BarSeries, PolarSeries, RadarSeries, StackingBarSeries, CandleSeries, StackingColumnSeries, StepLineSeries, StepAreaSeries, StackingAreaSeries, StackingStepAreaSeries, StackingLineSeries, ScatterSeries, RangeColumnSeries, RangeStepAreaSeries, WaterfallSeries, HiloSeries, HiloOpenCloseSeries, RangeAreaSeries, SplineRangeAreaSeries, BubbleSeries, SplineSeries, HistogramSeries, SplineAreaSeries, TechnicalIndicator, SmaIndicator, EmaIndicator, TmaIndicator, AccumulationDistributionIndicator, AtrIndicator, MomentumIndicator, RsiIndicator, StochasticIndicator, BollingerBands, MacdIndicator, Trendlines, sort, isBreakLabel, getVisiblePoints, rotateTextSize, removeElement$1 as removeElement, logBase, showTooltip, inside, withIn, logWithIn, withInRange, sum, subArraySum, subtractThickness, subtractRect, degreeToLocation, degreeToRadian, getRotatedRectangleCoordinates, isRotatedRectIntersect, getAngle, subArray, valueToCoefficient, TransformToVisible, indexFinder, CoefficientToVector, valueToPolarCoefficient, Mean, PolarArc, createTooltip, createZoomingLabels, findCrosshairDirection, withInBounds, getValueXByPoint, getValueYByPoint, findClipRect, firstToLowerCase, getTransform, getMinPointsDelta, getAnimationFunction, linear, markerAnimate, animateRectElement, pathAnimation, appendClipElement, triggerLabelRender, setRange, isZoomSet, getActualDesiredIntervalsCount, templateAnimate, drawSymbol, calculateShapes, getRectLocation, minMax, getElement$1 as getElement, getTemplateFunction, accReactTemplate, chartReactTemplate, createTemplate, getFontStyle, measureElementRect, findlElement, getPoint, appendElement, appendChildElement, getDraggedRectLocation, checkBounds, getLabelText, stopTimer, isCollide, isOverlap, containsRect, calculateRect, convertToHexCode, componentToHex, convertHexToColor, colorNameToHex, checkColorFormat, getSaturationColor, applyZLight, getMedian, calculateLegendShapes, textTrim, lineBreakLabelTrim, stringToNumber, redrawElement, animateRedrawElement, textElement$1 as textElement, calculateSize, createSvg, getTitle, titlePositionX, textWrap, textWrapAnyWhere, getUnicodeText, blazorTemplatesReset, CustomizeOption, StackValues, RectOption, ImageOption, CircleOption, PolygonOption, ChartLocation, LabelLocation, Thickness, ColorValue, PointData, AccPointData, Point3D, ControlPoints, getColorByValue, getGradientColor, getPercentageColor, getPercentage, getTextAnchor, Crosshair, Tooltip$1 as Tooltip, Zoom, Selection, DataEditing, Highlight, DataLabel, ErrorBar, DataLabelSettings, MarkerSettings, ParetoOptions, Points, Trendline, ErrorBarCapSettings, ChartSegment, ErrorBarSettings, SeriesBase, Series, Legend, ChartAnnotation, ChartAnnotationSettings, LabelBorder, MultiLevelCategories, StripLineSettings, MultiLevelLabels, ScrollbarSettingsRange, ScrollbarSettings, BoxAndWhiskerSeries, MultiColoredAreaSeries, MultiColoredLineSeries, MultiColoredSeries, MultiLevelLabel, ScrollBar, ParetoSeries, Export, AccumulationChart, AccumulationAnnotationSettings, AccumulationDataLabelSettings, PieCenter, AccPoints, AccumulationSeries, getSeriesFromIndex, pointByIndex, PieSeries, FunnelSeries, PyramidSeries, AccumulationLegend, AccumulationDataLabel, AccumulationTooltip, AccumulationSelection, AccumulationHighlight, AccumulationAnnotation, StockChart, StockChartFont, StockChartBorder, StockChartArea, StockMargin, StockChartStripLineSettings, StockEmptyPointSettings, StockChartConnector, StockSeries, StockChartIndicator, StockChartAxis, StockChartRow, StockChartTrendline, StockChartAnnotationSettings, StockChartIndexes, StockEventsSettings, StockChartLegendSettings, StockLegend, loaded, legendClick, load, animationComplete, legendRender, textRender, pointRender, sharedTooltipRender, seriesRender, axisLabelRender, axisLabelClick, axisRangeCalculated, axisMultiLabelRender, tooltipRender, chartMouseMove, chartMouseClick, chartDoubleClick, pointClick, pointDoubleClick, pointMove, chartMouseLeave, chartMouseDown, chartMouseUp, zoomComplete, dragComplete, selectionComplete, resized, beforeResize, beforePrint, annotationRender, scrollStart, scrollEnd, scrollChanged, stockEventRender, multiLevelLabelClick, dragStart, drag, dragEnd, regSub, regSup, beforeExport, afterExport, bulletChartMouseClick, onZooming, Theme, getSeriesColor, getThemeColor, getScrollbarThemeColor, PeriodSelector, RangeNavigator, rangeValueToCoefficient, getXLocation, getRangeValueXByPoint, getExactData, getNearestValue, DataPoint, getRangeThemeColor, RangeNavigatorAxis, RangeSeries, RangeSlider, RangeNavigatorSeries, ThumbSettings, StyleSettings, RangeTooltipSettings, RangeTooltip, BulletChart, Range, MajorTickLinesSettings, MinorTickLinesSettings, BulletLabelStyle, BulletTooltipSettings, BulletDataLabel, BulletChartLegendSettings, getBulletThemeColor, BulletTooltip, BulletChartLegend, Smithchart, SmithchartMajorGridLines, SmithchartMinorGridLines, SmithchartAxisLine, SmithchartAxis, LegendTitle, LegendLocation, LegendItemStyleBorder, LegendItemStyle, LegendBorder, SmithchartLegendSettings, SeriesTooltipBorder, SeriesTooltip, SeriesMarkerBorder, SeriesMarkerDataLabelBorder, SeriesMarkerDataLabelConnectorLine, SeriesMarkerDataLabel, SeriesMarker, SmithchartSeries, TooltipRender, Subtitle, Title, SmithchartFont, SmithchartMargin, SmithchartBorder, SmithchartRect, LabelCollection, LegendSeries, LabelRegion, HorizontalLabelCollection, RadialLabelCollections, LineSegment, PointRegion, Point, ClosestPoint, MarkerOptions, SmithchartLabelPosition, Direction, DataLabelTextOptions, LabelOption, SmithchartSize, GridArcPoints, smithchartBeforePrint, SmithchartLegend, Sparkline, SparklineTooltip, SparklineBorder, SparklineFont, TrackLineSettings, SparklineTooltipSettings, ContainerArea, LineSettings, RangeBandSettings, AxisSettings, Padding, SparklineMarkerSettings, LabelOffset, SparklineDataLabelSettings, Chart3D, Chart3DRender, Vector3D, Matrix3D, ChartTransform3D, Graphics3D, BinaryTreeBuilder, Svg3DRenderer, Polygon3D, getMinPointsDeltaValue, valueToCoefficients, WallRenderer, AxisRenderer, Chart3DRow, Chart3DColumn, Chart3DMajorGridLines, Chart3DMinorGridLines, Chart3DMajorTickLines, Chart3DMinorTickLines, Chart3DAxis, Visible3DLabels, NiceIntervals, CartesianAxisLayoutPanel$1 as CartesianAxisLayoutPanel, Category3D, DateTime3D, DateTimeCategory3D, Double3D, Logarithmic3D, Chart3DDataLabelSettings, Chart3DEmptyPointSettings, Chart3DPoint, Chart3DSeries, ColumnSeries3D, StackingColumnSeries3D, StackingBarSeries3D, BarSeries3D, DataLabel3D, Chart3DLegendSettings, Legend3D, Chart3DTooltipSettings, Tooltip3D, Selection3D, Highlight3D, Export3D, Chart3DFont, get3DThemeColor, get3DSeriesColor };
//# sourceMappingURL=ej2-charts.es5.js.map
